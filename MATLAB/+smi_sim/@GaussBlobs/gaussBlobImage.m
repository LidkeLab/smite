function [Model,Data] = gaussBlobImage(SMD,SMF,Background,ROIBoxType)
%gaussBlobImage Generates a stack of 2D images containing blobs  
%
%   A stack of images containing blobs is generated by first generating a
%   ROI stack containing the blobs using smi_sim.GaussBlobs.gaussBlobROIStack. 
%   The ROI images are then added to the image stack.
%   
%   Background is added during the ROI stack generation, so will only be
%   present around the blobs and not elsewhere in the images. For a image
%   wide offset set SMD.Background to 0 for all blobs and add offset later.
% 
%   A blob centered at 0,0 is at the upper-left corner of upper-left pixel
%   Boxes for blobs close to the edge are cut within the image, and
%   background will be added to full box so off-center from blob
% 
% INPUTS:
%   SMD:        Structure with fields: 
%       X:      Gaussian Blob Center X (Pixels) (Default=spatial Poisson)
%       Y:      Gaussian Blob Center Y (Pixels) (Default=spatial Poisson)
%       PSFSigma:   Gaussian Sigma (Pixels).  Can be scalar, 1x2, Nx1 or Nx2
%                   [Y X]. (Default=1)
%       Photons:    Integrated Photons in Blob (Default=1000)
%       Bg:         Photons per Pixel (Default=5)
%       FrameNum:   Frame number of Gaussian Blob Location
%       NFrames:    
%   SMF:        SMF object with set properties
%       BoxFinding.BoxSize ( Default=6*max(SMD.PSFSigma) )
%   Background:     Background (photons/pixel)
%   ROIBoxType:    Method for calc. box size ['auto','SMF'](Default='auto')
% 
% OUTPUTS:
%   Model:      Noise Free Images
%   Data:       Poisson Noise Corrupted Images with Read Noise
% 
% REQUIRES:
%   Statistics Toolbox
%   Parallel Procesing Toolbox
%   NVidia GPU
% 
% CITATION:
%   Keith Lidke 2017, Lidke Lab

%Set defaults


if nargin<3
   Background=0;
end

if nargin<4
   ROIBoxType='auto';
end

if nargin<2
    SZ=[SMD.XSize SMD.YSize];
    ROIBoxType='auto';
else
    %Get Image size
    SZ=[SMF.Data.DataROI(3)-SMF.Data.DataROI(1)+1, SMF.Data.DataROI(4)-SMF.Data.DataROI(2)+1];    
end

%Get Box Size
switch ROIBoxType
    case 'auto'
        MaxSigma=max(SMD.PSFSigma(:));
        ROISZ=min(min(ceil(MaxSigma*6),SZ(1)),SZ(2));  %Make boxes large enough for 3 sigma
        YStart=max(1,round(SMD.Y-ROISZ/2));
        YStart=min(YStart,SZ(1)-ROISZ+1);
        XStart=max(1,round(SMD.X-ROISZ/2));
        XStart=min(XStart,SZ(2)-ROISZ+1);
    case 'SMF'
        ROISZ=SMF.BoxFinding.BoxSize;
        if ~isempty(SMD.XBoxCorner)||isempty(SMD.YBoxCorner) %calculte
            YStart=max(1,round(SMD.Y-ROISZ/2));
            YStart=min(YStart,SZ(1)-ROISZ+1);
            XStart=max(1,round(SMD.X-ROISZ/2));
            XStart=min(XStart,SZ(2)-ROISZ+1);
        else %use existing
            XStart=SMD.XBoxCorner;
            YStart=SMD.YBoxCorner;
        end 
end

SMD.X=SMD.X-XStart;
SMD.Y=SMD.Y-YStart;

%Make the ROI Stack
if ~isempty(SMD.Z)
    error('Z simulation needs implementation')
end

if nargin<2
    VarianceIm=0;
else
    VarianceIm=SMF.Data.CameraReadNoise.^2;
end

Covariance=0;
PixType='integrate';
[ModelROI] = smi_sim.GaussBlobs.gaussBlobROIStack(ROISZ,SMD,VarianceIm,Covariance,PixType);

%Write ROIs into Image
NBlobs=length(SMD.X);
Model=zeros([SZ SMD.NFrames],'single');

for nn=1:NBlobs
    Model(YStart(nn):YStart(nn)+ROISZ-1,XStart(nn):XStart(nn)+ROISZ-1,SMD.FrameNum(nn))=...
        Model(YStart(nn):YStart(nn)+ROISZ-1,XStart(nn):XStart(nn)+ROISZ-1,SMD.FrameNum(nn))+ModelROI(:,:,nn);
end

Model=Model+Background; 

% Add poisson noise
if nargout>1
    % poissrnd is faster when used in a loop through all frames
    Data = zeros(size(Model),'single');
    for ii = 1:NFrames
        Data(:,:,ii)=poissrnd(Model(:,:,ii)); %not implemented in gpu yet
    end
    NoiseIm = sqrt(VarianceIm);
    Data=Data+randn(size(Data)).*repmat(NoiseIm,[1 1 NFrames]);
end

end

