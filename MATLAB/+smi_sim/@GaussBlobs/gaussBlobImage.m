function [Model,Data] = gaussBlobImage(SZ,NFrames,SMD,Background,Density,VarianceIm)
%gaussBlobImage Generates a stack of 2D images containing blobs  
%
%   A stack of images containing blobs is generated by first generating a
%   ROI stack containing the blobs using SMA_Si m.gaussBlobROIStack. The ROI 
%   images are then added to the image stack.
%   
%   Background is added during the ROI stack generation, so will only be
%   present around the blobs and not elsewhere in the images. For a image
%   wide offset set SMD.Background to 0 for all blobs and add offset later.
% 
%   A blob centered at 0,0 is at the upper-left corner of upper-left pixel
%   Boxes for blobs close to the edge are cut within the image, and
%   background will be added to full box so off-center from blob
% 
% INPUTS:
%   SZ:         Image size in pixels. Scalar or 1x2. (Default=256)
%   NFrames:    Number of Images (Default=100)
%   SMD:        Structure with fields: 
%       X:      Gaussian Blob Center X (Pixels) (Default=spatial Poisson)
%       Y:      Gaussian Blob Center Y (Pixels) (Default=spatial Poisson)
%       PSFSigma:   Gaussian Sigma (Pixels).  Can be scalar, 1x2, Nx1 or Nx2
%                   [Y X]. (Default=1)
%       Photons:    Integrated Photons in Blob (Default=1000)
%       Bg:         Photons per Pixel (Default=5)
%       FrameNum:   Frame number of Gaussian Blob Location
%   Background: Photons per pixel uniform background (Scalar, Default = 0;)
%   Density:    Density of Blobs in Blobs/Pixel^2.  (Default=.001)
%   VarianceIm:     Additional Pixel-Dependent ReadNoise Image given as variance (Default=0)
% 
% OUTPUTS:
%   Model:      Noise Free Images
%   Data:       Poisson Noise Corrupted Images with Read Noise
% 
% REQUIRES:
%   Statistics Toolbox
%   Parallel Procesing Toolbox
%   NVidia GPU
% 
% CITATION:
%   Keith Lidke 2017, Lidke Lab

%Set defaults
if nargin<1
    SZ=256;
end
if nargin<2
    NFrames=1000;
end
if nargin<3
    SMD=[];
end

if nargin<4
    Background=0;
end

if nargin<5
    Density=.001;
end

if length(SZ)==1 %its a scalar
    SZ=[SZ SZ];
end

if nargin<6
    VarianceIm=zeros(SZ(1),SZ(2),'single');
end

%Location of blobs.  If empty, create random at specified density
if isempty(SMD)
    
    Photons=1000;
    PSFSigma=1.3;
    %Create an empty SMAStruct
    SMD.X=[];
    SMD.Y=[];
    SMD.Z = [];
    SMD.Photons=[];
    SMD.Bg=[];
    SMD.FrameNum=[];
    SMD.PSFSigma=[];
    
    %Fill it up with particles
    for nn=1:NFrames
            NEmitters=poissrnd(Density*SZ(1)*SZ(2));
            SMD.X=cat(1,SMD.X,SZ(2)*rand(NEmitters,1));
            SMD.Y=cat(1,SMD.Y,SZ(2)*rand(NEmitters,1));
            SMD.Photons=cat(1,SMD.Photons,Photons*ones(NEmitters,1));
            SMD.Bg=cat(1,SMD.Bg,zeros(NEmitters,1));
            SMD.FrameNum=cat(1,SMD.FrameNum,nn*ones(NEmitters,1));
            SMD.PSFSigma=cat(1,SMD.PSFSigma,PSFSigma*ones(NEmitters,1));
    end
end

%Make the ROI Stack

%Find Start Y and X
if ~isfield(SMD,'FitBoxSize')||isempty(SMD.FitBoxSize)
    MaxSigma=max(SMD.PSFSigma(:));
    ROISZ=min(min(ceil(MaxSigma*4),SZ(1)),SZ(2));  %Make boxes large enough for 3 sigma 
else
    ROISZ=SMD.FitBoxSize;
end
YStart=max(1,round(SMD.Y-ROISZ/2));
YStart=min(YStart,SZ(1)-ROISZ+1);
XStart=max(1,round(SMD.X-ROISZ/2));
XStart=min(XStart,SZ(2)-ROISZ+1);

%Make a new SMAStruct with poisition relative to the box corner
SMAStruct_Rel=SMD;
SMAStruct_Rel.X=SMD.X-XStart;
SMAStruct_Rel.Y=SMD.Y-YStart;

%Make the ROI Stack
if isfield(SMD,'Z')
    if isempty(SMD.Z)
        [ModelROI] = SMA_Sim.gaussBlobROIStack(ROISZ,SMAStruct_Rel,VarianceIm);
    else
        [ModelROI] = SMA_PSF.psfROIStack(SMD.PSFSigma,SMD.XYSamPerPix,SMD.ZSamPerUnit,ROISZ,SMAStruct_Rel); 
    end
else
    [ModelROI] = SMA_Sim.gaussBlobROIStack(ROISZ,SMAStruct_Rel,VarianceIm);
end

%Write ROIs into Image
NBlobs=length(SMD.X);
Model=zeros([SZ NFrames],'single');

for nn=1:NBlobs
    Model(YStart(nn):YStart(nn)+ROISZ-1,XStart(nn):XStart(nn)+ROISZ-1,SMD.FrameNum(nn))=...
        Model(YStart(nn):YStart(nn)+ROISZ-1,XStart(nn):XStart(nn)+ROISZ-1,SMD.FrameNum(nn))+ModelROI(:,:,nn);
end

% Add uniform background
Model = Model+Background;

% Add poisson noise
if nargout>1
    % poissrnd is faster when used in a loop through all frames
    Data = zeros(size(Model),'single');
    for ii = 1:NFrames
        Data(:,:,ii)=poissrnd(Model(:,:,ii)); %not implemented in gpu yet
    end
    NoiseIm = sqrt(VarianceIm);
    Data=Data+randn(size(Data)).*repmat(NoiseIm,[1 1 NFrames]);
end

end

