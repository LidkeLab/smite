./ExternalSoftware/uipickfiles/uipickfiles.m
function out = uipickfiles(varargin)
%uipickfiles: GUI program to select files and/or folders.
%
% Syntax:
%   files = uipickfiles('PropertyName',PropertyValue,...)
%
% The current folder can be changed by operating in the file navigator:
% double-clicking on a folder in the list or pressing Enter to move further
% down the tree, using the popup menu, clicking the up arrow button or
% pressing Backspace to move up the tree, or typing a path in the box to
% move to any folder.  Right-clicking on the path box (control-click on the
% Mac) will pop up a context menu listing previously-visited folders. These
% folders are listed in order of when they were last visited (most recent
% at the top) and the list is saved between calls to uipickfiles.  The list
% can be cleared or its maximum length changed with the items at the bottom
% of the menu. Also included (and unclearable) are the user's home folder
% and one or more MATLAB startup folders.
%
% (Windows only: To go to a UNC-named resource you will have to type the
% UNC name in the path box, but all such visited resources will be
% remembered and listed along with the mapped drives.)  The items in the
% file navigator can be sorted by name, modification date or size by
% clicking on the headers, though neither date nor size are displayed.  All
% folders are considered to have zero size.
%
% Files can be added to the list by double-clicking or selecting files
% (non-contiguous selections are possible with the control key) and
% pressing the Add button.  Control-F will select all the files listed in
% the navigator while Control-A will select everything (Command instead of
% Control on the Mac).  Since double-clicking a folder will open it,
% folders can be added only by selecting them and pressing the Add button.
% Files/folders in the list can be removed or re-ordered.  Recall button
% will insert into the Selected Files list whatever files were returned the
% last time uipickfiles was run.  When finished, a press of the Done button
% will return the full paths to the selected items in a cell array,
% structure array or character array.  If the Cancel button or the escape
% key is pressed then zero is returned.
%
% The figure can be moved and resized in the usual way and this position is
% saved and used for subsequent calls to uipickfiles.  The default position
% can be restored by double-clicking in a vacant region of the figure.
%
% The following optional property/value pairs can be specified as arguments
% to control the indicated behavior:
%
%   Property    Value
%   ----------  ----------------------------------------------------------
%   FilterSpec  String to specify starting folder and/or file filter.
%               Ex:  'C:\bin' will start up in that folder.  '*.txt'
%               will list only files ending in '.txt'.  'c:\bin\*.txt' will
%               do both.  Default is to start up in the current folder and
%               list all files.  Can be changed with the GUI.
%
%   REFilter    String containing a regular expression used to filter the
%               file list.  Ex: '\.m$|\.mat$' will list files ending in
%               '.m' and '.mat'.  Default is empty string.  Can be used
%               with FilterSpec and both filters are applied.  Can be
%               changed with the GUI.
%
%   REDirs      Logical flag indicating whether to apply the regular
%               expression filter to folder names.  Default is false which
%               means that all folders are listed.  Can be changed with the
%               GUI.
%
%   Type        Two-column cell array where the first column contains file
%               filters and the second column contains descriptions.  If
%               this property is specified an additional popup menu will
%               appear below the File Filter and selecting an item will put
%               that item into the File Filter.  By default, the first item
%               will be entered into the File Filter.  For example,
%                   { '*.m',   'M-files'   ;
%                     '*.mat', 'MAT-files' }.
%               Can also be a cell vector of file filter strings in which
%               case the descriptions will be the same as the file filters
%               themselves.
%               Must be a cell array even if there is only one entry.
%
%   Prompt      String containing a prompt appearing in the title bar of
%               the figure.  Default is 'Select files'.
%
%   NumFiles    Scalar or vector specifying number of files that must be
%               selected.  A scalar specifies an exact value; a two-element
%               vector can be used to specify a range, [min max].  The
%               function will not return unless the specified number of
%               files have been chosen.  Default is [] which accepts any
%               number of files.
%
%   Append      Cell array of strings, structure array or char array
%               containing a previously returned output from uipickfiles.
%               Used to start up program with some entries in the Selected
%               Files list.  Any included files that no longer exist will
%               not appear.  Default is empty cell array, {}.
%
%   Output      String specifying the data type of the output: 'cell',
%               'struct' or 'char'.  Specifying 'cell' produces a cell
%               array of strings, the strings containing the full paths of
%               the chosen files.  'Struct' returns a structure array like
%               the result of the dir function except that the 'name' field
%               contains a full path instead of just the file name.  'Char'
%               returns a character array of the full paths.  This is most
%               useful when you have just one file and want it in a string
%               instead of a cell array containing just one string.  The
%               default is 'cell'.
%
% All properties and values are case-insensitive and need only be
% unambiguous.  For example,
%
%   files = uipickfiles('num',1,'out','ch')
%
% is valid usage.

% Version: 1.22, 15 June 2020
% Author:  Douglas M. Schwarz
% Email:   dmschwarz=ieee*org, dmschwarz=urgrad*rochester*edu
% Real_email = regexprep(Email,{'=','*'},{'@','.'})


% Define properties and set default values.
prop.filterspec = '*';
prop.refilter = '';
prop.redirs = false;
prop.type = {};
prop.prompt = 'Select files';
prop.numfiles = [];
prop.append = [];
prop.output = 'cell';

% Process inputs and set prop fields.
prop = parsepropval(prop,varargin{:});

% Validate FilterSpec property.
if isempty(prop.filterspec)
	prop.filterspec = '*';
end
if ~ischar(prop.filterspec)
	error('FilterSpec property must contain a string.')
end

% Validate REFilter property.
if ~ischar(prop.refilter)
	error('REFilter property must contain a string.')
end

% Validate REDirs property.
if ~isscalar(prop.redirs)
	error('REDirs property must contain a scalar.')
end

% Validate Type property.
if isempty(prop.type)
elseif iscellstr(prop.type) && isvector(prop.type)
	prop.type = repmat(prop.type(:),1,2);
elseif iscellstr(prop.type) && size(prop.type,2) == 2
else
	error(['Type property must be empty or a cellstr vector or ',...
		'a 2-column cellstr matrix.'])
end

% Validate Prompt property.
if ~ischar(prop.prompt)
	error('Prompt property must contain a string.')
end

% Validate NumFiles property.
if numel(prop.numfiles) > 2 || any(prop.numfiles < 0)
	error('NumFiles must be empty, a scalar or two-element vector.')
end
prop.numfiles = unique(prop.numfiles);
if isequal(prop.numfiles,1)
	numstr = 'Select exactly 1 item.';
elseif length(prop.numfiles) == 1
	numstr = sprintf('Select exactly %d items.',prop.numfiles);
else
	numstr = sprintf('Select %d to %d items.',prop.numfiles);
end

% Validate Append property and initialize pick data.
if isstruct(prop.append) && isfield(prop.append,'name')
	prop.append = {prop.append.name};
elseif ischar(prop.append)
	prop.append = cellstr(prop.append);
end
if isempty(prop.append)
	file_picks = {};
	full_file_picks = {};
	dir_picks = repmat(dir(char(127)),0,1);  % Create empty directory structure.
elseif iscellstr(prop.append) && isvector(prop.append)
	num_items = length(prop.append);
	file_picks = cell(1,num_items);
	full_file_picks = cell(1,num_items);
	dir_fn = fieldnames(repmat(dir(char(127)),0,1));
	dir_picks = repmat(cell2struct(cell(length(dir_fn),1),dir_fn(:)),...
		num_items,1);
	for item = 1:num_items
		if fdexist(prop.append{item},'dir') && ...
				~any(strcmp(full_file_picks,prop.append{item}))
			full_file_picks{item} = prop.append{item};
			[unused,fn,ext] = fileparts(prop.append{item});
			file_picks{item} = [fn,ext];
			path_c_tmp = path2cell(prop.append{item});
			temp = dir(cell2path(path_c_tmp(1:end-1)));
			if ispc || ismac
				thisdir = strcmpi({temp.name},[fn,ext]);
			else
				thisdir = strcmp({temp.name},[fn,ext]);
			end
			dir_picks(item) = temp(thisdir);
			dir_picks(item).name = prop.append{item};
		elseif fdexist(prop.append{item},'file') && ...
				~any(strcmp(full_file_picks,prop.append{item}))
			full_file_picks{item} = prop.append{item};
			[unused,fn,ext] = fileparts(prop.append{item});
			file_picks{item} = [fn,ext];
			dir_picks(item) = dir(prop.append{item});
			dir_picks(item).name = prop.append{item};
		else
			continue
		end
	end
	% Remove items which no longer exist.
	missing = cellfun(@isempty,full_file_picks);
	full_file_picks(missing) = [];
	file_picks(missing) = [];
	dir_picks(missing) = [];
else
	error('Append must be a cell, struct or char array.')
end

% Validate Output property.
legal_outputs = {'cell','struct','char'};
out_idx = find(strncmpi(prop.output,legal_outputs,length(prop.output)));
if length(out_idx) == 1
	prop.output = legal_outputs{out_idx};
else
	error(['Value of ''Output'' property, ''%s'', is illegal or '...
		'ambiguous.'],prop.output)
end


% Set style preference for display of folders.
%   1 => folder icon before and filesep after
%   2 => bullet before and filesep after
%   3 => filesep after only
folder_style_pref = 1;
fsdata = set_folder_style(folder_style_pref);

% Set style preference for context menu.
%   1 => home and logo icons before home and MATLAB folders
%   2 => no icons
cmenu_style_pref = 1;
csdata = set_cmenu_style(cmenu_style_pref);

% Get canonical names of current directory and filter.
jUserDir = java.lang.System.setProperty('user.dir',pwd);
if any(prop.filterspec == '*')
	jFile = java.io.File(prop.filterspec).getAbsoluteFile;
	current_dir  = char(jFile.getParentFile().getCanonicalPath());
	filter = char(jFile.getName());
else
	jFile = java.io.File(prop.filterspec).getCanonicalFile();
	if jFile.isDirectory()
		current_dir = char(jFile);
		filter = '*';
	else
		jDir = java.io.File(jFile.getParent());
		if jDir.isDirectory()
			current_dir = char(jDir);
			filter = char(jFile.getName());
		else
			java.lang.System.setProperty('user.dir',jUserDir);
			error('Path does not exist.')
		end
	end
end
java.lang.System.setProperty('user.dir',jUserDir);

% Initialize file lists.
re_filter = prop.refilter;
full_filter = fullfile(current_dir,filter);
network_volumes = {};
[path_cell,new_network_vol] = path2cell(current_dir);
if fdexist(new_network_vol,'dir')
	network_volumes = unique([network_volumes,{new_network_vol}]);
end
fdir = filtered_dir(full_filter,re_filter,prop.redirs,...
	@(x,c)file_sort(x,[1 0 0],c));
filenames = {fdir.name}';
[filenames,fdir] = annotate_file_names(filenames,fdir,fsdata);

% Initialize some data.
show_full_path = false;
nodupes = true;

% Get history preferences and set history.
history = getpref('uipickfiles','history',struct('name',{},'time',{}));
default_history_size = 15;
history_size = getpref('uipickfiles','history_size',default_history_size);

% Get favorites.
favorites = getpref('uipickfiles','favorites',{});

% Set history.
history = update_history(history,current_dir,now,history_size);

% Get figure position preference and create figure.
gray = [220 220 220]/255;
if ispref('uipickfiles','figure_position')
	fig_pos = getpref('uipickfiles','figure_position');
	create_fcn = '';
else
	fig_pos = [0 0 740 494];
	create_fcn = {@movegui,'center'};
end
fig = figure('Position',fig_pos,...
	'MenuBar','none',...
	'WindowStyle','modal',...
	'Color',gray,...
	'Resize','on',...
	'NumberTitle','off',...
	'Name',prop.prompt,...
	'IntegerHandle','off',...
	'CloseRequestFcn',@cancel,...
	'CreateFcn',create_fcn,...
	'ButtonDownFcn',@reset_figure_size,...
	'KeyPressFcn',@keypressmisc,...
	'Visible','off');
fig_color = fig.Color;

% Set system-dependent items.
if ismac
% 	ver = char(java.lang.System.getProperty('os.version'));
	set(fig,'DefaultUIControlFontName','Lucida Grande')
	set(fig,'DefaultUIControlFontSize',13)
	sort_ctrl_size = 12;
	mod_key = 'command';
	action = 'Control-click';
elseif ispc
% 	ver = str2double(java.lang.System.getProperty('os.version'));
	set(fig,'DefaultUIControlFontName','Segoe UI')
	set(fig,'DefaultUIControlFontSize',9)
	sort_ctrl_size = 7;
	mod_key = 'control';
	action = 'Right-click';
else
	set(fig,'DefaultUIControlFontName','Dialog')
	sort_ctrl_size = get(fig,'DefaultUIControlFontSize') - 1;
	mod_key = 'control';
	action = 'Right-click';
end

% Create uicontrols.
frame1 = uicontrol('Style','frame',...
	'BackgroundColor',fig_color,...
	'Position',[255 260 110 70]);
frame2 = uicontrol('Style','frame',...
	'BackgroundColor',fig_color,...
	'Position',[275 135 110 100]);

navlist = uicontrol('Style','listbox',...
	'Position',[10 10 250 320],...
	'String',filenames,...
	'Value',[],...
	'BackgroundColor','w',...
	'Callback',@clicknav,...
	'KeyPressFcn',@keypressnav,...
	'Max',2);

tri_up = repmat([1 1 1 1 0 1 1 1 1;1 1 1 0 0 0 1 1 1;1 1 0 0 0 0 0 1 1;...
	1 0 0 0 0 0 0 0 1],[1 1 3]);
tri_up(tri_up == 1) = NaN;
tri_down = tri_up(end:-1:1,:,:);
tri_null = NaN(4,9,3);
tri_icon = {tri_down,tri_null,tri_up};
sort_state = [1 0 0];
last_sort_state = [1 1 1];
sort_cb = zeros(1,3);
sort_cb(1) = uicontrol('Style','checkbox',...
	'Position',[15 331 70 15],...
	'String','Name',...
	'FontSize',sort_ctrl_size,...
	'BackgroundColor',fig_color,...
	'Value',sort_state(1),...
	'CData',tri_icon{sort_state(1)+2},...
	'KeyPressFcn',@keypressmisc,...
	'Callback',{@sort_type,1});
sort_cb(2) = uicontrol('Style','checkbox',...
	'Position',[85 331 70 15],...
	'String','Date',...
	'FontSize',sort_ctrl_size,...
	'BackgroundColor',fig_color,...
	'Value',sort_state(2),...
	'CData',tri_icon{sort_state(2)+2},...
	'KeyPressFcn',@keypressmisc,...
	'Callback',{@sort_type,2});
sort_cb(3) = uicontrol('Style','checkbox',...
	'Position',[155 331 70 15],...
	'String','Size',...
	'FontSize',sort_ctrl_size,...
	'BackgroundColor',fig_color,...
	'Value',sort_state(3),...
	'CData',tri_icon{sort_state(3)+2},...
	'KeyPressFcn',@keypressmisc,...
	'Callback',{@sort_type,3});

pickslist = uicontrol('Style','listbox',...
	'Position',[380 10 350 320],...
	'String',file_picks,...
	'BackgroundColor','w',...
	'Callback',@clickpicks,...
	'KeyPressFcn',@keypresslist,...
	'Max',2,...
	'Value',[]);

openbut = uicontrol('Style','pushbutton',...
	'Position',[265 295 90 30],...
	'String','Open',...
	'Enable','off',...
	'KeyPressFcn',@keypressmisc,...
	'Callback',@open);

arrow = [ ...
	'        1   ';
	'        10  ';
	'         10 ';
	'000000000000';
	'         10 ';
	'        10  ';
	'        1   '];
cmap = NaN(128,3);
cmap(double('10'),:) = [0.5 0.5 0.5;0 0 0];
arrow_im = NaN(7,76,3);
arrow_im(:,45:56,:) = ind2rgb(double(arrow),cmap);
add_cm = uicontextmenu;
add_cm_items(1) = uimenu(add_cm,...
	'Label','Add with path subfolders',...
	'Callback',{@add_with_subfolders,'pathsub'},...
	'Visible','off');
add_cm_items(2) = uimenu(add_cm,...
	'Label','Add with subfolders',...
	'Callback',{@add_with_subfolders,'sub'},...
	'Visible','off');
add_cm_items(3) = uimenu(add_cm,...
	'Label','<html>Add with <i>all</i> subfolders</html>',...
	'Separator','on',...
	'Callback',{@add_with_subfolders,'allsub'},...
	'Visible','off');
addbut = uicontrol('Style','pushbutton',...
	'Position',[265 265 90 30],...
	'String','Add    ',...
	'Enable','off',...
	'CData',arrow_im,...
	'KeyPressFcn',@keypressmisc,...
	'Callback',@add,...
	'UIContextMenu',add_cm);

removebut = uicontrol('Style','pushbutton',...
	'Position',[285 200 90 30],...
	'String','Remove',...
	'Enable','off',...
	'KeyPressFcn',@keypressmisc,...
	'Callback',@remove);
moveupbut = uicontrol('Style','pushbutton',...
	'Position',[285 170 90 30],...
	'String','Move Up',...
	'Enable','off',...
	'KeyPressFcn',@keypressmisc,...
	'Callback',@moveup);
movedownbut = uicontrol('Style','pushbutton',...
	'Position',[285 140 90 30],...
	'String','Move Down',...
	'Enable','off',...
	'KeyPressFcn',@keypressmisc,...
	'Callback',@movedown);

dir_popup = uicontrol('Style','popupmenu',...
	'Position',[10 350 225 20],...
	'BackgroundColor','w',...
	'String',path_cell,...
	'Value',length(path_cell),...
	'KeyPressFcn',@keypressmisc,...
	'Callback',@dirpopup);

uparrow = [ ...
	'  0     ';
	' 000    ';
	'00000   ';
	'  0     ';
	'  0     ';
	'  0     ';
	'  000000'];
cmap = NaN(128,3);
cmap(double('0'),:) = [0 0 0];
uparrow_im = ind2rgb(double(uparrow),cmap);
up_dir_but = uicontrol('Style','pushbutton',...
	'Position',[240 350 20 20],...
	'CData',uparrow_im,...
	'KeyPressFcn',@keypressmisc,...
	'Callback',@dir_up_one,...
	'ToolTip','Go to parent folder');
if length(path_cell) > 1
	up_dir_but.Enable = 'on';
else
	up_dir_but.Enable = 'off';
end

hist_cm = uicontextmenu;
pathbox = uicontrol('Style','edit',...
	'Position',[10 375 250 26],...
	'BackgroundColor','w',...
	'String',current_dir,...
	'HorizontalAlignment','left',...
	'TooltipString',[action,' to display folder history'],...
	'KeyPressFcn',@keypressmisc,...
	'Callback',@change_path,...
	'UIContextMenu',hist_cm);
label1 = uicontrol('Style','text',...
	'Position',[10 401 250 16],...
	'String','Current Folder',...
	'HorizontalAlignment','center',...
	'BackgroundColor',fig_color,...
	'TooltipString',[action,' to display folder history'],...
	'UIContextMenu',hist_cm);
hist_menus = [];
make_history_cm(csdata)

label2 = uicontrol('Style','text',...
	'Position',[10 440+36 80 17],...
	'String','File Filter',...
	'HorizontalAlignment','left',...
	'BackgroundColor',fig_color);
label3 = uicontrol('Style','text',...
	'Position',[100 440+36 160 17],...
	'String','Regular Expression Filter',...
	'HorizontalAlignment','left',...
	'BackgroundColor',fig_color);
label3.Position(3) = label3.Extent(3);
% 	'String','Reg. Exp. Filter',...
showallfiles = uicontrol('Style','checkbox',...
	'Position',[270 420+32 110 20],...
	'String','Show All Files',...
	'Value',0,...
	'HorizontalAlignment','left',...
	'BackgroundColor',fig_color,...
	'KeyPressFcn',@keypressmisc,...
	'Callback',@togglefilter);
showallfiles.Position(3) = showallfiles.Extent(3) + 20;
refilterdirs = uicontrol('Style','checkbox',...
	'Position',[270 420+10 100 20],...
	'String','RE Filter Dirs',...
	'Value',prop.redirs,...
	'HorizontalAlignment','left',...
	'BackgroundColor',fig_color,...
	'KeyPressFcn',@keypressmisc,...
	'Callback',@toggle_refiltdirs);
refilterdirs.Position(3) = refilterdirs.Extent(3) + 20;
filter_ed = uicontrol('Style','edit',...
	'Position',[10 420+30 80 26],...
	'BackgroundColor','w',...
	'String',filter,...
	'HorizontalAlignment','left',...
	'KeyPressFcn',@keypressmisc,...
	'Callback',@setfilspec);
refilter_ed = uicontrol('Style','edit',...
	'Position',[100 420+30 160 26],...
	'BackgroundColor','w',...
	'String',re_filter,...
	'HorizontalAlignment','left',...
	'KeyPressFcn',@keypressmisc,...
	'Callback',@setrefilter);

type_value = 1;
type_popup = uicontrol('Style','popupmenu',...
	'Position',[10 422 250 20],...
	'String','',...
	'BackgroundColor','w',...
	'Value',type_value,...
	'KeyPressFcn',@keypressmisc,...
	'Callback',@filter_type_callback,...
	'Visible','off');
if ~isempty(prop.type)
	filter_ed.String = prop.type{type_value,1};
	setfilspec()
	type_popup.String = prop.type(:,2);
	type_popup.Visible = 'on';
end

viewfullpath = uicontrol('Style','checkbox',...
	'Position',[380 335 230 20],...
	'String','Show full paths',...
	'Value',show_full_path,...
	'HorizontalAlignment','left',...
	'BackgroundColor',fig_color,...
	'KeyPressFcn',@keypressmisc,...
	'Callback',@showfullpath);
remove_dupes = uicontrol('Style','checkbox',...
	'Position',[380 360 280 20],...
	'String','Remove duplicates (as per full path)',...
	'Value',nodupes,...
	'HorizontalAlignment','left',...
	'BackgroundColor',fig_color,...
	'KeyPressFcn',@keypressmisc,...
	'Callback',@removedupes);
recall_button = uicontrol('Style','pushbutton',...
	'Position',[665 335 65 30],...
	'String','Recall',...
	'KeyPressFcn',@keypressmisc,...
	'Callback',@recall,...
	'ToolTip','Add previously selected items');
label4 = uicontrol('Style','text',...
	'Position',[380 405 350 20],...
	'String','Selected Items',...
	'HorizontalAlignment','center',...
	'BackgroundColor',fig_color);
done_button = uicontrol('Style','pushbutton',...
	'Position',[280 80 80 30],...
	'String','Done',...
	'KeyPressFcn',@keypressmisc,...
	'Callback',@done);
cancel_button = uicontrol('Style','pushbutton',...
	'Position',[280 30 80 30],...
	'String','Cancel',...
	'KeyPressFcn',@keypressmisc,...
	'Callback',@cancel);

% If necessary, add warning about number of items to be selected.
num_files_warn = uicontrol('Style','text',...
	'Position',[380 385 350 16],...
	'String',numstr,...
	'ForegroundColor',[0.8 0 0],...
	'BackgroundColor',fig_color,...
	'HorizontalAlignment','center',...
	'Visible','off');
if ~isempty(prop.numfiles)
	num_files_warn.Visible = 'on';
end

resize()
% Make figure visible and hide handle.
set(fig,'HandleVisibility','off',...
	'Visible','on',...
	'ResizeFcn',@resize)

% Wait until figure is closed.
uiwait(fig)

% Compute desired output.
switch prop.output
	case 'cell'
		out = full_file_picks;
	case 'struct'
		out = dir_picks(:);
	case 'char'
		out = char(full_file_picks);
	case 'cancel'
		out = 0;
end

% Update history preference.
setpref('uipickfiles','history',history)
if ~isempty(full_file_picks) && ~strcmp(prop.output,'cancel')
	setpref('uipickfiles','full_file_picks',full_file_picks)
end

% Update favorites preference.
setpref('uipickfiles','favorites',favorites)

% Update figure position preference.
setpref('uipickfiles','figure_position',fig_pos)


% ----------------- Callback nested functions ----------------

	function add(varargin)
		values = navlist.Value;
		for i = 1:length(values)
			dir_pick = fdir(values(i));
			pick = dir_pick.name;
			pick_full = fullfile(current_dir,pick);
			dir_pick.name = pick_full;
			if ~nodupes || ~any(strcmp(full_file_picks,pick_full))
				file_picks{end + 1} = pick; %#ok<AGROW>
				full_file_picks{end + 1} = pick_full; %#ok<AGROW>
				dir_picks(end + 1) = dir_pick; %#ok<AGROW>
			end
		end
		% Added 3/2/14 - 2 lines
		history = update_history(history,current_dir,now,history_size);
		make_history_cm(csdata)
		if show_full_path
			set(pickslist,'String',full_file_picks,'Value',[]);
		else
			set(pickslist,'String',file_picks,'Value',[]);
		end
		set([removebut,moveupbut,movedownbut],'Enable','off');
	end

	function add_with_subfolders(varargin)
		% Use final argument to determine exclusions for subdirs.
		switch varargin{end}
			case 'pathsub'
				exclusions = '.@+p';
			case 'sub'
				exclusions = '.';
			case 'allsub'
				exclusions = '';
		end
		values = navlist.Value;
		for i = 1:length(values)
			dir_pick = fdir(values(i));
			pick = dir_pick.name;
			pick_full = fullfile(current_dir,pick);
			subd = subdirs(pick_full,[],exclusions);
			for j = 1:length(subd)
				pick_full = subd{j};
				if ~nodupes || ~any(strcmp(full_file_picks,pick_full))
					[~,pick] = fileparts(pick_full);
					dir_temp = dir(pick_full);
					dir_pick = dir_temp(strcmp({dir_temp.name},'.'));
					dir_pick.name = pick_full;
					file_picks{end + 1} = pick; %#ok<AGROW>
					full_file_picks{end + 1} = pick_full; %#ok<AGROW>
					dir_picks(end + 1) = dir_pick; %#ok<AGROW>
				end
			end
		end
		% Added 3/2/14 - 2 lines
		history = update_history(history,current_dir,now,history_size);
		make_history_cm(csdata)
		if show_full_path
			set(pickslist,'String',full_file_picks,'Value',[]);
		else
			set(pickslist,'String',file_picks,'Value',[]);
		end
		set([removebut,moveupbut,movedownbut],'Enable','off');
	end

	function remove(varargin)
		values = pickslist.Value;
		file_picks(values) = [];
		full_file_picks(values) = [];
		dir_picks(values) = [];
		top = pickslist.ListboxTop;
		num_above_top = sum(values < top);
		top = top - num_above_top;
		num_picks = length(file_picks);
		new_value = min(min(values) - num_above_top,num_picks);
		if num_picks == 0
			new_value = [];
			set([removebut,moveupbut,movedownbut],'Enable','off')
		end
		if show_full_path
			set(pickslist,'String',full_file_picks,'Value',new_value,...
				'ListboxTop',top)
		else
			set(pickslist,'String',file_picks,'Value',new_value,...
				'ListboxTop',top)
		end
	end

	function open(varargin)
		values = navlist.Value;
		if fdir(values).isdir
			fig.Pointer = 'watch';
			drawnow
			% Convert 'My Documents' to 'Documents' when necessary.
			if ispc && strcmp(fdir(values).name,'My Documents')
				if isempty(dir(fullfile(current_dir,fdir(values).name)))
					values = find(strcmp({fdir.name},'Documents'));
				end
			end
			current_dir = fullfile(current_dir,fdir(values).name);
			if ispc && ~isempty(regexpi(current_dir,'\.lnk')) && ...
					is_shortcut_to_dir(current_dir)
				JFile = java.io.File(current_dir);
				sf = sun.awt.shell.ShellFolder.getShellFolder(JFile);
				current_dir = char(sf.getLinkLocation());
			end
% 			history = update_history(history,current_dir,now,history_size);
% 			make_history_cm(csdata)
			full_filter = fullfile(current_dir,filter);
			path_cell = path2cell(current_dir);
			fdir = filtered_dir(full_filter,re_filter,prop.redirs,...
				@(x,c)file_sort(x,sort_state,c));
			filenames = {fdir.name}';
			[filenames,fdir] = annotate_file_names(filenames,fdir,fsdata);
			set(dir_popup,'String',path_cell,'Value',length(path_cell))
			if length(path_cell) > 1
				up_dir_but.Enable = 'on';
			else
				up_dir_but.Enable = 'off';
			end
			pathbox.String = current_dir;
			set(navlist,'ListboxTop',1,'Value',[],'String',filenames)
			addbut.Enable = 'off';
			openbut.Enable = 'off';
			fig.Pointer = 'arrow';
		end
	end

	function clicknav(varargin)
		value = navlist.Value;
		nval = length(value);
		dbl_click_fcn = @add;
		switch nval
			case 0
				set([addbut,openbut],'Enable','off')
			case 1
				addbut.Enable = 'on';
				if fdir(value).isdir
					openbut.Enable = 'on';
					dbl_click_fcn = @open;
				else
					openbut.Enable = 'off';
				end
			otherwise
				addbut.Enable = 'on';
				openbut.Enable = 'off';
		end
		if any([fdir(value).isdir])
			set(add_cm_items,'Visible','on')
		else
			set(add_cm_items,'Visible','off')
		end
		if strcmp(fig.SelectionType,'open')
			dbl_click_fcn();
		end
	end

	function keypressmisc(h,evt) %#ok<INUSL>
		if strcmp(evt.Key,'escape') && isequal(evt.Modifier,cell(1,0))
			% Escape key means Cancel.
			cancel()
		end
	end

	function keypressnav(h,evt) %#ok<INUSL>
		if length(path_cell) > 1 && strcmp(evt.Key,'backspace') && ...
				isequal(evt.Modifier,cell(1,0))
			% Backspace means go to parent folder.
			dir_up_one()
		elseif strcmp(evt.Key,'f') && isequal(evt.Modifier,{mod_key})
			% Control-F (Command-F on Mac) means select all files.
			value = find(~[fdir.isdir]);
			navlist.Value = value;
		elseif strcmp(evt.Key,'rightarrow') && ...
				isequal(evt.Modifier,cell(1,0))
			% Right arrow key means select the file.
			add()
		elseif strcmp(evt.Key,'escape') && isequal(evt.Modifier,cell(1,0))
			% Escape key means Cancel.
			cancel()
		end
	end

	function keypresslist(h,evt) %#ok<INUSL>
		if strcmp(evt.Key,'backspace') && isequal(evt.Modifier,cell(1,0))
			% Backspace means remove item from list.
			remove()
		elseif strcmp(evt.Key,'escape') && isequal(evt.Modifier,cell(1,0))
			% Escape key means Cancel.
			cancel()
		end
	end

	function clickpicks(varargin)
		value = pickslist.Value;
		if isempty(value)
			set([removebut,moveupbut,movedownbut],'Enable','off')
		else
			removebut.Enable = 'on';
			if min(value) == 1
				moveupbut.Enable = 'off';
			else
				moveupbut.Enable = 'on';
			end
			if max(value) == length(file_picks)
				movedownbut.Enable = 'off';
			else
				movedownbut.Enable = 'on';
			end
		end
		if strcmp(fig.SelectionType,'open')
			remove();
		end
	end

	function recall(varargin)
		if ispref('uipickfiles','full_file_picks')
			ffp = getpref('uipickfiles','full_file_picks');
		else
			ffp = {};
		end
		for i = 1:length(ffp)
			if fdexist(ffp{i},'dir') && ...
					(~nodupes || ~any(strcmp(full_file_picks,ffp{i})))
				full_file_picks{end + 1} = ffp{i}; %#ok<AGROW>
				[unused,fn,ext] = fileparts(ffp{i});
				file_picks{end + 1} = [fn,ext]; %#ok<AGROW>
				path_c_temp = path2cell(ffp{i});
				temp = dir(cell2path(path_c_temp(1:end-1)));
				if ispc || ismac
					thisdir = strcmpi({temp.name},[fn,ext]);
				else
					thisdir = strcmp({temp.name},[fn,ext]);
				end
				dir_picks(end + 1) = temp(thisdir); %#ok<AGROW>
				dir_picks(end).name = ffp{i};
			elseif fdexist(ffp{i},'file') && ...
					(~nodupes || ~any(strcmp(full_file_picks,ffp{i})))
				full_file_picks{end + 1} = ffp{i}; %#ok<AGROW>
				[unused,fn,ext] = fileparts(ffp{i});
				file_picks{end + 1} = [fn,ext]; %#ok<AGROW>
				dir_picks(end + 1) = dir(ffp{i}); %#ok<AGROW>
				dir_picks(end).name = ffp{i};
			end
		end
		if show_full_path
			set(pickslist,'String',full_file_picks,'Value',[]);
		else
			set(pickslist,'String',file_picks,'Value',[]);
		end
		set([removebut,moveupbut,movedownbut],'Enable','off');
	end

	function sort_type(h,evt,cb) %#ok<INUSL>
		if sort_state(cb)
			sort_state(cb) = -sort_state(cb);
			last_sort_state(cb) = sort_state(cb);
		else
			sort_state = zeros(1,3);
			sort_state(cb) = last_sort_state(cb);
		end
		set(sort_cb,{'CData'},tri_icon(sort_state + 2)')
		
		fdir = filtered_dir(full_filter,re_filter,prop.redirs,...
				@(x,c)file_sort(x,sort_state,c));
		filenames = {fdir.name}';
		[filenames,fdir] = annotate_file_names(filenames,fdir,fsdata);
		set(dir_popup,'String',path_cell,'Value',length(path_cell))
		if length(path_cell) > 1
			up_dir_but.Enable = 'on';
		else
			up_dir_but.Enable = 'off';
		end
		pathbox.String = current_dir;
		set(navlist,'String',filenames,'Value',[])
		addbut.Enable = 'off';
		openbut.Enable = 'off';
		fig.Pointer = 'arrow';
	end

	function dirpopup(varargin)
		value = dir_popup.Value;
		container = path_cell{min(value + 1,length(path_cell))};
		path_cell = path_cell(1:value);
		fig.Pointer = 'watch';
		drawnow
		if ispc && value == 1
			current_dir = '';
			full_filter = filter;
			drives = getdrives(network_volumes);
			num_drives = length(drives);
			temp = tempname;
			mkdir(temp)
			dir_temp = dir(temp);
			rmdir(temp)
			fdir = repmat(dir_temp(1),num_drives,1);
			[fdir.name] = deal(drives{:});
		else
			current_dir = cell2path(path_cell);
% 			history = update_history(history,current_dir,now,history_size);
% 			make_history_cm(csdata)
			full_filter = fullfile(current_dir,filter);
			fdir = filtered_dir(full_filter,re_filter,prop.redirs,...
				@(x,c)file_sort(x,sort_state,c));
		end
		filenames = {fdir.name}';
		selected = find(strcmp(filenames,container));
		[filenames,fdir] = annotate_file_names(filenames,fdir,fsdata);
		set(dir_popup,'String',path_cell,'Value',length(path_cell))
		if length(path_cell) > 1
			up_dir_but.Enable = 'on';
		else
			up_dir_but.Enable = 'off';
		end
		pathbox.String = current_dir;
		set(navlist,'String',filenames,'Value',selected)
		addbut.Enable = 'off';
		fig.Pointer = 'arrow';
	end

	function dir_up_one(varargin)
		value = length(path_cell) - 1;
		container = path_cell{value + 1};
		path_cell = path_cell(1:value);
		fig.Pointer = 'watch';
		drawnow
		if ispc && value == 1
			current_dir = '';
			full_filter = filter;
			drives = getdrives(network_volumes);
			num_drives = length(drives);
			temp = tempname;
			mkdir(temp)
			dir_temp = dir(temp);
			rmdir(temp)
			fdir = repmat(dir_temp(1),num_drives,1);
			[fdir.name] = deal(drives{:});
		else
			current_dir = cell2path(path_cell);
% 			history = update_history(history,current_dir,now,history_size);
% 			make_history_cm(csdata)
			full_filter = fullfile(current_dir,filter);
			fdir = filtered_dir(full_filter,re_filter,prop.redirs,...
				@(x,c)file_sort(x,sort_state,c));
		end
		filenames = {fdir.name}';
		selected = find(strcmp(filenames,container));
		[filenames,fdir] = annotate_file_names(filenames,fdir,fsdata);
		set(dir_popup,'String',path_cell,'Value',length(path_cell))
		if length(path_cell) > 1
			up_dir_but.Enable = 'on';
		else
			up_dir_but.Enable = 'off';
		end
		pathbox.String = current_dir;
		set(navlist,'String',filenames,'Value',selected)
		addbut.Enable = 'off';
		fig.Pointer = 'arrow';
	end

	function change_path(varargin)
		fig.Pointer = 'watch';
		drawnow
		proposed_path = pathbox.String;
		% Process any folders named '..'.
		proposed_path_cell = path2cell(proposed_path);
		ddots = strcmp(proposed_path_cell,'..');
		ddots(find(ddots) - 1) = true;
		proposed_path_cell(ddots) = [];
		proposed_path = cell2path(proposed_path_cell);
		% Check for existance of folder.
		if ~fdexist(proposed_path,'dir')
			fig.Pointer = 'arrow';
			uiwait(errordlg(['Folder "',proposed_path,...
				'" does not exist.'],'','modal'))
			return
		end
		current_dir = proposed_path;
% 		history = update_history(history,current_dir,now,history_size);
% 		make_history_cm(csdata)
		full_filter = fullfile(current_dir,filter);
		[path_cell,new_network_vol] = path2cell(current_dir);
		if fdexist(new_network_vol,'dir')
			network_volumes = unique([network_volumes,{new_network_vol}]);
		end
		fdir = filtered_dir(full_filter,re_filter,prop.redirs,...
				@(x,c)file_sort(x,sort_state,c));
		filenames = {fdir.name}';
		[filenames,fdir] = annotate_file_names(filenames,fdir,fsdata);
		set(dir_popup,'String',path_cell,'Value',length(path_cell))
		if length(path_cell) > 1
			up_dir_but.Enable = 'on';
		else
			up_dir_but.Enable = 'off';
		end
		pathbox.String = current_dir;
		set(navlist,'String',filenames,'Value',[])
		addbut.Enable = 'off';
		openbut.Enable = 'off';
		fig.Pointer = 'arrow';
	end

	function showfullpath(varargin)
		show_full_path = viewfullpath.Value;
		if show_full_path
			pickslist.String = full_file_picks;
		else
			pickslist.String = file_picks;
		end
	end

	function removedupes(varargin)
		nodupes = remove_dupes.Value;
		if nodupes
			num_picks = length(full_file_picks);
			[unused,rev_order] = unique(full_file_picks(end:-1:1)); %#ok<SETNU>
			order = sort(num_picks + 1 - rev_order);
			full_file_picks = full_file_picks(order);
			file_picks = file_picks(order);
			dir_picks = dir_picks(order);
			if show_full_path
				set(pickslist,'String',full_file_picks,'Value',[])
			else
				set(pickslist,'String',file_picks,'Value',[])
			end
			set([removebut,moveupbut,movedownbut],'Enable','off')
		end
	end

	function moveup(varargin)
		value = pickslist.Value;
		removebut.Enable = 'on';
		n = length(file_picks);
		omega = 1:n;
		index = zeros(1,n);
		index(value - 1) = omega(value);
		index(setdiff(omega,value - 1)) = omega(setdiff(omega,value));
		file_picks = file_picks(index);
		full_file_picks = full_file_picks(index);
		dir_picks = dir_picks(index);
		value = value - 1;
		if show_full_path
			set(pickslist,'String',full_file_picks,'Value',value)
		else
			set(pickslist,'String',file_picks,'Value',value)
		end
		if min(value) == 1
			moveupbut.Enable = 'off';
		end
		movedownbut.Enable = 'on';
	end

	function movedown(varargin)
		value = pickslist.Value;
		removebut.Enable = 'on';
		n = length(file_picks);
		omega = 1:n;
		index = zeros(1,n);
		index(value + 1) = omega(value);
		index(setdiff(omega,value + 1)) = omega(setdiff(omega,value));
		file_picks = file_picks(index);
		full_file_picks = full_file_picks(index);
		dir_picks = dir_picks(index);
		value = value + 1;
		if show_full_path
			set(pickslist,'String',full_file_picks,'Value',value)
		else
			set(pickslist,'String',file_picks,'Value',value)
		end
		if max(value) == n
			movedownbut.Enable = 'off';
		end
		moveupbut.Enable = 'on';
	end

	function togglefilter(varargin)
		fig.Pointer = 'watch';
		drawnow
		value = showallfiles.Value;
		if value
			filter = '*';
			re_filter = '';
			set([filter_ed,refilter_ed],'Enable','off')
		else
			filter = filter_ed.String;
			re_filter = refilter_ed.String;
			set([filter_ed,refilter_ed],'Enable','on')
		end
		full_filter = fullfile(current_dir,filter);
		fdir = filtered_dir(full_filter,re_filter,prop.redirs,...
				@(x,c)file_sort(x,sort_state,c));
		filenames = {fdir.name}';
		[filenames,fdir] = annotate_file_names(filenames,fdir,fsdata);
		set(navlist,'String',filenames,'Value',[])
		addbut.Enable = 'off';
		fig.Pointer = 'arrow';
	end

	function toggle_refiltdirs(varargin)
		fig.Pointer = 'watch';
		drawnow
		value = refilterdirs.Value;
		prop.redirs = value;
		full_filter = fullfile(current_dir,filter);
		fdir = filtered_dir(full_filter,re_filter,prop.redirs,...
				@(x,c)file_sort(x,sort_state,c));
		filenames = {fdir.name}';
		[filenames,fdir] = annotate_file_names(filenames,fdir,fsdata);
		set(navlist,'String',filenames,'Value',[])
		addbut.Enable = 'off';
		fig.Pointer = 'arrow';
	end

	function setfilspec(varargin)
		fig.Pointer = 'watch';
		drawnow
		filter = filter_ed.String;
		if isempty(filter)
			filter = '*';
			filter_ed.String = filter;
		end
		% Process file spec if a subdirectory was included.
		[p,f,e] = fileparts(filter);
		if ~isempty(p)
			newpath = fullfile(current_dir,p,'');
			pathbox.String = newpath;
			filter = [f,e];
			if isempty(filter)
				filter = '*';
			end
			filter_ed.String = filter;
			change_path();
		end
		full_filter = fullfile(current_dir,filter);
		fdir = filtered_dir(full_filter,re_filter,prop.redirs,...
				@(x,c)file_sort(x,sort_state,c));
		filenames = {fdir.name}';
		[filenames,fdir] = annotate_file_names(filenames,fdir,fsdata);
		set(navlist,'String',filenames,'Value',[])
		addbut.Enable = 'off';
		fig.Pointer = 'arrow';
	end

	function setrefilter(varargin)
		fig.Pointer = 'watch';
		drawnow
		re_filter = refilter_ed.String;
		fdir = filtered_dir(full_filter,re_filter,prop.redirs,...
				@(x,c)file_sort(x,sort_state,c));
		filenames = {fdir.name}';
		[filenames,fdir] = annotate_file_names(filenames,fdir,fsdata);
		set(navlist,'String',filenames,'Value',[])
		addbut.Enable = 'off';
		fig.Pointer = 'arrow';
	end

	function filter_type_callback(varargin)
		type_value = type_popup.Value;
		set(filter_ed,'String',prop.type{type_value,1})
		setfilspec()
	end

	function done(varargin)
		% Optional shortcut: click on a file and press 'Done'.
% 		if isempty(full_file_picks) && strcmp(addbut.Enable,'on')
% 			add();
% 		end
		numfiles = length(full_file_picks);
		if ~isempty(prop.numfiles)
			if numfiles < prop.numfiles(1)
				msg = {'Too few items selected.',numstr};
				uiwait(errordlg(msg,'','modal'))
				return
			elseif numfiles > prop.numfiles(end)
				msg = {'Too many items selected.',numstr};
				uiwait(errordlg(msg,'','modal'))
				return
			end
		end
		fig_pos = fig.Position;
		delete(fig)
	end

	function cancel(varargin)
		prop.output = 'cancel';
		fig_pos = fig.Position;
		delete(fig)
	end

	function history_cb(h,evt,arg) %#ok<INUSL>
		fig.Pointer = 'watch';
		drawnow
		if ischar(arg)
			current_dir = arg;
		else
			current_dir = history(arg).name;
		end
% 		history = update_history(history,current_dir,now,history_size);
% 		make_history_cm(csdata)
		full_filter = fullfile(current_dir,filter);
		path_cell = path2cell(current_dir);
		fdir = filtered_dir(full_filter,re_filter,prop.redirs,...
				@(x,c)file_sort(x,sort_state,c));
		filenames = {fdir.name}';
		[filenames,fdir] = annotate_file_names(filenames,fdir,fsdata);
		set(dir_popup,'String',path_cell,'Value',length(path_cell))
		if length(path_cell) > 1
			up_dir_but.Enable = 'on';
		else
			up_dir_but.Enable = 'off';
		end
		pathbox.String = current_dir;
		set(navlist,'ListboxTop',1,'Value',[],'String',filenames)
		addbut.Enable = 'off';
		openbut.Enable = 'off';
		fig.Pointer = 'arrow';
	end

	function add_to_favorites(varargin)
		favorites{end+1} = current_dir;
		make_history_cm(csdata)
	end

	function remove_from_favorites(varargin)
		favorites = setdiff(favorites,current_dir);
		make_history_cm(csdata)
	end

	function clear_history(varargin)
		history = update_history(history(1),'',[],history_size);
		make_history_cm(csdata)
	end

	function set_history_size(varargin)
		result_cell = inputdlg('Number of Recent Folders:','',1,...
			{sprintf('%g',history_size)});
		if isempty(result_cell)
			return
		end
		result = sscanf(result_cell{1},'%f');
		if isempty(result) || result < 1
			return
		end
		history_size = result;
		history = update_history(history,'',[],history_size);
		make_history_cm(csdata)
		setpref('uipickfiles','history_size',history_size)
	end

	function resize(varargin)
		% Get current figure size.
		P = 'Position';
		pos = fig.Position;
		w = pos(3); % figure width in pixels
		h = pos(4); % figure height in pixels
		
		% Enforce minimum figure size.
		w = max(w,564);
		h = max(h,443);
		if any(pos(3:4) < [w h])
			pos(3:4) = [w h];
			fig.Position = pos;
		end
		
		% Change positions of all uicontrols based on the current figure
		% width and height.
		navw_pckw = round([1 1;-350 250]\[w-140;0]);
		navw = navw_pckw(1);
		pckw = navw_pckw(2);
		navp = [10 10 navw h-174];
		pckp = [w-10-pckw 10 pckw h-174];
		set(navlist,P,navp)
		set(pickslist,P,pckp)
		
		set(frame1,P,[navw+5 h-234 110 70])
		set(openbut,P,[navw+17 h-199 90 30])
		set(addbut,P,[navw+17 h-229 90 30])
		
		frame2y = round((h-234 + 110 - 100)/2);
		set(frame2,P,[w-pckw-115 frame2y 110 100])
		set(removebut,P,[w-pckw-105 frame2y+65 90 30])
		set(moveupbut,P,[w-pckw-105 frame2y+35 90 30])
		set(movedownbut,P,[w-pckw-105 frame2y+5 90 30])
		
		set(done_button,P,[navw+30 80 80 30])
		set(cancel_button,P,[navw+30 30 80 30])
		
		set(sort_cb(1),P,[15 h-163 70 15])
		set(sort_cb(2),P,[85 h-163 70 15])
		set(sort_cb(3),P,[155 h-163 70 15])
		
		set(dir_popup,P,[10 h-144 navw-25 20])
		set(up_dir_but,P,[navw-10 h-144 20 20])
		set(pathbox,P,[10 h-119 navw 26])
		set(label1,P,[10 h-93 navw 16])
		
		set(viewfullpath,P,[pckp(1) h-159 230 20])
		set(remove_dupes,P,[pckp(1) h-134 280 20])
		set(recall_button,P,[w-75 h-159 65 30])
		set(label4,P,[w-10-pckw h-89 pckw 20])
		set(num_files_warn,P,[w-10-pckw h-109 pckw 16])
		
		label2.Position(2) = h - 18;
		label3.Position(2) = h - 18;
		showallfiles.Position(2) = h - 42;
		refilterdirs.Position(2) = h - 64;
		filter_ed.Position(2) = h - 44;
		refilter_ed.Position(2) = h - 44;
		set(type_popup,P,[10 h-72 250 20])
	end

	function reset_figure_size(varargin)
		if strcmp(fig.SelectionType,'open')
			root_units = get(groot,'Units');
			screen_size = get(groot,'ScreenSize');
			set(0,'Units',root_units)
			hw = [740 494];
			pos = [round((screen_size(3:4) - hw - [0 26])/2),hw];
			fig.Position = pos;
			resize()
		end
	end



% ------------------ Other nested functions ------------------

	function make_history_cm(csdata)
		% Make context menu for history.
		if ~isempty(hist_menus)
			delete(hist_menus)
		end
		num_hist = length(history);
		hist_menus = zeros(1,num_hist);
		for i = 1:num_hist
			hist_menus(i) = uimenu(hist_cm,'Label',history(i).name,...
				'Callback',{@history_cb,i});
		end
		hist_menus(end+1) = uimenu(hist_cm,...
			'Label','Favorites',...
			'Enable','off',...
			'Separator','on');
		hist_menus(end+1) = uimenu(hist_cm,...
			'Label',[csdata.pre_home,csdata.home_folder,csdata.post],...
			'Callback',{@history_cb,csdata.home_folder});
		for i = 1:length(csdata.matlab_folders)
			hist_menus(end+1) = uimenu(hist_cm,...
				'Label',[csdata.pre_logo,csdata.matlab_folders{i},csdata.post],...
				'Callback',{@history_cb,csdata.matlab_folders{i}}); %#ok<AGROW>
		end
		for i = 1:length(favorites)
			hist_menus(end+1) = uimenu(hist_cm,...
				'Label',favorites{i},...
				'Callback',{@history_cb,favorites{i}}); %#ok<AGROW>
		end
		hist_menus(end+1) = uimenu(hist_cm,...
			'Label','Add Current Folder to Favorites',...
			'Separator','on',...
			'Callback',@add_to_favorites);
		hist_menus(end+1) = uimenu(hist_cm,...
			'Label','Remove Current Folder from Favorites',...
			'Callback',@remove_from_favorites);
		hist_menus(end+1) = uimenu(hist_cm,...
			'Label','Clear Menu',...
			'Separator','on',...
			'Callback',@clear_history);
		hist_menus(end+1) = uimenu(hist_cm,'Label',...
			sprintf('Set Number of Recent Folders (%d) ...',history_size),...
			'Callback',@set_history_size);
	end

end


% -------------------- Subfunctions --------------------

function [c,network_vol] = path2cell(p)
% Turns a path string into a cell array of path elements.
if ispc
	p = strrep(p,'/','\');
	c1 = regexp(p,'(^\\\\[^\\]+\\[^\\]+)|(^[A-Za-z]+:)|[^\\]+','match');
	vol = c1{1};
	c = [{'My Computer'};c1(:)];
	if strncmp(vol,'\\',2)
		network_vol = vol;
	else
		network_vol = '';
	end
else
	c = textscan(p,'%s','delimiter','/');
	c = [{filesep};c{1}(2:end)];
	network_vol = '';
end
end

% --------------------

function p = cell2path(c)
% Turns a cell array of path elements into a path string.
if ispc
	p = fullfile(c{2:end},'');
	if p(end) == ':'
		p = [p,filesep];
	end
else
	p = fullfile(c{:},'');
end
end

% --------------------

function d = filtered_dir(full_filter,re_filter,filter_both,sort_fcn)
% Like dir, but applies filters and sorting.
p = fileparts(full_filter);
if isempty(p) && full_filter(1) == '/'
	p = '/';
end
if fdexist(full_filter,'dir')
	dfiles = repmat(dir(char(127)),0,1);
else
	dfiles = dir(full_filter);
end
if ~isempty(dfiles)
	dfiles([dfiles.isdir]) = [];
end

ddir = dir(p);
ddir = ddir([ddir.isdir]);
[unused,index0] = sort(lower({ddir.name})); %#ok<ASGLU>
ddir = ddir(index0);
ddir(strcmp({ddir.name},'.') | strcmp({ddir.name},'..')) = [];

% Additional regular expression filter.
if nargin > 1 && ~isempty(re_filter)
	if ispc || ismac
		no_match = cellfun('isempty',regexpi({dfiles.name},re_filter));
	else
		no_match = cellfun('isempty',regexp({dfiles.name},re_filter));
	end
	dfiles(no_match) = [];
end
if filter_both
	if nargin > 1 && ~isempty(re_filter)
		if ispc || ismac
			no_match = cellfun('isempty',regexpi({ddir.name},re_filter));
		else
			no_match = cellfun('isempty',regexp({ddir.name},re_filter));
		end
		ddir(no_match) = [];
	end
end
% Set navigator style:
%	1 => list all folders before all files, case-insensitive sorting
%	2 => mix files and folders, case-insensitive sorting
%	3 => list all files before all folders, case-insensitive sorting
%	4 => list all folders before all files, case-sensitive sorting
%	5 => mix files and folders, case-sensitive sorting
%	6 => list all files before all folders, case-sensitive sorting
nav_style = 1;
switch nav_style
	case 1
		[unused,index1] = sort_fcn(dfiles,false); %#ok<ASGLU>
		[unused,index2] = sort_fcn(ddir,false); %#ok<ASGLU>
		d = [ddir(index2);dfiles(index1)];
	case 2
		d = [dfiles;ddir];
		[unused,index] = sort_fcn(d,false); %#ok<ASGLU>
		d = d(index);
	case 3
		[unused,index1] = sort_fcn(dfiles,false); %#ok<ASGLU>
		[unused,index2] = sort_fcn(ddir,false); %#ok<ASGLU>
		d = [dfiles(index1);ddir(index2)];
	case 4
		[unused,index1] = sort_fcn(dfiles,true); %#ok<ASGLU>
		[unused,index2] = sort_fcn(ddir,true); %#ok<ASGLU>
		d = [ddir(index2);dfiles(index1)];
	case 5
		d = [dfiles;ddir];
		[unused,index] = sort_fcn(d,true); %#ok<ASGLU>
		d = d(index);
	case 6
		[unused,index1] = sort_fcn(dfiles,true); %#ok<ASGLU>
		[unused,index2] = sort_fcn(ddir,true); %#ok<ASGLU>
		d = [dfiles(index1);ddir(index2)];
end
end

% --------------------

function [files_sorted,index] = file_sort(files,sort_state,casesen)
switch find(sort_state)
	case 1
		if casesen
			[files_sorted,index] = sort({files.name});
		else
			[files_sorted,index] = sort(lower({files.name}));
		end
		if sort_state(1) < 0
			files_sorted = files_sorted(end:-1:1);
			index = index(end:-1:1);
		end
	case 2
		if sort_state(2) > 0
			[files_sorted,index] = sort([files.datenum]);
		else
			[files_sorted,index] = sort([files.datenum],'descend');
		end
	case 3
		if sort_state(3) > 0
			[files_sorted,index] = sort([files.bytes]);
		else
			[files_sorted,index] = sort([files.bytes],'descend');
		end
end
end

% --------------------

function drives = getdrives(other_drives)
% Returns a cell array of drive names on Windows.
letters = char('A':'Z');
num_letters = length(letters);
drives = cell(1,num_letters);
for i = 1:num_letters
	if fdexist([letters(i),':\'],'dir')
		drives{i} = [letters(i),':'];
	end
end
drives(cellfun('isempty',drives)) = [];
if nargin > 0 && iscellstr(other_drives)
	drives = [drives,unique(other_drives)];
end
end

% --------------------

function [filenames,dir_listing] = ...
	annotate_file_names(filenames,dir_listing,fsdata)
% Adds a trailing filesep character to folder names and, optionally,
% prepends a folder icon or bullet symbol.
if ispc
	for i = 1:length(filenames)
		if ~isempty(regexpi(filenames{i},'\.lnk')) && ...
				is_shortcut_to_dir(dir_listing(i).name)
			filenames{i} = sprintf('%s%s%s%s',fsdata.pre_sc,filenames{i},...
				fsdata.filesep,fsdata.post);
			dir_listing(i).isdir = true;
		elseif dir_listing(i).isdir
			filenames{i} = sprintf('%s%s%s%s',fsdata.pre,filenames{i},...
				fsdata.filesep,fsdata.post);
		end
	end
else
	for i = 1:length(filenames)
		if dir_listing(i).isdir
			filenames{i} = sprintf('%s%s%s%s',fsdata.pre,filenames{i},...
				fsdata.filesep,fsdata.post);
		end
	end
end
end

% --------------------

function history = update_history(history,current_dir,time,history_size)
if ~isempty(current_dir)
	% Insert or move current_dir to the top of the history.
	% If current_dir already appears in the history list, delete it.
	match = strcmp({history.name},current_dir);
	history(match) = [];
	% Prepend history with (current_dir,time).
	history = [struct('name',current_dir,'time',time),history];
end
% Trim history to keep at most <history_size> newest entries.
history = history(1:min(history_size,end));
end

% --------------------

function success = generate_folder_icon(icon_path)
% Black = 1, manila color = 2, transparent white = 3.
im = [ ...
	3 3 3 1 1 1 1 3 3 3 3 3;
	3 3 1 2 2 2 2 1 3 3 3 3;
	3 1 1 1 1 1 1 1 1 1 1 3;
	1 2 2 2 2 2 2 2 2 2 2 1;
	1 2 2 2 2 2 2 2 2 2 2 1;
	1 2 2 2 2 2 2 2 2 2 2 1;
	1 2 2 2 2 2 2 2 2 2 2 1;
	1 2 2 2 2 2 2 2 2 2 2 1;
	1 2 2 2 2 2 2 2 2 2 2 1;
	1 1 1 1 1 1 1 1 1 1 1 1];
cmap = [0 0 0;255 220 130;255 255 255]/255;
fid = fopen(icon_path,'w');
if fid > 0
	fclose(fid);
	imwrite(im,cmap,icon_path,'Transparency',[1 1 0])
end
success = fdexist(icon_path,'file');
end

% --------------------

function success = generate_foldersc_icon(icon_path)
% Black = 1, blue color = 2, darker blue = 3, transparent white = 4.
im = [ ...
	4 4 4 1 1 1 1 4 4 4 4 4;
	4 4 1 2 2 2 2 1 4 4 4 4;
	4 1 1 1 1 1 1 1 1 1 1 4;
	1 2 2 2 2 2 3 2 2 2 2 1;
	1 2 2 2 2 2 2 1 2 2 2 1;
	1 2 2 2 1 1 1 1 1 2 2 1;
	1 2 2 1 2 2 2 1 2 2 2 1;
	1 2 1 2 2 2 3 2 2 2 2 1;
	1 2 2 2 2 2 2 2 2 2 2 1;
	1 1 1 1 1 1 1 1 1 1 1 1];
cmap = [0 0 0;163 185 255;65 83 128;255 255 255]/255;
fid = fopen(icon_path,'w');
if fid > 0
	fclose(fid);
	imwrite(im,cmap,icon_path,'Transparency',[1 1 1 0])
end
success = fdexist(icon_path,'file');
end

% --------------------

function success = generate_house_icon(icon_path)
im = [6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6;
	6 6 6 6 6 6 6 5 5 6 6 6 6 6 6 6;
	6 6 6 6 6 6 5 8 8 5 6 8 8 8 6 6;
	6 6 6 6 6 5 8 3 3 8 5 2 9 2 6 6;
	6 6 6 6 5 8 3 3 3 3 8 5 9 2 6 6;
	6 6 6 5 8 3 7 4 4 7 3 8 5 2 6 6;
	6 6 5 8 3 3 1 1 1 1 3 3 8 5 6 6;
	6 5 8 3 3 3 2 4 4 2 3 3 3 8 5 6;
	5 8 2 3 3 3 3 3 3 3 3 3 3 2 8 5;
	6 6 2 3 3 3 1 1 1 1 3 3 3 2 6 6;
	6 6 2 3 3 3 1 8 8 1 3 3 3 2 6 6;
	6 6 2 3 3 3 1 8 8 1 3 3 3 2 6 6;
	6 6 2 3 3 3 1 1 2 1 3 3 3 2 6 6;
	6 6 2 3 3 3 1 5 5 1 3 3 3 2 6 6;
	6 6 2 3 3 3 1 7 7 1 3 3 3 2 6 6;
	6 6 8 8 8 8 4 4 4 4 8 8 8 8 6 6];
im = [im,6*ones(16,5)];
cmap = [70 24 9;174 172 166;244 240 230;93 96 97;32 33 33;...
	255 255 255;153 71 21;66 52 39;255 255 254]/255;
fid = fopen(icon_path,'w');
if fid > 0
	fclose(fid);
	imwrite(im,cmap,icon_path,'Transparency',[1 1 1 1 1 0 1 1 1])
end
success = fdexist(icon_path,'file');
end

% --------------------

function success = generate_logo_icon(icon_path)
im = [9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9;
	9 9 9 9 9 9 9 9 9 9 10 9 9 9 9 9;
	9 9 9 9 9 9 9 9 9 10 8 6 9 9 9 9;
	9 9 9 9 9 9 9 9 9 4 3 7 10 9 9 9;
	9 9 9 9 9 9 9 9 2 1 7 7 6 9 9 9;
	9 9 9 9 9 9 9 2 1 1 7 7 3 9 9 9;
	9 9 9 9 9 10 4 1 1 8 7 7 3 5 9 9;
	9 9 9 9 10 1 1 1 1 8 7 7 3 6 5 9;
	9 9 10 2 4 4 1 1 8 8 7 7 3 3 9 9;
	10 2 2 2 4 4 1 1 8 3 3 7 7 3 6 9;
	9 2 2 4 4 4 1 8 8 3 7 7 7 3 6 5;
	9 9 10 2 4 1 8 8 8 3 7 7 6 6 3 5;
	9 9 9 9 9 1 8 3 3 7 7 9 9 9 6 6;
	9 9 9 9 9 5 3 7 7 7 5 9 9 9 9 5;
	9 9 9 9 9 9 6 7 7 5 9 9 9 9 9 9;
	9 9 9 9 9 9 5 6 5 9 9 9 9 9 9 9];
im = [im,9*ones(16,5)];
cmap = [73 50 49;132 193 188;182 60 15;97 146 141;246 224 205;...
	223 153 109;230 113 15;123 33 18;255 255 255;202 212 210]/255;
fid = fopen(icon_path,'w');
if fid > 0
	fclose(fid);
	imwrite(im,cmap,icon_path,'Transparency',[1 1 1 1 1 1 1 1 0 1])
end
success = fdexist(icon_path,'file');
end

% --------------------

function fsdata = set_folder_style(folder_style_pref)
% Set style to preference.
fsdata.style = folder_style_pref;
% If style = 1, check to make sure icon image file exists.  If it doesn't,
% try to create it.  If that fails set style = 2.
if fsdata.style == 1
	icon1_path = fullfile(prefdir,'uipickfiles_folder_icon.png');
	icon2_path = fullfile(prefdir,'uipickfiles_foldersc_icon.png');
	if ~(fdexist(icon1_path,'file') && fdexist(icon2_path,'file'))
		success1 = generate_folder_icon(icon1_path);
		success2 = generate_foldersc_icon(icon2_path);
		if ~(success1 && success2)
			fsdata.style = 2;
		end
	end
end
% Set pre and post fields.
if fsdata.style == 1
	icon1_url = ['file:///',strrep(strrep(icon1_path,':','|'),'\','/')];
	icon2_url = ['file:///',strrep(strrep(icon2_path,':','|'),'\','/')];
	fsdata.pre = sprintf('<html><img width=12 height=10 src="%s">&nbsp;',icon1_url);
	fsdata.pre_sc = sprintf('<html><img width=12 height=10 src="%s">&nbsp;',icon2_url);
	fsdata.post = '</html>';
elseif fsdata.style == 2
	fsdata.pre = '<html><b>&#8226;</b>&nbsp;';
	fsdata.pre_sc = '<html><b>&#8226;</b>&nbsp;';
	fsdata.post = '</html>';
elseif fsdata.style == 3
	fsdata.pre = '';
	fsdata.pre_sc = '';
	fsdata.post = '';
end
fsdata.filesep = filesep;

end

% --------------------

function csdata = set_cmenu_style(cmenu_style_pref)
% Set style to preference.
csdata.style = cmenu_style_pref;
% If style = 1, check to make sure icon image files exist.  If they don't,
% try to create them.  If that fails set style = 2.
if csdata.style == 1
	icon1_path = fullfile(prefdir,'uipickfiles_home_icon.png');
	icon2_path = fullfile(prefdir,'uipickfiles_logo_icon.png');
	if ~(fdexist(icon1_path,'file') && fdexist(icon2_path,'file'))
		success1 = generate_house_icon(icon1_path);
		success2 = generate_logo_icon(icon2_path);
		if ~(success1 && success2)
			csdata.style = 2;
		end
	end
end
% Set pre and post fields.
if csdata.style == 1
	icon1_url = ['file:///',strrep(strrep(icon1_path,':','|'),'\','/')];
	icon2_url = ['file:///',strrep(strrep(icon2_path,':','|'),'\','/')];
	csdata.pre_home = sprintf('<html><img width=21 height=16 src="%s">',icon1_url);
	csdata.pre_logo = sprintf('<html><img width=21 height=16 src="%s">',icon2_url);
	csdata.post = '</html>';
elseif csdata.style == 2
	csdata.pre_home = '';
	csdata.pre_logo = '';
	csdata.post = '';
end

% Get MATLAB folders from userpath.
matlab_folders = regexp(userpath,pathsep,'split');
matlab_folders(cellfun(@isempty,matlab_folders)) = [];
if ispc
	csdata.home_folder = getenv('USERPROFILE');
else
	csdata.home_folder = getenv('HOME');
end
csdata.matlab_folders = matlab_folders;

end

% --------------------

function prop = parsepropval(prop,varargin)
% Parse property/value pairs and return a structure.
properties = fieldnames(prop);
arg_index = 1;
while arg_index <= length(varargin)
	arg = varargin{arg_index};
	if ischar(arg)
		prop_index = match_property(arg,properties);
		prop.(properties{prop_index}) = varargin{arg_index + 1};
		arg_index = arg_index + 2;
	elseif isstruct(arg)
		arg_fn = fieldnames(arg);
		for i = 1:length(arg_fn)
			prop_index = match_property(arg_fn{i},properties);
			prop.(properties{prop_index}) = arg.(arg_fn{i});
		end
		arg_index = arg_index + 1;
	else
		error(['Properties must be specified by property/value pairs',...
			' or structures.'])
	end
end
end

% --------------------

function prop_index = match_property(arg,properties)
% Utility function for parsepropval.
prop_index = find(strcmpi(arg,properties));
if isempty(prop_index)
	prop_index = find(strncmpi(arg,properties,length(arg)));
end
if length(prop_index) ~= 1
	error('Property ''%s'' does not exist or is ambiguous.',arg)
end
end

% --------------------

function r = fdexist(item_path,type)
%fdexist: Check if file or directory exists.  Does not search MATLAB path.
%  type must be 'dir' or 'file'.
if strncmpi(type,'dir',length(type))
	r = java.io.File(item_path).isDirectory();
elseif strncmpi(type,'file',length(type))
	r = java.io.File(item_path).isFile();
end
end

% --------------------

function r = is_shortcut_to_dir(filename)
r = false;
% jFile = java.io.File(filename);
% sf = sun.awt.shell.ShellFolder.getShellFolder(jFile);
% r = sf.isDirectory();
end

% --------------------

function d = subdirs(basedir,depth,exclusions)
%subdirs: Recursive directory finder.
% Recursively find all subdirectories of a specified directory.
%
% Syntax:
%   dirs = subdirs;
%
% will return all subdirectories of the current directory, including the
% current directory, in a cell array of strings.
%
%   dirs = subdirs(base);
%
% starts at the directory in the string, base, rather than the current
% directory.
%
%   dirs = subdirs(base,depth);
%
% only searches to a limited depth (default is Inf).  A depth of zero
% returns only the base directory, depth = 1 returns the base directory and
% its immediate decendants, etc.

% Version: 1.1, 8 November 2014
% Author:  Douglas M. Schwarz
% Email:   dmschwarz=ieee*org, dmschwarz=urgrad*rochester*edu
% Real_email = regexprep(Email,{'=','*'},{'@','.'})

% If base directory not specified, use current directory.
if nargin < 1
	basedir = pwd;
end

% If depth not specified, search to infinite depth.
if nargin < 2 || isempty(depth)
	depth = inf;
end

if nargin < 3 || isempty(exclusions)
	exclusions = '';
end

% If instructed not to search deeper, return basedir in a cell.
if depth == 0
	d = {basedir};
	return
end

% Check exclusions for 'p' => exclude 'private' directories.  Other
% exclusions characters exclude directories beginning with that character,
% e.g., '.@+'.
exclu = exclusions;
no_private = any(exclu == 'p');
exclu(exclu == 'p') = [];

% Get directory contents.
items = dir(basedir);

% Get the name of each item in basedir.  Remove items that are not
% directories and the special directories named '.' and '..', leaving only
% the desired subdirectories.
item_names = {items.name};
item_names(~[items.isdir] | strcmp(item_names,'.') | ...
	strcmp(item_names,'..')) = [];

% Remove private directories, if desired.
if no_private
	item_names(strcmpi(item_names,'private')) = [];
end

% Remove directories beginning with the characters in exclu, e.g., '.@+'.
for i = 1:length(exclu)
	item_names(strncmp(item_names,exclu(i),1)) = [];
end

% Run this function recursively on each subdirectory and return basedir and
% those subdirectories.
num_items = length(item_names);
subitems = cell(1,num_items);
for i = 1:num_items
	subitems{i} = subdirs(fullfile(basedir,item_names{i},''),...
		depth - 1,exclusions);
end
d = [{basedir},subitems{:}];
end

./ExternalSoftware/setupExternalSoftware.m
function setupExternalSoftware()
%Run function in startup.m to setup required paths for smite external software.
% If the smite folder is located in userpath, then use the following: 
% 
% MATLAB 2017a and later:
%   run(fullfile(userpath, 'smite', 'ExternalSoftWare', ...
%                'setupExternalSoftware'))
%
% MATLAB 2016b and ealier:
%   run(fullfile(userpath(1:end-1), 'smite', 'ExternalSoftWare', ...
%                'setupExternalSoftware'))

ExternalSoftwarePath = fileparts(which('setupExternalSoftware'));

%addpath(ExternalSoftwarePath)
addpath(fullfile(ExternalSoftwarePath, 'FRCresolution_software', ...
                 'matlabdistribution', 'FRCresolutionfunctions'));
addpath(fullfile(ExternalSoftwarePath, 'PlotSpread'));
addpath(fullfile(ExternalSoftwarePath, 'uipickfiles'));

end

./ExternalSoftware/FRCresolution_software/matlabdistribution/example4.m
%Example4
% -- needs the matlab toolbox dipimage, free download at www.diplib.org
% run each section separtely. This file shows how the functions "imres_ims"
% and "imres_locs" can be used to generate and automatically display results
% from positions or images.
% -- you need to have the fullpaht to the FIREfunctions directory on the MATLAB path  

% this examples takes a few minutes to complete

clear all
close all

%% loading the data
% localizations of single emitters in the format:
%  x, y, t [pixels, pixels, frames]

coords = dlmread(['..' filesep 'ExampleData' filesep 'example_Fig2a.dat'],',');
pixelsize = 16e3/150;                                                           %in nanometers

%% Select input format and outputs
positions_order = 'xyt';
positions_units = 'CCD pixels';
show_im = 1;
show_frc = 1;
show_timefractions = 1;

%% call imres_locs
superzoom = 10;
sz = superzoom * 256 * [1 1];
SR_pixelsize = pixelsize/superzoom;
nblocks = 20;
timefractions = 10;
reps = 20;

[res_value frc_curve im_out res_high res_low res_t] = imres_locs(coords,sz,superzoom,nblocks,timefractions,reps,SR_pixelsize,positions_order, positions_units, show_im, show_frc,show_timefractions);
% [res_value frc_curve im_out res_high res_low res_t] = imres_locs(coords,sz,superzoom,nblocks,timefractions,reps,SR_pixelsize);

%% call imres_ims
maxt = max(coords(:,3));

% Define two images for resolution computation
in1 = binlocalizations(coords(coords(:,3)<maxt/2,:),sz(1),sz(2),superzoom);
in2 = binlocalizations(coords(coords(:,3)>=maxt/2,:),sz(1),sz(2),superzoom);

% Use res_ims
[res_value frc_curve res_high res_low] = imres_ims(in1,in2,SR_pixelsize,show_frc);

./ExternalSoftware/FRCresolution_software/matlabdistribution/example1.m
%Example1
% -- needs the matlab toolbox dipimage, free download at www.diplib.org
% run each section separtely. This file shows a lot of different
% possibilities to compute the resolution from positions via the function
% "postoresolution"
% -- you need to have the fullpaht to the FIREfunctions directory on the MATLAB path  

clear all
close all

%% loading the data
% localizations of single emitters in the format:
%  x, y, t [pixels, pixels, frames]

fprintf('\n -- loading the data --\n')
coords = dlmread(['..' filesep 'ExampleData' filesep 'example_Fig2a.dat'],',');
pixelsize = 16e3/150;                                                           %in nanometers

%% make an overview image
superzoom = 10;
szx = superzoom * 256;
szy = superzoom * 256;

im = binlocalizations(coords, szx, szy, superzoom);
h=dipshow(im);
dipmapping(h,[0 5],'colormap',hot)


%% compute resolution
fprintf('\n -- computing resolution --\n')
[res_value, ~, resH, resL] = postoresolution(coords, szx, superzoom); % in super-resolution pixels
fprintf('resolution value %2.1f +- %2.2f [px]\n', res_value, (resL-resH)/2);
fprintf('resolution value %2.1f +- %2.2f [nm]\n', res_value*pixelsize/superzoom, (resL-resH)/2*pixelsize/superzoom);


%% compute resolution as a function of frame time (takes ~1-2min.)
fprintf('\n -- computing resolution as a function of time for in 25 steps--\n')
tfrac = 25;
[~,~,~,~,resT] = postoresolution(coords, szx, superzoom, 500, tfrac); % in super-resolution pixels
figure;
plot(linspace(0,1,tfrac),resT*pixelsize/superzoom,'x-')
xlabel('time fraction')
ylabel('Resolution (nm)')
title('Resolution as a function of total number of frames')


%% compute FRC curve
fprintf('\n -- computing FRC curve--\n')
[~,frc_curve] = postoresolution(coords, szx, superzoom); 
figure;
qmax = 0.5/(pixelsize/superzoom);
plot(linspace(0,qmax*sqrt(2), length(frc_curve)), frc_curve,'-')
xlim([0,qmax])
hold on
plot([0 qmax],[1/7 1/7],'r-');
plot([0 qmax],[0 0],'k--'); hold off
xlabel('spatial frequency (nm^{-1})')
ylabel('FRC')
title('Fourier Ring Correlation curve')


%% compute resolution (averaged over 20 runs)
fprintf('\n -- computing resolution averaged over 20 random block splits --\n')
[res_value, ~, resH, resL] = postoresolution(coords, szx, superzoom, 500,[], 20); % in super-resolution pixels
fprintf('res value %2.1f +- %2.2f [px]\n', res_value, (resL-resH)/2);
fprintf('res value %2.1f +- %2.2f [nm]\n', res_value*pixelsize/superzoom, (resL-resH)/2*pixelsize/superzoom);

%% compute resolution as a function of frame time (averaged over 20 runs) - takes a while 10-20min.
% uncomment to run
% fprintf('\n -- computing resolution versus time; each time point averaged over 20 random block splits--\n')
% [~,~,~,~,resT] = postoresolution(coords, szx, superzoom, 500, tfrac, 20); % in super-resolution pixels
% figure;
% plot(linspace(0,1,tfrac),resT*pixelsize/superzoom,'x-')
% xlabel('time fraction')
% ylabel('Resolution (nm)')
% title('Resolution as a function of total number of frames')

./ExternalSoftware/FRCresolution_software/matlabdistribution/example2.m
%Example2: anisotropy extention in 2D
% Fourier Line Correlation
% -- needs the matlab toolbox dipimage, free download at www.diplib.org

clear all
close all

%% loading the data
% localizations of single emitters in the format:
%  x, y, t [pixels, pixels, frame]
coords = dlmread(['..' filesep 'ExampleData' filesep 'example_Fig2j.dat'],',');     %1/10 of the total data
pixelsize = 16e3/160;                                                               %in nanometers

superzoom = 5;                                                                      %10 was used in the paper
szx = superzoom * 180;
szy = superzoom * 180;

%%make two images
t = coords(:,3);
tmax = max(t);
in1 = binlocalizations(coords(t<tmax/2,:), szx, szy, superzoom);
in2 = binlocalizations(coords(t>=tmax/2,:), szx, szy, superzoom);

%%compute the FLC, (takes ~30 seconds)
flc_out = flc(in1,in2);

flc_cut = cut(flc_out, round(imsize(flc_out)./4));
h = dipshow(flc_cut,'lin');
dipmapping(h,'colormap',jet)


%% show via matlab toolbox
allfreqs = linspace(-1/8,1/8,imsize(flc_cut,1))/(pixelsize/superzoom);
[qx, qy] = meshgrid(allfreqs,allfreqs);
figure;
pcolor(qx,qy, im2mat(rot90(flc_cut)))
xlabel('q_x (nm^{-1})')
ylabel('q_y (nm^{-1})')
shading flat;
colormap('jet');
axis equal
%colorbar;

./ExternalSoftware/FRCresolution_software/matlabdistribution/example3.m
%Example3: anisotropy extention in 3D
% Fourier Plane Correlation
% -- needs the matlab toolbox dipimage, free download at www.diplib.org

clear all
close all

%% loading the data
% localizations of single emitters in the format:
%  x, y, t [pixels, pixels, frame]
coords = dlmread(['..' filesep 'ExampleData' filesep 'example_Fig4.dat'],',');
pixelsize = 16e3/147;                                                           %in nanometers xy, in z microns
SRpixelsize = 10;


%% make two images
zoom = 1;
coordsin = coords./SRpixelsize;
numpixelsx = ceil(max(coordsin(:,1)));
numpixelsy = ceil(max(coordsin(:,2)));
numpixelsz = ceil(max(coordsin(:,3)));
Nem = length(coordsin);
im1 = binlocalizations3D(coordsin(1:round(Nem/2),1:3),numpixelsx,numpixelsy,numpixelsz,zoom);
im1 = mat2im(im1);
im2 = binlocalizations3D(coordsin(round(Nem/2)+1:end,1:3),numpixelsx,numpixelsy,numpixelsz,zoom);
im2 = mat2im(im2);
Nim1 = imsize(im1);

% crop images
Nsize = 512;
xmin = 90;
ymin = 0;
zmin = 0;
imcrop1 = cut(im1,Nsize,[xmin ymin zmin]);
imcrop2 = cut(im2,Nsize,[xmin ymin zmin]);
szCR = imsize(imcrop1);
imcrop1 = extend(imcrop1,[szCR(1) szCR(1) szCR(1)]);
imcrop2 = extend(imcrop2,[szCR(1) szCR(1) szCR(1)]);
clear im1 im2

%% compute FPC slices only

[fpc_xy,fpc_xz,fpc_yz]=fpc(imcrop1,imcrop2);
dipshow(fpc_xy,'lin')
dipshow(fpc_xz,'lin')
dipshow(fpc_yz,'lin')


%% compute the full FPC (much slowers as the full 3D volume is computed)
% this routine requires much memory if the images are large, you need to
% Fourier transform the cubes NxNxN and operate on them
% for the manuscript a much larger part of the image was used and more
% angles, this is very time costly.

[~, ~, ~, fpc_out] = fpc(imcrop1, imcrop2, 360*3, 0.2);
sz=imsize(fpc_out);
h=dipshow(fpc_out,'lin');
dipmapping(h,'global','slice',round(sz(1)/2))


./ExternalSoftware/FRCresolution_software/matlabdistribution/FRCresolutionfunctions/localdipmenus.m
function [menulist,excludelist] = localdipmenus(menulist)
I = size(menulist,1)+1;
menulist{I,1} = 'FRC resolution';
menulist{I,2} = {'imres_ims','imres_locs','-','frc','flc','fpc','-','qcorrection_locs','qcorrection_ims'};
excludelist = {'isect','sphere_tesselation','wkk','gfca3D_sub','frctoresolution'};

./ExternalSoftware/FRCresolution_software/matlabdistribution/FRCresolutionfunctions/imres_locs.m
%IMRES_LOCS   Compute resolution from a list of localizations
%
% The resolution is computed by taking blocks of localizations and assigning
% them randomly to half data sets. The localizations in these sets are
% binned into 2 images from which the FRC curve and subsequently the
% resolution are computed.
%
% SYNOPSIS:
%   [resolution_value frc_curve im_out resolution_high resolution_low resolution_t] = imres_locs(positions,size,zoomfactor,blocks,timefractions,reps,SR_pixelsize,positions_order, positions_units, show_im, show_frc,show_timefractions)
%
%   size
%      Size of the binned images
%   zoom
%      Pixels per unit distance in the positions list in the binned images
%   blocks
%      Number of time blocks into which the dataset is split.
%   timefractions
%      scalar: The acquisition time is split into timefractions blocks and
%              the resolution is computed for 1,2,...,timefractions blocks.
%      vector: The resolution is computed for each fraction of the
%              acquisition time specified in the vector.
%   reps
%      Number of times the FRC curve is computed for averaging
%   SR_pixelsize
%      Pixel size of the output image (in nm)
%   positions_order
%      Order of quantities in positions: 'xyt','xy', or 'txy'
%   positions_units
%      Units of quantities in positions: 'CCD pixels','SR pixels','nm', or 'um'
%   show_im
%      Display image of binned localizations?
%   show_frc
%      Display FRC curve?
%   show_timefractions
%      Display resolution vs time?
%
% DEFAULTS:
%   size : image edge corresponds to maximum y-coordinate
%   zoomfactor  = 1
%   blocks = 50
%   timefractions = 1
%   reps = 1 (no averaging)
%   SR_pixelsize = 10
%   positions_order = 'xyt'
%   positions_units = 'CCD pixels'
%   show_im = 1
%   show_frc = 1
%   show_timefractions = 1
%
% NOTES:
%   The third column of positions is assumed to contain time stamps of the
%   localizations. If positions only has 2 columns then the localizations 
%   are assumed to be time-ordered.
%   The minimum number of time blocks is 2.

% (C) Copyright 2012               Quantitative Imaging Group
%     All rights reserved          Faculty of Applied Physics
%                                  Delft University of Technology
%                                  Lorentzweg 1
%                                  2628 CJ Delft
%                                  The Netherlands
% Robert Nieuwenhuizen & Bernd Rieger, Oct 2012


function varargout = imres_locs(varargin)

d = struct('menu','FRC resolution',...
    'display','Resolution from localizations',...
    'inparams',struct('name',       {'positions','sz', 'zoomfactor',   'blocks',                   'timefractions',                 'reps',                 'SR_pixelsize',                     'positions_order',  'positions_units',                      'show_im',          'show_frc',             'show_timefractions'},...
    'description',{'Localizations',    'Output image size',   'Zoom',  'Number of time blocks',    'Fractions of acquistion time',  'Number of averages',   'Superresolution pixel size (nm)',  'Input order',      'Input format',                         'Display image',    'Display FRC curve',    'Display resolution vs time'},...
    'type',       {'array',            'array',        'array',        'array',                    'array',                         'array',                'array',                            'option',           'option',                               'boolean',          'boolean',              'boolean'},...
    'dim_check',  {{[],[-1 2],[-1 3]}, {[],0,[1 2],[2 1]},         {[],0},         {[],0},         {[],0,[-1 1]},                   {[],0},                 0,                                  0,                  0,                                      0,                  0,                      0},...
    'range_check',{'R',                'N+',           [eps Inf],      'N+',                       'R+',                            'N+',                   [eps Inf],                          {'xy','xyt','txy'}, {'CCD pixels','SR pixels','nm','um'},   [],                 [],                     []},...
    'required',   {1,                  0,              0,              0,                          0,                               0,                      1,                                  0,                  0,                                      0,                  0,                      0},...
    'default',    {[],                 [],             1,              50,                         [],                              1,                      10,                                 'xyt',              'CCD pixels',                           1,                  1,                      1}...
    ),...
    'outparams',struct('name',{'resolution_value','frc_curve','im_out','resolution_high','resolution_low','resolution_t'},...
    'description',{'resolution value','FRC curve','Binned localizations','resolution - 1 std. dev.','resolution + 1 std. dev.','resolution vs time'},...
    'type',{'array','array','image','array','array','array'},...
    'suppress',{1,1,1,1,1,1}...
    )...
    );

if nargin == 1
    s = varargin{1};
    if ischar(s) & strcmp(s,'DIP_GetParamList')
        varargout{1} = d;
        return
    end
end

try
    [positions,sz,zoomfactor,nblocks,timefractions,reps,SR_pixelsize,positions_order, positions_units, show_im, show_frc,show_timefractions] = getparams(d,varargin{:});
catch
    if ~isempty(paramerror)
        error(paramerror)
    else
        error(firsterr)
    end
end

if isempty(zoomfactor)
    zoomfactor = 1;
end

%% Compute results

% Set right order of columns in positions
if strcmp(positions_order,'txy')
    positions = circshift(positions,[0 -1]);
end

% Convert units to superresolution pixels
switch positions_units
    case 'nm'
        positions(:,1:2) = positions(:,1:2)/SR_pixelsize;
        zoomfactor = 1;
    case 'um'
        positions(:,1:2) = positions(:,1:2)/1E3/SR_pixelsize;
        zoomfactor = 1;
end

% Compute results
[resolution_value, frc_curve, resolution_high, resolution_low, resolution_time] = postoresolution(positions, sz, zoomfactor,nblocks,timefractions,reps); % in super-resolution pixels
    
fprintf('Resolution value %2.1f +- %2.2f nm.\n', resolution_value*SR_pixelsize, (resolution_low-resolution_high)/2*SR_pixelsize);
fprintf('Resolution value %2.1f +- %2.2f superresolution pixels.\n', resolution_value, (resolution_low-resolution_high)/2);

%% Generate requested visualizations

% Output image
if isempty(sz)
    sz = 1+round(zoomfactor*max(positions(:,1:2),[],1));
end
if numel(sz) == 1
    sz = [sz sz];
end
im_out = mat2im(binlocalizations(positions, sz(1), sz(2), zoomfactor));
    
if show_im
    h=dipshow(gaussf(im_out,1));
    dipmapping(h,'colormap',hot)
end

% Plot FRC curve
if show_frc
    qmax = 0.5/(SR_pixelsize);
    
    figure
    hold on
    plot([0 qmax],[0 0],'k')
    plot(linspace(0,qmax*sqrt(2), length(frc_curve)), frc_curve,'-')
    plot([0 qmax],[1/7 1/7],'m')
    plot(1/(resolution_value*SR_pixelsize),1/7,'rx')
    plot(1/(resolution_value*SR_pixelsize)*[1 1],[-0.2 1/7],'r')
    hold off
    xlim([0,qmax]);
    ylim([-0.2 1.2])
    xlabel('Spatial frequency (nm^{-1})');
    ylabel('FRC')
end

% Show resolution value vs time

if isempty(timefractions) || all(timefractions==1)
    show_timefractions = 0;
end

if show_timefractions
    if isscalar(timefractions)
        timefractions = (1:timefractions)/timefractions;
    end
    
    figure
    plot(timefractions,resolution_time*SR_pixelsize)
    xlabel('Relative acquisition time');
    ylabel('Resolution (nm)');
    xlim([0 1])
end

%% Outputs
varargout{1} = resolution_value*SR_pixelsize;
varargout{2} = frc_curve;
varargout{3} = im_out;
varargout{4} = resolution_high*SR_pixelsize;
varargout{5} = resolution_low*SR_pixelsize;
varargout{6} = resolution_time*SR_pixelsize;

./ExternalSoftware/FRCresolution_software/matlabdistribution/FRCresolutionfunctions/postoresolution.m
%POSTORESOLUTION   Compute resolution from a list of localizations
%
% The resolution is computed by taking blocks of localizations and assigning
% them randomly to half data sets. The localizations in these sets are
% binned into 2 images from which the FRC curve and subsequently the
% resolution are computed.
%
% SYNOPSIS:
%   [resolution frc_out resolution_high resolution_low resolution_t] = postoresolution(positions,size,zoomfactor,blocks,timefractions,reps)
%
%   size
%      Size of the binned images
%   zoom
%      Pixels per unit distance in the positions list in the binned images
%   blocks
%      Number of time blocks into which the dataset is split.
%   timefractions
%      scalar: The acquisition time is split into timefractions blocks and
%              the resolution is computed for 1,2,...,timefractions blocks.
%      vector: The resolution is computed for each fraction of the
%              acquisition time specified in the vector.
%   reps
%      Number of times the FRC curve is computed for averaging
%
% DEFAULTS:
%   size : image edge corresponds to maximum y-coordinate
%   zoomfactor  = 1
%   blocks = 50
%   timefractions = 1
%   reps = 1 (no averaging)
%
% NOTES:
%   The third column of positions is assumed to contain time stamps of the
%   localizations. If positions only has 2 columns then the localizations 
%   are assumed to be time-ordered.
%   The minimum number of time blocks is 2.

% (C) Copyright 2012               Quantitative Imaging Group
%     All rights reserved          Faculty of Applied Physics
%                                  Delft University of Technology
%                                  Lorentzweg 1
%                                  2628 CJ Delft
%                                  The Netherlands
% Robert Nieuwenhuizen & Bernd Rieger, Oct 2012

function varargout = postoresolution(varargin)

d = struct('menu','FRC resolution',...
    'display','Resolution from localizations',...
    'inparams',struct('name',       {'positions',        'sz', 'zm',    'blocks',                  'timefractions',                 'reps'},...
    'description',{'Localizations',    'Image size',   'Zoom',         'Number of time blocks',    'Fractions of acquistion time',  'Number of averages'},...
    'type',       {'array',            'array',        'array',        'array',                    'array',                         'array'},...
    'dim_check',  {{[],[-1 2],[-1 3]}, {[],0,[1 2]},         {[],0},         {[],0},                     {[],0,[-1 1]},                   0},...
    'range_check',{'R',                'N+',           [eps Inf],      'N+',                       'R+',                            'N+'},...
    'required',   {0,                  0,              0,              0,                          0,                               0},...
    'default',    {'[]',               '[]',           1,              50,                         '[]',                            1}...
    ),...
    'outparams',struct('name',{'resolution','frc_out','resolution_high','resolution_low','resolution_t'},...
    'description',{'Resolution','FRC curve','Upper bound','Lower bound','Resolution vs time'},...
    'type',{'array','array','array','array','array'}...
    )...
    );

if nargin == 1
    s = varargin{1};
    if ischar(s) & strcmp(s,'DIP_GetParamList')
        varargout{1} = struct('menu','none');
        return
    end
end

try
    [positions,sz,zm,nblocks,timefractions,reps] = getparams(d,varargin{:});
catch
    if ~isempty(paramerror)
        error(paramerror)
    else
        error(firsterr)
    end
end

if isempty(zm)
    zm = 1;
end

% Check that the size of the binned images is provided
if isempty(sz)
   % Use a square bounding box as output size
   sz = 1+round(zm*max(positions(:,1:2),[],1));
end

if reps > 1
%     matlabpool(4); %using the parallelization toolbox for faster computation
    frc_out = 0;
    res_tmp = zeros(reps,1);
    
%     parfor ii=1:reps
    for ii =1:reps
        %fprintf('  iteration %d/%d\n',ii,reps);
        % Calculate the FRC curve
        frc_out_tmp = postofrc(positions,sz,zm,nblocks);
        % Calculate the resolution from the FRC curve
        [res_tmp(ii)] = frctoresolution(frc_out_tmp,max(sz));
        frc_out = frc_out + frc_out_tmp;
    end
%     matlabpool close
    resolution = mean(res_tmp(res_tmp>0));
    frc_out  = frc_out./reps;
    % we do not divide by sqrt(reps) here as the repeats are correlated,
    % we keep it on the safe side this way (larger bounds).
    resolution_high = resolution-std(res_tmp);
    resolution_low = resolution+std(res_tmp);
else
    % Calculate the FRC curve
    frc_out = postofrc(positions,sz,zm,nblocks);
    % Calculate the resolution from the FRC curve
    [resolution resolution_high resolution_low] = frctoresolution(frc_out,max(sz));
end


% --- outputs ---
varargout{1} = resolution;
varargout{2} = frc_out;
if nargout > 2
    varargout{2} = frc_out;
    varargout{3} = resolution_high;
end
if nargout > 3
    varargout{4} = resolution_low;
end

% Check if resolution vs time needs to be calculated
if nargout < 5
    if ~isempty(timefractions);fprintf('timefractions given, but not requested as output.\n');end
    return;
end


%% Check that the variable timefractions is not trivial
if isempty(timefractions)
    varargout{5} = resolution;
    return
end
if (timefractions == 1)
    varargout{5} = resolution;
    return
end

% Check that positions is not empty
if isempty(positions)
    fprintf(' -- Could not find the resolution --\n')
    varargout{5} = (-1)*ones(length(timefractions,1));
    return
end

% Prepare calculation of resolution vs time
if isscalar(timefractions)
    if timefractions>1
        timefractions = (1:timefractions)/timefractions;
    end
else
    timefractions(timefractions>1) = 1;
end

if size(positions,2)==2
    N = length(positions); 
    T=0; %this is needed for parfor (altough never used)
else %3
    T = max(positions(:,3));
    N = 0; %this is needed for parfor (altough never used)
end

resolution_t = zeros(length(timefractions),1);
% Calculate resolution vs time
fprintf(' Computing resolution versus time ...\n')

% Check if the distributed computing toolbox is available
try 
    toolboxdir('distcomp');
    TB_distcomp=1;
catch
    TB_distcomp=0;
end

% Use for loop or parfor loop
if TB_distcomp

%     for nn = 1:length(timefractions)
    parfor nn = 1:length(timefractions)    
        % Select positions up to given fractions of time
        if size(positions,2)==2
            positions_tmp = positions(1:ceil(timefractions(nn)*N),:);
        else
            positions_tmp = positions(positions(:,3)<timefractions(nn)*T,:);
        end 
        if isempty(positions_tmp)
            resolution_t(nn) = -1;
            continue
        end

        res_tmp = zeros(reps,1);
        for ii=1:reps
            frc_out = postofrc(positions_tmp,sz,zm,nblocks);
            res_tmp(ii) = frctoresolution(frc_out,max(sz));
        end
        resolution_t(nn) = mean(res_tmp(res_tmp>0));
        %fprintf('res %d, %f\n',nn,resolution_t(nn));
    end
    % matlabpool close

else

    for nn = 1:length(timefractions)
        % Select positions up to given fractions of time
        if size(positions,2)==2
            positions_tmp = positions(1:ceil(timefractions(nn)*N),:);
        else
            positions_tmp = positions(positions(:,3)<timefractions(nn)*T,:);
        end 
        if isempty(positions_tmp)
            resolution_t(nn) = -1;
            continue
        end

        res_tmp = zeros(reps,1);
        for ii=1:reps
            frc_out = postofrc(positions_tmp,sz,zm,nblocks);
            res_tmp(ii) = frctoresolution(frc_out,max(sz));
        end
        resolution_t(nn) = mean(res_tmp(res_tmp>0));
        %fprintf('res %d, %f\n',nn,resolution_t(nn));
    end
    
end

varargout{5} = resolution_t;





./ExternalSoftware/FRCresolution_software/matlabdistribution/FRCresolutionfunctions/wkk.m
%WKK   Sum values along lines perpendicular to each position vector [x y]
%
% A line is defined through each vector which is perpendicular to the line
% from that pixel to the center pixel of the image. The sum of the pixel 
% values along that line is taken as outfput.
%
% SYNOPSIS:
%   out = wkk(in)
% 
% NOTES:
%  The center pixel of in is defined as: floor((size(in)-1)/2) 

% (C) Copyright 2012               Quantitative Imaging Group
%     All rights reserved          Faculty of Applied Physics
%                                  Delft University of Technology
%                                  Lorentzweg 1
%                                  2628 CJ Delft
%                                  The Netherlands
% Robert Nieuwenhuizen, Oct 2012

function out = wkk(in)

in = real(in);

% Check that the input is a square 2D image.
if ~isa(in,'dip_image')
    error('Input must be an image.');
end

if ~(ndims(in) == 2)
    error('Input image must be 2D.')
end
    
% Radon transform image
t = 0:1:180;                    % Angles
[c,xp] = radon(im2mat(in),-t);

% Find xy-coordinates of radon transform values
[t,xp] = ndgrid(t./180*pi,xp);
[x,y] = pol2cart(t,xp);

% Compute grid of output coordinates
xc = (-ceil((size(in,1)-1)/2):floor((size(in,1)-1)/2));
yc = (-ceil((size(in,2)-1)/2):floor((size(in,2)-1)/2))';

% Check if a warning will be displayed when calling TriScatteredInterp
s = warning('query', 'MATLAB:TriScatteredInterp:DupPtsAvValuesWarnId');
if strcmp(s.state,'on')
    warning('off', 'MATLAB:TriScatteredInterp:DupPtsAvValuesWarnId');
end

% Interpolate the radon transform data on the gridpoints (xc,yc)
Int_obj = TriScatteredInterp(reshape(x,[numel(x) 1]),reshape(y,[numel(x) 1]),reshape(c',[numel(x) 1]));
out = mat2im(Int_obj(repmat(xc,[length(yc) 1]),repmat(yc,[1 length(xc)])));
out(isnan(out)) = 0;

% Return the state of the warning from griddata to its original state
if strcmp(s.state,'on')
    warning('on', 'MATLAB:TriScatteredInterp:DupPtsAvValuesWarnId');
end

./ExternalSoftware/FRCresolution_software/matlabdistribution/FRCresolutionfunctions/postofrc.m
%POSTOFRC   Compute FRC curve from a list of localizations
%
% The FRC curve is computed by taking blocks of localizations and assigning 
% them randomly to half data sets. The localizations in these sets are 
% binned into 2 images from which the FRC curve is computed.
%
% SYNOPSIS:
%   frc_out = postofrc(positions,size,zoomfactor,blocks)
%
%   size
%      Size of the binned images
%   zoom
%      Pixels per unit distance in the positions list in the binned images
%   blocks
%      Number of time blocks into which the dataset is split. 2 block is
%      the minimum accepted amount.
%
% DEFAULTS:
%   size : image edge corresponds to maximum y-coordinate
%   zoomfactor  = 1
%   blocks = 50
%
% NOTES:
%   The third column of positions is assumed to contain time stamps of the
%   localizations. If positions only has 2 columns then the localizations 
%   are assumed to be time-ordered.
%   The minimum number of time blocks is 2.

% (C) Copyright 2012               Quantitative Imaging Group
%     All rights reserved          Faculty of Applied Physics
%                                  Delft University of Technology
%                                  Lorentzweg 1
%                                  2628 CJ Delft
%                                  The Netherlands
% Robert Nieuwenhuizen, Oct 2012

function frc_out = postofrc(varargin)

d = struct('menu','FRC resolution',...
           'display','FRC from localizations',...
           'inparams',struct('name',       {'positions',        'sz',           'zm',           'nblocks'},...
                             'description',{'Localizations',    'Image size',   'Zoom',         'Number of time blocks'},...
                             'type',       {'array',            'array',        'array',        'array'},...
                             'dim_check',  {{[],[-1 2],[-1 3]}, {[],0,[1 2]},         {[],0},         {[],0},},...
                             'range_check',{'R',                'N+',           [eps Inf],      'N+'},...
                             'required',   {0,                  0,              0,              0},...
                             'default',    {'[]',               '[]',           1,             50}...
                              ),...
           'outparams',struct('name',{'frc_out'},...
                              'description',{'FRC curve'},...
                              'type',{'array'}...
                              )...
           );       
       
if nargin == 1
   s = varargin{1};
   if ischar(s) && strcmp(s,'DIP_GetParamList')
      frc_out = struct('menu','none');
      return
   end
end

try
   [positions, sz, zm, nblocks] = getparams(d,varargin{:});
catch
   if ~isempty(paramerror)
      error(paramerror)
   else
      error('Parameter parsing was unsuccessful.')
   end
end

% Check that position data are provided as input
if isempty(positions)
    if isempty(sz)
        error('No output image size can be defined.')
    else
        frc_out = zeros(1,ceil(max(sz)/sqrt(2)));
        return
    end
end

if isempty(zm)
   zm = 1;
end

% Check that the size of the binned images is provided
if isempty(sz)
   % Use a bounding box as output size
   sz = 1+round(zm*max(positions(:,1:2),[],1));
end

if isscalar(sz)
    sz = sz*[1 1];
end

% Check that a correct number of time blocks is specified
if isempty(nblocks)
    nblocks = 50;
end

if nblocks<2
    nblocks = 2;
    warning('postofrc:toofewblocks','Time series is split into 2 blocks.') 
end

% Assign localizations to half data sets
if size(positions,2) == 2
    if nblocks > size(positions,1)
        nblocks = size(positions,1);
        warning('postofrc:toomanyblocks','Number of time blocks is larger than the number of localizations.')
    end
    blocksel = randperm(nblocks,ceil(nblocks/2));                       % Block numbers in the first half data set              
    s = ceil((1:size(positions,1))/size(positions,1)*nblocks);          % Block numbers of the localizations
    s = ismember(s,blocksel);                                           % Localizations in the first half data set
else   
    % Sort blocks 
    maxt = max(positions(:,3));
    positions(:,3) = ceil(positions(:,3)/maxt*nblocks);                 % Go from time stamps to block numbers of the localizations                                      
    blocksel = randperm(nblocks,ceil(nblocks/2));                       % Block numbers in the first half data set
    s = ismember(positions(:,3),blocksel);                              % Localizations in the first half data set
end

% Bin images into 2 half data images
in1 = binlocalizations(positions(s,1:2),sz(1),sz(2),zm);
in2 = binlocalizations(positions(~s,1:2),sz(1),sz(2),zm);

% Compute FRC curve
frc_out = frc(in1,in2);
frc_out = double(frc_out);
./ExternalSoftware/FRCresolution_software/matlabdistribution/FRCresolutionfunctions/flc.m
%FLC   Compute FLC from 2 images
%
% First a Tukey window is applied to the 2 images, and subsequently the FLC
% is computed from the Fourier Transforms of the two images. The
% maximum frequency for which the FLC is computed is 1/2.
%
% SYNOPSIS:
%   flc_out = flc(in1,in2)
%
% NOTES:
%   Non-square images are zero padded to make them square.
%   Images with even sizes are zero padded to make the image sizes uneven.

% (C) Copyright 2012               Quantitative Imaging Group
%     All rights reserved          Faculty of Applied Physics
%                                  Delft University of Technology
%                                  Lorentzweg 1
%                                  2628 CJ Delft
%                                  The Netherlands
% Robert Nieuwenhuizen, Oct 2012

function flc_out = flc(varargin)

d = struct('menu','FRC resolution',...
           'display','FLC',...
           'inparams',struct('name',       {'in1',    'in2'},...
                             'description',{'Image 1','Image 2'},...
                             'type',       {'image',  'image'},...
                             'dim_check',  {2,        2},...
                             'range_check',{[],       []},...
                             'required',   {1,        1},...
                             'default',    {'in1',    'in2'}...
                              ),...
           'outparams',struct('name',{'flc_out'},...
                              'description',{'FLC'},...
                              'type',{'image'}...
                              )...
           );       
       
if nargin == 1
   s = varargin{1};
   if ischar(s) && strcmp(s,'DIP_GetParamList')
      flc_out = d;
      return
   end
end

try
   [in1, in2] = getparams(d,varargin{:});
catch
   if ~isempty(paramerror)
      error(paramerror)
   else
      error('Parameter parsing was unsuccessful.')
   end
end

sz = imsize(in1);

if any(imsize(in2) ~= sz)
    error('Image 1 and image 2 have different image sizes.');
end

% Compute mask in x-direction
nfac = 8;                                                   % Image width / Width of edge region
x_im = xx(sz(1),sz(2))/sz(1);
mask = 0.5-0.5*cos(pi*nfac*x_im);          
mask(abs(x_im)<((nfac-2)/(nfac*2))) = 1;
clear x_im

% Check that input images are square and mask
if sz(1) == sz(2)
    mask = mask*rot90(mask);
    
    % Mask input images
    in1 = mask*in1;
    in2 = mask*in2;
else
    % Compute mask in y-direction
    y_im = yy(sz(1),sz(2))/sz(2);
    mask_y = 0.5-0.5*cos(pi*nfac*y_im);          
    mask_y(abs(y_im)<((nfac-2)/(nfac*2))) = 1;
    mask = mask*mask_y;
    clear mask_y
    
    % Mask input images
    in1 = mask*in1;
    in2 = mask*in2;
    
    % Make images square through zero padding
    sz(sz<max(sz)) = max(sz);
    in1 = extend(in1,sz);
    in2 = extend(in2,sz);
end
clear mask

% Make image size uneven through zero padding
if ~mod(sz(1),2)
    sz = sz+1;
    in1 = extend(in1,sz);
    in2 = extend(in2,sz);
end

% Fourier transform input images
in1 = ft(in1);
in2 = ft(in2);

% Mask frequencies larger than 0.5
in1 = in1*(rr(sz(1),sz(2))<=floor((sz(1)-1)/2));
in2 = in2*(rr(sz(1),sz(2))<=floor((sz(1)-1)/2));

% Compute fourier line correlation
flc_num = wkk(in1.*conj(in2));          % Numerator of the FLC
in1 = abs(in1).^2;
in2 = abs(in2).^2;
flc_denom = sqrt(wkk(in1)*wkk(in2));    % Denominator of the FLC
flc_out = real(flc_num./flc_denom);

./ExternalSoftware/FRCresolution_software/matlabdistribution/FRCresolutionfunctions/qcorrection_locs.m
%QCORRECTION_LOCS   Correct resolution from localizations for spurious correlations
%
% SYNOPSIS:
%   [resolution_corr, resolution_uncorr, Q, frc_curve_corr frc_curve] = qcorrection_locs(positions,size,zoomfactor,blocks,reps, meansig, stdsig, SR_pixelsize, floorcor,show_frc)
%
%   SR_pixelsize
%      Pixel size of the images (in nm)
%   show_frc
%      Display FRC curve?

%
% PARAMETERS:
%   meansig
%       Mean localization uncertainty (in SR pixels)
%   stdsig
%       St. dev. of localization uncertainties (in SR pixels)
%   pixelsize  
%      Pixel size of the images (in nm)
%   floorcor
%      Take into account noise floor on the numerator of the FRC?
%
% OUTPUT:
%   resolution_corr
%      Resolution value after correction for spurious correlations
%   resolution_uncorr
%      Resolution value without correction
%   Q                   
%      Estimate for the number of times an emitter is localized on average 
%      assuming Poisson statistics for the localizations per emitter
%  frc_curve_corr
%      FRC curve corrected for spurious correlations
%  frc_curve            
%      FRC curve without correction
%
% NOTES:
%   Non-square images are zero padded to make them square.
%
% SEE ALSO:
%  binlocalizations, frc, frctoresolution
%
% (C) Copyright 2012               Quantitative Imaging Group
%     All rights reserved          Faculty of Applied Physics
%                                  Delft University of Technology
%                                  Lorentzweg 1
%                                  2628 CJ Delft
%                                  The Netherlands
% Robert Nieuwenhuizen & Bernd Rieger, Dec 2012

function varargout = qcorrection_locs(varargin)

d = struct('menu','FRC resolution',...
           'display','Q-corrected resolution from localizations',...
           'inparams',struct('name',       {'positions',            'sz',               'zoomfactor',   'blocks',               'reps',                'meansig',          'stdsig',                   'SR_pixelsize',     'floorcorr',                'show_frc'},...
                             'description',{'Localizations',        'Output image size','Zoom',         'Number of time blocks','Number of averages',  'Loc. unc.',        'Std. dev. of loc. unc.'    'Pixel size (nm)',  'Correct for noise floor',  'Display figures'},...
                             'type',       {'array',                'array',            'array',        'array',                'array',               'array',            'array',                    'array',            'boolean',                  'boolean'},...
                             'dim_check',  {{[],[-1 2],[-1 3]},     {[],0,[1 2],[2 1]}, {[],0},         {[],0},                 {[],0},                0,                  0,                          0,                  0,                          0},...
                             'range_check',{'R',                    'N+',               [eps Inf],      'N+',                   'N+',                  [eps Inf],          'R+',                       [eps Inf],          [],                         []},...
                             'required',   {1,                      0,                  0,              0,                      0,                     1,                  1,                          1,                  0,                          0},...
                             'default',    {[],                     [],                 1,              50,                     1,                     1,                  0,                          10,                 0,                          0}...
                              ),...
           'outparams',struct('name',{'resolution_corr','resolution_value','Q','frc_curve_corr','frc_curve'},...
                              'description',{'Resolution (corrected)','Resolution (uncorrected)','Q','FRC curve (corrected)','FRC curve (uncorrected)'},...
                              'type',{'array','array','array','array','array'},...
                              'suppress',{1,1,1,1,1}...
                              )...
           );       
       
if nargin == 1
   s = varargin{1};
   if ischar(s) & strcmp(s,'DIP_GetParamList')
      varargout{1} = d;
      return
   end
end

try
   [positions,sz,zoomfactor,nblocks,reps,meansig, stdsig, SR_pixelsize, floorcorr, show_frc] = getparams(d,varargin{:});
catch
   if ~isempty(paramerror)
      error(paramerror)
   else
      error('Parameter parsing was unsuccessful.')
   end
end


%% Check inputs
if isempty(sz)
    sz = 1+round(zoomfactor*max(positions(:,1:2),[],1));
end
if numel(sz) == 1
    sz = [sz sz];
end

if isempty(zoomfactor)
    zoomfactor = 1;
end

if isempty(nblocks)
    nblocks = 50;
end

if isempty(reps)
    reps = 1;
end

%% Prepare masking
% Compute mask in x-direction
nfac = 8;                                                   % Image width / Width of edge region
x_im = xx(sz(1),sz(2))/sz(1);
mask = 0.5-0.5*cos(pi*nfac*x_im);          
mask(abs(x_im)<((nfac-2)/(nfac*2))) = 1;

if sz(1) == sz(2)
    mask = mask*rot90(mask);
else
    warning('qcorrection_locs:nonsquare','Images are not square.');
   
    % Compute mask in y-direction
    y_im = yy(sz(1),sz(2))/sz(2);
    mask_y = 0.5-0.5*cos(pi*nfac*y_im);          
    mask_y(abs(y_im)<((nfac-2)/(nfac*2))) = 1;
    mask = mask*mask_y;
    clear mask_y
end

%% Compute numerator and denominator of FRC curve

for nn = 1:reps

    % Assign localizations to half data sets
    if size(positions,2) == 2
        if nblocks > size(positions,1)
            nblocks = size(positions,1);
            warning('qcorrection_locs:toomanyblocks','Number of time blocks is larger than the number of localizations.')
        end
        blocksel = randperm(nblocks,ceil(nblocks/2));                       % Block numbers in the first half data set              
        s = ceil((1:size(positions,1))/size(positions,1)*nblocks);          % Block numbers of the localizations
        s = ismember(s,blocksel);                                           % Localizations in the first half data set
    else   
        % Sort blocks 
        maxt = max(positions(:,3));
        positions(:,3) = ceil(positions(:,3)/maxt*nblocks);                 % Go from time stamps to block numbers of the localizations                                      
        blocksel = randperm(nblocks,ceil(nblocks/2));                       % Block numbers in the first half data set
        s = ismember(positions(:,3),blocksel);                              % Localizations in the first half data set
    end

    % Bin images into 2 half data images
    in1 = binlocalizations(positions(s,1:2),sz(1),sz(2),zoomfactor);
    in2 = binlocalizations(positions(~s,1:2),sz(1),sz(2),zoomfactor);

    % Check that input images are square and mask
    if sz(1) == sz(2)
        % Mask input images
        in1 = mask*in1;
        in2 = mask*in2;
    else
        % Mask input images
        in1 = mask*in1;
        in2 = mask*in2;

        % Make images square through zero padding
        in1 = extend(in1,[max(sz) max(sz)]);
        in2 = extend(in2,[max(sz) max(sz)]);
    end

    % Prepare calculation of Q
    if nn == 1
        Qnorm = (1/mean(in1)+1/mean(in2));
    end
    % Fourier transform input images
    in1 = ft(in1);
    in2 = ft(in2);
    
    if nn == 1
        frcnum = double(real(radialmean(in1.*conj(in2))));
        frcdenom = double(sqrt(real(radialmean(abs(in1).^2).*radialmean(abs(in2).^2))));
    else
        frcnum = frcnum + double(real(radialmean(in1.*conj(in2))));
        frcdenom = frcnum + double(sqrt(real(radialmean(abs(in1).^2).*radialmean(abs(in2).^2))));
      end
end

frcnum = frcnum/reps;
frcdenom = frcdenom/reps;

%% Calculate Q etc.

sz = max(sz);
q = (0:(length(frcnum)-1))./sz;

% find logmin and minloc for range of scaled sigs in order to be able to
% find average noise floor in that region, the noisefloor varies steeply in
% the plateau-region depending on where the minimum is on the plateau (to
% the left or to the right) the noisefloor-correction will be too large or
% too small, respectively.

allscales = [0.8 1.2 1.0];
allminloc = zeros(3,1);
alllogmin = zeros(3,1);

for jsc=1:numel(allscales)
scale = allscales(jsc);

% Calculate exponential decay function for Gaussian distribution of sigs
stdfac = 1+8*pi^2*(scale*stdsig)^2*(q.^2);
exp_decay = exp(-4*pi^2*(scale*meansig)^2*(q.^2)./stdfac)./sqrt(stdfac);

% Find smoothing kernel size
tmplog = real(log(frcnum) - log(exp_decay) -2*log(sinc(q)));
tmplog = tmplog(~isnan(tmplog));
tmplog = tmplog(~isinf(tmplog));
d = find(tmplog>(1+tmplog(1)),1);

if ((isempty(d) || d>sz/2))
    d = sz/2;
end

% Smooth FRC numerator
tmplog = real(log(frcnum) - log(exp_decay) -2*log(sinc(q)));
smoothlog = cfsmooth(real(log(frcnum) - log(exp_decay) -2*log(sinc(q))),d/5,'rloess');
if any(smoothlog==0)
    smoothlog(smoothlog==0) = tmplog(smoothlog==0);
end

% Find minimum of logarithm
% smoothlog(1:99) = 1E10;
% smoothlog(801:end) = 1E10;
[logmin minloc] = min(smoothlog(1:ceil(sz/2)));
allminloc(jsc) = minloc;
alllogmin(jsc) = logmin;

end

% Correct for contribution from the noise floor
nr = double(radialsum(ones(sz)));
noisefac = mean(log(frcnum(round(sz/2):end).^2.*nr(round(sz/2):end)));
noiselog = real(0.5*log(exp(noisefac)./nr)) - log(exp_decay) -2*log(sinc(q));

meannoiselog = (noiselog(allminloc(1))+noiselog(allminloc(2)))/2;
if floorcorr
  if logmin>meannoiselog
    logmin = log(exp(logmin)-exp(meannoiselog));
  else
    logmin = -Inf;
  end
end

% Correct for spurious correlations
frcnum_corr = exp(logmin).*exp_decay.*(sinc(q)).^2;

% Estimate number of localizations per emitter
Q = exp(logmin)*Qnorm;
fprintf('Estimated Q: %2.2f.\n',Q);

% Corrected frc
frccurve = frcnum./frcdenom;
frccurve_corr = (frcnum-frcnum_corr)./(frcdenom +frcnum_corr);


%% Plot results
if show_frc
    figure
    hold on
    plot(q/SR_pixelsize,frccurve);
    plot(q/SR_pixelsize,frccurve_corr,'r')
    plot([0 1/SR_pixelsize],[0 0],'k');
    xlim([0 0.5/SR_pixelsize])
    xlabel('Spatial frequency (nm^{-1})')
    ylabel('FRC')
    legend('Normal','Corrected for spurious correlations')
    hold off

    figure
    hold on
    % semilogy(q/ps, exp(log(Qnorm)+real(log(frcnum)) - log(exp_decay) -2*log(sinc(q))),'k',...
    %          q/ps, (log(Qnorm)+smoothlog)/log(10),'r','Linewidth',2,...
    %          q/ps, (log(Qnorm)+noiselog)/log(10),'g','Linewidth',2,...
    %          q/ps, (log(Qnorm)+smoothlog(minloc)*ones(size(q)))/log(10),'m','Linewidth',2)
    plot(q/SR_pixelsize, (log(Qnorm)+real(log(frcnum)) - log(exp_decay) -2*log(sinc(q)))/log(10),'k')
    plot(q/SR_pixelsize, (log(Qnorm)+smoothlog)/log(10),'r')
    % plot(q/ps, (log(Qnorm)+noiselog)/log(10),'g','Linewidth',2);
    plot(q/SR_pixelsize, (log(Qnorm)+smoothlog(minloc)*ones(size(q)))/log(10),'m')
    % plot(q(allminloc(:))/ps, (log(Qnorm)+smoothlog(allminloc(:)))/log(10),'ro');
    xlim([0 0.5/SR_pixelsize])
    ylim([min(log(frcnum(frcnum>0))) log(log(Qnorm)+frcnum(1))])
    ylim([-2 3])
    % % hleg = legend('normal','smooth','noise floor','plateau','minimum','Position','SouthEast');
    legend('Raw data','Smoothed data','Found plateau');
    hold off
    xlabel('Spatial frequency (nm^{-1})')
    ylabel('^{10}log(scaled FRC numerator)')
    set(gca,'YTick',[-2 -1 0 1 2 3])
    box on

    figure
    hold on
    plot(q/SR_pixelsize, real(log(frcnum)))
    plot(q/SR_pixelsize, real(log(frcdenom)),'k')
    plot(q/SR_pixelsize, real(log(frcnum_corr)),'r')
    plot(q/SR_pixelsize, real(log(frcnum-frcnum_corr)),'m')
    plot(q/SR_pixelsize, real(0.5*log(exp(noisefac)./nr)),'g');
    xlim([0 0.5/SR_pixelsize])
    ylim([min(log(frcnum(frcnum>0))) log(frcnum(1))])
    legend('FRC numerator','FRC denominator','Estimated spurious term','Corrected numerator','Noise floor')
    hold off
    xlabel('Spatial frequency (nm^{-1})')
    ylabel('log(FRC numerator)')
end

%% Calculate resolutions
resolution_uncorrr = frctoresolution(frcnum./frcdenom,sz);
resolution_corr = frctoresolution((frcnum-frcnum_corr)./(frcdenom +frcnum_corr),sz);

varargout{1} = resolution_corr;
varargout{2} = resolution_uncorrr;
varargout{3} = Q;
varargout{4} = frccurve_corr;
varargout{5} = frccurve;
./ExternalSoftware/FRCresolution_software/matlabdistribution/FRCresolutionfunctions/sphere_tesselation.m
%SPHERE_TESSELATION   Generate 4^N sampling angles
%
% SYNOPSIS:
%   [polar_angle azimuthal_angle] = sphere_tesselation(N)
%
% NOTES:
%   This function is for generating a tesselation of a sphere by iteratively
%   dividing triangles in 4 equal triangles. Starting from 8 octants defined
%   by +/-e_x, +/-e_y, +/-e_z we get in n steps 2*4^n triangles. Taking the
%   center of gravity of the three corners gives 2*4^n directions. Rotating
%   over R to put one of these on +e_z and using those vectors that have
%   n_z>0 should give 4^n indpendent directions covering the half-sphere.

% (C) Copyright 2012               Quantitative Imaging Group
%     All rights reserved          Faculty of Applied Physics
%                                  Delft University of Technology
%                                  Lorentzweg 1
%                                  2628 CJ Delft
%                                  The Netherlands
% Sjoerd Stallinga, Oct 2012

function [polang,aziang] = sphere_tesselation(maxlevel)
% Avoid being in menu
if nargin==1
   if ischar(varargin{1}) & strcmp(varargin{1},'DIP_GetParamList')
      polang = struct('menu','none');
      return
   end
end
if ~isnumeric(maxlevel)
    error('Input must be a positive integer.');
end

if ~isscalar(maxlevel)
    error('Input must be a positive integer.');
end

if ~(maxlevel>0)
    error('Input must be a positive integer.');
end

alltriangles = cell(maxlevel,2*4^maxlevel);

% initial level
plx = [1,0,0];
mnx = [-1,0,0];
ply = [0,1,0];
mny = [0,-1,0];
plz = [0,0,1];
mnz = [0,0,-1];
triangleinit = cell(8,1);
triangleinit{1} = [plx;ply;plz];
triangleinit{2} = [ply;mnx;plz];
triangleinit{3} = [mnx;mny;plz];
triangleinit{4} = [mny;plx;plz];
triangleinit{5} = [plx;ply;mnz];
triangleinit{6} = [ply;mnx;mnz];
triangleinit{7} = [mnx;mny;mnz];
triangleinit{8} = [mny;plx;mnz];
for jj=1:8
  alltriangles{1,jj} = triangleinit{jj};
end

% loop over all levels
for ilevel = 2:maxlevel
  for jj=1:2*4^(ilevel-1)
    allvecs = alltriangles{ilevel-1,jj};
    a = allvecs(1,:);
    b = allvecs(2,:);
    c = allvecs(3,:);
    ab = a+b;
    norm = sqrt(sum(ab.^2));
    ab = ab/norm;
    bc = b+c;
    norm = sqrt(sum(bc.^2));
    bc = bc/norm;
    ca = c+a;
    norm = sqrt(sum(ca.^2));
    ca = ca/norm;
    alltriangles{ilevel,4*jj-3} = [a;ab;ca];
    alltriangles{ilevel,4*jj-2} = [b;bc;ab];
    alltriangles{ilevel,4*jj-1} = [c;ca;bc];
    alltriangles{ilevel,4*jj} = [ab;bc;ca];
  end
end

% find centers of gravity of all triangles
alldirections = zeros(2*4^maxlevel,3);
for jj=1:2*4^maxlevel
  allvecs = alltriangles{maxlevel,jj};
  a = allvecs(1,:);
  b = allvecs(2,:);
  c = allvecs(3,:);
  abc = a+b+c;
  norm = sqrt(sum(abc.^2));
  abc = abc/norm;
  alldirections(jj,:) = abc;
end

% generate rotation to get one direction along +e_z
cosphi = 1/sqrt(2.0);
sinphi = 1/sqrt(2.0);
costheta = 1/sqrt(3.0);
sintheta = sqrt(2.0/3.0);
Rz = [cosphi,-sinphi,0;sinphi,cosphi,0;0,0,1];
Rx = [1,0,0;0,costheta,-sintheta;0,sintheta,costheta];
R = Rx*Rz;
for jj=1:2*4^maxlevel
  alldirections(jj,:) = alldirections(jj,:)*R';
end

% restrict to vectors with n_z>0
epsy = 1e-6;
alldirections = alldirections(alldirections(:,3)>-epsy,:);

% transform to spherical coordinates
[aziang,polang,radius] = cart2sph(alldirections(:,1),alldirections(:,2),alldirections(:,3));
polang = pi/2-polang;

% % make plot
% figure;
% u = alldirections(:,1);
% v = alldirections(:,2);
% w = alldirections(:,3);
% allzeros = zeros(size(alldirections));
% x = allzeros(:,1);
% y = allzeros(:,2);
% z = allzeros(:,3);
% quiver3(x,y,z,u,v,w);

end

./ExternalSoftware/FRCresolution_software/matlabdistribution/FRCresolutionfunctions/isect.m
%ISECT   Find intersections of functions a and b defined at gridpoints x
%
% SYNOPSIS:
%   intersections = isect(x,a,b)

% (C) Copyright 2012               Quantitative Imaging Group
%     All rights reserved          Faculty of Applied Physics
%                                  Delft University of Technology
%                                  Lorentzweg 1
%                                  2628 CJ Delft
%                                  The Netherlands
% Robert Nieuwenhuizen, Oct 2012

function out = isect(x,a,b)
% Avoid being in menu
%if nargin==1
%   if ischar(varargin{1}) & strcmp(varargin{1},'DIP_GetParamList')
%      out = struct('menu','none');
%      return
%   end
%end

if (size(x)~= size(a)) OR (size(x)~= size(b))
    error('x, a, and b must have the same size.');
end

% Check for uniqueness of x-values
if size(x)~= size(unique(x))
    error('x must have unique values.');
end

if isrow(x)
    x = x';
    a = a';
    b = b';
end

% Remove NaN points from arrays
sortmat = [x a b];
sortmat = sortmat(~isnan(a),:);
sortmat = sortmat(~isnan(b),:);

% Sort a,b and x based on x
sortmat = sortrows(sortmat);
x = sortmat(:,1);
a = sortmat(:,2);
b = sortmat(:,3);
clear sortmat

% Calculate the difference between a and b
a = a-b;

% Indices for the values of x before a and b intersect
i_inds = ((a(2:end)>0)&(a(1:(end-1))<0))|((a(2:end)<0)&(a(1:(end-1))>0));

% x-values for points not in x where a and b intersect 
i_points = i_inds.*(x(1:(end-1)) - a(1:(end-1))./(a(2:end)-a(1:(end-1))).*(x(2:end)-x(1:(end-1))));

% Include gridpoints where a and b intersect
if sum(a==0)~=0
    out = cat(1,x(a==0),i_points(i_inds));
else
    out = i_points(i_inds);
end

% Remove undesirable values
out = out(~isnan(out));
out = out(~isinf(out));

% Sort output
out = sort(out);

end

./ExternalSoftware/FRCresolution_software/matlabdistribution/FRCresolutionfunctions/sinc.m
function y=sinc(x)
%SINC Sin(pi*x)/(pi*x) function.
%   SINC(X) returns a matrix whose elements are the sinc of the elements 
%   of X, i.e.
%        y = sin(pi*x)/(pi*x)    if x ~= 0
%          = 1                   if x == 0
%   where x is an element of the input matrix and y is the resultant
%   output element.
%
%   % Example of a sinc function for a linearly spaced vector:
%   t = linspace(-5,5);
%   y = sinc(t);
%   plot(t,y);
%   xlabel('Time (sec)');ylabel('Amplitude'); title('Sinc Function')
%
%   See also SQUARE, SIN, COS, CHIRP, DIRIC, GAUSPULS, PULSTRAN, RECTPULS,
%   and TRIPULS.

%   Author(s): T. Krauss, 1-14-93
%   Copyright 1988-2004 The MathWorks, Inc.

%#codegen

i=find(x==0);                                                              
x(i)= 1;      % From LS: don't need this is /0 warning is off                           
y = sin(pi*x)./(pi*x);                                                     
y(i) = 1;   


./ExternalSoftware/FRCresolution_software/matlabdistribution/FRCresolutionfunctions/imres_ims.m
%IMRES_IMS   Compute resolution from two images
%
% The FRC curve and subsequently the resolution are computed from the two
% input images.
%
% SYNOPSIS:
%   [resolution_value frc_out resolution_high resolution_low] = imres_ims(in1,in2,pixelsize,show_frc)
%
%   pixelsize
%      Pixel size of the images (in nm)
%   show_frc
%      Display FRC curve?
%
% NOTES:
%   Non-square images are zero padded to make them square.
%
% (C) Copyright 2012               Quantitative Imaging Group
%     All rights reserved          Faculty of Applied Physics
%                                  Delft University of Technology
%                                  Lorentzweg 1
%                                  2628 CJ Delft
%                                  The Netherlands
% Robert Nieuwenhuizen & Bernd Rieger, Dec 2012

function varargout = imres_ims(varargin)

d = struct('menu','FRC resolution',...
           'display','Resolution from images',...
           'inparams',struct('name',       {'in1',      'in2',          'SR_pixelsize',     'show_frc'},...
                             'description',{'Image 1',  'Image 2',      'Pixel size (nm)',  'Display FRC curve'},...
                             'type',       {'image',    'image',        'array',            'boolean'},...
                             'dim_check',  {2,          2,              0,                  0},...
                             'range_check',{[],         [],             [eps Inf],          []},...
                             'required',   {1,          1,              1,                  0},...
                             'default',    {'in1',      'in2',          10,                 1}...
                              ),...
           'outparams',struct('name',{'resolution_value','frc_curve','resolution_high','resolution_low'},...
                              'description',{'Resolution value','FRC curve','Resolution - 1 std. dev.','Resolution + 1 std. dev.'},...
                              'type',{'array','array','array','array'},...
                              'suppress',{1,1,1,1}...
                              )...
           );       
       
if nargin == 1
   s = varargin{1};
   if ischar(s) & strcmp(s,'DIP_GetParamList')
      varargout{1} = d;
      return
   end
end

try
   [in1, in2, SR_pixelsize, show_frc] = getparams(d,varargin{:});
catch
   if ~isempty(paramerror)
      error(paramerror)
   else
      error('Parameter parsing was unsuccessful.')
   end
end

%% Compute results
[resolution_value, frc_curve, resolution_high, resolution_low] = frcresolution(in1,in2);

fprintf('Resolution value %2.1f +- %2.2f nm.\n', resolution_value*SR_pixelsize, (resolution_low-resolution_high)/2*SR_pixelsize);
fprintf('Resolution %2.1f +- %2.2f pixels.\n', resolution_value, (resolution_low-resolution_high)/2);

%% Plot FRC curve
if show_frc
    qmax = 0.5/(SR_pixelsize);
    
    figure
    hold on
    plot([0 qmax],[0 0],'k')
    plot(linspace(0,qmax*sqrt(2), length(frc_curve)), frc_curve,'-')
    plot([0 qmax],[1/7 1/7],'m')
    plot(1/(resolution_value*SR_pixelsize),1/7,'rx')
    plot(1/(resolution_value*SR_pixelsize)*[1 1],[-0.2 1/7],'r')
    hold off
    xlim([0,qmax]);
    ylim([-0.2 1.2])
    xlabel('Spatial frequency (nm^{-1})');
    ylabel('FRC')
end

%% Outputs
varargout{1} = resolution_value*SR_pixelsize;
varargout{2} = frc_curve;
varargout{3} = resolution_high*SR_pixelsize;
varargout{4} = resolution_low*SR_pixelsize;
./ExternalSoftware/FRCresolution_software/matlabdistribution/FRCresolutionfunctions/binlocalizations.m
%BINLOCALIZATIONS   Create image of binned localizations
%
% SYNOPSIS:
%   out = binlocalizations(positions,xsize,ysize,zoomfactor)
%
% PARAMETERS:
%   xsize
%      Size in x-direction of output
%   ysize
%      Size in y-direction of output
%   zoomfactor
%      Pixels per unit distance in the positions list
%
% DEFAULTS:
%   xsize : image edge corresponds to maximum x-coordinate
%   ysize : image edge corresponds to maximum y-coordinate
%   zoomfactor  = 1
%
% NOTES:
%  Columns of positions are assumed to have the same dimensionality.
%  Localizations with x or y-values smaller than -0.5 are discarded.

% (C) Copyright 2012               Quantitative Imaging Group
%     All rights reserved          Faculty of Applied Physics
%                                  Delft University of Technology
%                                  Lorentzweg 1
%                                  2628 CJ Delft
%                                  The Netherlands
% Robert Nieuwenhuizen, Oct 2012


function out = binlocalizations(varargin)

d = struct('menu','FRC resolution',...
           'display','Bin localizations',...
           'inparams',struct('name',       {'positions',        'xsize',            'ysize',            'zm'},...
                             'description',{'Localizations',    'X-size of output', 'Y-size of output', 'Zoom'},...
                             'type',       {'array',            'array',            'array',            'array'},...
                             'dim_check',  {{[],[-1 2],[-1 3]}, {[],0},             {[],0},             {[],0}},...
                             'range_check',{'R',                'N+',            	'N+',               [eps Inf]},...
                             'required',   {0,                  0,                  0,                  0},...
                             'default',    {[],                 [],                 [],                 1}...
                              ),...
           'outparams',struct('name',{'out'},...
                              'description',{'Image with binned localizations'},...
                              'type',{'array'}...
                              )...
           );       

if nargin == 1
   s = varargin{1};
   if ischar(s) & strcmp(s,'DIP_GetParamList')
      out = d;
      return
   end
end

try
   [positions,xsize,ysize,zm] = getparams(d,varargin{:});
catch
   if ~isempty(paramerror)
      error(paramerror)
   else
      error('Parameter parsing was unsuccessful.')
   end
end       

% Check that an output image size can be defined
if isempty(positions)
    if isempty(xsize) || isempty(ysize)
        error('No output image size can be defined.')
    else
        out = newim(xsize,ysize);
        return
    end
end

if isempty(zm)
    zm = 1;
end

% Offset and rescale positions
positions = single(positions);
positions(:,1:2) = positions(:,1:2) + 0.5;
positions(:,1:2) = positions(:,1:2)*zm;

% Define output sizes if necessary
if isempty(xsize)
    xsize = ceil(max(positions(:,1)));
end

if isempty(ysize)
    ysize = ceil(max(positions(:,2)));
end

% Filter localizations outside the FOV
keep = positions(:,1)>=0;
keep = keep & positions(:,2)>=0;
keep = keep & positions(:,1)<=xsize;
keep = keep & positions(:,2)<=ysize;
positions = positions(keep,:); 

% Bin localizations
out = cHistRecon(xsize,ysize,positions(:,1),positions(:,2),0)';
out = mat2im(out);

./ExternalSoftware/FRCresolution_software/matlabdistribution/FRCresolutionfunctions/binlocalizationsNM.m
%BINLOCALIZATIONSNM   Create image of binned localizations
%
% SYNOPSIS:
%   out = binlocalizationsNM(positions,xsize,ysize,pixelsize)
%
% PARAMETERS:
%   xsize
%      Size in x-direction of output (in nm)
%   ysize
%      Size in y-direction of output (in nm)
%   pixelsize
%      Pixel size of the output image (in nm)
%
% DEFAULTS:
%   xsize : image edge corresponds to maximum x-coordinate
%   ysize : image edge corresponds to maximum y-coordinate
%   pixelsize  = 10
%
% NOTES:
%  Columns of positions are assumed to be in nm.
%  Localizations with x or y-values smaller than -0.5*pixelsize are discarded.

% (C) Copyright 2012               Quantitative Imaging Group
%     All rights reserved          Faculty of Applied Physics
%                                  Delft University of Technology
%                                  Lorentzweg 1
%                                  2628 CJ Delft
%                                  The Netherlands
% Robert Nieuwenhuizen, Nov 2012


function out = binlocalizationsNM(varargin)

d = struct('menu','FRC resolution',...
           'display','Bin localizations in nm',...
           'inparams',struct('name',       {'positions',        'xsize',            'ysize',                        'ps'},...
                             'description',{'Localizations',    'X-size of output (nm)', 'Y-size of output (nm)',   'Superresolution pixel size (nm)'},...
                             'type',       {'array',            'array',            'array',                        'array'},...
                             'dim_check',  {{[],[-1 2],[-1 3]}, {[],0},             {[],0},                         {[],0}},...
                             'range_check',{'R',                'N+',            	'N+',                           [eps Inf]},...
                             'required',   {0,                  0,                  0,                              0},...
                             'default',    {[],                 [],                 [],                             10}...
                              ),...
           'outparams',struct('name',{'out'},...
                              'description',{'Image with binned localizations'},...
                              'type',{'array'}...
                              )...
           );       

if nargin == 1
   s = varargin{1};
   if ischar(s) & strcmp(s,'DIP_GetParamList')
      out = d;
      return
   end
end

try
   [positions,xsize,ysize,ps] = getparams(d,varargin{:});
catch
   if ~isempty(paramerror)
      error(paramerror)
   else
      error('Parameter parsing was unsuccessful.')
   end
end       

% Check that an output image size can be defined
if isempty(positions)
    if isempty(xsize) || isempty(ysize)
        error('No output image size can be defined.')
    else
        out = newim(xsize,ysize);
        return
    end
end

if isempty(ps)
    ps = 10;
end

zm = 1/ps;

if ~isempty(xsize)
    xsize = xsize/ps;
end

if ~isempty(xsize)
    ysize = ysize/ps;
end

out = binlocalizations(positions,xsize,ysize,zm);

./ExternalSoftware/FRCresolution_software/matlabdistribution/FRCresolutionfunctions/cfsmooth.m
function [c,ww] = smooth(varargin)
%SMOOTH  Smooth data.
%   Z = SMOOTH(Y) smooths data Y using a 5-point moving average.
%
%   Z = SMOOTH(Y,SPAN) smooths data Y using SPAN as the number of points used
%   to compute each element of Z.
%
%   Z = SMOOTH(Y,SPAN,METHOD) smooths data Y with specified METHOD. The
%   available methods are:
%
%           'moving'   - Moving average (default)
%           'lowess'   - Lowess (linear fit)
%           'loess'    - Loess (quadratic fit)
%           'sgolay'   - Savitzky-Golay
%           'rlowess'  - Robust Lowess (linear fit)
%           'rloess'   - Robust Loess (quadratic fit)
%
%   Z = SMOOTH(Y,METHOD) uses the default SPAN 5.
%
%   Z = SMOOTH(Y,SPAN,'sgolay',DEGREE) and Z = SMOOTH(Y,'sgolay',DEGREE)
%   additionally specify the degree of the polynomial to be used in the
%   Savitzky-Golay method. The default DEGREE is 2. DEGREE must be smaller
%   than SPAN.
%
%   Z = SMOOTH(X,Y,...) additionally specifies the X coordinates.  If X is
%   not provided, methods that require X coordinates assume X = 1:N, where
%   N is the length of Y.
%
%   Notes:
%   1. When X is given and X is not uniformly distributed, the default method
%   is 'lowess'.  The 'moving' method is not recommended.
%
%   2. For the 'moving' and 'sgolay' methods, SPAN must be odd.
%   If an even SPAN is specified, it is reduced by 1.
%
%   3. If SPAN is greater than the length of Y, it is reduced to the
%   length of Y.
%
%   4. In the case of (robust) lowess and (robust) loess, it is also
%   possible to specify the SPAN as a percentage of the total number
%   of data points. When SPAN is less than or equal to 1, it is
%   treated as a percentage.
%
%   For example:
%
%   Z = SMOOTH(Y) uses the moving average method with span 5 and
%   X=1:length(Y).
%
%   Z = SMOOTH(Y,7) uses the moving average method with span 7 and
%   X=1:length(Y).
%
%   Z = SMOOTH(Y,'sgolay') uses the Savitzky-Golay method with DEGREE=2,
%   SPAN = 5, X = 1:length(Y).
%
%   Z = SMOOTH(X,Y,'lowess') uses the lowess method with SPAN=5.
%
%   Z = SMOOTH(X,Y,SPAN,'rloess') uses the robust loess method.
%
%   Z = SMOOTH(X,Y) where X is unevenly distributed uses the
%   'lowess' method with span 5.
%
%   Z = SMOOTH(X,Y,8,'sgolay') uses the Savitzky-Golay method with
%   span 7 (8 is reduced by 1 to make it odd).
%
%   Z = SMOOTH(X,Y,0.3,'loess') uses the loess method where span is
%   30% of the data, i.e. span = ceil(0.3*length(Y)).
%
%   See also SPLINE.

%   Copyright 2001-2016 The MathWorks, Inc.

if nargin < 1
    error(message('curvefit:smooth:needMoreArgs'));
end

if nargout > 1 % Called from the GUI cftool
    ws = warning('off', 'all'); % turn warning off and record the previous warning state.
    [lw,lwid] = lastwarn;
    lastwarn('');
else
    ws = warning('query','all'); % Leave warning state alone but save it so resets are no-ops.
end

% is x given as the first argument?
if nargin==1 || ( nargin > 1 && (length(varargin{2})==1 || ischar(varargin{2})) )
    % smooth(Y) | smooth(Y,span,...) | smooth(Y,method,...)
    is_x = 0; % x is not given
    y = varargin{1};
    y = y(:);
    x = (1:length(y))';
else % smooth(X,Y,...)
    is_x = 1;
    y = varargin{2};
    x = varargin{1};
    y = y(:);
    x = x(:);
end

% is span given?
span = [];
if nargin == 1+is_x || ischar(varargin{2+is_x})
    % smooth(Y), smooth(X,Y) || smooth(X,Y,method,..), smooth(Y,method)
    is_span = 0;
else
    % smooth(...,SPAN,...)
    is_span = 1;
    span = varargin{2+is_x};
end

% is method given?
method = [];
if nargin >= 2+is_x+is_span
    % smooth(...,Y,method,...) | smooth(...,Y,span,method,...)
    method = varargin{2+is_x+is_span};
end

t = length(y);
if t == 0
    c = y;
    ww = '';
    if nargout > 1
        ww = lastwarn;
        lastwarn(lw,lwid);
        warning(ws);  % turn warning back to the previous state.
    end
    return
elseif length(x) ~= t
    warning(ws); % reset warn state before erroring
    error(message('curvefit:smooth:XYmustBeSameLength'));
end

if isempty(method)
    diffx = diff(x);
    if uniformx(diffx,x,y)
        method = 'moving'; % uniformly distributed X.
    else
        method = 'lowess';
    end
end

% realize span
if span <= 0
    warning(ws); % reset warn state before erroring
    error(message('curvefit:smooth:spanMustBePositive'));
end
if span < 1, span = ceil(span*t); end % percent convention
if isempty(span), span = 5; end % smooth(Y,[],method)

idx = 1:t;

sortx = any(diff(isnan(x))<0);   % if NaNs not all at end
if sortx || any(diff(x)<0) % sort x
    [x,idx] = sort(x);
    y = y(idx);
end

if islogical(y)
    y = double(y);
end

c = NaN(size(y),'like',y);

ok = ~isnan(x);
switch method
    case 'moving'
        c(ok) = moving(x(ok),y(ok),span);
    case {'lowess','loess','rlowess','rloess'}
        robust = 0;
        iter = 5;
        if method(1)=='r'
            robust = 1;
            method = method(2:end);
        end
        c(ok) = lowess(x(ok),y(ok),span, method,robust,iter);
    case 'sgolay'
        if nargin >= 3+is_x+is_span
            degree = varargin{3+is_x+is_span};
        else
            degree = 2;
        end
        if degree < 0 || degree ~= floor(degree) || degree >= span
            warning(ws); % reset warn state before erroring
            error(message('curvefit:smooth:invalidDegree'));
        end
        c(ok) = sgolay(x(ok),y(ok),span,degree);
    otherwise
        warning(ws); % reset warn state before erroring
        error(message('curvefit:smooth:unrecognizedMethod'));
end

c(idx) = c;

if nargout > 1
    ww = lastwarn;
    lastwarn(lw,lwid);
    warning(ws);  % turn warning back to the previous state.
end
%--------------------------------------------------------------------
function c = moving(x,y, span)
% moving average of the data.

ynan = isnan(y);
span = floor(span);
n = length(y);
span = min(span,n);
width = span-1+mod(span,2); % force it to be odd
xreps = any(diff(x)==0);
if width==1 && ~xreps && ~any(ynan), c = y; return; end
if ~xreps && ~any(ynan)
    % simplest method for most common case
    c = filter(ones(width,1)/width,1,y);
    cbegin = cumsum(y(1:width-2));
    cbegin = cbegin(1:2:end)./(1:2:(width-2))';
    cend = cumsum(y(n:-1:n-width+3));
    cend = cend(end:-2:1)./(width-2:-2:1)';
    c = [cbegin;c(width:end);cend];
elseif ~xreps
    % with no x repeats, can take ratio of two smoothed sequences
    yy = y;
    yy(ynan) = 0;
    nn = double(~ynan);
    ynum = moving(x,yy,span);
    yden = moving(x,nn,span);
    c = ynum ./ yden;
else
    % with some x repeats, loop
    notnan = ~ynan;
    yy = y;
    yy(ynan) = 0;
    c = zeros(n,1,'like',y);
    for i=1:n
        if i>1 && x(i)==x(i-1)
            c(i) = c(i-1);
            continue;
        end
        R = i;                                 % find rightmost value with same x
        while(R<n && x(R+1)==x(R))
            R = R+1;
        end
        hf = ceil(max(0,(span - (R-i+1))/2));  % need this many more on each side
        hf = min(min(hf,(i-1)), (n-R));
        L = i-hf;                              % find leftmost point needed
        while(L>1 && x(L)==x(L-1))
            L = L-1;
        end
        R = R+hf;                              % find rightmost point needed
        while(R<n && x(R)==x(R+1))
            R = R+1;
        end
        c(i) = sum(yy(L:R)) / sum(notnan(L:R));
    end
end
%--------------------------------------------------------------------
function c = lowess(x,y, span, method, robust, iter)
% LOWESS  Smooth data using Lowess or Loess method.
%
% The difference between LOWESS and LOESS is that LOWESS uses a
% linear model to do the local fitting whereas LOESS uses a
% quadratic model to do the local fitting. Some other software
% may not have LOWESS, instead, they use LOESS with order 1 or 2 to
% represent these two smoothing methods.
%
% Reference: 
% [C79] W.S.Cleveland, "Robust Locally Weighted Regression and Smoothing
%    Scatterplots", _J. of the American Statistical Ass._, Vol 74, No. 368 
%    (Dec.,1979), pp. 829-836.
%    http://www.math.tau.ac.il/~yekutiel/MA%20seminar/Cleveland%201979.pdf


n = length(y);
span = floor(span);
span = min(span,n);
c = y;
if span == 1
    return;
end

useLoess = false;
if isequal(method,'loess')
    useLoess = true;
end

diffx = diff(x);

% For problems where x is uniform, there's a faster way
isuniform = uniformx(diffx,x,y);
if isuniform
    % For uniform data, an even span actually covers an odd number of
    % points.  For example, the four closest points to 5 in the
    % sequence 1:10 are {3,4,5,6}, but 7 is as close as 3.
    % Therefore force an odd span.
    span = 2*floor(span/2) + 1;

    c = unifloess(y,span,useLoess);
    if ~robust || span<=2
        return;
    end
end

% Turn off warnings when called from command line (already off if called from
% cftool).
ws = warning( 'off', 'MATLAB:rankDeficientMatrix' );
cleanup = onCleanup( @() warning( ws ) );


ynan = isnan(y);
anyNans = any(ynan(:));
seps = sqrt(eps);
theDiffs = [1; diffx; 1];

if isuniform
    % We've already computed the non-robust smooth, so in preparation for
    % the robust smooth, compute the following arrays directly
    halfw = floor(span/2);
    
    % Each local interval is from |halfw| below the current index to |halfw|
    % above
    lbound = (1:n)-halfw;
    rbound = (1:n)+halfw;
    % However, there always has to be at least |span| points to the right of the
    % left bound
    lbound = min( n+1-span, lbound );
    % ... and at least |span| points to the left of the right bound
    rbound = max( span, rbound );
    % Furthermore, because these bounds index into vectors of length n, they
    % must contain valid indices
    lbound = max( 1, lbound );
    rbound = min( n, rbound );
    
    % Since the input is uniform we can use natural numbers for the input when
    % we need them.
    x = (1:numel(x))';
else
    if robust
        % pre-allocate space for lower and upper indices for each fit,
        % to avoid re-computing this information in robust iterations
        lbound = zeros(n,1,'like',y);
        rbound = zeros(n,1,'like',y);
    end

    % Compute the non-robust smooth for non-uniform x
    for i=1:n
        % if x(i) and x(i-1) are equal we just use the old value.
        if theDiffs(i) == 0
            c(i) = c(i-1);
            if robust
                lbound(i) = lbound(i-1);
                rbound(i) = rbound(i-1);
            end
            continue;
        end
        
        % Find nearest neighbours
        idx = iKNearestNeighbours( span, i, x, ~ynan );
        if robust
            % Need to store neighborhoods for robust loop
            lbound(i) = min(idx);
            rbound(i) = max(idx);
        end
        
        if isempty(idx)
            c(i) = NaN;
            continue
        end

        x1 = x(idx)-x(i); % center around current point to improve conditioning
        d1 = abs(x1);
        y1 = y(idx);

        weight = iTricubeWeights( d1 );
        if all(weight<seps)
            weight(:) = 1;    % if all weights are 0, just skip weighting
        end

        v = [ones(size(x1)) x1];
        if useLoess
            v = [v x1.*x1]; %#ok<AGROW> There is no significant growth here
        end
        
        v = weight(:,ones(1,size(v,2))).*v;
        y1 = weight.*y1;
        if size(v,1)==size(v,2)
            % Square v may give infs in the \ solution, so force least squares
            b = [v;zeros(1,size(v,2))]\[y1;0];
        else
            b = v\y1;
        end
        c(i) = b(1);
    end
end

% now that we have a non-robust fit, we can compute the residual and do
% the robust fit if required
maxabsyXeps = max(abs(y))*eps;
if robust
    for k = 1:iter
        r = y-c;
        
        % Compute robust weights
        rweight = iBisquareWeights( r, maxabsyXeps ); 
        
        % Find new value for each point.
        for i=1:n
            if i>1 && x(i)==x(i-1)
                c(i) = c(i-1);
                continue;
            end
            if isnan(c(i)), 
                continue; 
            end
            
            idx = lbound(i):rbound(i);
            if anyNans
                idx = idx(~ynan(idx));
            end
            % check robust weights for removed points
            if any( rweight(idx) <= 0 )
                idx = iKNearestNeighbours( span, i, x, (rweight > 0) );
            end
            
            x1 = x(idx) - x(i);
            d1 = abs(x1);
            y1 = y(idx);

            weight = iTricubeWeights( d1 );
            if all(weight<seps)
                weight(:) = 1;    % if all weights 0, just skip weighting
            end

            v = [ones(size(x1)) x1];
            if useLoess
                v = [v x1.*x1]; %#ok<AGROW> There is no significant growth here
            end
            
            % Modify the weights based on x values by multiplying them by
            % robust weights.
            weight = weight.*rweight(idx);
            
            v = weight(:,ones(1,size(v,2))).*v;
            y1 = weight.*y1;
            if size(v,1)==size(v,2)
                % Square v may give infs in the \ solution, so force least squares
                b = [v;zeros(1,size(v,2))]\[y1;0];
            else
                b = v\y1;
            end
            c(i) = b(1);
        end
    end
end
%--------------------------------------------------------------------
function c=sgolay(x,y,f,k)
% savitziki-golay smooth
% (x,y) are given data. f is the frame length to be taken, should
% be an odd number. k is the degree of polynomial filter. It should
% be less than f.

% Reference: Orfanidis, S.J., Introduction to Signal Processing,
% Prentice-Hall, Englewood Cliffs, NJ, 1996.

n = length(x);
f = floor(f);
f = min(f,n);
f = f-mod(f-1,2); % will subtract 1 if frame is even.
diffx = diff(x);
notnan = ~isnan(y);
nomissing = all(notnan);
if f <= k && all(diffx>0) && nomissing, c = y; return; end
hf = (f-1)/2; % half frame length

idx = 1:n;
if any(diffx<0) % make sure x is monotonically increasing
    [x,idx]=sort(x);
    y = y(idx);
    notnan = notnan(idx);
    diffx = diff(x);
end
% note that x is sorted so max(abs(x)) must be abs(x(1)) or abs(x(end));
% already calculated diffx for monotonic case, so use it again. Only
% recalculate if we sort x.
if nomissing && uniformx(diffx,x,y)
    v = ones(f,k+1);
    t=(-hf:hf)';
    for i=1:k
        v(:,i+1)=t.^i;
    end
    [q,~]=qr(v,0);
    ymid = filter(q*q(hf+1,:)',1,y);
    ybegin = q(1:hf,:)*q'*y(1:f);
    yend = q((hf+2):end,:)*q'*y(n-f+1:n);
    c = [ybegin;ymid(f:end);yend];
    return;
end

% non-uniformly distributed data
c = y;

% Turn off warnings when called from command line (already off if called from
% cftool).
ws = warning('off', 'all');
[lastwarnmsg,lastwarnid]=lastwarn;

for i = 1:n
    if i>1 && x(i)==x(i-1)
        c(i) = c(i-1);
        continue
    end
    L = i; R = i;                          % find leftmost and rightmost values
    while(R<n && x(R+1)==x(i))
        R = R+1;
    end
    while(L>1 && x(L-1)==x(i))
        L = L-1;
    end
    HF = ceil(max(0,(f - (R-L+1))/2));     % need this many more on each side

    L = min(n-f+1,max(1,L-HF));            % find leftmost point needed
    while(L>1 && x(L)==x(L-1))
        L = L-1;
    end
    R = min(n,max(R+HF,L+f-1));            % find rightmost point needed
    while(R<n && x(R)==x(R+1))
        R = R+1;
    end

    tidx = L:R;
    tidx = tidx(notnan(tidx));
    if isempty(tidx)
        c(i) = NaN;
        continue;
    end
    q = x(tidx) - x(i);   % center to improve conditioning
    vrank = 1 + sum(diff(q)>0);
    ncols = min(k+1, vrank);
    v = ones(length(q),ncols,'like',q);
    for j = 1:ncols-1
        v(:,j+1) = q.^j;
    end
    if size(v,1)==size(v,2)
        % Square v may give infs in the \ solution, so force least squares
        d = [v;zeros(1,size(v,2))]\[y(tidx);0];
    else
        d = v\y(tidx);
    end
    c(i) = d(1);
end
c(idx) = c;

lastwarn(lastwarnmsg,lastwarnid);
warning(ws);
%--------------------------------------------------------------------
function ys = unifloess(y,span,useLoess)
%UNIFLOESS Apply loess on uniformly spaced X values

y = y(:);

% Omit points at the extremes, which have zero weight
halfw = (span-1)/2;              % halfwidth of entire span
d = abs((1-halfw:halfw-1));      % distances to pts with nonzero weight
dmax = halfw;                    % max distance for tri-cubic weight

% Set up weighted Vandermonde matrix using equally spaced X values
x1 = (2:span-1)-(halfw+1);
weight = (1 - (d/dmax).^3).^1.5; % tri-cubic weight
v = [ones(length(x1),1) x1(:)];
if useLoess
    v = [v x1(:).^2];
end
V = v .* repmat(weight',1,size(v,2));

% Do QR decomposition
[Q,~] = qr(V,0);

% The projection matrix is Q*Q'.  We want to project onto the middle
% point, so we can take just one row of the first factor.
alpha = Q(halfw,:)*Q';

% This alpha defines the linear combination of the weighted y values that
% yields the desired smooth values.  Incorporate the weights into the
% coefficients of the linear combination, then apply filter.
alpha = alpha .* weight;
ys = filter(alpha,1,y);

% We need to slide the values into the center of the array.
ys(halfw+1:end-halfw) = ys(span-1:end-1);

% Now we have taken care of everything except the end effects.  Loop over
% the points where we don't have a complete span.  Now the Vandermonde
% matrix has span-1 points, because only 1 has zero weight.
x1 = 1:span-1;
v = [ones(length(x1),1) x1(:)];
if useLoess
    v = [v x1(:).^2];
end
for j=1:halfw
    % Compute weights based on deviations from the jth point,
    % then compute weights and apply them as above.
    d = abs((1:span-1) - j);
    weight = (1 - (d/(span-j)).^3).^1.5;
    V = v .* repmat(weight(:),1,size(v,2));
    [Q,~] = qr(V,0);
    alpha = Q(j,:)*Q';
    alpha = alpha .* weight;
    ys(j) = alpha * y(1:span-1);

    % These coefficients can be applied to the other end as well
    ys(end+1-j) = alpha * y(end:-1:end-span+2);
end
%--------------------------------------------------------------------
function isuniform = uniformx(diffx,x,y)
%ISUNIFORM True if x is of the form a:b:c

if any(isnan(y)) || any(isnan(x))
    isuniform = false;
else
    isuniform = all(abs(diff(diffx)) <= eps*max(abs([x(1),x(end)])));
end
%--------------------------------------------------------------------
function idx = iKNearestNeighbours( k, i, x, in )
% Find the k points from x(in) closest to x(i)

if nnz( in ) <= k
    % If we have k points or fewer, then return them all
    idx = find( in );
else
    % Find the distance to the k closest point
    d = abs( x - x(i) );
    ds = sort( d(in) );
    dk = ds(k);
    
    % Find all points that are as close as or closer than the k closest point
    close = (d <= dk);
    
    % The required indices are those points that are both close and "in"
    idx = find( close & in );
end
%--------------------------------------------------------------------
% Bi-square (robust) weight function
function delta = iBisquareWeights( r, myeps )
% Convert residuals to weights using the bi-square weight function.
% NOTE that this function returns the square root of the weights

% Only use non-NaN residuals to compute median
idx = ~isnan( r );
% And bound the median away from zero
s = max( 1e8 * myeps, median( abs( r(idx) ) ) );
% Covert the residuals to weights
delta = iBisquare( r/(6*s) );
% Everything with NaN residual should have zero weight
delta(~idx) = 0;
function b = iBisquare( x )
% This is this bi-square function defined at the top of the left hand
% column of page 831 in [C79]
% NOTE that this function returns the square root of the weights
b = zeros( size( x ) , 'like', x);
idx = abs( x ) < 1;
b(idx) = abs( 1 - x(idx).^2 );
%--------------------------------------------------------------------
% Tri-cubic weight function
function w = iTricubeWeights( d )
% Convert distances into weights using tri-cubic weight function.
% NOTE that this function returns the square-root of the weights.
%
% Protect against divide-by-zero. This can happen if more points than the span
% are coincident.
maxD = max( d );
if maxD > 0
    d = d/max( d );
end
w = (1 - d.^3).^1.5;

./ExternalSoftware/FRCresolution_software/matlabdistribution/FRCresolutionfunctions/frcresolution.m
%FRCRESOLUTION   Compute the resolution from 2 images
%
% SYNOPSIS:
%   [resolution frc_out resolution_high resolution_low] = frcresolution(in1,in2)
%
% NOTES:
%   Non-square images are zero padded to make them square.

% (C) Copyright 2012               Quantitative Imaging Group
%     All rights reserved          Faculty of Applied Physics
%                                  Delft University of Technology
%                                  Lorentzweg 1
%                                  2628 CJ Delft
%                                  The Netherlands
% Robert Nieuwenhuizen, Oct 2012

function varargout = frcresolution(varargin)

d = struct('menu','FRC resolution',...
           'display','Resolution from images',...
           'inparams',struct('name',       {'in1',      'in2',},...
                             'description',{'Image 1',  'Image 2',},...
                             'type',       {'image',    'image',},...
                             'dim_check',  {2,          2,},...
                             'range_check',{[],         [],},...
                             'required',   {1,          1,},...
                             'default',    {[],         [],}...
                              ),...
           'outparams',struct('name',{'resolution','frc_out','resolution_high','resolution_low'},...
                              'description',{'Resolution','FRC curve','Upper bound','Lower bound'},...
                              'type',{'array','array','array','array'}...
                              )...
           );       
       
if nargin == 1
   s = varargin{1};
   if ischar(s) & strcmp(s,'DIP_GetParamList')
      varargout{1} = struct('menu','none');
      return
   end
end

try
   [in1, in2] = getparams(d,varargin{:});
catch
   if ~isempty(paramerror)
      error(paramerror)
   else
      error('Parameter parsing was unsuccessful.')
   end
end

% Calculate FRC curve
frc_out = frc(in1,in2);

% Calculate the resolution
sz = max(imsize(in1));

if (~sum(in1)) || (~sum(in2))
    varargout{1} = NaN;
    varargout{2} = radialsum(0*in1);
    varargout{3} = NaN;
    varargout{4} = NaN;
    return;
end

switch nargout
    case 1
        resolution = frctoresolution(frc_out,sz);
        varargout{1} = resolution;
        return
    case 2
        resolution = frctoresolution(frc_out,sz);
        varargout{1} = resolution;
        varargout{2} = frc_out;
        return        
    case 3
        [resolution resolution_high] = frctoresolution(frc_out,sz);
        varargout{1} = resolution;
        varargout{2} = frc_out;
        varargout{3} = resolution_high;
        return
    case 4
        [resolution resolution_high resolution_low] = frctoresolution(frc_out,sz);
        varargout{1} = resolution;
        varargout{2} = frc_out;
        varargout{3} = resolution_high;
        varargout{4} = resolution_low;
        return
end

./ExternalSoftware/FRCresolution_software/matlabdistribution/FRCresolutionfunctions/gfca3D_sub.m
%GFCA3D_SUB   Compute FPC from 2 images for specified angles
%
% Computes the FPC for the given combination of angles and radii in Fourier
% space.
%
% SYNOPSIS:
%   fpc_out = gfca3D_sub(in1,in2,polar_angles,azim_angles,N_freq)
%
%   polar_angles
%      List of M polar angles of the planes' orientations. 
%   azim_angles
%      List of M azimuthal angles of the planes' orientations. 
%   N_freq
%      Width in pixels of the volume in frequency space that is used.
%
% NOTES:
%   Input images must be cubic.

% (C) Copyright 2012               Quantitative Imaging Group
%     All rights reserved          Faculty of Applied Physics
%                                  Delft University of Technology
%                                  Lorentzweg 1
%                                  2628 CJ Delft
%                                  The Netherlands
% Bernd Rieger and Robert Nieuwenhuizen, Oct 2012

function fpc_out = gfca3D_sub(varargin)

d = struct('menu','FRC resolution',...
           'display','FLC',...
           'inparams',struct('name',       {'in1',    'in2',        'pol_ang',           'azim_ang',        'Nsub'},...
                             'description',{'Image 1','Image 2',    'Polar angles',     'Azimuthal angles', 'Cutout volume'},...
                             'type',       {'image',  'image',      'array',            'array',            'array'},...
                             'dim_check',  {3,        3,            [-1 1],             [-1 1],             {[],0}},...
                             'range_check',{[],       [],           [],                 [],                 'N+'},...
                             'required',   {1,        1,            1,                  1,                  0},...
                             'default',    {'in1',    'in2',        [],                 [],                 []}...
                              ),...
           'outparams',struct('name',{'fpc_out'},...
                              'description',{'FPC'},...
                              'type',{'image'}...
                              )...
           );       
       
if nargin == 1
   s = varargin{1};
   if ischar(s) && strcmp(s,'DIP_GetParamList')
      fpc_out = struct('menu','none');
      return
   end
end

try
   [in1, in2, pol_ang, azim_ang, Nsub] = getparams(d,varargin{:});
catch
   if ~isempty(paramerror)
      error(paramerror)
   else
      error('Parameter parsing was unsuccessful.')
   end
end

%... it is assumed that in1 and in2 are NpxNpxNp images...
%... with isotropic sampling...
%... with Np preferably an odd number to guarantee symmetry in end result... 
sz = imsize(in1);

if any(imsize(in2) ~= sz)
    error('Image 1 and image 2 have different image sizes.');
end

if any(sz ~= max(sz))
    error('Input images are not cubic.');
end

% Check that the numbers of angles are the same
if any(size(pol_ang) ~= size(azim_ang))
    error('The number of polar and azimuthal angles must be the same.');
end

% Define the volume in frequency space that is used if necessary
if isempty(Nsub)
    Nsub = sz(1);
end

% Fourier transform input images
fprintf('Computing Fourier transformation\n')
f1 = ft(in1);
f2 = ft(in2);
clear in1 in2

% Cutout volume in Fourier space
f1 = cut(f1,Nsub);
f2 = cut(f2,Nsub);
Np = imsize(f1,1);
Ncenter = floor(Np/2);

% Compute correlations
h12 = real(f1*conj(f2)); % the product is complex but later the complex part cancels
                         % out in the sum over the planes, faster to due it this way.
h11 = real(f1*conj(f1)); % just change the datatype as output is real
h22 = real(f2*conj(f2));
clear f1 f2

% Prepare computation of rotation matrices for all directions to +e_z
cospol = cos(pol_ang);
sinpol = sin(pol_ang);
cosazi = cos(azim_ang);
sinazi = sin(azim_ang);

% Loop over all directions, for each direction rotation to +e_z and sum
% over rotated xy-plane
fprintf('Rotating..\n')
fpc_out = zeros(numel(pol_ang),Np);

matlabpool(4)
parfor jj=1:numel(pol_ang)
  fprintf('%d of %d\n',jj,numel(pol_ang))
  Rz = [cosazi(jj),sinazi(jj),0;-sinazi(jj),cosazi(jj),0;0,0,1];
  Ry = [cospol(jj),0,-sinpol(jj);0,1,0;sinpol(jj),0,cospol(jj)];
  R = Ry*Rz;
  
  % ...somehow we need the transpose of R here...
  h12rot = rotation3d(h12,'direct',R',[Ncenter, Ncenter, Ncenter]);
  h11rot = rotation3d(h11,'direct',R',[Ncenter, Ncenter, Ncenter]);
  h22rot = rotation3d(h22,'direct',R',[Ncenter, Ncenter, Ncenter]);
  
  h12av = squeeze(sum(h12rot,[],[1,2]));
  h11av = squeeze(sum(h11rot,[],[1,2]));
  h22av = squeeze(sum(h22rot,[],[1,2]));
  fpc_out(jj,:) = im2mat(h12av./sqrt(h11av)./sqrt(h22av));
end
matlabpool close
% Correct for q = 0
% fpc(:,Np/2+1) = 1.0;

fpc_out = mat2im(fpc_out);



./ExternalSoftware/FRCresolution_software/matlabdistribution/FRCresolutionfunctions/binlocalizations3D.m
%BINLOCALIZATIONS   Create image of binned 3D localizations
%
% SYNOPSIS:
%   out = binlocalizations(positions,xsize,ysize,zsize,zoomfactor)
%
% PARAMETERS:
%   xsize
%      Size in x-direction of output
%   ysize
%      Size in y-direction of output
%   zsize
%      Size in z-direction of output
%   zoomfactor
%      Pixels per unit distance in the positions list
%
% DEFAULTS:
%   xsize : image edge corresponds to maximum x-coordinate
%   ysize : image edge corresponds to maximum y-coordinate
%   zsize : image edge corresponds to maximum z-coordinate
%   zoomfactor  = 1
%
% NOTES:
%   All columns of positions are assumed to have the same dimensionality.
%   Localizations with x,y or z-values smaller than -0.5 are discarded.

% (C) Copyright 2012               Quantitative Imaging Group
%     All rights reserved          Faculty of Applied Physics
%                                  Delft University of Technology
%                                  Lorentzweg 1
%                                  2628 CJ Delft
%                                  The Netherlands
% Robert Nieuwenhuizen, Oct 2012

function out = binlocalizations3D(varargin)

d = struct('menu','FRC resolution',...
           'display','Bin 3D localizations',...
           'inparams',struct('name',       {'positions',        'xsize',            'ysize',            'zsize',            'zm'},...
                             'description',{'Localizations',    'X-size of output', 'Y-size of output', 'Z-size of output', 'Zoom'},...
                             'type',       {'array',            'array',            'array',            'array',            'array'},...
                             'dim_check',  {{[],[-1 3],[-1 4]}, {[],0},             {[],0},             {[],0},             {[],0}},...
                             'range_check',{'R',                'N+',            	'N+',               'N+',               [eps Inf]},...
                             'required',   {0,                  0,                  0,                  0,                  0},...
                             'default',    {[],                 [],                 [],                 [],                 1}...
                              ),...
           'outparams',struct('name',{'out'},...
                              'description',{'Image with binned localizations'},...
                              'type',{'array'}...
                              )...
           );       

if nargin == 1
   s = varargin{1};
   if ischar(s) & strcmp(s,'DIP_GetParamList')
      out = d;
      return
   end
end

try
   [positions,xsize,ysize,zsize,zm] = getparams(d,varargin{:});
catch
   if ~isempty(paramerror)
      error(paramerror)
   else
      error('Parameter parsing was unsuccessful.')
   end
end       

% Check that an output image size can be defined
if isempty(positions)
    if isempty(xsize) || isempty(ysize) || isempty(zsize)
        error('No output image size can be defined.')
    else
        out = newim(xsize,ysize,zsize);
        return
    end
end

if isempty(zm)
    zm = 1;
end

% Offset and rescale positions
positions = single(varargin{1});
positions(:,1:2) = positions(:,1:2) + 0.5;
positions = positions*zm;

% Define output sizes if necessary
if isempty(xsize)
    xsize = ceil(max(positions(:,1)));
end

if isempty(ysize)
    ysize = ceil(max(positions(:,2)));
end

if isempty(zsize)
    zsize = ceil(max(positions(:,3)));
end

% Filter localizations outside the FOV
keep = positions(:,1)>=0;
keep = keep & positions(:,2)>=0;
keep = keep & positions(:,3)>=0;
keep = keep & positions(:,1)<=xsize;
keep = keep & positions(:,2)<=ysize;
keep = keep & positions(:,3)<=zsize;
positions = positions(keep,:); 

% Bin localizations
out = cHistRecon3D(xsize,ysize,zsize,positions(:,1),positions(:,2),positions(:,3),0);
out = mat2im(out);

./ExternalSoftware/FRCresolution_software/matlabdistribution/FRCresolutionfunctions/frctoresolution.m
%FRCTORESOLUTION   Compute the resolution from a FRC curve
%
% SYNOPSIS:
%   [resolution resolution_high resolution_low] = binlocalizations(frc_in,size)
%
% PARAMETERS:
%   size
%     Size in pixels of the half data images from which frc_in was obtained

% (C) Copyright 2012               Quantitative Imaging Group
%     All rights reserved          Faculty of Applied Physics
%                                  Delft University of Technology
%                                  Lorentzweg 1
%                                  2628 CJ Delft
%                                  The Netherlands
% Robert Nieuwenhuizen, Oct 2012

function varargout = frctoresolution(frc_in,sz)

% Check the format of frc_in
if ~isa(frc_in,'numeric')
    error('The FRC curve does not have the right data format.')
end
if ~isvector(frc_in)
    error('The FRC curve has the wrong dimensionality')
end
if isrow(frc_in)
    frc_in = frc_in';
end
    % Check the format of sz
if ~isa(sz,'numeric')
    error('The specified image size does not have the right data format.')
end
if ~isscalar(sz)
    if numel(sz)~= 2
        error('The specified image size does not have the right data format.');
    else
        sz = max(sz);
    end
end
if (sz ~= round(sz)) || ~(sz > 0) 
    error('The image size must be a positive integer.')
end

% Check that the curvefit toolbox function smooth exists
TB_curve=0;
try 
    TB_d=toolboxdir('curvefit');
    TB_curve=1;
catch
    warning('Curvefit toolbox not available. Using another not optimal smoothing method for FRC.')
end

%% Check for undesirable values in FRC curve
frc_in = real(frc_in);
% frc_in(isnan(frc_in)) = 0;
frc_in(frc_in>1) = 1;
frc_in(frc_in<-1) = -1;

%% Calculate the number of pixels in a Fourier ring
% Number of pixels in a Fourier ring
nr = double(radialsum(ones(sz)))';       

if length(nr) ~= length(frc_in)
   error('The specified image size could not have resulted in this FRC curve.'); 
end

% Calculate the effective width of pixels in a Fourier ring
if nargout >1
    n1 = find(frc_in<0, 1,'first' );
    frc_tmp = frc_in;
    frc_tmp(isnan(frc_tmp)) = 0;
    frc_tmp(isinf(frc_tmp)) = 0;
    ne_inv = mean(frc_tmp(n1:end).^2.*nr(n1:end));
end

%% Smoot the FRC curve 
% Least squares interpolation for curve smoothing
sspan = ceil(sz/20);      % Smoothing span
if (sz/20)<5
    sspan = 5;
end
sspan = sspan  + (1-mod(sspan,2));

if TB_curve
   p = pwd; % hack to avoid the function shadwoing by smooth from dip_image
   cd([TB_d filesep 'curvefit'])
   frc_in = double(smooth(frc_in,sspan,'loess'));        
   cd(p)
else
   frc_in = [double(gaussf(frc_in,.9))]';
end
q = (0:(length(frc_in)-1))'/sz;                   % Spatial frequencies

%% Calculate intersections between the FRC curve and the threshold curve
% isects = polyxpoly(q,frc_in,q,thresholdcurve);
thresholdcurve = 1/7*ones(size(frc_in));
isects = isect(q,frc_in,thresholdcurve);

%% Find first intersection to obtain the resolution

% Throw away intersections at frequencies beyond the Nyquist frequency
isects = isects(isects<0.5);

if ~isempty(isects)
    % Find the first intersection where the FRC curve is decreasing
    isect_inds = 1+floor(sz*isects);    % Indices of the intersections
    for ii = 1:length(isect_inds)
        isect_ind = isect_inds(ii);
        if frc_in(isect_ind+1) < frc_in(isect_ind)
            resolution = 1/isects(ii);
            break
        end
    end
end

if ~exist('resolution','var')
    resolution = -1;
end

if resolution == -1
    varargout{1} = NaN;
    varargout{2} = 0;
    varargout{3} = 0.5;
    fprintf(' -- Could not find the resolution --\n')
    return
end

if nargout < 2
    varargout{1} = resolution;
    return
end

%% Calculate the resolution uncertainty

% Variance of the unsmoothed FRC values
frc_var = (1+2*frc_in-frc_in.^2).*(1-frc_in).^2*ne_inv./nr;

% Indices of FRC values inside the smoothing window
indexvec = (ceil(isect_ind-sspan/2)):(floor(isect_ind+sspan/2));    
indexvec = indexvec(indexvec>0);
indexvec = indexvec(indexvec<=length(frc_in));

% Calculate the covariance matrix of the LMS fit parameters.
S = diag(frc_var(indexvec));    % Approximate covariance matrix of the FRC values
X = cat(2,ones(size(indexvec')),q(indexvec),q(indexvec).^2);
C = inv(X'*X);
C = C*X'*S*X*C;

% Estimate the variance of FRC(fres) resulting from the least mean
% squares fit. The factor ne_inv arises to correct for the
% correlations between neighbouring FRC values.
frc_newvar = ne_inv*(1./[1 resolution resolution^2])*C*(1./[1; resolution; resolution^2]);

if isnan(frc_newvar) || isinf(frc_newvar)
    frc_newvar = frc_var(isect_ind);
end

% Calculate the crossing between FRC + 1*stdev(FRC) and threshold
frc_high = frc_in+sqrt(frc_newvar);
isects_high = isect(q,frc_high,thresholdcurve);
isects_high = isects_high(isects_high<0.5);
% Calculate the crossing between FRC - 1*stdev(FRC) and threshold 
frc_low = frc_in-sqrt(frc_newvar);
isects_low = isect(q,frc_low,thresholdcurve);
isects_low = isects_low(isects_low<0.5);

% Find resolution + 1 standard deviation
if ~isempty(isects_high)
    isect_inds = 1+floor(sz*isects_high);
    for ii = 1:length(isect_inds)
        isect_ind = isect_inds(ii);
        if frc_high(isect_ind+1) < frc_high(isect_ind)
            resolution_high = 1/isects_high(ii);
            break
        end
    end
end
if ~exist('resolution_high','var')
    resolution_high = 0;
end

% Find resolution + - standard deviation
if ~isempty(isects_low)
    isect_inds = 1+floor(sz*isects_low);
    for ii = 1:length(isect_inds)
        isect_ind = isect_inds(ii);
        if frc_low(isect_ind+1) < frc_low(isect_ind)
            resolution_low = 1/isects_low(ii);
            break
        end
    end
end
if ~exist('resolution_low','var')
    resolution_low = 0.5;
end

%% Write outputs
varargout{1} = resolution;
varargout{2} = resolution_high;
varargout{3} = resolution_low;

./ExternalSoftware/FRCresolution_software/matlabdistribution/FRCresolutionfunctions/fpc_slices.m
%FPC_SLICES   Compute the FPC from 2 images in 3 planes
%
% First a Tukey window is applied to the 2 images, and subsequently the FPC
% is computed from the Fourier Transforms of the two images, for slices
% where the x,y, or z-component of the frequency vector is 0.
%
% SYNOPSIS:
%   [fpc_xy fpc_xz fpc_yz] = fpc_slices(in1,in2)
%
% NOTES:
%   Non-cubed images are zero padded to make them square.
%   Images with even sizes are zero padded to make the image sizes uneven.

% (C) Copyright 2012               Quantitative Imaging Group
%     All rights reserved          Faculty of Applied Physics
%                                  Delft University of Technology
%                                  Lorentzweg 1
%                                  2628 CJ Delft
%                                  The Netherlands
% Robert Nieuwenhuizen, Oct 2012

function varargout = fpc_slices(varargin)

d = struct('menu','FRC resolution',...
           'display','FLC',...
           'inparams',struct('name',       {'in1',    'in2'},...
                             'description',{'Image 1','Image 2'},...
                             'type',       {'image',  'image'},...
                             'dim_check',  {3,        3},...
                             'range_check',{[],       []},...
                             'required',   {1,        1},...
                             'default',    {'in1',    'in2'}...
                              ),...
           'outparams',struct('name',{'fpc_xy','fpc_xz','fpc_yz'},...
                              'description',{'FPC xy-slice','FPC xz-slice','FPC yz-slice'},...
                              'type',{'image','image','image'}...
                              )...
           );       
       
if nargin == 1
   s = varargin{1};
   if ischar(s) && strcmp(s,'DIP_GetParamList')
      varargout{1} = struct('menu','none');
      return
   end
end

try
   [in1, in2] = getparams(d,varargin{:});
catch
   if ~isempty(paramerror)
      error(paramerror)
   else
      error('Parameter parsing was unsuccessful.')
   end
end

sz = imsize(in1);

if any(imsize(in2) ~= sz)
    error('Image 1 and image 2 have different image sizes.');
end

%% Mask and extend images

% Compute mask in x-direction
nfac = 8;                                                   % Image width / Width of edge region
x_im = xx(sz(1),sz(2),sz(3))/sz(1);
mask = 0.5-0.5*cos(pi*nfac*x_im);          
mask(abs(x_im)<((nfac-2)/(nfac*2))) = 1;
clear x_im

% Check that input images are square and mask
if sz(1) == sz(2)
    mask = mask*rot90(mask);
else
    % Compute mask in y-direction
    y_im = yy(sz(1),sz(2))/sz(2);
    mask_y = 0.5-0.5*cos(pi*nfac*y_im);          
    mask_y(abs(y_im)<((nfac-2)/(nfac*2))) = 1;
    mask = mask*mask_y;
    clear mask_y
end

% Mask input images
in1 = mask*in1;
in2 = mask*in2;
clear mask

% Make images cubed through zero padding if necessary
sz(sz<max(sz)) = max(sz);
in1 = extend(in1,sz);
in2 = extend(in2,sz);
    
% Make image size uneven through zero padding
if ~mod(sz(1),2)
    sz = sz+1;
    in1 = extend(in1,sz);
    in2 = extend(in2,sz);
end

%% Evaluate Fourier Plane Correlation

% Fourier transform input images
f1 = ft(in1);
f2 = ft(in2);
clear in1 in2

f1 = f1*(rr(sz)<=floor(sz(1)/2));
f2 = f2*(rr(sz)<=floor(sz(1)/2));

% Compute correlations
h12 = real(f1*conj(f2)); % the product is complex but later the complex part cancels
                         % out in the sum over the planes, faster to due it this way.
h11 = real(f1*conj(f1)); % just change the datatype as output is real
h22 = real(f2*conj(f2));
clear f1 f2

% Calculate FPC in the qx-qy plane by summing the z dimension and taking line sums
fpc_num = wkk(squeeze(sum(h12,[],3)));                                          % Numerator of the FPC in the qx-qy plane
fpc_denom = sqrt(wkk(squeeze(sum(h11,[],3)))*wkk(squeeze(sum(h22,[],3))));      % Denominator of the FPC in the qx-qy plane
fpc_xy = real(fpc_num./fpc_denom);

% Calculate FPC in the qx-qz plane
fpc_num = wkk(squeeze(sum(h12,[],2)));                                          % Numerator of the FPC in the qx-qz plane
fpc_denom = sqrt(wkk(squeeze(sum(h11,[],2)))*wkk(squeeze(sum(h22,[],2))));      % Denominator of the FPC in the qx-qz plane
fpc_xz = real(fpc_num./fpc_denom);

% Calculate FPC in the qy-qz plane
fpc_num = wkk(squeeze(sum(h12,[],1)));                                          % Numerator of the FPC in the qy-qz plane
fpc_denom = sqrt(wkk(squeeze(sum(h11,[],1)))*wkk(squeeze(sum(h22,[],1))));      % Denominator of the FPC in the qy-qz plane
fpc_yz = real(fpc_num./fpc_denom);

varargout{1} = fpc_xy;
varargout{2} = fpc_xz;
varargout{3} = fpc_yz;


./ExternalSoftware/FRCresolution_software/matlabdistribution/FRCresolutionfunctions/fpc.m
%FPC   Compute FPC from 2 images
%
% First a Tukey window is applied to the 2 images, and subsequently the FPC
% is computed from the Fourier Transforms of the two images.
%
% SYNOPSIS:
%   [fpc_xy fpc_xz fpc_yz fpc_out] = fpc(in1,in2,angles,maxfreq)
%
%   angles
%      Number of different orienations of the orientation planes. 
%   maxfreq
%      A cubic volume in Fourier space from -maxfreq to maxfreq is cut out
%      for the FPC calculation
%
% DEFAULTS:
%   angles = 64
%   maxfreq = 0.5
%
% NOTES:
%   Non-cubed images are zero padded to make them square.
%   Images with even sizes are zero padded to make the image sizes uneven.
%   The variable angles is rounded down to the nearest power of 4.

% (C) Copyright 2012               Quantitative Imaging Group
%     All rights reserved          Faculty of Applied Physics
%                                  Delft University of Technology
%                                  Lorentzweg 1
%                                  2628 CJ Delft
%                                  The Netherlands
% Bernd Rieger and Robert Nieuwenhuizen, Oct 2012

function varargout = fpc(varargin)

d = struct('menu','FRC resolution',...
           'display','FPC',...
           'inparams',struct('name',       {'in1',    'in2',        'N_angles',         'maxfreq',              'full_fpc'},...
                             'description',{'Image 1','Image 2',    'Rotation angles',  'Maximum frequency',    'Compute full FPC'},...
                             'type',       {'image',  'image',      'array',            'array',                'boolean'},...
                             'dim_check',  {3,        3,            {0},                {0},                    0},...
                             'range_check',{[],       [],           'N+',               [eps 0.5],              []},...
                             'required',   {1,        1,            0,                  0,                      0},...
                             'default',    {'in1',    'in2',        64,                 0.5,                    0}...
                              ),...
           'outparams',struct('name',{'fpc_xy','fpc_xz','fpc_yz','fpc_out'},...
                              'description',{'FPC in xy-plane','FPC in xz-plane','FPC in yz-plane','Full FPC'},...
                              'type',{'image','image','image','image'}...
                              )...
           );       
       
if nargin == 1
   s = varargin{1};
   if ischar(s) && strcmp(s,'DIP_GetParamList')
      varargout{1} = d;
      return
   end
end

try
   [in1, in2, N_angles, maxfreq, full_fpc] = getparams(d,varargin{:});
catch
   if ~isempty(paramerror)
      error(paramerror)
   else
      error('Parameter parsing was unsuccessful.')
   end
end

% Only compute slices of the FPC if 3 output arguments are used
if nargout>4
    error('Incorrect number of output arguments.')
end

if nargout>1
    [fpc_xy fpc_xz fpc_yz] = fpc_slices(in1,in2);
    varargout{1} = fpc_xy;
    varargout{2} = fpc_xz;
    varargout{3} = fpc_yz;
    if nargout<4
        return
    end
    
    if ~full_fpc
        varargout{4} = [];
        return
    end
end

% Check that N_angles exists and is 4 or larger
if N_angles<4
    N_angles = 4;
end

% Check that maxfreq exists
sz = imsize(in1);

if any(imsize(in2) ~= sz)
    error('Image 1 and image 2 have different image sizes.');
end

%% Mask and extend images

% Compute mask in x-direction
nfac = 8;                                                   % Image width / Width of edge region
x_im = xx(sz(1),sz(2),sz(3))/sz(1);
mask = 0.5-0.5*cos(pi*nfac*x_im);          
mask(abs(x_im)<((nfac-2)/(nfac*2))) = 1;
clear x_im

% Check that input images are square and mask
if sz(1) == sz(2)
    mask = mask*rot90(mask);
else
    % Compute mask in y-direction
    y_im = yy(sz(1),sz(2))/sz(2);
    mask_y = 0.5-0.5*cos(pi*nfac*y_im);          
    mask_y(abs(y_im)<((nfac-2)/(nfac*2))) = 1;
    mask = mask*mask_y;
    clear mask_y
end

% Mask input images
in1 = mask*in1;
in2 = mask*in2;
clear mask

% Make images cubed through zero padding if necessary
sz(sz<max(sz)) = max(sz);
in1 = extend(in1,sz);
in2 = extend(in2,sz);
    
% Make image size uneven through zero padding
if ~mod(sz(1),2)
    sz = sz+1;
    in1 = extend(in1,sz);
    in2 = extend(in2,sz);
end

%% Evaluate Fourier Plane Correlation

% Get all plane orientations (polar angle and azimuthal angle)
[pol_ang,azim_ang] = sphere_tesselation(floor(log(N_angles)/log(4)));

% Find the width in Fourier space of the pixels that are used
n = ceil(2*maxfreq*sz(1));                              % 2 times the radius in Fourier space of highest unmasked frequency component
if (~mod(n,2) && n>1)
    n = n-1;                                            % Make n uneven if necessary
end

% Fourier Plane Correlation
fpc_raw = gfca3D_sub(in1,in2,pol_ang,azim_ang,n);       % FPC for the specified angles and radii in Fourier space
fpc_raw = im2mat(fpc_raw)';

% Find xyz-coordinates of plane correlation values
Np = size(fpc_raw,1);                                   % Number of Fourier plane radii
qradius = ceil((0:Np-1)-Np/2)';                         % Plane radii
[~, pol_ang] = ndgrid(qradius,pol_ang);            
[q_mat, azim_ang] = ndgrid(qradius,azim_ang);
[x,y,z] = sph2cart(azim_ang,pi/2-pol_ang,q_mat);
clear q_mat pol_ang azim_ang

% Define grid of output values
[xc,yc,zc] = meshgrid(qradius,qradius,qradius); 

% Check if a warning will be displayed when calling TriScatteredInterp
s = warning('query', 'MATLAB:TriScatteredInterp:DupPtsAvValuesWarnId');
if strcmp(s.state,'on')
    warning('off', 'MATLAB:TriScatteredInterp:DupPtsAvValuesWarnId');
end

% Interpolate the FPC data on the gridpoints (xc,yc,zc)
x = reshape(x,[numel(x) 1]);
y = reshape(y,[numel(y) 1]);
z = reshape(z,[numel(z) 1]);
fpc_raw = reshape(fpc_raw,[numel(fpc_raw) 1]);
Int_obj = TriScatteredInterp(x,y,z,fpc_raw);            % Interpolated hypersurface v = fpc_raw(x,y,z)
fpc_out = mat2im(Int_obj(xc,yc,zc));                    % Evaluate value of hypersurface at (xc,yc,zc)
fpc_out(isnan(fpc_out)) = 0;

% Return the state of the warning from griddata to its original state
if strcmp(s.state,'on')
    warning('on', 'MATLAB:TriScatteredInterp:DupPtsAvValuesWarnId');
end

if nargout == 1
    varargout{1} = fpc_out;
else
    varargout{4} = fpc_out;
end
./ExternalSoftware/FRCresolution_software/matlabdistribution/FRCresolutionfunctions/frc.m
%FRC   Compute FRC curve from 2 images
%
% First a Tukey window is applied to the 2 images, and subsequently the FRC
% curve is computed from the Fourier Transforms of the two images. The
% maximum frequency for which the FRC is computed is sqrt(1/2).
%
% SYNOPSIS:
%   frc_out = frc(in1,in2)
%
% NOTES:
%   Non-square images are zero padded to make them square.

% (C) Copyright 2012               Quantitative Imaging Group
%     All rights reserved          Faculty of Applied Physics
%                                  Delft University of Technology
%                                  Lorentzweg 1
%                                  2628 CJ Delft
%                                  The Netherlands
% Robert Nieuwenhuizen, Oct 2012

function frc_out = frc(varargin)

d = struct('menu','FRC resolution',...
           'display','FRC',...
           'inparams',struct('name',       {'in1',    'in2'},...
                             'description',{'Image 1','Image 2'},...
                             'type',       {'image',  'image'},...
                             'dim_check',  {2,        2},...
                             'range_check',{[],       []},...
                             'required',   {1,        1},...
                             'default',    {'in1',    'in2'}...
                              ),...
           'outparams',struct('name',{'frc_out'},...
                              'description',{'FRC curve'},...
                              'type',{'array'}...
                              )...
           );       
       
if nargin == 1
   s = varargin{1};
   if ischar(s) && strcmp(s,'DIP_GetParamList')
      frc_out = struct('menu','none');
      return
   end
end

try
   [in1, in2] = getparams(d,varargin{:});
catch
   if ~isempty(paramerror)
      error(paramerror)
   else
      error('Parameter parsing was unsuccessful.')
   end
end

sz = imsize(in1);

if any(imsize(in2) ~= sz)
    error('Image 1 and image 2 have different image sizes.');
end

if (~sum(in1)) || (~sum(in2))
    frc_out = radialsum(0*in1);
    return;
end

% Compute mask in x-direction
nfac = 8;                                                   % Image width / Width of edge region
x_im = xx(sz(1),sz(2))/sz(1);
mask = 0.5-0.5*cos(pi*nfac*x_im);          
mask(abs(x_im)<((nfac-2)/(nfac*2))) = 1;

% Check that input images are square and mask
if sz(1) == sz(2)
    mask = mask*rot90(mask);
    
    % Mask input images
    in1 = mask*in1;
    in2 = mask*in2;
else
    warning('frc:nonsquare','Images are not square.');
   
    % Compute mask in y-direction
    y_im = yy(sz(1),sz(2))/sz(2);
    mask_y = 0.5-0.5*cos(pi*nfac*y_im);          
    mask_y(abs(y_im)<((nfac-2)/(nfac*2))) = 1;
    mask = mask*mask_y;
    clear mask_y
    
    % Mask input images
    in1 = mask*in1;
    in2 = mask*in2;
    
    % Make images square through zero padding
    in1 = extend(in1,[max(sz) max(sz)]);
    in2 = extend(in2,[max(sz) max(sz)]);
end

% Fourier transform input images
in1 = ft(in1);
in2 = ft(in2);

% Compute fourier ring correlation curve
frc_num = real(radialsum(in1.*conj(in2)));                                  % Numerator
in1 = abs(in1).^2;
in2 = abs(in2).^2;
frc_denom = sqrt(abs(radialsum(in1).*radialsum(in2)));                      % Denominator
frc_out = double(frc_num)./double(frc_denom);                               % FRC
frc_out(isnan(frc_out)) = 0;                                                % Remove NaNs
./ExternalSoftware/FRCresolution_software/matlabdistribution/FRCresolutionfunctions/qcorrection_ims.m
%QCORRECTION_IMS   Correct resolution from two images for spurious correlations
%
% SYNOPSIS:
%   [resolution_corr, resolution_uncorr, Q, frc_curve_corr frc_curve] = qcorrection_ims(in1, in2, meansig, stdsig, pixelsize, floorcor,show_frc)
%
%   pixelsize
%      Pixel size of the images (in nm)
%   show_frc
%      Display FRC curve?

%
% PARAMETERS:
%   meansig
%       Mean localization uncertainty (in SR pixels)
%   stdsig
%       St. dev. of localization uncertainties (in SR pixels)
%   pixelsize  
%      Pixel size of the images (in nm)
%   floorcor
%      Take into account noise floor on the numerator of the FRC?
%
% OUTPUT:
%   resolution_corr
%      Resolution value after correction for spurious correlations
%   resolution_uncorr
%      Resolution value without correction
%   Q                   
%      Estimate for the number of times an emitter is localized on average 
%      assuming Poisson statistics for the localizations per emitter
%  frc_curve_corr
%      FRC curve corrected for spurious correlations
%  frc_curve            
%      FRC curve without correction
%
% NOTES:
%   Non-square images are zero padded to make them square.
%
% SEE ALSO:
%  binlocalizations, frc, frctoresolution
%
% (C) Copyright 2012               Quantitative Imaging Group
%     All rights reserved          Faculty of Applied Physics
%                                  Delft University of Technology
%                                  Lorentzweg 1
%                                  2628 CJ Delft
%                                  The Netherlands
% Robert Nieuwenhuizen & Bernd Rieger, Dec 2012

function varargout = qcorrection_ims(varargin)

d = struct('menu','FRC resolution',...
           'display','Q-corrected resolution from images',...
           'inparams',struct('name',       {'in1',      'in2',          'meansig',          'stdsig',                   'SR_pixelsize',     'floorcorr',                'show_frc'},...
                             'description',{'Image 1',  'Image 2',      'Loc. unc.',        'Std. dev. of loc. unc.'    'Pixel size (nm)',  'Correct for noise floor',  'Display figures'},...
                             'type',       {'image',    'image',        'array',            'array',                    'array',            'boolean',                  'boolean'},...
                             'dim_check',  {2,          2,              0,                  0,                          0,                  0,                          0},...
                             'range_check',{[],         [],             [eps Inf],          'R+',                       [eps Inf],          [],                         []},...
                             'required',   {1,          1,              1,                  1,                          1,                  0,                          0},...
                             'default',    {'in1',      'in2',          1,                  0,                          10,                 0,                          0}...
                              ),...
           'outparams',struct('name',{'resolution_corr','resolution_value','Q','frc_curve_corr','frc_curve'},...
                              'description',{'Resolution (corrected)','Resolution (uncorrected)','Q','FRC curve (corrected)','FRC curve (uncorrected)'},...
                              'type',{'array','array','array','array','array'},...
                              'suppress',{1,1,1,1,1}...
                              )...
           );       
       
if nargin == 1
   s = varargin{1};
   if ischar(s) & strcmp(s,'DIP_GetParamList')
      varargout{1} = d;
      return
   end
end

try
   [in1, in2, meansig, stdsig, SR_pixelsize, floorcorr, show_frc] = getparams(d,varargin{:});
catch
   if ~isempty(paramerror)
      error(paramerror)
   else
      error('Parameter parsing was unsuccessful.')
   end
end

sz = imsize(in1);

if any(imsize(in2) ~= sz)
    error('Image 1 and image 2 have different image sizes.');
end

%% Make images square
% Compute mask in x-direction
nfac = 8;                                                   % Image width / Width of edge region
x_im = xx(sz(1),sz(2))/sz(1);
mask = 0.5-0.5*cos(pi*nfac*x_im);          
mask(abs(x_im)<((nfac-2)/(nfac*2))) = 1;

% Check that input images are square and mask
if sz(1) == sz(2)
    mask = mask*rot90(mask);
    
    % Mask input images
    in1 = mask*in1;
    in2 = mask*in2;
    
else
    warning('qcorrection_ims:nonsquare','Images are not square.');
   
    % Compute mask in y-direction
    y_im = yy(sz(1),sz(2))/sz(2);
    mask_y = 0.5-0.5*cos(pi*nfac*y_im);          
    mask_y(abs(y_im)<((nfac-2)/(nfac*2))) = 1;
    mask = mask*mask_y;
    clear mask_y
    
    % Mask input images
    in1 = mask*in1;
    in2 = mask*in2;
    
    % Make images square through zero padding
    in1 = extend(in1,[max(sz) max(sz)]);
    in2 = extend(in2,[max(sz) max(sz)]);
end

%% Prepare calculation of Q
Qnorm = (1/mean(in1)+1/mean(in2));

%% Fourier transform input images
in1 = ft(in1);
in2 = ft(in2);

%% Calculate FRC numerator
frcnum = double(real(radialmean(in1.*conj(in2))));

sz = size(in1,1);
q = (0:(length(frcnum)-1))./sz;

% find logmin and minloc for range of scaled sigs in order to be able to
% find average noise floor in that region, the noisefloor varies steeply in
% the plateau-region depending on where the minimum is on the plateau (to
% the left or to the right) the noisefloor-correction will be too large or
% too small, respectively.

allscales = [0.8 1.2 1.0];
allminloc = zeros(3,1);
alllogmin = zeros(3,1);

for jsc=1:numel(allscales)
scale = allscales(jsc);

% Calculate exponential decay function for Gaussian distribution of sigs
stdfac = 1+8*pi^2*(scale*stdsig)^2*(q.^2);
exp_decay = exp(-4*pi^2*(scale*meansig)^2*(q.^2)./stdfac)./sqrt(stdfac);

% Find smoothing kernel size
tmplog = real(log(frcnum) - log(exp_decay) -2*log(sinc(q)));
tmplog = tmplog(~isnan(tmplog));
tmplog = tmplog(~isinf(tmplog));
d = find(tmplog>(1+tmplog(1)),1);

if ((isempty(d) || d>sz/2))
    d = sz/2;
end

% Smooth FRC numerator
tmplog = real(log(frcnum) - log(exp_decay) -2*log(sinc(q)));
smoothlog = cfsmooth(real(log(frcnum) - log(exp_decay) -2*log(sinc(q))),d/5,'rloess');
if any(smoothlog==0)
    smoothlog(smoothlog==0) = tmplog(smoothlog==0);
end

% Find minimum of logarithm
% smoothlog(1:99) = 1E10;
% smoothlog(801:end) = 1E10;
[logmin minloc] = min(smoothlog(1:ceil(sz/2)));
allminloc(jsc) = minloc;
alllogmin(jsc) = logmin;

end

% Correct for contribution from the noise floor
nr = double(radialsum(ones(sz)));
noisefac = mean(log(frcnum(round(sz/2):end).^2.*nr(round(sz/2):end)));
noiselog = real(0.5*log(exp(noisefac)./nr)) - log(exp_decay) -2*log(sinc(q));

meannoiselog = (noiselog(allminloc(1))+noiselog(allminloc(2)))/2;
if floorcorr
  if logmin>meannoiselog
    logmin = log(exp(logmin)-exp(meannoiselog));
  else
    logmin = -Inf;
  end
end

% Correct for spurious correlations
frcnum_corr = exp(logmin).*exp_decay.*(sinc(q)).^2;

% Estimate number of localizations per emitter
Q = exp(logmin)*Qnorm;
fprintf('Estimated Q: %2.2f.\n',Q);

% Corrected frc
frcdenom = double(sqrt(real(radialmean(abs(in1).^2).*radialmean(abs(in2).^2))));
frccurve = frcnum./frcdenom;
frccurve_corr = (frcnum-frcnum_corr)./(frcdenom +frcnum_corr);


%% Plot results
if show_frc
    figure
    hold on
    plot(q/SR_pixelsize,frccurve);
    plot(q/SR_pixelsize,frccurve_corr,'r')
    plot([0 1/SR_pixelsize],[0 0],'k');
    xlim([0 0.5/SR_pixelsize])
    xlabel('Spatial frequency (nm^{-1})')
    ylabel('FRC')
    legend('Normal','Corrected for spurious correlations')
    hold off

    figure
    hold on
    % semilogy(q/ps, exp(log(Qnorm)+real(log(frcnum)) - log(exp_decay) -2*log(sinc(q))),'k',...
    %          q/ps, (log(Qnorm)+smoothlog)/log(10),'r','Linewidth',2,...
    %          q/ps, (log(Qnorm)+noiselog)/log(10),'g','Linewidth',2,...
    %          q/ps, (log(Qnorm)+smoothlog(minloc)*ones(size(q)))/log(10),'m','Linewidth',2)
    plot(q/SR_pixelsize, (log(Qnorm)+real(log(frcnum)) - log(exp_decay) -2*log(sinc(q)))/log(10),'k')
    plot(q/SR_pixelsize, (log(Qnorm)+smoothlog)/log(10),'r')
    % plot(q/ps, (log(Qnorm)+noiselog)/log(10),'g','Linewidth',2);
    plot(q/SR_pixelsize, (log(Qnorm)+smoothlog(minloc)*ones(size(q)))/log(10),'m')
    % plot(q(allminloc(:))/ps, (log(Qnorm)+smoothlog(allminloc(:)))/log(10),'ro');
    xlim([0 0.5/SR_pixelsize])
    ylim([min(log(frcnum(frcnum>0))) log(log(Qnorm)+frcnum(1))])
    ylim([-2 3])
    % % hleg = legend('normal','smooth','noise floor','plateau','minimum','Position','SouthEast');
    legend('Raw data','Smoothed data','Found plateau');
    hold off
    xlabel('Spatial frequency (nm^{-1})')
    ylabel('^{10}log(scaled FRC numerator)')
    set(gca,'YTick',[-2 -1 0 1 2 3])
    box on

    figure
    hold on
    plot(q/SR_pixelsize, real(log(frcnum)))
    plot(q/SR_pixelsize, real(log(frcdenom)),'k')
    plot(q/SR_pixelsize, real(log(frcnum_corr)),'r')
    plot(q/SR_pixelsize, real(log(frcnum-frcnum_corr)),'m')
    plot(q/SR_pixelsize, real(0.5*log(exp(noisefac)./nr)),'g');
    xlim([0 0.5/SR_pixelsize])
    ylim([min(log(frcnum(frcnum>0))) log(frcnum(1))])
    legend('FRC numerator','FRC denominator','Estimated spurious term','Corrected numerator','Noise floor')
    hold off
    xlabel('Spatial frequency (nm^{-1})')
    ylabel('log(FRC numerator)')
end

%% Calculate resolutions
resolution_uncorrr = frctoresolution(frcnum./frcdenom,sz);
resolution_corr = frctoresolution((frcnum-frcnum_corr)./(frcdenom +frcnum_corr),sz);

varargout{1} = resolution_corr;
varargout{2} = resolution_uncorrr;
varargout{3} = Q;
varargout{4} = frccurve_corr;
varargout{5} = frccurve;
./ExternalSoftware/PlotSpread/distinguishable_colors.m
function colors = distinguishable_colors(n_colors,bg,func)
% DISTINGUISHABLE_COLORS: pick colors that are maximally perceptually distinct
%
% When plotting a set of lines, you may want to distinguish them by color.
% By default, Matlab chooses a small set of colors and cycles among them,
% and so if you have more than a few lines there will be confusion about
% which line is which. To fix this problem, one would want to be able to
% pick a much larger set of distinct colors, where the number of colors
% equals or exceeds the number of lines you want to plot. Because our
% ability to distinguish among colors has limits, one should choose these
% colors to be "maximally perceptually distinguishable."
%
% This function generates a set of colors which are distinguishable
% by reference to the "Lab" color space, which more closely matches
% human color perception than RGB. Given an initial large list of possible
% colors, it iteratively chooses the entry in the list that is farthest (in
% Lab space) from all previously-chosen entries. While this "greedy"
% algorithm does not yield a global maximum, it is simple and efficient.
% Moreover, the sequence of colors is consistent no matter how many you
% request, which facilitates the users' ability to learn the color order
% and avoids major changes in the appearance of plots when adding or
% removing lines.
%
% Syntax:
%   colors = distinguishable_colors(n_colors)
% Specify the number of colors you want as a scalar, n_colors. This will
% generate an n_colors-by-3 matrix, each row representing an RGB
% color triple. If you don't precisely know how many you will need in
% advance, there is no harm (other than execution time) in specifying
% slightly more than you think you will need.
%
%   colors = distinguishable_colors(n_colors,bg)
% This syntax allows you to specify the background color, to make sure that
% your colors are also distinguishable from the background. Default value
% is white. bg may be specified as an RGB triple or as one of the standard
% "ColorSpec" strings. You can even specify multiple colors:
%     bg = {'w','k'}
% or
%     bg = [1 1 1; 0 0 0]
% will only produce colors that are distinguishable from both white and
% black.
%
%   colors = distinguishable_colors(n_colors,bg,rgb2labfunc)
% By default, distinguishable_colors uses the image processing toolbox's
% color conversion functions makecform and applycform. Alternatively, you
% can supply your own color conversion function.
%
% Example:
%   c = distinguishable_colors(25);
%   figure
%   image(reshape(c,[1 size(c)]))
%
% Example using the file exchange's 'colorspace':
%   func = @(x) colorspace('RGB->Lab',x);
%   c = distinguishable_colors(25,'w',func);

% Copyright 2010-2011 by Timothy E. Holy

  % Parse the inputs
  if (nargin < 2)
    bg = [1 1 1];  % default white background
  else
    if iscell(bg)
      % User specified a list of colors as a cell aray
      bgc = bg;
      for i = 1:length(bgc)
	bgc{i} = parsecolor(bgc{i});
      end
      bg = cat(1,bgc{:});
    else
      % User specified a numeric array of colors (n-by-3)
      bg = parsecolor(bg);
    end
  end
  
  % Generate a sizable number of RGB triples. This represents our space of
  % possible choices. By starting in RGB space, we ensure that all of the
  % colors can be generated by the monitor.
  n_grid = 30;  % number of grid divisions along each axis in RGB space
  x = linspace(0,1,n_grid);
  [R,G,B] = ndgrid(x,x,x);
  rgb = [R(:) G(:) B(:)];
  if (n_colors > size(rgb,1)/3)
    error('You can''t readily distinguish that many colors');
  end
  
  % Convert to Lab color space, which more closely represents human
  % perception
  if (nargin > 2)
    lab = func(rgb);
    bglab = func(bg);
  else
    C = makecform('srgb2lab');
    lab = applycform(rgb,C);
    bglab = applycform(bg,C);
  end

  % If the user specified multiple background colors, compute distances
  % from the candidate colors to the background colors
  mindist2 = inf(size(rgb,1),1);
  for i = 1:size(bglab,1)-1
    dX = bsxfun(@minus,lab,bglab(i,:)); % displacement all colors from bg
    dist2 = sum(dX.^2,2);  % square distance
    mindist2 = min(dist2,mindist2);  % dist2 to closest previously-chosen color
  end
  
  % Iteratively pick the color that maximizes the distance to the nearest
  % already-picked color
  colors = zeros(n_colors,3);
  lastlab = bglab(end,:);   % initialize by making the "previous" color equal to background
  for i = 1:n_colors
    dX = bsxfun(@minus,lab,lastlab); % displacement of last from all colors on list
    dist2 = sum(dX.^2,2);  % square distance
    mindist2 = min(dist2,mindist2);  % dist2 to closest previously-chosen color
    [dummy,index] = max(mindist2);  % find the entry farthest from all previously-chosen colors
    colors(i,:) = rgb(index,:);  % save for output
    lastlab = lab(index,:);  % prepare for next iteration
  end
end

function c = parsecolor(s)
  if ischar(s)
    c = colorstr2rgb(s);
  elseif isnumeric(s) && size(s,2) == 3
    c = s;
  else
    error('MATLAB:InvalidColorSpec','Color specification cannot be parsed.');
  end
end

function c = colorstr2rgb(c)
  % Convert a color string to an RGB value.
  % This is cribbed from Matlab's whitebg function.
  % Why don't they make this a stand-alone function?
  rgbspec = [1 0 0;0 1 0;0 0 1;1 1 1;0 1 1;1 0 1;1 1 0;0 0 0];
  cspec = 'rgbwcmyk';
  k = find(cspec==c(1));
  if isempty(k)
    error('MATLAB:InvalidColorString','Unknown color string.');
  end
  if k~=3 || length(c)==1,
    c = rgbspec(k,:);
  elseif length(c)>2,
    if strcmpi(c(1:3),'bla')
      c = [0 0 0];
    elseif strcmpi(c(1:3),'blu')
      c = [0 0 1];
    else
      error('MATLAB:UnknownColorString', 'Unknown color string.');
    end
  end
end

./ExternalSoftware/PlotSpread/plotSpread.m
function handles = plotSpread(varargin)
%PLOTSPREAD plots distributions of points by spreading them around the y-axis
%
% SYNOPSIS: handles = plotSpread(data,binWidth,spreadFcn,xNames,showMM,xValues)
%           handles = plotSpread(ah,...)
%
% INPUT data: cell array of distributions or nDatapoints-by-mDistributions
%           array, or array with data that is indexed by either
%           distributionIdx or categoryIdx, or both.
%       distributionIdx: grouping variable that determines to which
%           distribution a data point belongs. Grouping is
%           resolved by calling grp2idx, and unless xNames have
%           been supplied, group names determine the x-labels.
%           If the grouping variable is numeric, group labels also
%           determine x-values, unless the parameter xValues has
%           been specified.
%       distributionColors : color identifier (string, cell array of
%           strings), or colormap, with a single color, or one color per
%           distribution (or per entry in distributionIdx). Colors the
%           distributions. Default: 'b'
%       distributionMarkers : string, or cell array of strings, with either
%           a single marker or one marker per distribution (or per entry in
%           distributionIdx). See linespec for admissible markers.
%           Default: '.'
%		categoryIdx: grouping variable that determines group membership for data
%			points across distributions. Grouping is resolved by calling
%           grp2idx.
%       categoryColors : color identifier (cell array of
%           strings), or colormap, with one color per category.
%           Colors the categories, and will override distributionColors.
%           Default is generated using distinguishable_colors by Timothy E.
%           Holy.
%       categoryMarkers : cell array of strings, with one marker per
%           category. See linespec for admissible markers. Will override
%           distributionMarkers. Default: ''
%       binWidth : width of bins (along y) that control which data
%           points are considered close enough to be spread. Default: 0.1
%       spreadFcn : cell array of length 2 with {name,param}
%           if name is 'lin', the spread goes linear with the number of
%             points inside the bin, until it reaches the maximum of 0.9 at
%             n==param.
%           if name is 'xp', the spread increases as 1-exp(log(0.9)*x).
%             param is empty
%           Default {'xp',[]}
%       spreadWidth : width, along the x-axis (y-axis if flipped) that can
%           at most be covered by the points. Default:
%           median(diff(sort(xValues))); 1 if no xValues have been supplied
%       showMM : if 1, mean and median are shown as red crosses and
%                green squares, respectively. Default: 0
%                2: only mean
%                3: only median
%                4: mean +/- standard error of the mean (no median)
%                5: mean +/- standard deviation (no median)
%       xNames : cell array of length nDistributions containing x-tick names
%               (instead of the default '1,2,3')
%       xValues : list of x-values at which the data should
%                 be plotted. Default: 1,2,3...
%       xMode  : if 'auto', x-ticks are spaced automatically. If 'manual',
%                there is a tick for each distribution. If xNames is
%                provided as input, xMode is forced to 'manual'. Default:
%                'manual'.
%       xyOri  : orientation of axes. Either 'normal' (=default), or
%                'flipped'. If 'flipped', the x-and y-axes are switched, so
%                that violin plots are horizontal. Consequently,
%                axes-specific properties, such as 'yLabel' are applied to
%                the other axis.
%       yLabel : string with label for y-axis. Default : ''
%       ah  : handles of axes into which to plot
%
% OUTPUT handles: 3-by-1 cell array with handles to distributions,
%          mean/median etc, and the axes, respectively
%
% REMARKS: plotSpread is useful for distributions with a small number of
%          data points. For larger amounts of data, distributionPlot is
%          more suited.
%
% EXAMPLES: data = {randn(25,1),randn(100,1),randn(300,1)};
%           figure,plotSpread(data,[],[],{'25 pts','100 pts','300 pts'})
%
%            data = [randn(50,1);randn(50,1)+3.5]*[1 1];
%            catIdx = [ones(50,1);zeros(50,1);randi([0,1],[100,1])];
%            figure
%            plotSpread(data,'categoryIdx',catIdx,...
%                 'categoryMarkers',{'o','+'},'categoryColors',{'r','b'})
%
% END
%
% created with MATLAB ver.: 7.9.0.3470 (R2009b) on Mac OS X  Version: 10.5.7 Build: 9J61
%
% created by: jonas
% DATE: 11-Jul-2009
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

def.binWidth = 0.1;
def.spreadFcn = {'xp',[]};
def.xNames = [];
def.showMM = false;
def.xValues = [];
def.distributionIdx = [];
def.distributionColors = 'b';
def.distributionMarkers = '.';
def.xMode = 'manual';
def.xyOri = 'normal';
def.categoryIdx = [];
def.categoryColors = [];
def.categoryMarkers = '';
def.yLabel = '';
def.spreadWidth = [];

%% CHECK INPUT

% check for axes handle
if ~iscell(varargin{1}) && length(varargin{1}) == 1 && ...
        ishandle(varargin{1}) && strcmp(get(varargin{1},'Type'),'axes')
    ah = varargin{1};
    data = varargin{2};
    varargin(1:2) = [];
    newAx = false;
else
    ah = gca;
    data = varargin{1};
    varargin(1) = [];
    % if the axes have children, it's not new (important for adjusting
    % limits below)
    newAx = isempty(get(ah,'Children'));
end

% optional arguments
parserObj = inputParser;
parserObj.FunctionName = 'plotSpread';
distributionIdx = [];distributionLabels = '';
if ~isempty(varargin) && ~ischar(varargin{1}) && ~isstruct(varargin{1})
    % old syntax
    parserObj.addOptional('binWidth',def.binWidth);
    parserObj.addOptional('spreadFcn',def.spreadFcn);
    parserObj.addOptional('xNames',def.xNames);
    parserObj.addOptional('showMM',def.showMM);
    parserObj.addOptional('xValues',def.xValues);
    
    parserObj.parse(varargin{:});
    opt = parserObj.Results;
    
    opt.distributionIdx = [];
    opt.distributionColors = def.distributionColors;
    opt.distributionMarkers = def.distributionMarkers;
    opt.xMode = def.xMode;
    opt.xyOri = def.xyOri;
    opt.categoryIdx = [];
    opt.categoryColors = def.distributionColors;
    opt.categoryMarkers = def.distributionMarkers;
    opt.yLabel = '';
    opt.spreadWidth = def.spreadWidth;
    
    for fn = fieldnames(def)'
        if ~isfield(opt,fn{1})
            % Manually adding the new defaults means a lot fewer bugs
            error('please add option %s to old syntax',fn{1});
        end
        if isempty(opt.(fn{1}))
            opt.(fn{1}) = def.(fn{1});
        end
    end
    
else
    % new syntax
    defNames = fieldnames(def);
    for dn = defNames(:)'
        parserObj.addParamValue(dn{1},def.(dn{1}));
    end
    
    
    parserObj.parse(varargin{:});
    opt = parserObj.Results;
end

% We want data to be a vector, so that indexing with both groupIdx and
% distributionIdx becomes straightforward, and so that we can conveniently
% eliminate NaNs that otherwise could mess up grouping.
% Consequently, if data is a cell array, we convert it, and build a
% corresponding distributionIdx (allowing a user-supplied distributionIdx
% to override, though), and then we go and take care of groupIdx. Once all
% three indices have been built, NaN can be removed.

if iscell(data)
    % make sure data is all n-by-1
    data = cellfun(@(x)x(:),data,'UniformOutput',false);
    nData = length(data);
    nn = cellfun(@numel,data);
    % make vector
    data = cat(1,data{:});
    distributionIdx = repeatEntries((1:nData)',nn);
else
    % distributions in columns
    nData = size(data,2);
    distributionIdx = repeatEntries((1:nData)',size(data,1));
    data = data(:);
end



% distribution groups
if ~isempty(opt.distributionIdx)
    [distributionIdx,distributionLabels,vals] = grp2idx(opt.distributionIdx);
    % convert data to cell array
    nData = length(distributionLabels);
    % if not otherwise provided, use group labels for xnames
    if isempty(opt.xNames)
        opt.xNames = distributionLabels;
        if ~iscell(opt.xNames)
            opt.xNames = num2cell(opt.xNames);
        end
    end
    if isnumeric(vals) && isempty(opt.xValues)
        opt.xValues = vals;
    end
end

if ~isempty(opt.xNames)
    opt.xMode = 'manual';
end


% distribution colors&markers
if ischar(opt.distributionColors)
    opt.distributionColors = {opt.distributionColors};
end
if iscell(opt.distributionColors)
    if length(opt.distributionColors) == 1
        % expand
        opt.distributionColors = repmat(opt.distributionColors,nData,1);
    elseif length(opt.distributionColors) ~= nData
        error('please submit one color per distribution (%i dist, %i colors)',nData,length(opt.distributionColors));
    end
    
else
    if size(opt.distributionColors,2) ~= 3
        error('please specify colormap with three columns')
    end
    if size(opt.distributionColors,1) == 1
        opt.distributionColors = repmat(opt.distributionColors,nData,1);
    elseif size(opt.distributionColors,1) ~= nData
        error('please submit one color per distribution (%i dist, %i colors)',nData,size(opt.distributionColors,1));
    end
    
    % create a cell array
    opt.distributionColors = mat2cell(opt.distributionColors,ones(nData,1),3);
end

if ischar(opt.distributionMarkers)
    opt.distributionMarkers = {opt.distributionMarkers};
end
if length(opt.distributionMarkers) == 1
    % expand
    opt.distributionMarkers = repmat(opt.distributionMarkers,nData,1);
elseif length(opt.distributionMarkers) ~= nData
    error('please submit one color per distribution (%i dist, %i colors)',nData,length(opt.distributionMarkers));
end


stdWidth = 1;
if isempty(opt.xValues)
    opt.xValues = 1:nData;
end

if isempty(opt.spreadWidth) 
    % scale width
    tmp = median(diff(sort(opt.xValues)));
    if ~isnan(tmp)
        stdWidth = tmp;
    end
else
    stdWidth = opt.spreadWidth;
end

if ~ischar(opt.xyOri) || ~any(ismember(opt.xyOri,{'normal','flipped'}))
    error('option xyOri must be either ''normal'' or ''flipped'' (is ''%s'')',opt.xyOri);
end


% check for categoryIdx/colors/markers
% If there are categories, check colors/markers individually first,
% then check whether any of them at all have been supplied, and
% if not, override distributionColors with default categoryColors

if isempty(opt.categoryIdx)
    categoryIdx = ones(size(distributionIdx));
    nCategories = 1;
    categoryLabels = '';
else
    [categoryIdx,categoryLabels] = grp2idx(opt.categoryIdx(:));
    nCategories = max(categoryIdx);
end

% plotColors, plotMarkers, plotLabels: nDist-by-nCat arrays
plotColors = repmat(opt.distributionColors(:),1,nCategories);
plotMarkers= repmat(opt.distributionMarkers(:),1,nCategories);

if isempty(distributionLabels)
    distributionLabels = opt.xNames;
    if isempty(distributionLabels)
        distributionLabels = cellstr(num2str(opt.xValues(:)));
    end
end

if nCategories == 1
    plotLabels = distributionLabels(:);
else
    plotLabels = cell(nData,nCategories);
    for iData = 1:nData
        for iCategory = 1:nCategories
            plotLabels{iData,iCategory} = ...
                sprintf('%s-%s',num2str(distributionLabels{iData}),...
                num2str(categoryLabels{iCategory}));
        end
    end
    
end




categoryIsLabeled = false;
if nCategories > 1
    % if not using defaults for categoryColors: apply them
    if ~any(strcmp('categoryColors',parserObj.UsingDefaults))
        if iscell(opt.categoryColors)
            if length(opt.categoryColors) ~= nCategories
                error('please supply one category color per category')
            end
            plotColors = repmat(opt.categoryColors(:)',nData,1);
            categoryIsLabeled = true;
        else
            if all(size(opt.categoryColors) ~= [nCategories,3])
                error('please supply a #-of-categories-by-3 color array')
            end
            plotColors = repmat( mat2cell(opt.categoryColors,ones(nCategories,1),3)', nData,1);
            categoryIsLabeled = true;
        end
    end
    
    if ~any(strcmp('categoryMarkers',parserObj.UsingDefaults))
        if length(opt.categoryMarkers) ~= nCategories
            error('please supply one category marker per category')
        end
        if ~iscell(opt.categoryMarkers)
            error('please supply a list of markers as cell array')
        end
        plotMarkers = repmat(opt.categoryMarkers(:)',nData,1);
        categoryIsLabeled = true;
    end
    
    if ~categoryIsLabeled
        % use distinguishable_colors to mark categories
        
        plotColors = repmat( mat2cell(...
            distinguishable_colors(nCategories),...
            ones(nCategories,1),3)', nData,1);
        
    end
    
end


% remove NaNs from data
badData = ~isfinite(data) | ~isfinite(distributionIdx) | ~isfinite(categoryIdx);
data(badData) = [];
distributionIdx(badData) = [];
categoryIdx(badData) = [];




%% TRANSFORM DATA
% Here, I try to estimate what the aspect ratio of the data is going to be
fh = figure('Visible','off');
if ~isempty(data)
    minMax = [min(data);max(data)];
else
    minMax = [0 1];
end
switch opt.xyOri
    case 'normal'
        plot([0.5;nData+0.5],minMax,'o');
    case 'flipped'
        plot(minMax,[0.5;nData+0.5],'o');
        
end
aspectRatio = get(gca,'DataAspectRatio');
close(fh);

tFact = aspectRatio(2)/aspectRatio(1);
if strcmp(opt.xyOri,'flipped')
    tFact = 1/tFact;
end

%% SPREAD POINTS
% assign either nData, or xValues number of values, in case we're working
% with group-indices
[m,md,sem,sd] = deal(nan(max(nData,length(opt.xValues)),1));
% augment data to make n-by-2
data(:,2) = 0;
for iData = 1:nData
    currentDataIdx = distributionIdx==iData;
    currentData = data(currentDataIdx,1);
    
    if ~isempty(currentData)
        
        % transform and sort
        currentData = currentData / tFact;
        %currentData = sort(currentData);
        
        % add x
        currentData = [ones(size(currentData))*opt.xValues(iData),currentData]; %#ok<AGROW>
        
        % step through the data in 0.1 increments. If there are multiple
        % entries, spread along x
        for y = min(currentData(:,2)):opt.binWidth:max(currentData(:,2))
            % find values
            valIdx = find(currentData(:,2) >= y & currentData(:,2) < y+opt.binWidth);
            nVal = length(valIdx);
            if nVal > 1
                % spread
                switch opt.spreadFcn{1}
                    case 'xp'
                        spreadWidth = stdWidth*0.9*(1-exp(log(0.9)*(nVal-1)));
                    case 'lin'
                        spreadWidth = stdWidth*0.9*min(nVal-1,opt.spreadFcn{2})/opt.spreadFcn{2};
                end
                spreadDist = spreadWidth / (nVal - 1);
                if isEven(nVal)
                    offset = spreadDist / 2;
                else
                    offset = eps;
                end
                for v = 1:nVal
                    currentData(valIdx(v),1) = opt.xValues(iData) + offset;
                    % update offset
                    offset = offset - sign(offset) * spreadDist * v;
                end
            end
        end
        
        % update data
        currentData(:,2) = data(currentDataIdx,1);
        data(currentDataIdx,:) = currentData;
        
        
        if opt.showMM > 0
            m(iData) = nanmean(currentData(:,2));
            md(iData) = nanmedian(currentData(:,2));
            sd(iData) = nanstd(currentData(:,2));
            sem(iData) = sd(iData)/sqrt(sum(isfinite(currentData(:,2))));
        end
    end % test isempty
end


%% plot
set(ah,'NextPlot','add')
ph = NaN(nData,nCategories);
for iData = 1:nData
    for iCategory = 1:nCategories
        currentIdx = distributionIdx == iData & categoryIdx == iCategory;
        if any(currentIdx)
            switch opt.xyOri
                case 'normal'
                    ph(iData,iCategory) = plot(ah,data(currentIdx,1),...
                        data(currentIdx,2),...
                        'marker',plotMarkers{iData,iCategory},...
                        'color',plotColors{iData,iCategory},...
                        'lineStyle','none',...
                        'DisplayName',plotLabels{iData,iCategory});
                case 'flipped'
                    ph(iData,iCategory) = plot(ah,data(currentIdx,2),...
                        data(currentIdx,1),...
                        'marker',plotMarkers{iData,iCategory},...
                        'color',plotColors{iData,iCategory},...
                        'lineStyle','none',...
                        'DisplayName',plotLabels{iData,iCategory});
            end
        end
    end
end


% if ~empty, use xNames
switch opt.xyOri
    case 'normal'
        switch opt.xMode
            case 'manual'
                set(ah,'XTick',opt.xValues);
                if ~isempty(opt.xNames)
                    set(ah,'XTickLabel',opt.xNames)
                end
            case 'auto'
                % no need to do anything
        end
        
        % have plot start/end properly
        minX = min(opt.xValues)-stdWidth;
        maxX = max(opt.xValues)+stdWidth;
        if ~newAx
            oldLim = xlim;
            minX = min(minX,oldLim(1));
            maxX = max(maxX,oldLim(2));
        end
        xlim([minX,maxX])
        
        ylabel(ah,opt.yLabel)
        
    case 'flipped'
        switch opt.xMode
            case 'manual'
                set(ah,'YTick',opt.xValues);
                if ~isempty(opt.xNames)
                    set(ah,'YTickLabel',opt.xNames)
                end
            case 'auto'
                % no need to do anything
        end
        
        % have plot start/end properly (for ease of copying, only switch
        % xlim to ylim
        minX = min(opt.xValues)-stdWidth;
        maxX = max(opt.xValues)+stdWidth;
        if ~newAx
            oldLim = ylim;
            minX = min(minX,oldLim(1));
            maxX = max(maxX,oldLim(2));
        end
        ylim([minX,maxX])
        
        xlabel(ah,opt.yLabel);
        
end


% add mean/median
mh = [];mdh=[];
if opt.showMM
    % plot mean, median. Mean is filled red circle, median is green square
    % I don't know of a very clever way to flip xy and keep everything
    % readable, thus it'll be copy-paste
    switch opt.xyOri
        case 'normal'
            if any(opt.showMM==[1,2])
                mh = plot(ah,opt.xValues,m,'+r','Color','r','MarkerSize',12);
            end
            if any(opt.showMM==[1,3])
                mdh = plot(ah,opt.xValues,md,'sg','MarkerSize',12);
            end
            if opt.showMM == 4
                mh = plot(ah,opt.xValues,m,'+r','Color','r','MarkerSize',12);
                mdh = myErrorbar(ah,opt.xValues,m,sem);
            end
            if opt.showMM == 5
                mh = plot(ah,opt.xValues,m,'+r','Color','r','MarkerSize',12);
                mdh = myErrorbar(ah,opt.xValues,m,sd);
            end
        case 'flipped'
            if any(opt.showMM==[1,2])
                mh = plot(ah,m,opt.xValues,'+r','Color','r','MarkerSize',12);
            end
            if any(opt.showMM==[1,3])
                mdh = plot(ah,md,opt.xValues,'sg','MarkerSize',12);
            end
            if opt.showMM == 4
                mh = plot(ah,m,opt.xValues,'+r','Color','r','MarkerSize',12);
                mdh = myErrorbar(ah,m,opt.xValues,[sem,NaN(size(sem))]);
            end
            if opt.showMM == 5
                mh = plot(ah,m,opt.xValues,'+r','Color','r','MarkerSize',12);
                mdh = myErrorbar(ah,m,opt.xValues,[sd,NaN(size(sd))]);
            end
    end
end

%==========================
%% CLEANUP & ASSIGN OUTPUT
%==========================

if nargout > 0
    handles{1} = ph;
    handles{2} = [mh;mdh];
    handles{3} = ah;
end


./ExternalSoftware/PlotSpread/repeatEntries.m
function out = repeatEntries(val,kTimes)
%REPEATENTRIES fills a matrix with k repeats the rows of the input matrix
%
% SYNOPSIS out = repeatEntries(val,kTimes)
%
% INPUT    val    : matrix (or vectors) containing the rows to repeat (works for strings, too)
%          kTimes : number of repeats of each row (scalar or vector of size(vlaues,1))
%
% OUTPUT   out    : matrix of size [sum(kTimes) size(values,2)] containing
%                   repeated entries specified with k
%
% EXAMPLES     repeatEntries([1;2;3;4],[2;3;1;1]) returns [1;1;2;2;2;3;4]
%
%              repeatEntries([1;2;3;4],2) returns [1;1;2;2;3;3;4;4]
%
% c: jonas, 2/04
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%===========
% test input
%===========

% nargin
if nargin ~= 2 || isempty(val) || isempty(kTimes)
    error('two non-empty input arguments are needed!')
end

% size
valSize = size(val);
if length(valSize)>2
    error('only 2D arrays supported for val')
end



% decide whether we have scalar k
numK = length(kTimes);
if numK == 1
    scalarK = 1;
elseif numK ~= valSize(1)
    error('vector k must have the same length as the number of rows in val or be a scalar')
else
    % check again whether we could use scalar k
    if all(kTimes(1) == kTimes)
        scalarK = 1;
        kTimes = kTimes(1);
    else
        scalarK = 0;
    end
end

% do not care about size of k: we want to make a col vector out of it - and
% this vector should only contain nonzero positive integers
kTimes = round(kTimes(:));
% if there are any negative values or zeros, remove the entry
if scalarK && kTimes < 1
    out = [];
    return
end
if ~scalarK
    badK = kTimes < 1;
    kTimes(badK) = [];
    val(badK,:) = [];
    % update valSize
    valSize = size(val);
    if any(valSize==0)
        out = [];
        return
    end
end
%kTimes = max(kTimes,ones(size(kTimes)));


%============
% fill in out
%============

% first the elegant case: scalar k
if scalarK

    % build repeat index matrix idxMat
    idxMat = meshgrid( 1:valSize(1), 1:kTimes(1) );
    idxMat = idxMat(:); % returns [1;1...2;2;... etc]

    out = val(idxMat,:);

    % second: the loop
else

    % init out, init counter
    if iscell(val)
        out = cell(sum(kTimes) , valSize(2));
    else
    out = zeros( sum(kTimes), valSize(2) );
    end
    endct = 0;

    if valSize(2) == 1

        % vector: fill directly

        % loop and fill
        for i = 1:valSize(1)
            startct = endct + 1;
            endct   = endct + kTimes(i);
            out(startct:endct,:) = val(i);
        end % for i=1:valSize(1)

    else

        % matrix: fill via index list

        idxMat = zeros(sum(kTimes),1);

        for i = 1:valSize(1)
            startct = endct + 1;
            endct   = endct + kTimes(i);
            idxMat(startct:endct) = i;
        end % for i=1:valSize(1)
        out = val(idxMat,:);

    end

    % check for strings and transform if necessary
    if ischar(val)
        out = char(out);
    end

end % if doScalar



./ExternalSoftware/PlotSpread/myErrorbar.m
function hh = myErrorbar(varargin)
%MYERRORBAR Adds errorbars to existing plot (unlike errorbar.m, which creates a new plot, and allows only bars for y values)
%   MYERRORBAR(X,Y,L,U) adds error bars to the graph of vector X vs. vector Y with
%   error bars specified by the vectors L and U.  L and U contain the
%   lower and upper error ranges for each point in Y.  Each error bar
%   is L(i) + U(i) long and is drawn a distance of U(i) above and L(i)
%   below the points in (X,Y). If X,Y,L and U are matrices then each column
%   produces a separate line.
%   If L,U are the same size as X, Y, only error bars for Y will be plotted.
%   If L,U are twice the size of X,Y (or have twice the number of columns for
%   matrices), the first half of L, U specifies error bar lengths for X and the
%   second half specifies error bars for Y
%
%   MYERRORBAR(X,Y,E) or MYERRORBAR(Y,E) plots error bars [Y-E Y+E].
%
%   MYERRORBAR(AX,...), where AX is an axis handle, plots errorbars into
%                       axes AX
%
%   H = MYERRORBAR(...) returns a vector of line handles.
%
%   The tag of the errorbar-lines is: errorBar
%
%   For example,
%      x = 1:10;
%      y = sin(x);
%      e = std(y)*ones(size(x));
%      myErrorbar(x,y,e)
%   draws symmetric error bars of unit standard deviation for y values.
%      myErrorbar(x,y,[e,e])
%   draws symmetric error bars of unit standard deviation for x and y
%   values.
%
%   Based on the matlab-function errorbar as revised by Claude Berney
%   c: jonas, 06-03
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%==================
% check input
%==================

if nargin < 2
    error('not enough input arguments!')
end

% check if the first input argument is a handle
if length(varargin{1}) == 1 && ishandle(varargin{1}) && strcmpi(get(varargin{1},'Type'),'axes')
    axesH = varargin{1};
    % remove axis handle
    varargin(1) = [];
else
    axesH = gca;
end

% there could be
% y,e
% x,y,e
% x,y,l,u

switch length(varargin)
    case 2
        % y, e
        y = varargin{1};
        y = y(:);
        lengthY = length(y);
        x = [1:lengthY]';
        
        e = varargin{2};
        % check for 2 dimension errorbars
        e = e(:);
        if length(e) == 2*lengthY
            e = reshape(e,lengthY,2);
        end
        [l,u] = deal(e);
        
    case 3
        % x,y,e
        x = varargin{1};
        x = x(:);
        y = varargin{2};
        y = y(:);
        lengthY = length(y);
        
        e = varargin{3};
        % check for 2 dimension errorbars
        e = e(:);
        if length(e) == 2*lengthY
            e = reshape(e,lengthY,2);
        end
        [l,u] = deal(e);
        
    case 4
        % x,y,l,u
        % x,y,e
        x = varargin{1};
        x = x(:);
        y = varargin{2};
        y = y(:);
        lengthY = length(y);
        
        l = varargin{3};
        % check for 2 dimension errorbars
        l = l(:);
        if length(l) == 2*lengthY
            l = reshape(l,lengthY,2);
        end
        u = varargin{4};
        % check for 2 dimension errorbars
        u = u(:);
        if length(u) == 2*lengthY
            u = reshape(u,lengthY,2);
        end
        
        if ~all(size(u)==size(l))
            error('l, u have to be the same size!')
        end
        
end % switch number of inputs


u = abs(u);
l = abs(l);

if ischar(x) || ischar(y) || ischar(u) || ischar(l)
    error('Arguments must be numeric.')
end

if ~isequal(size(x),size(y))
    error('The sizes of X and Y must be the same.');
end

if isequal([1 2].*size(x),size(l)) && isequal([1 2].*size(x),size(u))
    xyBars = 1;
elseif isequal(size(x),size(l)) && isequal(size(x),size(u))
    xyBars = 0;
else
    error('The sizes of L and U must be equal to or twice the size of X, Y')
end

%=======================


% Plot graph and bars
hold_state = ishold;
hold on;


%find color of current plot
dataH = get(axesH,'Children');
myLineH = dataH(1);
% support also bar plots
if strcmp(get(myLineH,'Type'),'hggroup')
    latestColor = get(myLineH,'EdgeColor'); %new children are added on top!
else
    latestColor = get(myLineH,'Color'); %new children are added on top!
end

tee=0;
if ~strcmp('log',get(axesH,'XScale'))
    tee = (max(x(:))-min(x(:)))/100;  % make tee .02 x-distance for error bars
    tee = min(tee,0.3*nanmedian(diff(unique(x(:))))); % or at most 0.3*deltaX
    xl = x - tee;
    xr = x + tee;
end
if strcmp('log',get(axesH,'XScale'))
    tee = (max(log(x(:)))-min(log(x(:))))/100;  % make tee .02 x-distance for error bars
    tee = min(tee,0.3*nanmedian(diff(unique(log(x(:)))))); % or at most 0.3*deltaX
    
    xl = x *exp(tee);
    xr = x *exp(-tee);
end

if xyBars
    if ~strcmp('log',get(axesH,'YScale'))
        tee = (max(y(:))-min(y(:)))/100;  % make tee .02 y-distance for error bars
        tee = min(tee,0.3*nanmedian(diff(unique(y(:))))); % or at most 0.3*deltaY
        
        yl = y - tee;
        yr = y + tee;
    end
    if strcmp('log',get(axesH,'YScale'))
        tee = (max(log(y(:)))-min(log(y(:))))/100;  % make tee .02 y-distance for error bars
        tee = min(tee,0.3*nanmedian(diff(unique(log(y(:)))))); % or at most 0.3*deltaX
        
        yl = y *exp(tee);
        yr = y *exp(-tee);
    end
end

%specify coordinates to plot error bars
if xyBars
    xtop = x + u(:,1:size(x,2));
    xbot = x - l(:,1:size(x,2));
    ytop = y + u(:,size(x,2)+1:end);
    ybot = y - l(:,size(x,2)+1:end);
else
    ytop = y + u;
    ybot = y - l;
end
n = size(y,2);

% build up nan-separated vector for bars
xb = zeros(lengthY*9,n);
xb(1:9:end,:) = x;
xb(2:9:end,:) = x;
xb(3:9:end,:) = NaN;
xb(4:9:end,:) = xl;
xb(5:9:end,:) = xr;
xb(6:9:end,:) = NaN;
xb(7:9:end,:) = xl;
xb(8:9:end,:) = xr;
xb(9:9:end,:) = NaN;

yb = zeros(lengthY*9,n);
yb(1:9:end,:) = ytop;
yb(2:9:end,:) = ybot;
yb(3:9:end,:) = NaN;
yb(4:9:end,:) = ytop;
yb(5:9:end,:) = ytop;
yb(6:9:end,:) = NaN;
yb(7:9:end,:) = ybot;
yb(8:9:end,:) = ybot;
yb(9:9:end,:) = NaN;

h = [line(xb,yb,'parent',axesH,'Color',latestColor)];

if xyBars
    
    xb(1:9:end,:) = xtop;
    xb(2:9:end,:) = xbot;
    xb(3:9:end,:) = NaN;
    xb(4:9:end,:) = xtop;
    xb(5:9:end,:) = xtop;
    xb(6:9:end,:) = NaN;
    xb(7:9:end,:) = xbot;
    xb(8:9:end,:) = xbot;
    xb(9:9:end,:) = NaN;
    
    yb(1:9:end,:) = y;
    yb(2:9:end,:) = y;
    yb(3:9:end,:) = NaN;
    yb(4:9:end,:) = yl;
    yb(5:9:end,:) = yr;
    yb(6:9:end,:) = NaN;
    yb(7:9:end,:) = yl;
    yb(8:9:end,:) = yr;
    yb(9:9:end,:) = NaN;
    
    h = [h;line(xb,yb,'parent',axesH,'Color',latestColor)];
    
end

%set the tag of all errorBar-objects to 'errorBar'
set(h,'Tag','errorBar');

% make sure errorbar doesn't produce a legend entry
for lineH = h'
    set(get(get(lineH,'Annotation'),'LegendInformation'),...
        'IconDisplayStyle','off');
end


if ~hold_state, hold off; end

if nargout>0, hh = h; end

./ExternalSoftware/PlotSpread/isEven.m
function out = isEven(in)
%ISEVEN checks whether a number is even
%
% SYNOPSIS out = isEven(in)
%
% INPUT    in :  input (array) of numbers to be tested. 
% OUTPUT   out:  array of size(in) with 
%                   1 for even integers and zero
%                   0 for odd integers
%                 NaN for non-integers
%                out is a logical array as long as the input is all integers.
%
% c: jonas 5/05
% Last modified 11/24/2009 - Jonas Dorn
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

out = mod(in+1, 2);
% Set NaN for non-integer data, because they are neither odd or even
out((out ~= 0) & (out ~= 1)) = NaN;

% since doubles cannot be used for logical indexing, we should convert to
% logicals if possible. 
if all(isfinite(out(:)))
    out = logical(out);
end
./ExternalSoftware/PlotSpread/plotSpreadMM.m
function handles = plotSpread(varargin)
%PLOTSPREAD plots distributions of points by spreading them around the y-axis
%
% SYNOPSIS: handles = plotSpread(data,binWidth,spreadFcn,xNames,showMM,xValues)
%           handles = plotSpread(ah,...)
%
% INPUT data: cell array of distributions or nDatapoints-by-mDistributions
%           array, or array with data that is indexed by either
%           distributionIdx or categoryIdx, or both.
%       distributionIdx: grouping variable that determines to which
%           distribution a data point belongs. Grouping is
%           resolved by calling grp2idx, and unless xNames have
%           been supplied, group names determine the x-labels.
%           If the grouping variable is numeric, group labels also
%           determine x-values, unless the parameter xValues has
%           been specified.
%       distributionColors : color identifier (string, cell array of
%           strings), or colormap, with a single color, or one color per
%           distribution (or per entry in distributionIdx). Colors the
%           distributions. Default: 'b'
%       distributionMarkers : string, or cell array of strings, with either
%           a single marker or one marker per distribution (or per entry in
%           distributionIdx). See linespec for admissible markers.
%           Default: '.'
%		categoryIdx: grouping variable that determines group membership for data
%			points across distributions. Grouping is resolved by calling
%           grp2idx.
%       categoryColors : color identifier (cell array of
%           strings), or colormap, with one color per category.
%           Colors the categories, and will override distributionColors.
%           Default is generated using distinguishable_colors by Timothy E.
%           Holy.
%       categoryMarkers : cell array of strings, with one marker per
%           category. See linespec for admissible markers. Will override
%           distributionMarkers. Default: ''
%       binWidth : width of bins (along y) that control which data
%           points are considered close enough to be spread. Default: 0.1
%       spreadFcn : cell array of length 2 with {name,param}
%           if name is 'lin', the spread goes linear with the number of
%             points inside the bin, until it reaches the maximum of 0.9 at
%             n==param.
%           if name is 'xp', the spread increases as 1-exp(log(0.9)*x).
%             param is empty
%           Default {'xp',[]}
%       spreadWidth : width, along the x-axis (y-axis if flipped) that can
%           at most be covered by the points. Default:
%           median(diff(sort(xValues))); 1 if no xValues have been supplied
%       showMM : if 1, mean and median are shown as red crosses and
%                green squares, respectively. Default: 0
%                2: only mean
%                3: only median
%                4: mean +/- standard error of the mean (no median)
%                5: mean +/- standard deviation (no median)
%       xNames : cell array of length nDistributions containing x-tick names
%               (instead of the default '1,2,3')
%       xValues : list of x-values at which the data should
%                 be plotted. Default: 1,2,3...
%       xMode  : if 'auto', x-ticks are spaced automatically. If 'manual',
%                there is a tick for each distribution. If xNames is
%                provided as input, xMode is forced to 'manual'. Default:
%                'manual'.
%       xyOri  : orientation of axes. Either 'normal' (=default), or
%                'flipped'. If 'flipped', the x-and y-axes are switched, so
%                that violin plots are horizontal. Consequently,
%                axes-specific properties, such as 'yLabel' are applied to
%                the other axis.
%       yLabel : string with label for y-axis. Default : ''
%       ah  : handles of axes into which to plot
%
% OUTPUT handles: 3-by-1 cell array with handles to distributions,
%          mean/median etc, and the axes, respectively
%
% REMARKS: plotSpread is useful for distributions with a small number of
%          data points. For larger amounts of data, distributionPlot is
%          more suited.
%
% EXAMPLES: data = {randn(25,1),randn(100,1),randn(300,1)};
%           figure,plotSpread(data,[],[],{'25 pts','100 pts','300 pts'})
%
%            data = [randn(50,1);randn(50,1)+3.5]*[1 1];
%            catIdx = [ones(50,1);zeros(50,1);randi([0,1],[100,1])];
%            figure
%            plotSpread(data,'categoryIdx',catIdx,...
%                 'categoryMarkers',{'o','+'},'categoryColors',{'r','b'})
%
% END
%
% created with MATLAB ver.: 7.9.0.3470 (R2009b) on Mac OS X  Version: 10.5.7 Build: 9J61
%
% created by: jonas
% DATE: 11-Jul-2009
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

def.binWidth = 0.1;
def.spreadFcn = {'xp',[]};
def.xNames = [];
def.showMM = false;
def.xValues = [];
def.distributionIdx = [];
def.distributionColors = 'b';
def.distributionMarkers = '.';
def.xMode = 'manual';
def.xyOri = 'normal';
def.categoryIdx = [];
def.categoryColors = [];
def.categoryMarkers = '';
def.yLabel = '';
def.spreadWidth = [];

%% CHECK INPUT

% check for axes handle
if ~iscell(varargin{1}) && length(varargin{1}) == 1 && ...
        ishandle(varargin{1}) && strcmp(get(varargin{1},'Type'),'axes')
    ah = varargin{1};
    data = varargin{2};
    varargin(1:2) = [];
    newAx = false;
else
    ah = gca;
    data = varargin{1};
    varargin(1) = [];
    % if the axes have children, it's not new (important for adjusting
    % limits below)
    newAx = isempty(get(ah,'Children'));
end

% optional arguments
parserObj = inputParser;
parserObj.FunctionName = 'plotSpread';
distributionIdx = [];distributionLabels = '';
if ~isempty(varargin) && ~ischar(varargin{1}) && ~isstruct(varargin{1})
    % old syntax
    parserObj.addOptional('binWidth',def.binWidth);
    parserObj.addOptional('spreadFcn',def.spreadFcn);
    parserObj.addOptional('xNames',def.xNames);
    parserObj.addOptional('showMM',def.showMM);
    parserObj.addOptional('xValues',def.xValues);
    
    parserObj.parse(varargin{:});
    opt = parserObj.Results;
    
    opt.distributionIdx = [];
    opt.distributionColors = def.distributionColors;
    opt.distributionMarkers = def.distributionMarkers;
    opt.xMode = def.xMode;
    opt.xyOri = def.xyOri;
    opt.categoryIdx = [];
    opt.categoryColors = def.distributionColors;
    opt.categoryMarkers = def.distributionMarkers;
    opt.yLabel = '';
    opt.spreadWidth = def.spreadWidth;
    
    for fn = fieldnames(def)'
        if ~isfield(opt,fn{1})
            % Manually adding the new defaults means a lot fewer bugs
            error('please add option %s to old syntax',fn{1});
        end
        if isempty(opt.(fn{1}))
            opt.(fn{1}) = def.(fn{1});
        end
    end
    
else
    % new syntax
    defNames = fieldnames(def);
    for dn = defNames(:)'
        parserObj.addParamValue(dn{1},def.(dn{1}));
    end
    
    
    parserObj.parse(varargin{:});
    opt = parserObj.Results;
end

% We want data to be a vector, so that indexing with both groupIdx and
% distributionIdx becomes straightforward, and so that we can conveniently
% eliminate NaNs that otherwise could mess up grouping.
% Consequently, if data is a cell array, we convert it, and build a
% corresponding distributionIdx (allowing a user-supplied distributionIdx
% to override, though), and then we go and take care of groupIdx. Once all
% three indices have been built, NaN can be removed.

if iscell(data)
    % make sure data is all n-by-1
    data = cellfun(@(x)x(:),data,'UniformOutput',false);
    nData = length(data);
    nn = cellfun(@numel,data);
    % make vector
    data = cat(1,data{:});
    distributionIdx = repeatEntries((1:nData)',nn);
else
    % distributions in columns
    nData = size(data,2);
    distributionIdx = repeatEntries((1:nData)',size(data,1));
    data = data(:);
end



% distribution groups
if ~isempty(opt.distributionIdx)
    [distributionIdx,distributionLabels,vals] = grp2idx(opt.distributionIdx);
    % convert data to cell array
    nData = length(distributionLabels);
    % if not otherwise provided, use group labels for xnames
    if isempty(opt.xNames)
        opt.xNames = distributionLabels;
        if ~iscell(opt.xNames)
            opt.xNames = num2cell(opt.xNames);
        end
    end
    if isnumeric(vals) && isempty(opt.xValues)
        opt.xValues = vals;
    end
end

if ~isempty(opt.xNames)
    opt.xMode = 'manual';
end


% distribution colors&markers
if ischar(opt.distributionColors)
    opt.distributionColors = {opt.distributionColors};
end
if iscell(opt.distributionColors)
    if length(opt.distributionColors) == 1
        % expand
        opt.distributionColors = repmat(opt.distributionColors,nData,1);
    elseif length(opt.distributionColors) ~= nData
        error('please submit one color per distribution (%i dist, %i colors)',nData,length(opt.distributionColors));
    end
    
else
    if size(opt.distributionColors,2) ~= 3
        error('please specify colormap with three columns')
    end
    if size(opt.distributionColors,1) == 1
        opt.distributionColors = repmat(opt.distributionColors,nData,1);
    elseif size(opt.distributionColors,1) ~= nData
        error('please submit one color per distribution (%i dist, %i colors)',nData,size(opt.distributionColors,1));
    end
    
    % create a cell array
    opt.distributionColors = mat2cell(opt.distributionColors,ones(nData,1),3);
end

if ischar(opt.distributionMarkers)
    opt.distributionMarkers = {opt.distributionMarkers};
end
if length(opt.distributionMarkers) == 1
    % expand
    opt.distributionMarkers = repmat(opt.distributionMarkers,nData,1);
elseif length(opt.distributionMarkers) ~= nData
    error('please submit one color per distribution (%i dist, %i colors)',nData,length(opt.distributionMarkers));
end


stdWidth = 1;
if isempty(opt.xValues)
    opt.xValues = 1:nData;
end

if isempty(opt.spreadWidth) 
    % scale width
    tmp = median(diff(sort(opt.xValues)));
    if ~isnan(tmp)
        stdWidth = tmp;
    end
else
    stdWidth = opt.spreadWidth;
end

if ~ischar(opt.xyOri) || ~any(ismember(opt.xyOri,{'normal','flipped'}))
    error('option xyOri must be either ''normal'' or ''flipped'' (is ''%s'')',opt.xyOri);
end


% check for categoryIdx/colors/markers
% If there are categories, check colors/markers individually first,
% then check whether any of them at all have been supplied, and
% if not, override distributionColors with default categoryColors

if isempty(opt.categoryIdx)
    categoryIdx = ones(size(distributionIdx));
    nCategories = 1;
    categoryLabels = '';
else
    [categoryIdx,categoryLabels] = grp2idx(opt.categoryIdx(:));
    nCategories = max(categoryIdx);
end

% plotColors, plotMarkers, plotLabels: nDist-by-nCat arrays
plotColors = repmat(opt.distributionColors(:),1,nCategories);
plotMarkers= repmat(opt.distributionMarkers(:),1,nCategories);

if isempty(distributionLabels)
    distributionLabels = opt.xNames;
    if isempty(distributionLabels)
        distributionLabels = cellstr(num2str(opt.xValues(:)));
    end
end

if nCategories == 1
    plotLabels = distributionLabels(:);
else
    plotLabels = cell(nData,nCategories);
    for iData = 1:nData
        for iCategory = 1:nCategories
            plotLabels{iData,iCategory} = ...
                sprintf('%s-%s',num2str(distributionLabels{iData}),...
                num2str(categoryLabels{iCategory}));
        end
    end
    
end




categoryIsLabeled = false;
if nCategories > 1
    % if not using defaults for categoryColors: apply them
    if ~any(strcmp('categoryColors',parserObj.UsingDefaults))
        if iscell(opt.categoryColors)
            if length(opt.categoryColors) ~= nCategories
                error('please supply one category color per category')
            end
            plotColors = repmat(opt.categoryColors(:)',nData,1);
            categoryIsLabeled = true;
        else
            if all(size(opt.categoryColors) ~= [nCategories,3])
                error('please supply a #-of-categories-by-3 color array')
            end
            plotColors = repmat( mat2cell(opt.categoryColors,ones(nCategories,1),3)', nData,1);
            categoryIsLabeled = true;
        end
    end
    
    if ~any(strcmp('categoryMarkers',parserObj.UsingDefaults))
        if length(opt.categoryMarkers) ~= nCategories
            error('please supply one category marker per category')
        end
        if ~iscell(opt.categoryMarkers)
            error('please supply a list of markers as cell array')
        end
        plotMarkers = repmat(opt.categoryMarkers(:)',nData,1);
        categoryIsLabeled = true;
    end
    
    if ~categoryIsLabeled
        % use distinguishable_colors to mark categories
        
        plotColors = repmat( mat2cell(...
            distinguishable_colors(nCategories),...
            ones(nCategories,1),3)', nData,1);
        
    end
    
end


% remove NaNs from data
badData = ~isfinite(data) | ~isfinite(distributionIdx) | ~isfinite(categoryIdx);
data(badData) = [];
distributionIdx(badData) = [];
categoryIdx(badData) = [];




%% TRANSFORM DATA
% Here, I try to estimate what the aspect ratio of the data is going to be
fh = figure('Visible','off');
if ~isempty(data)
    minMax = [min(data);max(data)];
else
    minMax = [0 1];
end
switch opt.xyOri
    case 'normal'
        plot([0.5;nData+0.5],minMax,'o');
    case 'flipped'
        plot(minMax,[0.5;nData+0.5],'o');
        
end
aspectRatio = get(gca,'DataAspectRatio');
close(fh);

tFact = aspectRatio(2)/aspectRatio(1);
if strcmp(opt.xyOri,'flipped')
    tFact = 1/tFact;
end

%% SPREAD POINTS
% assign either nData, or xValues number of values, in case we're working
% with group-indices
[m,md,sem,sd] = deal(nan(max(nData,length(opt.xValues)),1));
% augment data to make n-by-2
data(:,2) = 0;
for iData = 1:nData
    currentDataIdx = distributionIdx==iData;
    currentData = data(currentDataIdx,1);
    
    if ~isempty(currentData)
        
        % transform and sort
        currentData = currentData / tFact;
        %currentData = sort(currentData);
        
        % add x
        currentData = [ones(size(currentData))*opt.xValues(iData),currentData]; %#ok<AGROW>
        
        % step through the data in 0.1 increments. If there are multiple
        % entries, spread along x
        for y = min(currentData(:,2)):opt.binWidth:max(currentData(:,2))
            % find values
            valIdx = find(currentData(:,2) >= y & currentData(:,2) < y+opt.binWidth);
            nVal = length(valIdx);
            if nVal > 1
                % spread
                switch opt.spreadFcn{1}
                    case 'xp'
                        spreadWidth = stdWidth*0.9*(1-exp(log(0.9)*(nVal-1)));
                    case 'lin'
                        spreadWidth = stdWidth*0.9*min(nVal-1,opt.spreadFcn{2})/opt.spreadFcn{2};
                end
                spreadDist = spreadWidth / (nVal - 1);
                if isEven(nVal)
                    offset = spreadDist / 2;
                else
                    offset = eps;
                end
                for v = 1:nVal
                    currentData(valIdx(v),1) = opt.xValues(iData) + offset;
                    % update offset
                    offset = offset - sign(offset) * spreadDist * v;
                end
            end
        end
        
        % update data
        currentData(:,2) = data(currentDataIdx,1);
        data(currentDataIdx,:) = currentData;
        
        if opt.showMM > 0
            m(iData) = nanmean(currentData(:,2));
            md(iData) = nanmedian(currentData(:,2));
            sd(iData) = nanstd(currentData(:,2));
            sem(iData) = sd(iData)/sqrt(sum(isfinite(currentData(:,2))));
        end
    end % test isempty
end


%% plot
set(ah,'NextPlot','add')
ph = NaN(nData,nCategories);
for iData = 1:nData
    for iCategory = 1:nCategories
        currentIdx = distributionIdx == iData & categoryIdx == iCategory;
        if any(currentIdx)
            switch opt.xyOri
                case 'normal'
                    ph(iData,iCategory) = plot(ah,data(currentIdx,1),...
                        data(currentIdx,2),...
                        'marker',plotMarkers{iData,iCategory},...
                        'color',plotColors{iData,iCategory},...
                        'lineStyle','none',...
                        'DisplayName',plotLabels{iData,iCategory});
                case 'flipped'
                    ph(iData,iCategory) = plot(ah,data(currentIdx,2),...
                        data(currentIdx,1),...
                        'marker',plotMarkers{iData,iCategory},...
                        'color',plotColors{iData,iCategory},...
                        'lineStyle','none',...
                        'DisplayName',plotLabels{iData,iCategory});
            end
        end
    end
end


% if ~empty, use xNames
switch opt.xyOri
    case 'normal'
        switch opt.xMode
            case 'manual'
                set(ah,'XTick',opt.xValues);
                if ~isempty(opt.xNames)
                    set(ah,'XTickLabel',opt.xNames)
                end
            case 'auto'
                % no need to do anything
        end
        
        % have plot start/end properly
        minX = min(opt.xValues)-stdWidth;
        maxX = max(opt.xValues)+stdWidth;
        if ~newAx
            oldLim = xlim;
            minX = min(minX,oldLim(1));
            maxX = max(maxX,oldLim(2));
        end
        xlim([minX,maxX])
        
        ylabel(ah,opt.yLabel)
        
    case 'flipped'
        switch opt.xMode
            case 'manual'
                set(ah,'YTick',opt.xValues);
                if ~isempty(opt.xNames)
                    set(ah,'YTickLabel',opt.xNames)
                end
            case 'auto'
                % no need to do anything
        end
        
        % have plot start/end properly (for ease of copying, only switch
        % xlim to ylim
        minX = min(opt.xValues)-stdWidth;
        maxX = max(opt.xValues)+stdWidth;
        if ~newAx
            oldLim = ylim;
            minX = min(minX,oldLim(1));
            maxX = max(maxX,oldLim(2));
        end
        ylim([minX,maxX])
        
        xlabel(ah,opt.yLabel);
        
end


% add mean/median
mh = [];mdh=[];
if opt.showMM
    % plot mean, median. Mean is filled red circle, median is green square
    % I don't know of a very clever way to flip xy and keep everything
    % readable, thus it'll be copy-paste
    stdW = 0.9*stdWidth/2;
    switch opt.xyOri
        case 'normal'
            if any(opt.showMM==[1,2])
                mh = plot(ah,opt.xValues,m,'+r','Color','r','MarkerSize',12);
            end
            if any(opt.showMM==[1,3])
                mdh = plot(ah,opt.xValues,md,'sg','MarkerSize',12);
            end
            if opt.showMM == 4
                mh = plot(ah,opt.xValues,m,'+r','Color','r','MarkerSize',12);
                mdh = myErrorbar(ah,opt.xValues,m,sem);
            end
            if opt.showMM == 5
                mh = plot(ah,opt.xValues,m,'+r','Color','r','MarkerSize',12);
                mdh = myErrorbar(ah,opt.xValues,m,sd);
            end
            if any(opt.showMM==[11,12])
                %mh = plot(ah,opt.xValues,m,'+r','Color','r','MarkerSize',12);
                for i = 1 : nData
                   mh = plot(ah,[opt.xValues(i)-stdW,opt.xValues(i)+stdW], ...
                             [m(i),m(i)],'Color','r','LineWidth',3);
                end
            end
            if any(opt.showMM==[11,13])
                %mdh = plot(ah,opt.xValues,md,'sg','MarkerSize',12);
                for i = 1 : nData
                   mdh = plot(ah,[opt.xValues(i)-stdW,opt.xValues(i)+stdW], ...
                              [md(i),md(i)],'Color','g','LineWidth',3);
                end
            end
        case 'flipped'
            if any(opt.showMM==[1,2])
                mh = plot(ah,m,opt.xValues,'+r','Color','r','MarkerSize',12);
            end
            if any(opt.showMM==[1,3])
                mdh = plot(ah,md,opt.xValues,'sg','MarkerSize',12);
            end
            if opt.showMM == 4
                mh = plot(ah,m,opt.xValues,'+r','Color','r','MarkerSize',12);
                mdh = myErrorbar(ah,m,opt.xValues,[sem,NaN(size(sem))]);
            end
            if opt.showMM == 5
                mh = plot(ah,m,opt.xValues,'+r','Color','r','MarkerSize',12);
                mdh = myErrorbar(ah,m,opt.xValues,[sd,NaN(size(sd))]);
            end
    end
end

%==========================
%% CLEANUP & ASSIGN OUTPUT
%==========================

if nargout > 0
    handles{1} = ph;
    handles{2} = [mh;mdh];
    handles{3} = ah;
end


./MATLAB/+smi/@SMLM/gui.m
function gui(obj)
%gui generates a GUI to facilitate use of the SMLM class.
% This method generates a GUI which allows the user to load single-molecule
% localization microscopy data, set parameters through the
% SingleMoleculeFitting class, and generate results.

% Created by:
%   David J. Schodt (Lidke lab, 2020)


% Create a figure for the GUI.
DefaultFigurePosition = get(0, 'defaultFigurePosition');
FigureXYSize = [DefaultFigurePosition(3), 600];
GUIFigure = figure('MenuBar', 'none', ...
    'Name', 'SMLM Interface', 'NumberTitle', 'off', ...
    'Units', 'pixels' , ...
    'Position', [DefaultFigurePosition(1), 0, FigureXYSize]);

% Add some panels to help organize the GUI.
SMFPanel = uipanel(GUIFigure, 'Title', 'Fitting parameters', ...
    'Units', 'normalized', 'Position', [0, 0.3, 1, 0.7]);
ControlPanel = uipanel(GUIFigure, 'Title', 'Controls', ...
    'Units', 'normalized', 'Position', [0, 0, 1, 0.3]);

% Stick the SingleMoleculeFitting GUI inside of the SMFPanel.
obj.SMF.gui(SMFPanel)

% Add some controls to the ControlPanel.
% NOTE: To anyone adding to this, I'm trying to follow the convention
%       that the uicontrol handles have their type appended to the end
%       of the name, e.g., a pushbutton might be called 'TestFitPushbutton'
%       or 'TestFitButton'.  This is one of those things that is only
%       useful if all handles adhere to the convention!
TextSize = [0, 0, 0.2, 0.2];
EditSize = [0, 0, 0.1, 0.2];
ButtonSize = [0, 0, 0.2, 0.2];
ControlHandles.FullFitButton = uicontrol(ControlPanel, ...
    'Style', 'pushbutton', 'String', 'Full fit', ...
    'FontUnits', 'normalized', 'FontSize', 0.4, ...
    'Units', 'normalized', ...
    'Position', ButtonSize, 'callback', @runFullFit);
ControlHandles.TestFitButton = uicontrol(ControlPanel, ...
    'Style', 'pushbutton', 'String', 'Test fit', ...
    'FontUnits', 'normalized', 'FontSize', 0.4, ...
    'Units', 'normalized', ...
    'Position', ButtonSize + [0, ButtonSize(4), 0, 0], ...
    'callback', @runTestFit);
DatasetNumberTip = ...
    'Dataset number to be analyzed when you click ''Test fit''';
uicontrol(ControlPanel, ...
    'Style', 'text', 'String', 'Dataset number:', ...
    'FontUnits', 'normalized', 'FontSize', 0.4, ...
    'Units', 'normalized', ...
    'Position', TextSize + [0, 2*ButtonSize(4), 0, 0], ...
    'Tooltip', DatasetNumberTip);
ControlHandles.DatasetNumberEdit = uicontrol(ControlPanel, ...
    'Style', 'edit', 'String', '1', ...
    'FontUnits', 'normalized', 'FontSize', 0.4, ...
    'Units', 'normalized', ...
    'Position', EditSize + [TextSize(3), 2*ButtonSize(4), 0, 0], ...
    'Tooltip', DatasetNumberTip);


    function runTestFit(~,~)
        DatasetID=str2num(ControlHandles.DatasetNumberEdit.String);
        obj.CalledByGUI = true;
        obj.testFit(DatasetID);  
    end

    function runFullFit(~,~)
        obj.CalledByGUI = true;
        obj.fullAnalysis();  
    end


end

./MATLAB/+smi/@SMLM/unitTest.m
function Success = unitTest()
%unitTest Tests all functionality of smi.SMLM .
%
% OUTPUTS:
%   Success:    Flags indicating which tests passed (1 - yes, 0 - no)
%
% REQUIRES:
%   Statistics Toolbox
%   Parallel Procesing Toolbox
%   NVidia GPU

%% ----------------------------------------------------------------------------

% start unitTest
Success(1) = 1;
fprintf(['Running smi.SMLM.unitTest.\n', ...
         'Testing all smi.SMLM functionality.\n']);

% Test loading various datatypes.
fprintf('Testing loading of various datatypes.\n')

saveName = 'SMLM_testData';

SaveDir = smi_helpers.mkSMITETmpDir('unitTest', 'SMLM');
mkdir(fullfile(SaveDir, saveName));

file1 = [saveName, '1.mat'];
file2 = [saveName, '2.mat'];

% Create SMF structure.
SMF = smi_core.SingleMoleculeFitting();
SMF.Data.FileDir      = SaveDir;
SMF.Data.DataVariable = 'Data';
SMF.Data.CameraType   = 'EMCCD';
SMF.Data.CameraGain   = 1;
SMF.Data.CameraOffset = 0;
%SMF.Fitting.FitType   = 'XYNB';
%SMF.ROISearchType     = 'Flat';

% Simulate two small datasets.
fprintf('Simulating data.\n')
SimData1 = smi_sim.GaussBlobs.genRandomBlobImage(64, 250);
SimData2 = smi_sim.GaussBlobs.genRandomBlobImage(64, 250);

% Save datasets as mat files.
fprintf('Saving data as mat files.\n')
Data = SimData1;
save(fullfile(SaveDir, file1), 'Data');
Data = SimData2;
save(fullfile(SaveDir, file2), 'Data');

% Try running smi.SMLM.  If it fails, delete files before returning error.
fprintf(['Loading and analyzing data saved as mat files.\n', ...
         '   (Only doing box finding and fitting.)\n']);
% Update SMF object.
SMF.Data.FileName = {file1, file2};
% Create smi.SMLM object.
%SMLMobj = smi.SMLM('nogui');
SMLMobj = smi.SMLM(SMF);
try
    % Analyze all datasets.
    SMLMobj.analyzeAll();
    clear SMLMobj
catch ME
    delete(fullfile(SaveDir, [saveName, '*.*']));
    fprintf('Caught following error during smi.SMLM.unitTest:\n')
    disp(ME.identifier);
    disp(ME.message);
    Success(1) = 0;
end
fprintf('Loading and analyzing data saved as mat file done.\n');
delete(fullfile(SaveDir, [saveName, '*.*']));

%% ----------------------------------------------------------------------------

Success(2) = 1;
% Save datasets as h5 files.
fprintf('\nSaving data as h5 files.\n')
h5create(fullfile(SaveDir,[saveName '.h5']),'/Data/Channel01/Data0001',size(SimData1));
h5write(fullfile(SaveDir,[saveName '.h5']),'/Data/Channel01/Data0001',SimData1);
h5create(fullfile(SaveDir,[saveName '.h5']),'/Data/Channel01/Data0002',size(SimData2));
h5write(fullfile(SaveDir,[saveName '.h5']),'/Data/Channel01/Data0002',SimData2);
% Try running smi.SMLM.  If it fails, delete files before returning error,
fprintf(['Loading and analyzing data saved as h5 files.\n', ...
         '   (Only doing box finding and fitting.)\n']);
% Create SMF structure.
SMF = smi_core.SingleMoleculeFitting();
SMF.Data.FileDir      = SaveDir;
SMF.Data.FileName     = {[saveName '.h5']};
SMF.Data.CameraType   = 'EMCCD';
SMF.Data.CameraGain   = 1;
SMF.Data.CameraOffset = 0;
SMF.Data.FileName = {[saveName, '.h5']};
%SMF.RawImageSize = [size(SimData1,1),size(SimData1,2)];
% Create smi.SMLM object.
SMLMobj = smi.SMLM(SMF);
try
    % Analyze all datasets.
    SMLMobj.analyzeAll();
    clear SMLMobj
catch ME
    delete(fullfile(SaveDir, [saveName '.*']));
    fprintf('Caught following error during smi.SMLM.unitTest:\n')
    disp(ME.identifier)
    disp(ME.message);
    Success(2) = 0;
end
fprintf('Loading and analyzing data saved as h5 file done.\n');
delete(fullfile(SaveDir, [saveName, '.*']));

%% ----------------------------------------------------------------------------

Success(3) = 1;
% Simulate and save realistic SMLM data.
fprintf('\nSimulating realistic 2D SMLM data\n');

SimData1 = smi_sim.GaussBlobs.genRandomBlobImage(256, 1000);
SimData2 = smi_sim.GaussBlobs.genRandomBlobImage(256, 1000);
fprintf('Saving realistic SMSR data.\n');
saveName = 'SMLM_testData';
h5create(fullfile(SaveDir,[saveName '.h5']),'/Data/Channel01/Data0001',size(SimData1));
h5write(fullfile(SaveDir,[saveName '.h5']),'/Data/Channel01/Data0001',SimData1);
h5create(fullfile(SaveDir,[saveName '.h5']),'/Data/Channel01/Data0002',size(SimData2));
h5write(fullfile(SaveDir,[saveName '.h5']),'/Data/Channel01/Data0002',SimData2);

% Test complete data flow
fprintf('Testing 2D analysis.\n');
% Create SMF structure.
SMF = smi_core.SingleMoleculeFitting();
% Cannot save in folders inside SaveDir, so everything must be saved in SaveDir
% directly.
SMF.Data.FileDir          = SaveDir;
SMF.Data.FileName         = {[saveName, '.h5']};
SMF.Data.ResultsDir       = SaveDir;
SMF.Data.CameraType       = 'EMCCD';
SMF.Data.CameraGain       = 1;
SMF.Data.CameraOffset     = 0;
SMF.Thresholding.On       = true;
SMF.Thresholding.MaxSE_XY = 0.1;
SMF.FrameConnection.On    = true;
SMF.DriftCorrection.On    = true;
%SMF.RawImageSize = [size(SimData1,1),size(SimData1,2)];
fprintf('-> ResultsDir = %s\n', SMF.Data.ResultsDir);
% Create smi.SMLM object.
%SMLMobj = smi.SMLM('nogui');
SMLMobj = smi.SMLM(SMF);
try
   % fullFit: fitting -> thresholding -> frame connection -> drift correction
   SMLMobj.fullAnalysis();
   fprintf('Files produced in %s:\n', SMF.Data.ResultsDir);
   dir(fullfile(SMF.Data.ResultsDir, [saveName, '*.*']))
%  % generate color overlay
%  fprintf('Generating color overlay.\n');
%  %SMLMobj.SMD.FitBoxSize = SMLMobj.BoxSize;   % needed for genBlobOverlay
%  %SMLMobj.SMR.FitBoxSize = SMLMobj.BoxSize;   % needed for genBlobOverlay
%  DatasetNum = 1;
%  SMLMobj.genBlobOverlay(DatasetNum);
%  % save
%  SMLMobj.save();
%  SMLMobj.saveResults();
%  SMLMobj.exportFileType='Excel';
%  SMLMobj.exportResults();
%  SMLMobj.exportFileType='txt';
%  SMLMobj.exportResults();
catch ME
   delete(fullfile(SaveDir, saveName, '*.*'));
   rmdir(fullfile(SaveDir, saveName));
   delete(fullfile(SaveDir, [saveName, '*.*']));
   fprintf('Caught following error during smi.SMLM.unitTest:\n')
   disp(ME.identifier)
   disp(ME.message);
   Success(3) = 0;
end
% delete object and data
%clear SMLMobj
%delete(fullfile(SaveDir, saveName, '*.*'));
%rmdir(fullfile(SaveDir, saveName));
%delete(fullfile(SaveDir, [saveName, '*.*']));
fprintf('Done.\n');

./MATLAB/+smi/@SMLM/fitsPerFrame.m
function FitFrame = fitsPerFrame(SMD, DatasetIndex)
%fitsPerFrame finds the fits per frame for the localizations in the given SMD
% structure.
%
% INPUTS:
%    SMD            SMD structure
%    DatasetIndex   dataset index for fits per frame for a single dataset 
%
% OUTPUTS:
%    FitFrame       fits per frame discovered for this/these dataset/s

   Nloc_frame = [];
   FitFrame = [];
   % Number of localizations per frame
   if ~exist('DatasetIndex', 'var')
       range = 1:max(SMD.DatasetNum);
   else
       range = DatasetIndex;
   end
   for jj=range
       for ii=1:SMD.NFrames
           idx=find(SMD.FrameNum==ii & SMD.DatasetNum==jj);
           Nloc_frame{jj}(ii)=length(idx);
       end
   end
   if ~isempty(Nloc_frame)
       FitFrame = Nloc_frame{1};
       for ii=2:length(Nloc_frame)
           FitFrame=cat(2, FitFrame, Nloc_frame{ii});
       end
   end

end

./MATLAB/+smi/@SMLM/generatePlots.m
function generatePlots(obj, PlotSaveDir1, PlotSaveDir2, AnalysisID, ...
                            ShowPlots, PlotDo)
%generatePlots creates all histograms and plots for an SMD structure.
%
% INPUT:
%    obj          SMLM object
%       obj.SMD      Single Molecule Data structure
%       obj.SMF      Single Molecule Fitting structure
%       obj.SRImageZoom    magnification factor for SR     images
%       obj.SRCircImZoom   magnification factor for circle images
%    PlotSaveDir1 Directory in which to save especially useful (priority 1)
%                 plots, like GaussIm
%    PlotSaveDir2 Directory in which to save all the other (priority 2) plots
%                 (typically, a subdirectory of PlotSaveDir1)
%    AnalysisID   Analysis ID, if non-empty, to add to the filenames generated
%    ShowPlots:   Flag for showing plots on the screen (Default = false)
%    PlotDo:      Plots to make chosen from the following list:
%                 "Photons"    intensity (estimated photons) histogram
%                 "Bg"         background intensity histogram
%                 "PSFSigma"   sigma of 2D Gaussian PSF model histogram
%                 "PValue"     P-value of fit histogram
%                 "X_SE"       standard error in estimated X position histogram
%                 "Y_SE"       standard error in estimated Y position histogram
%                 "Z_SE"       standard error in estimated Z position histogram
%                 "NCombined"  number of connection localizations histogram
%                 "DriftX"     cumulative x-drift
%                 "DriftY"     cumulative y-drift
%                 "DriftZ"     cumulative z-drift
%                 "CumDrift"   estimated 2D or 3D cumulative drift
%                 "Drift"      estimated 2D or 3D absolute drift
%                 "FitFrame"   number of fits per frame
%                 "DriftIm"    2D drift image from SR data
%                 "GaussIm"    2D Gaussian blob image from SR data
%                 "HistIm"     2D histogram image from SR data
%                 "CircleIm"   2D Circle image from SR data
%                 "CircleImDrift" 2D circle image color coded by time
%                 (Default is to make all plots)
%                 For example, PlotDo = ["PValue", "FitFrame", "DriftIm"]
%                 NOTE: plots will only be produced if there is corresponding
%                      data in the SMD structure!
%
% OUTPUT:
%    The figures are saved in .png format in PlotSaveDir1/2.

% Created by:
%    Hanieh Mazloom-Farsibaf, Marjolein Meddens Apr 2017 (Keith A. Lidke's lab)
%    Michael J Wester (2020)

if obj.Verbose >= 1
   fprintf('Generating output plots ...\n');
end

if ~exist('ShowPlots', 'var')
   ShowPlots = false;
end

if ~exist('PlotDo', 'var') || isempty(PlotDo)
   % Removed: DriftX, DriftY, DritfZ, HistIm
   PlotDo = ["Photons", "Bg", "PSFSigma", "PValue", "X_SE", "Y_SE", "Z_SE", ...
             "NCombined", "CumDrift", "Drift", "FitFrame", "DriftIm",       ...
             "GaussIm", "CircleIm", "CircleImDrift"];
end

SMD = obj.SMD;

if isempty(SMD.X)
   fprintf('No localization data to plot!\n');
   return;
end

if ~isempty(AnalysisID)
   ID = ['_', AnalysisID];
else
   ID = '';
end
% BaseName is used to label plot files.
[~, BaseName, ~] = fileparts(obj.SMF.Data.FileName{1});
BaseName = [BaseName, ID];

if ismember("Photons", PlotDo)
   %create Photons histogram
   plotAndSaveHist('Photons','Intensity')
end

if ismember("Bg", PlotDo)
   %create Bg histogram
   plotAndSaveHist('Bg','Background')
end

if ismember("PSFSigma", PlotDo)
   % Estimated or Fixed Sigma of 2D Gaussian PSF Model (symmetric PSF)
   plotAndSaveHist('PSFSigma','PSFSigma')
end

if ismember("PValue", PlotDo)
   %create PValue histogram
   %plotAndSaveHist('PValue','P value')
   plotAndSavePValueHist('PValue','P value')
end

if ismember("X_SE", PlotDo)
   %create X_SE histogram
   plotAndSaveHist('X_SE','X std error')
end

if ismember("Y_SE", PlotDo)
   %create Y_SE histogram
   plotAndSaveHist('Y_SE','Y std error')
end

if ismember("Z_SE", PlotDo)
   %create Z_SE histogram
   plotAndSaveHist('Z_SE','Z std error')
end

if ismember("NCombined", PlotDo)
   %create Number of Connected localization histogram
   plotAndSaveNCombinedHist('NCombined','Connected emitters')
end

%cumulative of DriftX, DriftY {, DriftZ} and total drift
if isfield(SMD,'DriftX') && ~isempty(SMD.DriftX) && ...
   isfield(SMD,'DriftY') && ~isempty(SMD.DriftY)
   if ismember("DriftX", PlotDo)
      plotAndSaveCum('DriftX','DriftX')
   end
   if ismember("DriftY", PlotDo)
      plotAndSaveCum('DriftY','DriftY')
   end
   if isfield(SMD,'DriftZ') && ~isempty(SMD.DriftZ) && ismember("DriftZ",PlotDo)
      plotAndSaveCum('DriftZ','DriftZ')
   end 

   % Estimated 2D or 3D cumulative drift
   if ismember("CumDrift", PlotDo)
      DC = smi_core.DriftCorrection;
      DC.PixelSizeZUnit = obj.SMF.DriftCorrection.PixelSizeZUnit;
      figDC = DC.plotDriftCorrection(SMD, 'R');
      if ~isempty(PlotSaveDir2)
         FileName = [BaseName '_CumDriftCorrection'];
         saveas(gcf, fullfile(PlotSaveDir2, FileName), 'png');
      end
      if ~ShowPlots; close(gcf); end
   end

   % Estimated 2D or 3D drift
   if ismember("Drift", PlotDo)
      DC = smi_core.DriftCorrection;
      DC.PixelSizeZUnit = obj.SMF.DriftCorrection.PixelSizeZUnit;
      figDC = DC.plotDriftCorrection(SMD, 'A');
      if ~isempty(PlotSaveDir2)
         FileName = [BaseName '_DriftCorrection'];
         saveas(gcf, fullfile(PlotSaveDir2, FileName), 'png');
      end
      if ~ShowPlots; close(gcf); end
   end
end

if ismember("FitFrame", PlotDo)
   FitFrame = smi.SMLM.fitsPerFrame(SMD);
   Frames=1:length(FitFrame);

   FitFramePreFC = [];
   for i = 1 : obj.SMD.NDatasets
      if ~isempty(obj.FitFramePreFC{i})
         FitFramePreFC = [FitFramePreFC, obj.FitFramePreFC{i}];
      end
   end  
   FramesPreFC=1:length(FitFramePreFC);

   % plot fits per frame
   figure;

   subplot(2, 1, 1);
   plot(FramesPreFC,FitFramePreFC);
   xlabel('Frames');
   ylabel('Number of Fits');
   title('Fits per frame (pre-frame connection)');

   subplot(2, 1, 2);
   plot(Frames,FitFrame);
   xlabel('Frames');
   ylabel('Number of Fits');
   title('Fits per frame (post-frame connection)');

   if ~isempty(PlotSaveDir2)
      FileName = [BaseName '_FitsPerFrame.png'];
      saveas(gcf, fullfile(PlotSaveDir2, FileName), 'png');
   end

   if ~ShowPlots; close(gcf); end
end

if ismember("DriftIm", PlotDo)
   % Drift image
   [~, DriftImRGB] = smi_vis.GenerateImages.driftImage(SMD, obj.SRImageZoom);
   if ~isempty(PlotSaveDir2)
      FileName = [BaseName, '_DriftImage.png'];
      imwrite(single(DriftImRGB), fullfile(PlotSaveDir2, FileName))
   end
   if ShowPlots
      DriftImFigure = figure();
      DriftImAxes = axes(DriftImFigure);
      imshow(DriftImRGB, [], 'Parent', DriftImAxes)
   end
end

if ismember("GaussIm", PlotDo)
   % Gaussian image
   [GaussIm] = smi_vis.GenerateImages.gaussianImage(SMD, obj.SRImageZoom);
   if ~isempty(PlotSaveDir1)
      FileName = [BaseName, '_GaussImage.png'];
      imwrite(GaussIm, fullfile(PlotSaveDir1, FileName))
   end
   if ~isempty(PlotSaveDir2)
      FileName = [BaseName, '_GaussImage.png'];
      imwrite(GaussIm, fullfile(PlotSaveDir2, FileName))
   end
   if ShowPlots
      GaussImFigure = figure();
      GaussImAxes = axes(GaussImFigure);
      imshow(GaussIm, [], 'Parent', GaussImAxes)
   end
end

if ismember("HistIm", PlotDo)
   % Histogram image
   [HistIm] = smi_vis.GenerateImages.histogramImage(SMD, obj.SRImageZoom);
   if ~isempty(PlotSaveDir2)
      FileName = [BaseName, '_HistImage.png'];
      imwrite(single(HistIm), fullfile(PlotSaveDir2, FileName))
   end
   if ShowPlots
      HistImFigure = figure();
      HistImAxes = axes(HistImFigure);
      imshow(HistIm, [], 'Parent', HistImAxes)
   end
end

if ismember("CircleIm", PlotDo)
   % Generate a circle image.
   [~, CircleImageRGB] = smi_vis.GenerateImages.circleImage(...
      SMD, [], obj.SRCircImZoom);
   if ~isempty(PlotSaveDir2)
      FileName = [BaseName, '_CircleImage.png'];
      imwrite(CircleImageRGB, fullfile(PlotSaveDir2, FileName))
   end
   if ShowPlots
      CircleImFigure = figure();
      CircleImAxes = axes(CircleImFigure);
      imshow(CircleImageRGB, [], 'Parent', CircleImAxes)
   end
end

if ismember("CircleImDrift", PlotDo)
    % Generate a circle image.
    ColorMap = parula(SMD.NFrames * SMD.NDatasets);
    [~, CircleImageRGB] = smi_vis.GenerateImages.circleImage(...
        SMD, ColorMap(SMD.NFrames*(SMD.DatasetNum-1) + SMD.FrameNum, :), ...
        obj.SRCircImZoom);
    if ~isempty(PlotSaveDir2)
       FileName = [BaseName, '_CircleImageDrift.png'];
       imwrite(CircleImageRGB, fullfile(PlotSaveDir2, FileName))
   end
    if ShowPlots
        CircleImDriftFigure = figure();
        CircleImDriftAxes = axes(CircleImDriftFigure);
        imshow(CircleImageRGB, [], 'Parent', CircleImDriftAxes)
    end
end

    % nested function for plotting and saving histograms
    function plotAndSaveHist(FieldName,HistName)
       if isfield(SMD,FieldName) && ~isempty(SMD.(FieldName)) ...
                                 && ~isscalar(SMD.(FieldName))
          Vector_in=SMD.(FieldName);
          FigH = smi_vis.GenerateImages.plotHistogram(Vector_in,HistName);
          [~,BaseName,~] = fileparts(obj.SMF.Data.FileName{1});
          BaseName = [BaseName, ID];
          if ~isempty(PlotSaveDir2)
             FileName = [BaseName '_' regexprep(HistName,' ','_') '_Hist.png'];
             saveas(FigH,(fullfile(PlotSaveDir2,FileName)),'png');
          end
          if ~ShowPlots; close(gcf); end
       end
    end

    % nested function for plotting and saving the NCombined histogram
    function plotAndSaveNCombinedHist(FieldName,HistName)
       if isfield(SMD,FieldName) && ~isempty(SMD.(FieldName)) ...
                                 && ~isscalar(SMD.(FieldName))
          Vector_in=SMD.(FieldName);
          %FigH = smi_vis.GenerateImages.plotHistogram(Vector_in,HistName);
          FigH=figure;
          hold on
          h = histogram(Vector_in);
          xlabel(sprintf('%s', HistName));
          ylabel('Frequency');
          title(sprintf('Histogram of %s', HistName));
          hold off

          [~,BaseName,~] = fileparts(obj.SMF.Data.FileName{1});
          BaseName = [BaseName, ID];
          if ~isempty(PlotSaveDir2)
             FileName = [BaseName '_' regexprep(HistName,' ','_') '_Hist.png'];
             saveas(FigH,(fullfile(PlotSaveDir2,FileName)),'png');
          end
          if ~ShowPlots; close(gcf); end
       end
    end

    % nested function for plotting and saving the PValue histogram, which is
    % plotted specially with log axes.
    function plotAndSavePValueHist(FieldName,HistName)
       if isfield(SMD,FieldName) && ~isempty(SMD.(FieldName)) ...
                                 && ~isscalar(SMD.(FieldName))
          Vector_in=SMD.(FieldName);
          % Convert data values near zero to slightly larger values so that
          % they show up in the histogram plot below.
          %Vector_in(Vector_in <= 0.001) = 0.001;
          FigH = smi_vis.GenerateImages.plotHistogram(Vector_in,HistName);
          %set(gca, 'xscale', 'log');
          set(gca, 'yscale', 'log');
          xlim([0, 1]);

          [~,BaseName,~] = fileparts(obj.SMF.Data.FileName{1});
          BaseName = [BaseName, ID];
          if ~isempty(PlotSaveDir2)
             FileName = [BaseName '_' regexprep(HistName,' ','_') '_Hist.png'];
             saveas(FigH,(fullfile(PlotSaveDir2,FileName)),'png');
          end
          if ~ShowPlots; close(gcf); end
       end
    end

    % nested function for plotting and saving cumulative Drift
    function plotAndSaveCum(FieldName,CumName)
       if isfield(SMD,FieldName) && ~isempty(SMD.(FieldName))
          FigH = smi_core.DriftCorrection.plotCumDrift(SMD,FieldName);
          [~,BaseName,~] = fileparts(obj.SMF.Data.FileName{1});
          BaseName = [BaseName, ID];
          if ~isempty(PlotSaveDir2)
             FileName = [BaseName '_' CumName '_Cum.png'];
             saveas(FigH,(fullfile(PlotSaveDir2,FileName)),'png');
          end
          if ~ShowPlots; close(gcf); end
       end
    end

end

./MATLAB/+smi/@SMLM/README.md
### +smi/@SMLM

Single Molecule Localization Microscopy Analysis

This is a high-level class that provides complete analysis of SMLM data.
fullAnalysis/testFit performs an analysis on all/a selected dataset(s).
These routines require a Single Molecule Fitting (SMF) structure describing
the data and defining the analysis parameters.  This structure is either
produced earlier and fed into SMLM or it is created interactively when SMLM
is invoked.  The output is a Results.mat file holding the SMF and Single
Molecule Data (SMD) structures, the latter containing the processed data.  In
addition, various plots describing the processed data are created and placed
in a directory under Results/ identifying the dataset.  This identification is
derived from the original dataset's name, optionally with an analysis ID
appended.  See generatePlots (below) for more details on the plots produced.

---

```
properties:
    SMDPreThresh      % Keeps track of why localizations were filtered out
    SMD               % SMD structure with final analysis results
    SMF               % Single Molecule Fitting structure
    FitFramePreFC     % Fits per frame pre-frame connection
    PlotDo = []       % Plots to generate (all by default);see generatePlots comments
    SRImageZoom  = 20 % magnification factor for SR     images generated
    SRCircImZoom = 25 % magnification factor for circle images generated
    Verbose = 1       % Verbosity level
    VerboseTest = 3   % Verbosity level for testFits
    FullvsTest        % Logical value set by fullAnalysis or testFit to tell
                      % saveResults to make the proper call to generatePlots
    CalledByGUI=false % Keeps track of how fitting is called
```

---

**analyzeAll** loops over a list of datasets and creates an SMD.
If DatasetList not provided, use obj.SMD.Data.DatasetList .

**analyzeAll** flow:

```
analyzeAll:
   for n = DatasetList      (iterate over each dataset)
      analyzeDataset:
         LoadData           (load raw data [ADU] from the camera)
         DataToPhotons      (gain and offset corrections to convert to photons)
         LocalizeData       (produce localizations and put into SMD structure)
            Threshold       (threshold localizations generated)
         SingleMoleculeData (concatenate SMD into structure "SMDPreThresh")
         FrameConnection    (frame connection)
         DriftCorrection    (intra-dataset drift correction)
      SingleMoleculeData    (concatenate SMD into structure "SMD")
   end
   DriftCorrection (inter-dataset drift correction)
   Threshold       (produce statistics for rejected localizations)
```

---

**generatePlots** creates all histograms and plots for an SMD structure.

```
INPUT:
   obj          SMLM object
      obj.SMD      Single Molecule Data structure
      obj.SMF      Single Molecule Fitting structure
      obj.SRImageZoom    magnification factor for SR     images
      obj.SRCircImZoom   magnification factor for circle images
   PlotSaveDir1 Directory in which to save especially useful (priority 1)
                plots, like GaussIm
   PlotSaveDir2 Directory in which to save all the other (priority 2) plots
                (typically, a subdirectory of PlotSaveDir1)
   AnalysisID   Analysis ID, if non-empty, to add to the filenames generated
   ShowPlots:   Flag for showing plots on the screen (Default = false)
   PlotDo:      Plots to make chosen from the following list:
                "Photons"    intensity (estimated photons) histogram
                "Bg"         background intensity histogram
                "PSFSigma"   sigma of 2D Gaussian PSF model histogram
                "PValue"     P-value of fit histogram
                "X_SE"       standard error in estimated X position histogram
                "Y_SE"       standard error in estimated Y position histogram
                "Z_SE"       standard error in estimated Z position histogram
                "NCombined"  number of connection localizations histogram
                "DriftX"     cumulative x-drift
                "DriftY"     cumulative y-drift
                "DriftZ"     cumulative z-drift
                "CumDrift"   estimated 2D or 3D cumulative drift
                "Drift"      estimated 2D or 3D absolute drift
                "FitFrame"   number of fits per frame
                "DriftIm"    2D drift image from SR data
                "GaussIm"    2D Gaussian blob image from SR data
                "HistIm"     2D histogram image from SR data
                "CircleIm"   2D Circle image from SR data
                "CircleImDrift" 2D circle image color coded by time
                (Default is to make all plots)
                For example, PlotDo = ["PValue", "FitFrame", "DriftIm"]
                NOTE: plots will only be produced if there is corresponding
                     data in the SMD structure!

OUTPUT:
   The figures are saved in .png format in PlotSaveDir1/2.
```

---

methods:
- **[SMLM](SMLM.m)**:
  Create an SMLM object
- **[fullAnalysis](SMLM.m)**:
  analyzes all data, saves results and plots
- **[testFit](SMLM.m)**:
  performs detailed analysis and feedback of one dataset
- **[analyzeAll](SMLM.m)**:
  loops over a list of datasets and creates an SMD
- **[analyzeDataset](SMLM.m)**:
  loads and analyzes one dataset
- **[createDirectories](SMLM.m)**:
  creates directories for saving results in throughout the calculations
- **[saveResults](SMLM.m)**:
  saves all results and plots in subfolder.  Flow:  
  (1) Save SMD and SMF structures  
  (2) generatePlots (plots saved for fullAnalysis, displayed for testFit)

- **[fitsPerFrame](fitsPerFrame.m)**:
  finds the fits per frame for the localizations in the given SMD structure
- **[generatePlots](generatePlots.m)**:
  creates all histograms and plots for an SMD structure (see above)
- **[gui](gui.m)**:
  generates a GUI to facilitate use of the SMLM class
- **[unitTest](unitTest.m)**:
  Tests all functionality of smi.SMLM

./MATLAB/+smi/@SMLM/SMLM.m
classdef SMLM < handle
% Single Molecule Localization Microscopy Analysis
%
% This is a high-level class that provides complete analysis of SMLM data.
% fullAnalysis/testFit performs an analysis on all/a selected dataset(s).
% These routines require a Single Molecule Fitting (SMF) structure describing
% the data and defining the analysis parameters.  This structure is either
% produced earlier and fed into SMLM or it is created interactively when SMLM
% is invoked.  The output is a Results.mat file holding the SMF and Single
% Molecule Data (SMD) structures, the latter containing the processed data.  In
% addition, various plots describing the processed data are created and placed
% in a directory under Results identifying the dataset.  This identification is
% derived from the original dataset's name, optionally with an analysis ID
% appended.  See generatePlots for more details on the plots produced.

% =========================================================================
properties
    SMDPreThresh      % Keeps track of why localizations were filtered out
    SMD               % SMD structure with final analysis results
    SMF               % Single Molecule Fitting structure
    FitFramePreFC     % Fits per frame pre-frame connection
    PlotDo = [] % Plots to generate (all by default);see generatePlots comments
    SRImageZoom  = 20 % magnification factor for SR     images generated
    SRCircImZoom = 25 % magnification factor for circle images generated
    Verbose = 1       % Verbosity level
    VerboseTest = 3   % Verbosity level for testFits
    FullvsTest        % Logical value set by fullAnalysis or testFit to tell
                      % saveResults to make the proper call to generatePlots
    CalledByGUI=false % Keeps track of how fitting is called
end
% =========================================================================

% =========================================================================
properties (Hidden)
    DC                % DriftCorrection class object used internally
    DCMethod          % Drift correction method (DC-KNN or DC-BF)
    % NOTE: DC-BF should only be used for the sequential microscope!
    % The below are used by brightfield drift correction:
    RefImage          % Ref image to which all datasets will be corrected to
    PreSeqImages
    PostSeqImages
    ParamStruct       % Structure of parameters sent to smi_stat.findOffsetIter

    % Top level results directory: A few special results/plots (like GaussIm)
    % are saved here.  Default value is obj.SMF.Data.ResultsDir set in
    % createDirectories.  The rest of the results/plots are saved in
    % ResultsSubDir which will be a subdirectory of ResultsDir; its name will
    % be derived from the dataset name and analysis ID.
    ResultsDir = []   % This is set from SMF.Data.ResultsDir
    ResultsSubDir = []
    ShowPlots         % Show plots interactively as when doing a testFit
end % properties (Hidden)
% =========================================================================

% =========================================================================
methods

    function obj=SMLM(SMF,StartGUI)
        %SMLM Create an SMLM object
        %
        % INPUTS:
        %   SMF: Single Molecule Fitting Structure (Optional)
        %   StartGUI:   Automatically open the GUI (0 or 1)
        %
        % OUTPUT:
        %   SMLMobj: SMLM object. Autogenerated if nargout==0
        %
        %   If no inputs are given, a GUI is opened by default

        switch nargin
            case 0
                obj.SMF=smi_core.SingleMoleculeFitting();
                StartGUI=1;
            case 1
                obj.SMF = SMF;
                StartGUI=0;
            case 2
                obj.SMF = SMF;
        end

        %Autonaming
        if nargout==0 % No name has been given
            varname = 'SMLMobj'; % try using SR
            if exist(varname,'var') %if that fails try SR1,SR2, ...
                n=1;
                s=sprintf('%s%d',varname,n);
                while exist(s,'var')
                    s=sprintf('%s%d',varname,n);
                    n=n+1;
                end
                assignin('base',s,obj);
            else
                assignin('base',varname,obj);
            end
        end

        if StartGUI
            obj.gui();
        end

    end

    % ---------------------------------------------------------------------

    function fullAnalysis(obj)
        % fullAnalysis analyzes all data, saves results and plots.

        obj.FullvsTest = true;
        if isempty(obj.SMF.Data.DatasetList)
           obj.analyzeAll();
        else
           obj.analyzeAll(obj.SMF.Data.DatasetList);
        end
        obj.saveResults();

        if obj.Verbose >= 1
            fprintf('Done fullAnalysis.\n');
        end

    end

    % ---------------------------------------------------------------------

    function testFit(obj, DatasetIndex)
        % testFit performs detailed analysis and feedback of one dataset.
        
        obj.FullvsTest = false;
        obj.analyzeAll(DatasetIndex);
        obj.saveResults();
        
        if obj.Verbose >= 1
            fprintf('Done testFit.\n');
        end

    end

    % ---------------------------------------------------------------------

    function analyzeAll(obj, DatasetList)
        % analyzeAll loops over a list of datasets and creates an SMD.
        % If DatasetList not provided, use obj.SMD.Data.DatasetList .
        % analyzeAll flow:
        %
        % analyzeAll:
        %    for n = DatasetList
        %       analyzeDataset:
        %          LoadData           (load raw data)
        %          DataToPhotons      (gain and offset corrections)
        %          LocalizeData       (produce localizations for SMD structure)
        %             Threshold       (thresholding of localizations generated)
        %          SingleMoleculeData (catSMD for SMDPreThresh)
        %          FrameConnection    (frame connection)
        %          DriftCorrection    (intra-dataset)
        %       SingleMoleculeData    (catSMD for SMD)
        %    end
        %    DriftCorrection (inter-dataset)
        %    Threshold       (rejected localization statistics)

        obj.createDirectories();

        % Define the list of datasets to be processed.
        obj.SMF = smi_core.LoadData.setSMFDatasetList(obj.SMF);
        % DatasetList takes priority over what is in SMF.
        if ~exist('DatasetList', 'var')
            DatasetList = obj.SMF.Data.DatasetList;
        else
            obj.SMF.Data.DatasetList = DatasetList;
        end

        % Initialize FitFramePreFC for this invocation of analyzeAll.
        obj.FitFramePreFC = cell(max(DatasetList), 1);

        % Abbreviation useful for dealing with multiple drift correction
        % methods.
        obj.DCMethod = obj.SMF.DriftCorrection.Method;

        % DriftCorrection class object is also used in analyzeDataset.
        obj.DC = smi_core.DriftCorrection(obj.SMF);
        obj.DC.Verbose = obj.Verbose;
        obj.SMD=[];
        obj.SMDPreThresh=[];
        if strcmp(obj.DCMethod, 'DC-BF')
            % Initialize DC-BF.
            NDatasets = numel(DatasetList);
            [obj.RefImage, obj.PreSeqImages, obj.PostSeqImages, ...
             obj.ParamStruct] = obj.DC.driftCorrectBFInit(NDatasets, obj.SMF);
        end
        if obj.Verbose >= 1
            fprintf('Processing %d datasets ...\n', numel(DatasetList));
            if obj.SMF.FrameConnection.On
               fprintf('Frame Connection on, method = %s\n', ...
                       obj.SMF.FrameConnection.Method);
            end
            if obj.SMF.DriftCorrection.On
               fprintf('Drift Correction on, method = %s\n', obj.DCMethod);
            end
        end
        for nn=1:numel(DatasetList)
            SMDnn = obj.analyzeDataset(DatasetList(nn), nn);
            obj.SMD=smi_core.SingleMoleculeData.catSMD(obj.SMD,SMDnn,false);
        end

        % Inter-dataset drift correction.
        if obj.SMF.DriftCorrection.On && numel(DatasetList) > 1
            if obj.Verbose >= 1
                fprintf('Drift correcting (inter-dataset) ...\n');
            end
            if strcmp(obj.DCMethod, 'DC-KNN')
                obj.SMD = obj.DC.driftCorrectKNNInter(obj.SMD);
            elseif strcmp(obj.DCMethod, 'DC-BF')
                %obj.SMD = obj.DC.driftCorrectBF(obj.SMD, obj.SMF);
                obj.SMD = obj.DC.driftCorrectBFInter(obj.SMD, obj.RefImage, ...
                             obj.PreSeqImages, obj.ParamStruct);
            end
        end

        % Produce some statistics on rejected localizations.
        THR = smi_core.Threshold;
        if obj.Verbose >= 1 && obj.SMF.Thresholding.On
           THR.rejectedLocalizations(obj.SMDPreThresh, '');
        end

        % Localizations are eliminated if they do not have MinNumNeighbors
        % neighbors that are within MedianMultiplier times the localization
        % sigma median.  Do not use on dSTORM data.
        obj.SMD = smi_helpers.Filters.filterNN(obj.SMD, obj.Verbose, ...
                 obj.SMF.Thresholding.MinNumNeighbors, ...
                 obj.SMF.Thresholding.NNMedianMultiplier);

        % Copy PixelSize from SMF to SMD.
        obj.SMD.PixelSize = obj.SMF.Data.PixelSize;
    end

    % ---------------------------------------------------------------------

    function SMD=analyzeDataset(obj,DatasetIndex,DatasetCount)
        % analyzeDataset loads and analyzes one dataset.

        if ~exist('DatasetCount', 'var')
            DatasetCount = 1;
        end

        if obj.Verbose >= 1
            fprintf('Loading dataset %d ...\n', DatasetIndex);
        end
        LD = smi_core.LoadData;
        [~, Dataset, obj.SMF]=LD.loadRawData(obj.SMF,DatasetIndex);

        % Perform the gain and offset correction and update SMF
        % (internally, for an sCMOS, smi_core.DataToPhotons will load the
        % calibration data, which we'd like to store in obj.SMF.Data).
        DTP = smi_core.DataToPhotons(obj.SMF, Dataset, [], [], obj.Verbose);
        obj.SMF.Data.CameraGain = DTP.CameraGain;
        obj.SMF.Data.CameraOffset = DTP.CameraOffset;
        obj.SMF.Data.CameraReadNoise = DTP.CameraReadNoise;
        ScaledDataset = DTP.convertData();
        
        % Generate localizations from the current Dataset.
        if obj.FullvsTest
           V = obj.Verbose;
        else
           V = obj.VerboseTest;
        end
        LD = smi_core.LocalizeData(ScaledDataset, obj.SMF, V);
        LD.ResultsDir = obj.ResultsSubDir;   % if saving the color overlay
        if obj.Verbose >= 1
            fprintf('Generating localizations ...\n');
        end
        [SMD] = LD.genLocalizations();

        % Keep track of why localizations were filtered out.
        obj.SMDPreThresh = smi_core.SingleMoleculeData.catSMD( ...
                              obj.SMDPreThresh, LD.SMDPreThresh, false);

        % Define NDatasets, and DatasetNum from the dataset count.
        SMD.NDatasets  = 1;
        SMD.DatasetNum = DatasetCount * ones(size(SMD.FrameNum));

        % Perform frame-connection on localizations in SMD.
        obj.FitFramePreFC{DatasetIndex} = obj.fitsPerFrame(SMD, DatasetIndex);
        if obj.SMF.FrameConnection.On
            FC = smi_core.FrameConnection(SMD, obj.SMF, obj.Verbose);
            SMD = FC.performFrameConnection();

            % Filter out localizations representing fewer than MinNFrameConns
            % frame connections.  This filter should not be used for dSTORM
            % data.
            SMD = smi_helpers.Filters.filterFC(SMD, obj.Verbose, ...
                     obj.SMF.FrameConnection.MinNFrameConns);
        end

        % Intra-dataset drift correction.
        if obj.SMF.DriftCorrection.On
            if obj.Verbose >= 1
                fprintf('Drift correcting (intra-dataset) ...\n');
            end
            if strcmp(obj.DCMethod, 'DC-KNN')
                SMD = obj.DC.driftCorrectKNNIntra(SMD, DatasetCount, ...
                                                       DatasetIndex);
            elseif strcmp(obj.DCMethod, 'DC-BF')
                SMD = obj.DC.driftCorrectBFIntra(SMD, obj.PreSeqImages, ...
                         obj.PostSeqImages, obj.ParamStruct);
            end
        end
    end

    % ---------------------------------------------------------------------

    function createDirectories(obj)
        % createDirectories creates directories for saving results in
        % throughout the calculations.

        [~, f, ~] = fileparts(obj.SMF.Data.FileName{1});
        if isempty(obj.SMF.Data.AnalysisID)
            SubDir = f;
        else
            SubDir = [f, '_', obj.SMF.Data.AnalysisID];
        end

        if obj.FullvsTest   % fullFit
           obj.ResultsDir = obj.SMF.Data.ResultsDir;
           obj.ResultsSubDir = fullfile(obj.ResultsDir, SubDir);
           obj.ShowPlots = false;   % Don't show, but rather save, plots.
        else   % testFit
           obj.ResultsDir = [];
           if obj.CalledByGUI || obj.VerboseTest >= 5
              obj.ResultsSubDir = [];
              obj.ShowPlots = true;   % Show plots to the user in these cases.
           else
              obj.ResultsSubDir = fullfile(obj.SMF.Data.ResultsDir, ...
                                           SubDir, 'TestFit');
              obj.ShowPlots = false;  % Save testFit plots in TestFit subdir.
           end
        end

        if ~isempty(obj.ResultsDir) && ~isfolder(obj.ResultsDir)
            mkdir(obj.ResultsDir);
        end
        if ~isempty(obj.ResultsSubDir) && ~isfolder(obj.ResultsSubDir)
            mkdir(obj.ResultsSubDir);
        end
    end

    % ---------------------------------------------------------------------

    function saveResults(obj)
        % saveResults saves all results and plots in subfolder.
        % gaussblobs, drift image, fits/frame, NumConnected hist,
        % Driftcorrection plots, precision hist, intensity hist,
        % mat file with SMD and SMF structures.
        % saveResults flow:
        %
        % saveResults:
        %    Save SMD and SMF structures
        %    generatePlots (plots saved for fullAnalysis, displayed for testFit)

        if isempty(obj.SMD)
            error('No SMD results structure found to save!');
        end

        [~, f, ~] = fileparts(obj.SMF.Data.FileName{1});
        if isempty(obj.SMF.Data.AnalysisID)
            fn = [f, '_Results.mat'];
        else
            fnextend = strcat('_', obj.SMF.Data.AnalysisID, '_Results.mat');
            fn = [f, fnextend];
        end

        % Reset CalledByGUI for the next call that comes here.
        obj.CalledByGUI = false;

        SMD = obj.SMD;
        SMF = obj.SMF.packageSMF();
        if obj.Verbose >= 1
            fprintf('Saving SMD and SMF structures ...\n(%s)\n', ...
                    fullfile(obj.ResultsSubDir, fn));
        end

        % Save SMD and SMF structures.
        if ~isempty(obj.ResultsSubDir)
           save(fullfile(obj.ResultsSubDir, fn), 'SMD', 'SMF', '-v7.3');
        end
        % Generate (and optionally) save various data plots/histograms.
        obj.generatePlots(obj.ResultsDir, obj.ResultsSubDir, ...
                          obj.SMF.Data.AnalysisID, obj.ShowPlots, obj.PlotDo);
    end

    % ---------------------------------------------------------------------

    generatePlots(obj, PlotSaveDir1, PlotSaveDir2, AnalysisID, ...
                       ShowPlots, PlotDo)
    gui(obj)

end % methods
% =========================================================================

% =========================================================================
methods(Static)
    FitFrame = fitsPerFrame(SMD, DatasetIndex)
    Success = unitTest()
end % methods(Static)
% =========================================================================

end

./MATLAB/+smi/@SPT/autoTrack.m
function [] = autoTrack(obj)
%autoTrack performs iterative tracking by updating tracking parameters.
% This method will iteratively track the data pointed to by obj.SMF making
% new estimates of some parameters (e.g., diffusion constant) after each
% iteration.

% Created by:
%   David J. Schodt (Lidke Lab, 2021)


% Perform the iterative tracking.
NoBatchIter = ((obj.SMF.Tracking.NIterMaxBatch==1) ...
    || (numel(obj.SMF.Data.FileName)==1));
obj.SMD.ConnectID = [];
obj.updateTrackingParams(false)
ParamsHistory = {obj.SMF.Tracking};
for ii = 1:obj.SMF.Tracking.NIterMax
    % Send an update to the command window.
    if (obj.Verbose > 1)
        fprintf(['\tsmi.spt.performFullAnalysis(): ', ...
            'Tracking iteration %i...\n'], ii)
    end
    
    % Track the data.
    obj.SMD.ConnectID = [];
    obj.generateTrajectories();
    if (obj.SMF.Tracking.NIterMax == 1)
        return
    end
    
    % Update the tracking parameters based only on the current file.
    obj.updateTrackingParams(false)
    
    % Store the current set of tracking parameters.
    ParamsHistory{ii+1, 1} = obj.SMF.Tracking;
    
    % Check if the parameters have changed below the requested relative
    % change.  If so, we can stop early.
    Converged = obj.checkConvergence(...
        obj.SMF.Tracking, ParamsHistory{ii}, ...
        obj.SMF.Tracking.MaxRelativeChange);
    if ((ii==obj.SMF.Tracking.NIterMax) || Converged)
        % Store the parameter history (if needed) and stop iterating.
        if NoBatchIter
            obj.SMF.Tracking.ParamsHistory = ParamsHistory(1:ii);
        end
        return
    end
end


end
./MATLAB/+smi/@SPT/gui.m
function gui(obj)
%gui generates a GUI to facilitate use of the SPT class.
% This method generates a GUI which allows the user to load single-particle
% tracking data, set parameters through the SingleMoleculeFitting class,
% and generate results.

% Created by:
%   David J. Schodt (Lidke lab, 2021)


% Create a figure for the GUI.
DefaultFigurePosition = get(0, 'defaultFigurePosition');
FigureXYSize = [DefaultFigurePosition(3), 600];
GUIFigure = figure('MenuBar', 'none', ...
    'Name', 'SPT Interface', 'NumberTitle', 'off', ...
    'Units', 'pixels', ...
    'Position', [DefaultFigurePosition(1), 0, FigureXYSize]);

% Add some panels to help organize the GUI.
SMFPanel = uipanel(GUIFigure, 'Title', 'Fitting parameters', ...
    'Units', 'normalized', 'Position', [0, 0.3, 1, 0.7]);
ControlPanel = uipanel(GUIFigure, 'Title', 'Controls', ...
    'Units', 'normalized', 'Position', [0, 0, 1, 0.3]);

% Stick the SingleMoleculeFitting GUI inside of the SMFPanel.
obj.SMF.gui(SMFPanel);

% Add some controls to the ControlPanel.
TextSize = [0, 0, 0.2, 0.2];
EditSize = [0, 0, 0.1, 0.2];
ButtonSize = [0, 0, 0.2, 0.2];
ControlHandles.Track = uicontrol(ControlPanel, ...
    'Style', 'pushbutton', 'String', 'Track', ...
    'FontUnits', 'normalized', 'FontSize', 0.4, ...
    'Units', 'normalized', ...
    'Position', ButtonSize, ...
    'callback', @track);
ControlHandles.TestTrackButton = uicontrol(ControlPanel, ...
    'Style', 'pushbutton', 'String', 'Test Track', ...
    'FontUnits', 'normalized', 'FontSize', 0.4, ...
    'Units', 'normalized', ...
    'Position', ButtonSize + [0, ButtonSize(4), 0, 0], ...
    'callback', @testTrack);
ControlHandles.TestFitButton = uicontrol(ControlPanel, ...
    'Style', 'pushbutton', 'String', 'Test Fit', ...
    'FontUnits', 'normalized', 'FontSize', 0.4, ...
    'Units', 'normalized', ...
    'Position', ButtonSize + [0, 3*ButtonSize(4), 0, 0], ...
    'callback', @testFit);
uicontrol(ControlPanel, 'Style', 'text', 'String', 'Dataset Number:', ...
    'FontUnits', 'normalized', 'FontSize', 0.4, ...
    'Units', 'normalized', ...
    'Position', TextSize + [ButtonSize(3), 3*ButtonSize(4), 0, 0]);
ControlHandles.DatasetNumEdit = uicontrol(ControlPanel, ...
    'Style', 'edit', 'String', '1', ...
    'FontUnits', 'normalized', 'FontSize', 0.4, ...
    'Units', 'normalized', ...
    'Position', EditSize + [ButtonSize(3)+TextSize(3), 3*ButtonSize(4), 0, 0]);
ControlHandles.MakeMovie = uicontrol(ControlPanel, ...
    'Style', 'pushbutton', 'String', 'Movie GUI', ...
    'FontUnits', 'normalized', 'FontSize', 0.4, ...
    'Units', 'normalized', ...
    'Position', ButtonSize + [ControlPanel.Position(3)-ButtonSize(3), 0, 0, 0], ...
    'callback', @makeMovieGUI);

    function track(Source, ~)
        % Track the data based on the SMF GUI parameters.
        try
            Source.Enable = 'off';
            FindFilesInit = obj.FindFiles;
            obj.FindFiles = false;
            if (numel(obj.SMF.Data.FileName) > 1)
                % If multiple filenames are present, we'll try
                % batch-tracking.
                obj.batchTrack();
            else
                obj.performFullAnalysis()
            end
            Source.Enable = 'on';
            obj.FindFiles = FindFilesInit;
        catch MException
            Source.Enable = 'on';
            obj.FindFiles = FindFilesInit;
            rethrow(MException)
        end

        % Restore the SMF GUI in the panel.
        % NOTE: This is a workaround for a bug which causes detachment of
        %       the SMF GUI from the SPT class.  I haven't found the
        %       underlying cause of this bug, but this workaround seems to
        %       work okay. DJS 22/05/23
        obj.SMF = smi_core.SingleMoleculeFitting.reloadSMF(obj.SMF);
        obj.SMF.gui(SMFPanel);
    end

    function testTrack(Source, ~)
        % Track the data based on the SMF GUI parameters.
        TestFlagInit = obj.IsTestRun;
        VerboseInit = obj.Verbose;
        FindFilesInit = obj.FindFiles;
        obj.IsTestRun = true;
        obj.Verbose = 3;
        obj.FindFiles = false;
        try
            Source.Enable = 'off';
            if (numel(obj.SMF.Data.FileName) > 1)
                % For multiple files, we'll dispatch on batchTrack().
                obj.batchTrack();
            else
                obj.performFullAnalysis()
            end
            Source.Enable = 'on';
        catch MException
            Source.Enable = 'on';
            obj.IsTestRun = TestFlagInit;
            obj.Verbose = VerboseInit;
            obj.FindFiles = FindFilesInit;
            rethrow(MException)
        end
        obj.IsTestRun = TestFlagInit;
        obj.Verbose = VerboseInit;
        obj.FindFiles = FindFilesInit;

        % Restore the SMF GUI in the panel.
        % NOTE: This is a workaround for a bug which causes detachment of
        %       the SMF GUI from the SPT class.  I haven't found the
        %       underlying cause of this bug, but this workaround seems to
        %       work okay. DJS 22/05/23
        obj.SMF = smi_core.SingleMoleculeFitting.reloadSMF(obj.SMF);
        obj.SMF.gui(SMFPanel);
    end

    function testFit(~, ~)
        % Run the smi.SMLM test fit and update some relevant class
        % properties from the results (e.g., obj.SMD).
        obj.SMLM = smi.SMLM(obj.SMF, false);
        obj.SMLM.CalledByGUI = true;
        obj.SMLM.testFit(str2double(ControlHandles.DatasetNumEdit.String));
        obj.SMD = obj.SMLM.SMD;
        obj.SMDPreThresh = obj.SMLM.SMDPreThresh;
    end

    function makeMovieGUI(~, ~)
        % Prepare the movie maker.
        MovieMaker = smi_vis.GenerateMovies;
        MovieMaker.TR = obj.TR;
        MovieMaker.SMD = obj.SMD;
        MovieMaker.RawData = obj.ScaledData;
        MovieMaker.SMF = copy(obj.SMF);
        MovieMaker.gui()
    end


end
./MATLAB/+smi/@SPT/solveLAP.m
function [Assign12, Cost12] = solveLAP(CostMatrix, NonlinkMarker)
%solveLAP solves the linear assignment problem specified by CostMatrix.
% This method will treat the costs in the input matrix CostMatrix as the
% costs associated with linking rows and columns together with only one
% link per row/column allowed (linear assignment problem, or LAP).
%
% NOTE: The input CostMatrix must not have any NaN or inf elements, and it
%       must allow for at least one assignment per row/column (i.e., there
%       can't be an entire row of NonlinkMarker's, or for a sparse matrix,
%       there can't be an entire row of 0's).
%
% NOTE: This method is just a wrapper around the C++ code c_lap written by
%       R. Jonker and A. Volgenant, University of Amsterdam (see
%       smite/MATLAB/source/c/c_lap.cpp).
%
% INPUTS:
%   CostMatrix: This is a square matrix whose elements CostMatrix(ii, jj)
%               correspond to the cost associated with linking item ii with
%               jj (e.g., in frame connection, the cost of linking
%               localization ii in frame n with localization jj in frame
%               n+1). (NxN numeric array with no NaN or inf elements)
%   NonlinkMarker: A marker that may or may not be present in CostMatrix
%                  which indicate that we strictly will not link the items
%                  associated with that element of CostMatrix.
%                  (1x1 scalar that is not NaN or inf)(Default = -1)
%
% OUTPUTS:
%   Assign12: An array specifying which assignments were made by solving
%             the LAP.  For example, if Link12(nn) = mm, CostMatrix(mm, nn)
%             would be the cost associated with the optimal assignment.  In
%             the context of frame connection, this could mean, e.g., that
%             localization mm in frame 1 would link to localization nn in
%             frame 2. (Nx1 int32)
%   Cost12: An array providing the costs associated with the assignments in
%           Assign12 (these are just the elements of CostMatrix associated
%           with the assignments in Assign12). (Nx1 double)
%
% REQUIRES:
%   compiled c_lap.mex64

% Created by:
%   David J. Schodt, rewrote old code of unknown author, only minor
%       modifications were made (Lidke Lab, 2020)


% Set defaults if needed.
if (~exist('NonlinkMarker', 'var') || isempty(NonlinkMarker))
    NonlinkMarker = -1;
end

% If the input cost matrix is empty, we can just set the outputs to empty
% and stop here.
CostMatrixSize = size(CostMatrix, 1); % we need this later anyways
if ~CostMatrixSize
    Assign12 = [];
    Cost12 = [];
    return
end

% Validate the input CostMatrix.
CostMatrix = double(CostMatrix);
if (any(isnan(CostMatrix(:))) || any(isinf(CostMatrix(:))))
    error(['smi.SPT.solveLAP(): The input cost matrix cannot contain ', ...
        'NaNs or infs'])
end
if issparse(CostMatrix)
    % Ensure that the structural rank of the CostMatrix is equal to the
    % number of rows/columns (meaning that a unique assignment can be made
    % for every row/column).
    if (sprank(CostMatrix) < CostMatrixSize)
        error(['smi.SPT.solveLAP(): The input cost matrix must allow ', ...
            'for at least one assignment per row/column'])
    end
else
    % For non-sparse matrices we can still use the structural rank check,
    % we just want to ignore the NonlinkMarker elements.
    ValidCosts = (CostMatrix ~= NonlinkMarker);
    if (sprank(ValidCosts) < CostMatrixSize)
        error(['smi.SPT.solveLAP(): The input cost matrix must allow ', ...
            'for at least one assignment per row/column'])
    end
end

% Convert the CostMatrix into a column vector for use in c_lap.mex64
if issparse(CostMatrix)
    [RowIndices, ColumnIndices, CostMatrixStacked] = find(CostMatrix);
else
    [RowIndices, ColumnIndices] = find(ValidCosts);
    CostMatrixStacked = CostMatrix(ValidCosts);
end

% Force appropriate variable types for the c code/for improved memory usage
% NOTE: I don't know why we add the extra 0 at the beginning, so for now
%       I'm just leaving it.
RowIndices = int32([0; RowIndices]);
ColumnIndices = int32([0; ColumnIndices]);
CostMatrixStacked = double([0; CostMatrixStacked]);

% Solve the LAP with the mex code.
StackSize = int32(numel(CostMatrixStacked));
[Assign12, ~, ~, ~] = ...
    c_lap(CostMatrixSize, StackSize, CostMatrixStacked, ...
    RowIndices, [0; find(diff(ColumnIndices)); StackSize]);
Assign12 = Assign12(2:end);
Cost12 = full(CostMatrix(sub2ind([CostMatrixSize, CostMatrixSize], ...
    Assign12, (1:CostMatrixSize).')));


end
./MATLAB/+smi/@SPT/connectTrajFF.m
function [SMD] = connectTrajFF(SMD, Link12, FrameNumber)
%connectTrajFF connects frame-to-frame localizations into trajectories.
% Given an (M+N) x 1 vector containing localization link data found by
% smi.SPT.solveLAP(), this method will connect (as appropriate) the N
% localizations in frame FrameNumber to the M localizations in frame 
% FrameNumber+1.
%
% INPUTS:
%   SMD: Single Molecule Data structure (see smi_core.SingleMoleculeData)
%        containing the localizations that we wish to stitch into
%        trajectories.
%   Link12: Array containing the trajectory link data as found 
%           by smi.SPT.solveLAP(), where M+N is the sum of the number of 
%           localizations in frame FrameNumber+1 (M) and the number of 
%           localizations in frame FrameNumber (N). 
%           For example, if Link12(4) = 1, we need to link the fourth
%           localization in frame FrameNumber+1 to the first localization 
%           in frame FrameNumber. (M+N x 1) 
%   FrameNumber: The frame whose localizations will be connected to the 
%                subsequent frame FrameNumber+1. (1x1) 
%
% OUTPUTS:
%   SMD: Input SMD structure which contains the modified ConnectID field 
%        corresponding to newly linked localizations.
%
% CITATION:

% Created by:
%   David J. Schodt (Lidke Lab, 2018)


% Determine the total number of localizations in each of the two frames.
NLinks = numel(Link12);
NLocFirstFrame = sum(SMD.FrameNum == FrameNumber);
NLocSecondFrame = NLinks - NLocFirstFrame;

% Grab the maximum trajectory ID from the TD structure for later use.  If
% the field ConnectID is empty, initialize it first to an array of zeros
if isempty(SMD.ConnectID)
    SMD.ConnectID = zeros(numel(SMD.X), 1);
end
MaxTrajID = max(SMD.ConnectID);

% Find the set of indices corresponding to localizations in frames
% FrameNumber and FrameNumber+1 (frame 1 and frame 2).
FrameOneIndices = find(SMD.FrameNum == FrameNumber); 
FrameTwoIndices = find(SMD.FrameNum == (FrameNumber+1));

% Loop through each localization in frame FrameNumber and check if it has
% been associated with a ConnectID.  If it has not, set it's
% ConnectID to be the smallest possible non-existing ConnectID.
for nn = 1:NLocFirstFrame
    if ~SMD.ConnectID(FrameOneIndices(nn))
        MaxTrajID = MaxTrajID + 1; 
        SMD.ConnectID(FrameOneIndices(nn)) = MaxTrajID; 
    end
end

% Loop through the localizations in frame FrameNumber+1 and assign them a
% trajectory ID based on Link12.
% NOTE: We only care about the first NTrajSecondFrame elements of Link12
%       because the rest correspond to the "death" and "auxillary" blocks
%       of the cost matrix.
for nn = 1:NLocSecondFrame
    % Determine if Link12(nn) is linking this localization to a
    % localization in the first frame.  If it's not, assign to this
    % localization the smallest unique trajectory ID available.
    if (Link12(nn) > NLocFirstFrame)
        MaxTrajID = MaxTrajID + 1;
        SMD.ConnectID(FrameTwoIndices(nn)) = MaxTrajID;
    else
        SMD.ConnectID(FrameTwoIndices(nn)) = ...
            SMD.ConnectID(FrameOneIndices(Link12(nn)));
    end
end


end
./MATLAB/+smi/@SPT/checkConvergence.m
function [Converged] = checkConvergence(NewParams, PreviousParams, ...
    MaxRelativeChange)
%checkConvergence checks if tracking parameters have converged.
% This method checks if the set of parameters in NewParams differ from
% PreviousParams within the provided tolerance to claim convergence.
%
% INPUTS:
%   NewParams: New set of SMF.Tracking parameters.
%   PreviousParams: Previous set of SMF.Tracking parameters.
%   MaxRelativeChange: Maximum relative change between checked parameters
%                      allowed for convergence.
%
% OUTPUTS:
%   Converged: Flag indicating convergence (true) or failure to converge
%              (false).

% Created by:
%   David J. Schodt (Lidke Lab, 2021)


% Check relative differences in parameters and decide if they converged.
DChange = (median(PreviousParams.D)-median(NewParams.D)) ...
    / median(PreviousParams.D);
KOnChange = abs((PreviousParams.K_on-NewParams.K_on) ...
    / PreviousParams.K_on);
KOffChange = abs((PreviousParams.K_off-NewParams.K_off) ...
    / PreviousParams.K_off);
Converged = all([DChange, KOnChange, KOffChange] <= MaxRelativeChange);


end
./MATLAB/+smi/@SPT/createCostMatrixFF.m
function [CostMatrix] = ...
    createCostMatrixFF(SMD, SMF, RhoOff, FrameNumber, NonLinkMarker)
%createCostMatrixFF generates frame-to-frame connection cost matrix.
% This method creates the cost matrix for the frame-to-frame connection of
% localizations present in SMD.
%
% INPUTS:
%   SMD: Single Molecule Data structure (see smi_core.SingleMoleculeData)
%        containing the localizations that we wish to stitch into
%        trajectories.
%   SMF: Single Molecule Fitting structure defining many of the parameters
%        we'll just to populate cost matrix elements.
%       (see smi_core.SingleMoleculeFitting)
%   RhoOff: Density of dark emitters, given as an image with the same
%           aspect ratio as the SMD coordinate system.
%   FrameNumber: The frame containing the localizations for which we want
%                to construct a cost matrix (for connection to
%                FrameNumber+1).
%   NonLinkMarker: A marker in the output CostMatrix that indicates we
%                  don't want to select that element in the linear
%                  assignment problem.
%                  (scalar, ~=inf, ~=nan, and typically < 0)(Default = -1)
%
% OUTPUTS:
%   CostMatrix: The cost matrix whose elements represent the cost for
%               connecting a particle (whether it be a real localization
%               present in SMD, or a "ghost" particle that we don't see) in
%               frame FrameNumber to a particle in frame FrameNumber+1.
%               (m+n x m+n numeric array, where n is the number of
%               localizations in FrameNumber, m is the number of
%               localizations in FrameNumber+1)
%
% CITATION:

% Created by:
%   Will Kanagy (Lidke Lab, 2018)
%   Hanieh Mazloom-Farsibaf (Lidke Lab, 2019)
%   Revised and added comments, David J. Schodt (Lidke Lab, 2020)
%   Rewritten for smite + several new parameters, David J. Schodt 
%       (Lidke Lab, 2021)


% Set defaults as needed.
if (~exist('NonLinkMarker', 'var') || isempty(NonLinkMarker))
    NonLinkMarker = -1;
end

% Determine which emitters in SMD were present in frames FrameNumber and
% FrameNumber+1.
EmitterIndicesFrame1 = find(SMD.FrameNum == FrameNumber);
EmitterIndicesFrame2 = find(SMD.FrameNum == (FrameNumber+1));
NFrame1 = numel(EmitterIndicesFrame1);
NFrame2 = numel(EmitterIndicesFrame2);

% Generate the upper left (the upper NxM) block of the cost matrix.
CMSize = NFrame2 + NFrame1;
CostMatrix = NonLinkMarker * ones(CMSize);
for ii = 1:NFrame1
    % Isolate the localizations in frame FrameNumber from SMD.
    CurrentIndicesFrame1 = EmitterIndicesFrame1(ii);
    XFrame1 = SMD.X(CurrentIndicesFrame1);
    X_SEFrame1 = SMD.X_SE(CurrentIndicesFrame1);
    YFrame1 = SMD.Y(CurrentIndicesFrame1);
    Y_SEFrame1 = SMD.Y_SE(CurrentIndicesFrame1);
    DFrame1 =  SMF.Tracking.D(CurrentIndicesFrame1);
    for jj = 1:NFrame2
        % Isolate the localizations in frame FrameNumber+1 from SMD.
        CurrentIndicesFrame2 = EmitterIndicesFrame2(jj);
        XFrame2 = SMD.X(CurrentIndicesFrame2);
        X_SEFrame2 = SMD.X_SE(CurrentIndicesFrame2);
        YFrame2 = SMD.Y(CurrentIndicesFrame2);
        Y_SEFrame2 = SMD.Y_SE(CurrentIndicesFrame2);
        DFrame2 =  SMF.Tracking.D(CurrentIndicesFrame2);
        
        % Define the standard deviations of the distribution of observed X
        % and Y separations between two localizations in consecutive
        % frames, assuming they came from the same emitter which
        % experienced Brownian motion with diffusion constant D.
        % NOTE: When using trajectory-wise D's, I'm not sure which approach
        %       is more valid: D==DFrame1 in the following equations, or
        %       D==mean(DFrame1+DFrame2)?  I think D==DFrame1 makes more
        %       sense, however that might be too tight of a restriction
        %       (e.g., if one of the localizations was previously estimated
        %       to be from a very slow trajectory, that might prevent us
        %       from connecting the two localizations).
        Sigma_X = sqrt(DFrame1(1) + DFrame2(1) ...
            + X_SEFrame1^2 + X_SEFrame2^2);
        Sigma_Y = sqrt(DFrame1(1) + DFrame2(1) ...
            + Y_SEFrame1^2 + Y_SEFrame2^2);
        
        % Compute the distance between the localizations and determine if
        % we need to proceed.
        XJump = XFrame1 - XFrame2;
        YJump = YFrame1 - YFrame2;
        Separation = sqrt(XJump^2 + YJump^2);
        if ((Separation>SMF.Tracking.MaxDistFF) ...
                || (abs(XJump/Sigma_X)>SMF.Tracking.MaxZScoreDist) ...
                || (abs(YJump/Sigma_Y)>SMF.Tracking.MaxZScoreDist))
            continue
        end
        
        % Define the negative log-likelihood of the observed X, Y from
        % FrameNumber and FrameNumber+1 having come from the Normal
        % distributions defined by Sigma_X and Sigma_Y (i.e., this is
        % -log(Normal(mean = 0, Sigma_X) * Normal(mean = 0, Sigma_Y))
        NegLikelihoodOfXandY = log(2*pi*Sigma_X*Sigma_Y) ...
            + (XFrame1-XFrame2)^2 / (2*Sigma_X^2) ...
            + (YFrame1-YFrame2)^2 / (2*Sigma_Y^2);
        
        % Compute the negative log-likelihood of these two localizations
        % being the same emitter (i.e., this is
        % -log(NormalX * NormalY * P(not turning off))
        % NOTE: There is an implicit DeltaT = 1 frame, i.e., cost of not
        %       turning off is K_off*DeltaT with DeltaT = 1 frame
        % NOTE: The additional 0.5 multiplying the link costs comes from
        %       our choice to set the "auxillary" (bottom right) block of
        %       the cost matrix equal to the transpose of the "link"
        %       block.  With that choice, we have argued (but not proven!)
        %       that any element selected in the link block during the
        %       linear assignment problem will be selected in the
        %       "auxillary" block as well (and vice versa), and thus the
        %       factor of 0.5 ensures that the total cost of elements
        %       selected in the LAP will be consistent with the physically
        %       reasonable costs we've defined otherwise.
        CostMatrix(ii, jj) = ...
            0.5 * (NegLikelihoodOfXandY+SMF.Tracking.K_off);
    end
end

% Define the costs of birth and death of particles between frames
% FrameNumber and FrameNumber+1 (the costs of introducing a new emitter
% appearing in FrameNumber+1/an emitter disappearing in FrameNumber+1,
% respectively).
if isscalar(RhoOff)
    CostBirth = -log(RhoOff * (1-exp(-SMF.Tracking.K_on)));
else
    % Rescale the data to match the size of our density image.
    Scale = size(RhoOff) ./ [SMD.YSize, SMD.XSize];
    Y = min(size(RhoOff, 1), ...
        max(1, ceil((SMD.Y(EmitterIndicesFrame2)-0.5)*Scale(1) + 0.5)));
    X = min(size(RhoOff, 2), ...
        max(1, ceil((SMD.X(EmitterIndicesFrame2)-0.5)*Scale(2) + 0.5)));
    
    % Compute the birth costs
    CostBirth = inf(numel(Y));
    for ii = 1:numel(Y)
        CostBirth(:, ii) = ...
            -log(RhoOff(Y(ii), X(ii)) * (1-exp(-SMF.Tracking.K_on)));
    end
end
CostDeath = -log(1-exp(-SMF.Tracking.K_off));

% Populate the remaining blocks of the cost matrix as appropriate.
% NOTE: The bottom right "auxillary" block is not physically meaningful (at
%       least not in an obvious way?).  Our choice to set it equal to the
%       transpose of the upper left block seems appropriate but we never
%       "proved" that this is always the best choice.
CostMatrix((NFrame1+1):CMSize, 1:NFrame2) = CostBirth;
CostMatrix(1:NFrame1, (NFrame2+1):CMSize) = CostDeath;
CostMatrix((NFrame1+1):CMSize, (NFrame2+1):CMSize) = ...
    CostMatrix(1:NFrame1, 1:NFrame2).';


end
./MATLAB/+smi/@SPT/genTrajFF.m
function [SMD] = genTrajFF(SMD, SMF, RhoOff, NonLinkMarker)
%genTrajFF connects localizations frame-to-frame into trajectories.
% This method loops through frames of localizations in SMD and stitches
% localizations into trajectories frame-to-frame.
%
% INPUTS:
%   SMD: Single Molecule Data structure (see smi_core.SingleMoleculeData)
%        containing the localizations that we wish to stitch into
%        trajectories.
%   SMF: Single Molecule Fitting structure defining many of the parameters
%        we'll just to populate cost matrix elements.
%       (see smi_core.SingleMoleculeFitting)
%   RhoOff: Density of dark emitters, given as an image with the same
%           aspect ratio as the SMD coordinate system.
%   NonLinkMarker: A marker in the output CostMatrix that indicates we
%                  don't want to select that element in the linear
%                  assignment problem.
%                  (scalar, ~=inf, ~=nan, and typically < 0)(Default = -1)
%
% OUTPUTS:
%   SMD: Single Molecule Data structure (see smi_core.SingleMoleculeData)
%        with field ConnectID representing trajectory membership.

% Created by:
%   David J. Schodt (Lidke Lab, 2021)


% Set defaults.
if (~exist('NonLinkMarker', 'var') || isempty(NonLinkMarker))
    NonLinkMarker = -1;
end

% Loop over frames and solve the frame-to-frame connection LAP.
SMD.ConnectID = (1:numel(SMD.FrameNum)).';
UniqueFrames = unique(SMD.FrameNum, 'sorted');
for ff = UniqueFrames(1:(end-1)).'
    % Create the frame-to-frame connection cost matrix.
    CostMatrix = smi.SPT.createCostMatrixFF(SMD, SMF, RhoOff, ...
        ff, NonLinkMarker);
    if (numel(CostMatrix) < 2)
        % If there's only one localization considered, there's no use in
        % proceeding.
        continue
    end
    
    % Perform the linear assignment problem to determine how we should link
    % together trajectories.
    Link12 = smi.SPT.solveLAP(CostMatrix);
    SMD = smi.SPT.connectTrajFF(SMD, Link12, ff);
end


end
./MATLAB/+smi/@SPT/estimateDensities.m
function [RhoOff, RhoOn] = estimateDensities(SMD, SMF)
%estimateDensities estimates emitter densities.
% This method will make an estimate of the density of emitters based on
% trajectories defined by SMD (i.e., SMD with field ConnectID populated to
% indicate trajectory membership).
%
% INPUTS:
%   SMD: Single Molecule Data structure (see smi_core.SingleMoleculeData)
%        containing localizations associated by SMD.ConnectID.
%   SMF: Single Molecule Fitting structure (see
%        smi_core.SingleMoleculeFitting).
%
% OUTPUTS:
%   RhoOff: Density of dark emitters (emitters capable of transitioning to
%           a fluorescent state). (emitters / pixel^2)
%   RhoOn: Density of visible emitters. (emitters / pixel^2)
%
% CITATION:

% Created by:
%   David J. Schodt (Lidke Lab, 2021)


% Estimate the density of visible emitters.
% NOTE: It might be more accurate to set the second input to 0 (so that the
%       density image represents the localization distribution), however
%       smoothing by the max. gap size between trajectories gives a better
%       approximation to the density we really want (that is, the density
%       in the vicinity of the emitter).
RhoOn = smi_core.SingleMoleculeData.computeDensityImage(SMD, ...
    max(SMF.Tracking.MaxDistFF, SMF.Tracking.MaxDistGC));

% Estimate the density of dark emitters.
RhoOff = RhoOn * (SMF.Tracking.K_off/SMF.Tracking.K_on);


end
./MATLAB/+smi/@SPT/performFullAnalysis.m
function [TR, SMD, SMDPreThresh] = performFullAnalysis(obj)
%performFullAnalysis fits and tracks data pointed to by obj.SMF
% This method is the main run method for the smi.SPT class, meaning that it
% will load raw data, perform gain/offset correction, fit localizations to
% the data, create trajectories from the localizations, and then save the
% results.
%
% OUTPUTS:
%   TR: Tracking Results structure (see smi_core.TrackingResults)
%   SMD: Single Molecule Data structure (see smi_core.SingleMoleculeData)
%   SMDPreThresh: Output 'SMD' before thresholds are applied.

% Created by:
%   David J. Schodt (Lidke Lab, 2021)


% Load data, perform gain/offset correction, fit the data, and threshold
% the fits.
if obj.SMF.Tracking.TryLowPValueLocs
    obj.SMFCopy = smi_core.SingleMoleculeFitting.reloadSMF(obj.SMF);
    obj.SMF.Thresholding.MinPValue = 0;
end
LD = smi_core.LoadData;
[~, RawData] = LD.loadRawData(obj.SMF, 1);
DTP = smi_core.DataToPhotons(obj.SMF, RawData, [], [], obj.Verbose);
obj.SMF.Data.CameraGain = DTP.CameraGain;
obj.SMF.Data.CameraOffset = DTP.CameraOffset;
obj.SMF.Data.CameraReadNoise = DTP.CameraReadNoise;
obj.ScaledData = DTP.convertData();
LD = smi_core.LocalizeData(obj.ScaledData, obj.SMF, obj.Verbose);
[obj.SMD, obj.SMDPreThresh] = LD.genLocalizations();
obj.SMD.NDatasets = 1;
obj.SMD.DatasetNum = ones(size(obj.SMD.FrameNum));

% Add pixel size and framerate to SMD (this is a temporary workaround for
% other codes, e.g., the diffusion estimator, and should be removed later).
obj.SMD.PixelSize = obj.SMF.Data.PixelSize;
obj.SMD.FrameRate = obj.SMF.Data.FrameRate;
obj.SMDPreThresh.PixelSize = obj.SMF.Data.PixelSize;
obj.SMDPreThresh.FrameRate = obj.SMF.Data.FrameRate;

% Check if localizations were generated.  If none were generated, issue a
% warning and do not proceed.
if isempty(obj.SMD.FrameNum)
    if (obj.Verbose > 0)
        warning(['smi.SPT.performFullAnalysis(): No localizations were ', ...
            'generated from the provided dataset.'])
    end
    if nargout
        TR = obj.TR;
        SMD = obj.SMD;
        SMDPreThresh = obj.SMDPreThresh;
    end
    return
end

% Perform the tracking.
obj.autoTrack()

% If a channel registration file is provided, apply the transform to our
% tracking results.
if ~isempty(obj.SMF.Data.RegistrationFilePath)
    if isfile(obj.SMF.Data.RegistrationFilePath)
        % Load the registration transform and determine which transform
        % should be used based on the provided ROIs.
        load(obj.SMF.Data.RegistrationFilePath, ...
            'RegistrationTransform', 'FiducialROI', 'RegistrationErrorLOO')
        MatchedROI = find(all(FiducialROI == ...
            repmat(obj.SMF.Data.DataROI, [size(FiducialROI, 1), 1]), 2), ...
            1);
        
        % Apply the transform to the localizations. If no transform was
        % matched, issue a warning and proceed.
        % NOTE: For now, the registration error is just a scalar, but I'm
        %       storing it in SMD as an array for consistency with other
        %       "error" fields (which have a value for each localizations).
        if isempty(MatchedROI)
            warning(['smi.SPT.generateTrajectories(): None of the ', ...
                'available transforms match SMF.Data.DataROI!'])
        else
            obj.SMDPreCR = obj.SMD;
            obj.SMDPreThreshPreCR = obj.SMDPreThresh;
            obj.SMDPreThresh = smi_core.ChannelRegistration.transformSMD(...
                RegistrationTransform{MatchedROI}, obj.SMDPreThresh);
            obj.SMDPreThresh.RegError = ones(size(obj.SMDPreThresh.X)) ...
                * RegistrationErrorLOO(MatchedROI);
            obj.SMD = smi_core.ChannelRegistration.transformSMD(...
                RegistrationTransform{MatchedROI}, obj.SMD);
            obj.SMD.RegError = ones(size(obj.SMD.X)) ...
                * RegistrationErrorLOO(MatchedROI);
        end
        obj.TRPreCR = smi_core.TrackingResults.convertSMDToTR(obj.SMDPreCR);
        obj.TR = smi_core.TrackingResults.convertSMDToTR(obj.SMD);
    elseif (obj.Verbose > 0)
        warning(['smi.SPT.generateTrajectories(): The specified ', ...
            'SMF.Data.RegistrationFilePath cannot be found!'])
    end
end

% Remove short trajectories from the TR structure.
% NOTE: I'm leaving everything in SMD.  It might be nice to also threshold
%       short trajectories in SMD, but for now I'll leave it this way.
obj.TR = smi_core.TrackingResults.threshTrajLength(obj.TR, ...
    obj.SMF.Tracking.MinTrackLength);

% Make copies of TR and SMD for the outputs.
if nargout
    TR = obj.TR;
    SMD = obj.SMD;
    SMDPreThresh = obj.SMDPreThresh;
end

% Save the results.
if ~obj.IsTestRun
    obj.saveResults()
end

% Share an update in Command Window.
if (obj.Verbose > 0)
    fprintf('smi.SPT.performFullAnalysis(): Finished tracking file %s\n', ...
        obj.SMF.Data.FileName{1})
end


end
./MATLAB/+smi/@SPT/saveResults.m
function saveResults(obj)
%saveResults saves various tracking results produced by smi.SPT
% This method will save the SMD, TR, and SMF structures in .mat files
% in a Results folder.  This method will also save 2D and 3D plots of the
% tracked trajectories, as well as a 3D movie of the tracked trajectories
% (if requested).

% Created by:
%   David J. Schodt (Lidke Lab, 2018)


% Create the Results directory within the obj.SaveDir (if needed).
if (exist(obj.SMF.Data.ResultsDir, 'dir') ~= 7)
    % exist() will return a 7 if the ResultsDir is an existing directory.
    mkdir(obj.SMF.Data.ResultsDir)
end

% Create the filename for the saved results.
% NOTE: For now, this is only setup for a single file (hence the {1}).
[~, FileName] = fileparts(obj.SMF.Data.FileName{1});
BaseName = [FileName, ...
    smi_helpers.arrayMUX({'_', ''}, isempty(obj.SMF.Data.AnalysisID)), ...
    obj.SMF.Data.AnalysisID];
ResultsFileName = [BaseName, '_Results.mat'];

% Move the data structures of interest into the workspace with appropriate
% names for saving.
SMD = obj.SMD;
SMDPreThresh = obj.SMDPreThresh;
TR = obj.TR;
SMF = obj.SMF.packageSMF();

% Save the data in a .mat file.
save(fullfile(obj.SMF.Data.ResultsDir, ResultsFileName), ...
    'SMD', 'SMDPreThresh', 'TR', 'SMF', '-v7.3');

% If pre-channel registration results were stored, we'll save those too.
if ~(isempty(obj.SMDPreCR) || isempty(obj.SMDPreThreshPreCR) ...
        || isempty(obj.TRPreCR))
    ResultsFileNamePreCR = [BaseName, '_Results_PreCR.mat'];
    SMD = obj.SMDPreCR;
    SMDPreThresh = obj.SMDPreThreshPreCR;
    TR = obj.TRPreCR;
    save(fullfile(obj.SMF.Data.ResultsDir, ResultsFileNamePreCR), ...
        'SMD', 'SMDPreThresh', 'TR', 'SMF', '-v7.3');
end

% Create a movie of the tracks and save the resulting movie.
if obj.GenerateMovies
    % Load the raw data.
    LD = smi_core.LoadData;
    [~, RawData, obj.SMF] = ...
        LD.loadRawData(obj.SMF, 1, obj.SMF.Data.DataVariable);
    
    % Generate and save the movie.
    if ~(isempty(RawData) || isempty(cell2mat({obj.TR.FrameNum}.')))
        MovieMaker = smi_vis.GenerateMovies(obj.MovieParams);
        MovieMaker.TR = obj.TR;
        MovieMaker.RawData = RawData;
        MovieMaker.SMF = obj.SMF;
        MovieFileName = [BaseName, '_movie.mp4'];
        MovieMaker.saveMovie(fullfile(obj.SMF.Data.ResultsDir, MovieFileName))
    elseif (obj.Verbose > 0)
        warning('smi.SPT.saveResults(): no movie produced, data is empty!')
    end
end

% Create and save 2D and 3D trajectory plots.
if obj.GeneratePlots
    % Make and save the 2D plot.
    if ~isempty(cell2mat({obj.TR.FrameNum}.'))
        PlotFigure = figure();
        PlotAxes = axes(PlotFigure);
        MovieMaker = smi_vis.GenerateMovies(obj.MovieParams);
        MovieMaker.SMF = obj.SMF;
        MovieMaker.TR = obj.TR;
        MovieMaker.setVitalParams()
        MovieMaker.prepAxes(PlotAxes);
        EmptySMD = smi_core.SingleMoleculeData.createSMD();
        MovieMaker.makeFrame(PlotAxes, obj.TR, [], MovieMaker.Params, ...
            obj.SMF, EmptySMD, obj.TR(1).NFrames);
        Traj2DFileName = [BaseName, '_plot2D'];
        saveas(PlotFigure, fullfile(obj.SMF.Data.ResultsDir, Traj2DFileName))
        saveas(PlotFigure, ...
            fullfile(obj.SMF.Data.ResultsDir, [Traj2DFileName, '.png']))
        
        % Make and save the 3D plot.
        MovieMaker.Params.LineOfSite = [-45, 15];
        MovieMaker.prepAxes(PlotAxes);
        EmptySMD = smi_core.SingleMoleculeData.createSMD();
        MovieMaker.makeFrame(PlotAxes, obj.TR, [], MovieMaker.Params, ...
            obj.SMF, EmptySMD, obj.TR(1).NFrames);
        Traj3DFileName = [BaseName, '_plot3D'];
        saveas(PlotFigure, fullfile(obj.SMF.Data.ResultsDir, Traj3DFileName))
        saveas(PlotFigure, ...
            fullfile(obj.SMF.Data.ResultsDir, [Traj3DFileName, '.png']))
        close(PlotFigure);
    elseif (obj.Verbose > 0)
        warning('smi.SPT.saveResults(): no plots produced, no trajectories!')
    end
end

% Create and save some histograms related to track lengths/track fidelity.
if obj.GeneratePlots
    % Generate a histogram of trajectory durations.
    TrajDurations = smi_core.TrackingResults.computeTrajDurations(obj.TR);
    TrajDurationsUF = obj.UnitFlag*(TrajDurations-1)/obj.SMF.Data.FrameRate ...
        + ~obj.UnitFlag*TrajDurations;
    PlotFigure = figure();
    PlotAxes = axes(PlotFigure);
    histogram(PlotAxes, TrajDurationsUF)
    xlabel(PlotAxes, ['Trajectory duration ', ...
        smi_helpers.arrayMUX({'(frames)'; '(seconds)'}, obj.UnitFlag)])
    PlotAxes.FontWeight = 'bold';
    PlotAxes.FontSize = 14;
    saveas(PlotFigure, fullfile(obj.SMF.Data.ResultsDir, ...
        [BaseName, '_trajectory_durations.fig']))
    saveas(PlotFigure, fullfile(obj.SMF.Data.ResultsDir, ...
        [BaseName, '_trajectory_durations.png']))
    close(PlotFigure)

    % Generate a histogram of trajectory lengths (number of observations).
    NObservations = smi_core.TrackingResults.computeTrajLengths(obj.TR);
    PlotFigure = figure();
    PlotAxes = axes(PlotFigure);
    histogram(PlotAxes, NObservations)
    xlabel(PlotAxes, 'Num. of points in trajectory')
    PlotAxes.FontWeight = 'bold';
    PlotAxes.FontSize = 14;
    saveas(PlotFigure, fullfile(obj.SMF.Data.ResultsDir, ...
        [BaseName, '_trajectory_lengths.fig']))
        saveas(PlotFigure, fullfile(obj.SMF.Data.ResultsDir, ...
        [BaseName, '_trajectory_lengths.png']))
    close(PlotFigure)

    % Generate a histogram of trajectory fidelity (number of observations
    % divided by the duration in frames).
    PlotFigure = figure();
    PlotAxes = axes(PlotFigure);
    histogram(PlotAxes, NObservations ./ TrajDurations)
    title(PlotAxes, 'Num. observations / duration of trajectory')
    xlabel(PlotAxes, 'Trajectory fidelity')
    PlotAxes.XLim = [0, 1];
    PlotAxes.FontWeight = 'bold';
    PlotAxes.FontSize = 14;
    saveas(PlotFigure, fullfile(obj.SMF.Data.ResultsDir, ...
        [BaseName, '_trajectory_fidelity.fig']))
    saveas(PlotFigure, fullfile(obj.SMF.Data.ResultsDir, ...
        [BaseName, '_trajectory_fidelity.png']))
    close(PlotFigure)

    % Generate a scatterplot of the durations vs. obvservations (this can
    % be helpful to put the histograms in perspective, e.g., if there are a
    % lot of short trajectories with large gaps relative to their length).
    PlotFigure = figure();
    PlotAxes = axes(PlotFigure);
    scatter(PlotAxes, NObservations, TrajDurations, '.')
    hold(PlotAxes, 'on')
    axis(PlotAxes, 'equal')
    SquareLims = [0, max([NObservations; TrajDurations])];
    PlotAxes.XLim = SquareLims;
    PlotAxes.YLim = SquareLims;
    line(PlotAxes, PlotAxes.XLim, PlotAxes.XLim, ...
        'LineStyle', ':', 'LineWidth', 2, 'Color', [0, 0, 0])
    xlabel(PlotAxes, 'Num. of points in trajectory')
    ylabel(PlotAxes, 'Trajectory duration (frames)')
    PlotAxes.FontWeight = 'bold';
    PlotAxes.FontSize = 14;
    saveas(PlotFigure, fullfile(obj.SMF.Data.ResultsDir, ...
        [BaseName, '_trajectory_durations_vs_lengths.fig']))
    saveas(PlotFigure, fullfile(obj.SMF.Data.ResultsDir, ...
        [BaseName, '_trajectory_durations_vs_lengths.png']))
    close(PlotFigure)
end


end
./MATLAB/+smi/@SPT/estimateDiffCoeffs.m
function [DiffusionStruct] = ...
    estimateDiffCoeffs(TR, DiffusionEstimator, DReset)
%estimateDiffCoeffs estimates diffusion coefficients from TR.
% This method estimates diffusion coefficients for the trajectories in 'TR'
% using the provided instance of the smi_stat.DiffusionEstimator class.
%
% INPUTS:
%   TR: Tracking Results structure. (see smi_core.TrackingResults)
%   DiffusionEstimator: Instance of the smi_stat.DiffusionEstimator class.
%                       (Default = smi_stat.DiffusionEstimator)
%   DReset: If 2 elements: Min. and max. diffusion coefficients.
%           If 1 element: Value used to reset all "bad" values.
%           If empty: A bad ensemble diffusion coefficient is reset to a
%                     value of 0.01.  Individual trajectory values are
%                     reset to the ensemble value. (Default = [])
%
% OUTPUTS:
%   DiffusionStruct: DiffusionEstimator.DiffusionStruct with DReset
%                    applied.

% Created by:
%   David J. Schodt (Lidke Lab, 2021)


% Set defaults.
if (~exist('DiffusionEstimator', 'var') || isempty(DiffusionEstimator))
    DiffusionEstimator = smi_stat.DiffusionEstimator;
end
if ~exist('DReset', 'var')
    DReset = [];
end

% Estimate the diffusion coefficients.
DiffusionEstimator.UnitFlag = false;
DiffusionEstimator.FitIndividualTrajectories = true;
DiffusionEstimator.TR = TR;
DiffusionEstimator.estimateDiffusionConstant();
DiffusionStruct = DiffusionEstimator.DiffusionStruct;

% Filter the diffusion coefficients.
if isempty(DReset)
    % An empty DReset means we'll set a bad ensemble value to 1e-5 and bad
    % individual values to the ensemble value.
    ResetBool = ((DiffusionStruct(2).DiffusionConstant<=0) ...
        || isnan(DiffusionStruct(2).DiffusionConstant) ...
        || isinf(DiffusionStruct(2).DiffusionConstant));
    DiffusionStruct(2).DiffusionConstant(ResetBool) = 0.01;
    DiffusionStruct(2).DiffusionConstantSE(ResetBool) = inf;
    ResetBool = ((DiffusionStruct(1).DiffusionConstant<=0) ...
        | isnan(DiffusionStruct(1).DiffusionConstant) ...
        | isinf(DiffusionStruct(1).DiffusionConstant));
    DiffusionStruct(1).DiffusionConstant(ResetBool) = ...
        DiffusionStruct(2).DiffusionConstant;
    DiffusionStruct(1).DiffusionConstantSE(ResetBool) = inf;
elseif (numel(DReset) > 1)
    % DReset represents a minimum and maximum allowed value.
    SetToMin = ((DiffusionStruct(1).DiffusionConstant<DReset(1)) ...
        | isnan(DiffusionStruct(1).DiffusionConstant));
    SetToMax = (DiffusionStruct(1).DiffusionConstant > DReset(2));
    DiffusionStruct(1).DiffusionConstant(SetToMin) = DReset(1);
    DiffusionStruct(1).DiffusionConstant(SetToMax) = DReset(2);
    DiffusionStruct(1).DiffusionConstant(SetToMin | SetToMax) = inf;
    SetToMin = ((DiffusionStruct(2).DiffusionConstant<DReset(1)) ...
        || isnan(DiffusionStruct(2).DiffusionConstant));
    SetToMax = (DiffusionStruct(2).DiffusionConstant > DReset(2));
    DiffusionStruct(2).DiffusionConstant(SetToMin) = DReset(1);
    DiffusionStruct(2).DiffusionConstant(SetToMax) = DReset(2);
    DiffusionStruct(2).DiffusionConstant(SetToMin || SetToMax) = inf;
else
    % DReset is a scalar (assumed) that we'll use to set all bad values.
    ResetBool = ((DiffusionStruct(1).DiffusionConstant<=0) ...
        | isnan(DiffusionStruct(1).DiffusionConstant) ...
        | isinf(DiffusionStruct(1).DiffusionConstant));
    DiffusionStruct(1).DiffusionConstant(ResetBool) = DReset;
    DiffusionStruct(1).DiffusionConstantSE(ResetBool) = inf;
    ResetBool = ((DiffusionStruct(2).DiffusionConstant<=0) ...
        || isnan(DiffusionStruct(2).DiffusionConstant) ...
        || isinf(DiffusionStruct(2).DiffusionConstant));
    DiffusionStruct(2).DiffusionConstant(ResetBool) = DReset;
    DiffusionStruct(2).DiffusionConstantSE(ResetBool) = inf;
end


end
./MATLAB/+smi/@SPT/batchTrack.m
function [TR, SMD, SMDPreThresh, FileList, TransformList] = batchTrack(obj)
%batchTrack performs batch tracking on multiple sets of SPT data.
% This method is a wrapper around obj.performFullAnalysis() which
% simplifies batch tracking.  That is, this method can be used to simplify
% batch tracking for multiple sets of data.
%
% OUTPUTS:
%   TR: Cell array of Tracking Results structures.
%       (see smi_core.TrackingResults)
%   SMD: Cell array of Single Molecule Data structures.
%        (see smi_core.SingleMoleculeData)
%   SMDPreThresh: Cell array of pre-thresholded 'SMD's.
%   FileList: Cell array of the paths to the files which were used.  The
%             indexing matches that of the cell arrays TR and SMD, e.g.,
%             SMD{n} contains the SMD results from file FileList{n}.
%   TransformList: Cell array of the paths to the transform files used.
%                  The indexing matches that of the cell arrays TR and SMD,
%                  e.g., SMD{n} contains was transformed by
%                  TransformList{n}.

% Created by:
%   David J. Schodt (Lidke Lab, 2021)


% Generate a list of all files in obj.SMF.Data.FileDir which match the 
% pattern given in obj.FilePattern (if needed).
if (obj.FindFiles || isempty(obj.SMF.Data.FileName))
    FileNames = smi_helpers.getFileNames(obj.SMF.Data.FileDir, ...
        obj.FilePattern);
    if isempty(FileNames)
        return
    end
else
    FileNames = obj.SMF.Data.FileName;
end
FileList = fullfile(obj.SMF.Data.FileDir, FileNames);
NFiles = numel(FileNames);
if (obj.Verbose > 1)
    fprintf('smi.SPT.batchTrack(): Found %i files to be tracked.\n', NFiles)
    for ii = 1:NFiles
        fprintf('\t%s\n', FileNames{ii})
    end
end

% Match the files to a channel registration file based on their timestamps.
TransformFiles = ...
    smi_helpers.getFileNames(obj.TransformDir, obj.TransformPattern);
NTransforms = numel(TransformFiles);
if isempty(TransformFiles)
    TransformList = repmat({''}, NFiles, 1);
else
    if (NTransforms > 1)
        TransformTimeStrings = ...
            regexp(TransformFiles, obj.TimeStampRegExp, 'match');
        FileTimeStrings = regexp(FileNames, obj.TimeStampRegExp, 'match');
        PairIndices = smi_helpers.pairTimeStrings(...
            FileTimeStrings, TransformTimeStrings, 'before');
        PairedTransforms = TransformFiles(PairIndices);
        TransformList = fullfile(obj.TransformDir, PairedTransforms);
    else
        % If there's only one transform, we don't need to check timestamps.
        PairedTransforms = repmat(TransformFiles(1), NFiles, 1);
        TransformList = fullfile(obj.TransformDir, PairedTransforms);
    end
    if (obj.Verbose > 1)
        fprintf('smi.SPT.batchTrack(): %i transform(s) matched to data.\n', ...
            NTransforms)
        for ii = 1:NFiles
            fprintf('\t%s <-> %s\n',  FileNames{ii}, PairedTransforms{ii})
        end
    end
end

% Temporarily reset obj.IsTestRun so that obj.saveResults() isn't called
% for every iteration.  Also, reset obj.Verbose to hide some outputs during
% iterations.
VerboseInit = obj.Verbose;
obj.Verbose = 0;
IsTestRunInit = obj.IsTestRun;
obj.IsTestRun = (obj.IsTestRun || (obj.SMF.Tracking.NIterMaxBatch>1));

% Loop through the files and perform tracking. For iterative batch
% tracking, track each file with the current set of SMF parameters before
% making a new estimate from the results.
TR = cell(NFiles, 1);
SMD = cell(NFiles, 1);
SMDPreThresh = cell(NFiles, 1);
IsLastIter = false;
ii = 1;
ParamsHistory = {obj.SMF.Tracking};
while ((ii<=obj.SMF.Tracking.NIterMaxBatch) && ~IsLastIter)
    % Send an update to the command window.
    if (VerboseInit > 1)
        fprintf(['smi.spt.batchTrack(): ', ...
            'Batch tracking iteration %i...\n'], ii)
    end
    
    % Check parameters for convergence.
    if (ii > 1)
        Converged = obj.checkConvergence(...
            obj.SMF.Tracking, ParamsHistory{ii-1}, ...
            obj.SMF.Tracking.MaxRelativeChange);
        if ((ii==obj.SMF.Tracking.NIterMaxBatch) || Converged)
            % Indicate it's the last iteration and restore the initial
            % setting of obj.IsTestRun (which, if true, will allow for
            % results to be saved on this last iteration).
            obj.IsTestRun = IsTestRunInit;
            obj.Verbose = VerboseInit;
            IsLastIter = true;
        end
    end
    
    % Track all of the files.
    for ff = 1:NFiles
        if (VerboseInit > 0)
            fprintf('\tsmi.SPT.batchTrack(): Tracking file %i of %i...\n', ...
                ff, NFiles)
        end
        obj.SMF.Tracking = ParamsHistory{ii};
        if IsLastIter
            obj.SMF.Tracking.ParamsHistory = ParamsHistory;
        end
        obj.SMF.Data.RegistrationFilePath = TransformList{ff};
        obj.SMF.Data.FileName = FileNames(ff);
        [TR{ff}, SMD{ff}, SMDPreThresh{ff}] = obj.performFullAnalysis();
        obj.SMDBatch = smi_core.SingleMoleculeData.catSMD(...
            obj.SMDBatch, SMD{ff}, false, (obj.Verbose > 1));
    end
    
    % Update the tracking parameters.
    obj.updateTrackingParams(true)
    ParamsHistory{ii+1, 1} = obj.SMF.Tracking;
    ii = ii + 1;
end

% Restore the filenames in SMF (internally, this is overwitten, which
% becomes annoying when testing batch-tracking in the GUI).
obj.SMF.Data.FileName = FileNames;
if (obj.Verbose > 0)
    fprintf('smi.SPT.batchTrack(): Batch-tracking complete.\n')
end


end
./MATLAB/+smi/@SPT/generateTrajectories.m
function generateTrajectories(obj)
%generateTrajectories generates trajectories from localizations in obj.SMD
% This method will generate trajectories from the localizations in obj.SMD
% using the parameters present in obj.SMF.

% Created by:
%   David J. Schodt (Lidke Lab, 2021)


% Perform the frame-to-frame connection of the localizations.
obj.SMD = obj.genTrajFF(obj.SMD, obj.SMF, obj.RhoOff, obj.NonLinkMarker);

% Throw away unconnected low p-value localizations.
if obj.SMF.Tracking.TryLowPValueLocs
    obj.SMF.Thresholding.MinPValue = obj.SMFCopy.Thresholding.MinPValue;
    [GroupCounts, GroupIDs] = groupcounts(obj.SMD.ConnectID);
    UniqueTraj = GroupIDs(GroupCounts == 1);
    obj.SMD.ThreshFlag = ...
        int32(((obj.SMD.PValue<obj.SMF.Thresholding.MinPValue) ...
        & ismember(obj.SMD.ConnectID, UniqueTraj)));
    obj.SMD = smi_core.Threshold.applyThresh(obj.SMD, obj.Verbose);
end
obj.SMD.ConnectID = smi_helpers.compressToRange(obj.SMD.ConnectID);

% Perform the gap closing on the trajectory segments.
obj.SMD = obj.genTrajGC(obj.SMD, obj.SMF, obj.RhoOff, ...
    obj.NonLinkMarker, obj.UseSparseMatrices);

% Convert obj.SMD to a TR structure.
obj.TR = smi_core.TrackingResults.convertSMDToTR(obj.SMD);


end
./MATLAB/+smi/@SPT/connectTrajGC.m
function [SMD] = connectTrajGC(SMD, Link12)
%connectTrajGC connects gaps in trajectories in an SMD structure.
% Given an Mx1 vector Link12 containing gap closing data found by
% smi.SPT.solveLAP(), this method will connect (as appropriate)
% trajectories in a global sense.
%
% NOTE: This method assumes that min(SMD.ConnectID)==1 .
%
% INPUTS:
%   SMD: Single Molecule Data structure (see smi_core.SingleMoleculeData)
%        containing the localizations that we wish to stitch into
%        trajectories.
%   Link12: Vector containing the gap closing data as found by
%           smi.SPT.solveLAP(), where M is twice the number of trajectories
%           which have been considered by the gap closing LAP. 
%           Link12 is defined such that, e.g., if Link12(7) = 3, 
%           the end of the third trajectory should be linked to the start 
%           of the seventh trajectory. (Mx1)
%
% OUTPUTS:
%   SMD: Input SMD structure which contains the modified ConnectID field 
%        corresponding to newly linked localizations.
%
% CITATION:

% Created by:
%   David J. Schodt (Lidke lab, 2018)
%   Revised by Hanieh Mazloom-Farsibaf (Lidke lab, 2019)
%   Reorganized with minor revisions, David J. Schodt (Lidke Lab, 2020)


% Keep original ConnectID before Gap Closing (=SMD.PreGCConnectID) and
% define the SMD.ConnectID for final results.
SMD.PreGCConnectID = SMD.ConnectID;

% Determine the maximum value of ConnectID for later use.
MaxTrajID = max(SMD.ConnectID);

% Loop through all of the potential gaps, assuming that the ConnectID
% consists of consecutive integers up until this point.
for ee = 1:MaxTrajID
    % If a gap has been closed, trajectories with ConnectID's Link12(ee)
    % and ee (which were previously thought to be distinct trajectories)
    % should be linked, and thus their ConnectID's should be set to the
    % same value. The linked trajectories will be assigned a ConnectID
    % that is the minimum of the ConnectID of the trajectory end being
    % considered (which is just ee), the ConnectID of the trajectory
    % beginning it was linked to (Link12(ee)), and the ID which was 
    % previously re-assigned to another segment associated with the ee-th
    % (or Link12(ee)-th) trajectory.
    
    % If the end of trajectory ee was linked to the start of
    % another trajectory (and not to a death), we will assign each of them
    % the same trajectory ID.
    if (Link12(ee) <= MaxTrajID)
        % Create a boolean array indicating which trajectory ID's we will
        % be updating.  We need to update the ee-th trajectory, the
        % Link12(ee)-th trajectory, as well as trajectories previously
        % connected to either of those trajectories.
        UpdateBoolean = ismember(SMD.PreGCConnectID, [ee, Link12(ee)]);
        UpdateBoolean = (UpdateBoolean ...
            | ismember(SMD.ConnectID, SMD.ConnectID(UpdateBoolean)));
                
        % If the ee-th trajectory ID was already re-assigned, determine
        % which ID it was assigned to.
        ReassignedCurrentID = min(SMD.ConnectID(SMD.PreGCConnectID == ee));
        
        % If linking to a trajectory which itself had already been given a
        % new trajectory ID (i.e. the trajectory with id Link12(ee) has
        % been assigned a new ConnectID ~= Link12(ee)), we also want to
        % consider assigning the current trajectory the updated ConnectID
        % associated with Link12(ee).
        ReassigedLinkID = ...
            min(SMD.ConnectID(SMD.PreGCConnectID == Link12(ee)));
        
        % Re-assign the appropriate set of trajectories to their new
        % ConnectID.
        NewID = min([ee, Link12(ee), ReassignedCurrentID, ReassigedLinkID]);
        SMD.ConnectID(UpdateBoolean) = int32(NewID);
    end
end

% Ensure SMD.ConnectID consists of the set of integers 1:NTraj without
% skipping any integers.
SMD.ConnectID = smi_helpers.compressToRange(SMD.ConnectID);


end
./MATLAB/+smi/@SPT/estimateRateParameters.m
function [KOn, KOff] = estimateRateParameters(SMD)
%estimateRateParameters estimates blinking rates for localizations in SMD
% This method will make an estimate of the blinking kinetics (KOn, KOff) 
% based on the localizations in SMD associated by SMD.ConnectID.
%
% INPUTS:
%   SMD: Single Molecule Data structure (see smi_core.SingleMoleculeData)
%        containing localizations associated by SMD.ConnectID
%
% OUTPUTS:
%   KOn: Rate parameter for blinking on (1 / frame)
%   KOff: Rate parameter for blinking off (1 / frame)
%
% CITATION:

% Created by:
%   David J. Schodt (Lidke Lab, 2021)


% Grab some arrays from the SMD (sometimes can help with speed).
FrameNum = SMD.FrameNum;
ConnectID = SMD.ConnectID;

% Determine the bright and dark durations for each trajectory.
OnDurations = [];
OffDurations = [];
UniqueIDs = unique(ConnectID);
for ii = 1:numel(UniqueIDs)
    CurrentTraj = (SMD.ConnectID == UniqueIDs(ii));
    FrameDiff = diff(FrameNum(CurrentTraj));
    OffIndices = find(FrameDiff ~= 1);
    if isempty(OffIndices)
        continue
    end
    OffDurations = [OffDurations; FrameDiff(OffIndices) - 1];
    OnDurations = [OnDurations; OffIndices(1); diff(OffIndices)];
end

% Make an estimate of the rate parameters, setting a default value if not
% enough information is available.
KOn = -log(1 - 1/mean(OffDurations));
KOff = -log(1 - 1/mean(OnDurations));

% If needed, reset KOn and KOff to boundary values.
% NOTE: I'm taking max(SMD.NFrames) in case it's stored as an array instead
%       of a scalar.
KOn = min(numel(FrameNum)/max(SMD.NFrames), max(1e-5, KOn));
KOff = min(1, max(1/numel(FrameNum), KOff));
if isnan(KOn)
    KOn = numel(FrameNum) / max(SMD.NFrames);
end
if isnan(KOff)
    KOff = 1 / NLocalizations;
end


end
./MATLAB/+smi/@SPT/README.md
### +smi/@SPT

SPT contains methods useful for single-particle tracking analysis.
  This class contains a collection of analysis/visualization methods
  useful for the analysis of single-particle tracking data.

REQUIRES:
- Image Processing Toolbox
- Statistics and Machine Learning Toolbox

---

```
properties:
    % Structure of parameters (see smi_core.SingleMoleculeFitting)
    SMF
    
    % Directory containing channel reg. transforms (char array)
    % NOTE: This property is only used in obj.batchTrack().
    TransformDir = '';
    
    % Pattern to match for transform files in TransformDir.
    % (see obj.batchTrack() for usage)
    % NOTE: This is used in the MATLAB built-in method dir(), which
    %       allows for a wildcard (*) in the name, but not a full
    %       regexp.
    TransformPattern = 'RegistrationTransform*.mat';
    
    % Indicate we should search for files to track. (Default = true)
    % NOTES: This is only used in obj.batchTrack().  If true,
    %        obj.batchTrack() will search for the files matching
    %        obj.FilePattern in obj.SMF.Data.FileDir.  If false, the
    %        files in obj.SMF.Data.FileName will be used instead.
    FindFiles = true;
    
    % Pattern to match for file names in obj.SMF.FileDir.
    % (see obj.batchTrack() for usage)
    % NOTE: This is used in the MATLAB built-in method dir(), which
    %       allows for a wildcard (*) in the name, but not a full
    %       regexp.
    FilePattern = '*.mat';
    
    % Diffusion estimator class for when UseTrackByTrackD is set.
    % NOTE: This is used here so that the user can change properties of
    %       the DiffusionEstimator class as needed when using
    %       obj.SMF.Tracking.TrajwiseD
    DiffusionEstimator
    
    % Structure of parameters used when generating movies.
    % NOTE: This only gets used when calling obj.saveResults() when
    %       obj.GenerateMovies = true.
    MovieParams
    
    % Marker to ignore entries in cost matrices (Default = -1)
    % NonlinkMarker can't be inf or NaN.
    NonLinkMarker = -1;
    
    % Flag to indicate movies should be made (Default = true)
    GenerateMovies = true;
    
    % Flag to indicate plots should be made (Default = true)
    GeneratePlots = true;
    
    % Flag to indicate test run (Default = false)
    IsTestRun = false;
    
    % Flag to make some outputs in physical units (Default = false)
    UnitFlag = false;
    
    % Flag to indicate sparse matrix usage (Default = true)
    % For now, this only applies to gap-closing.
    UseSparseMatrices = true;
    
    % Verbosity of the main analysis workflow. (Default = 1)
    Verbose = 1;
```

./MATLAB/+smi/@SPT/updateTrackingParams.m
function [] = updateTrackingParams(obj, IsBatch)
%updateTrackingParams updates tracking parameters based on previous results
% This method will attempt to update as many SMF.Tracking parameters as
% possible from obj.SMD, obj.SMDBatch, obj.TR, ..., as well as computing
% DiffusionCoefficients for the trajectories in obj.SMD.  The intention is 
% that this can simplify iterative tracking by making all parameter updates
% in one methods.
%
% INPUTS:
%   IsBatch: Flag indicating parameters should be estimated for the entire
%            batch if possible.  Note that only the rate parameters will be
%            affected by this flag, as the density and diffusion
%            coefficients should always be estimated for the current file
%            being tracked.  (Default = true)
%
% CITATION:

% Created by:
%   David J. Schodt (Lidke Lab, 2021)


% Set defaults.
if (~exist('IsBatch', 'var') || isempty(IsBatch))
    IsBatch = true;
end

% If SMD has the field ConnectID populated, estimate diffusion constants
% and rate parameters.
if isempty(obj.SMD.ConnectID)
    % Make sure SMF.Tracking.D matches the size of SMD.
    obj.SMF.Tracking.D = padarray(obj.SMF.Tracking.D, ...
        [max(0, numel(obj.SMD.FrameNum)-numel(obj.SMF.Tracking.D)), 0], ...
        median(obj.SMF.Tracking.D(:)), 'post');
else
    % Update the diffusion coefficients, storing results so that indices
    % match indices of obj.SMD.
    obj.DiffusionEstimator.FitIndividualTrajectories = ...
        obj.SMF.Tracking.TrajwiseD;
    DiffusionStruct = obj.estimateDiffCoeffs(obj.TR, obj.DiffusionEstimator);
    obj.SMF.Tracking.D = ...
        DiffusionStruct(2).DiffusionConstant * ones(size(obj.SMD.FrameNum));
    if obj.SMF.Tracking.TrajwiseD
        for ii = 1:numel(obj.TR)
            obj.SMF.Tracking.D(obj.TR(ii).IndSMD, 1) = ...
                DiffusionStruct(1).DiffusionConstant(ii);
        end
    end
    
    % Update our rate parameter estimates.  If batch tracking, we should
    % try to update 
    if (~isempty(obj.SMDBatch) && IsBatch)
        [obj.SMF.Tracking.K_on, obj.SMF.Tracking.K_off] = ...
            obj.estimateRateParameters(obj.SMDBatch);
    else
        [obj.SMF.Tracking.K_on, obj.SMF.Tracking.K_off] = ...
            obj.estimateRateParameters(obj.SMD);
    end
end

% Estimate the density of off emitters for the current file.
obj.RhoOff = obj.estimateDensities(obj.SMD, obj.SMF);


end
./MATLAB/+smi/@SPT/genTrajGC.m
function [SMD] = genTrajGC(SMD, SMF, RhoOff, ...
    NonLinkMarker, UseSparseMatrices)
%genTrajFF connects trajectory segments into longer trajectories.
% This method solves the linear assignment problem for connecting
% trajectory segments into longer trajectories.
%
% INPUTS:
%   SMD: Single Molecule Data structure (see smi_core.SingleMoleculeData)
%        containing the localizations that we wish to stitch into
%        trajectories.
%   SMF: Single Molecule Fitting structure defining many of the parameters
%        we'll just to populate cost matrix elements.
%       (see smi_core.SingleMoleculeFitting)
%   RhoOff: Density of dark emitters, given as an image with the same
%           aspect ratio as the SMD coordinate system.
%   NonLinkMarker: A marker in the output CostMatrix that indicates we
%                  don't want to select that element in the linear
%                  assignment problem.
%                  (scalar, ~=inf, ~=nan, and typically < 0)(Default = -1)
%   UseSparseMatrices: This boolean flag will determine whether or not we
%                      should define the gap closing CM as a sparse matrix
%                       (and represent it in MATLAB as a sparse type) or
%                       as a "regular" matrix with a NonLinkMarker for
%                       uninteresting costs.
%                       (boolean flag, 0 or 1)(Default = true)
%
% OUTPUTS:
%   SMD: Single Molecule Data structure (see smi_core.SingleMoleculeData)
%        with field ConnectID representing trajectory membership.

% Created by:
%   David J. Schodt (Lidke Lab, 2021)


% Set defaults.
if (~exist('NonLinkMarker', 'var') || isempty(NonLinkMarker))
    NonLinkMarker = -1;
end
if (~exist('UseSparseMatrices', 'var') || isempty(UseSparseMatrices))
    UseSparseMatrices = true;
end

% Cluster trajectories together so that we can solve several smaller LAPs.
TrajClusters = smi_cluster.clusterSTDist(SMD, ...
    SMF.Tracking.MaxFrameGap, SMF.Tracking.MaxDistGC);

% Solve the gap-closing LAP(s).
UniqueClusters = unique(TrajClusters);
SMDOut = smi_core.SingleMoleculeData.createSMD();
for nn = UniqueClusters.'
    SMDSub = smi_core.SingleMoleculeData.isolateSubSMD(SMD, ...
        TrajClusters == nn);
    SMDSub.ConnectID = smi_helpers.compressToRange(SMDSub.ConnectID);
    CostMatrix = smi.SPT.createCostMatrixGC(SMDSub, SMF, RhoOff, ...
        NonLinkMarker, UseSparseMatrices);
    Link12 = smi.SPT.solveLAP(CostMatrix);
    SMDSub = smi.SPT.connectTrajGC(SMDSub, Link12);
    SMDOut = smi_core.SingleMoleculeData.catSMD(SMDOut, SMDSub, ...
        false, false);
end
SMD = SMDOut;


end
./MATLAB/+smi/@SPT/createCostMatrixGC.m
function [CostMatrix, StartEndIndices] = createCostMatrixGC(SMD, SMF, ...
    RhoOff, NonLinkMarker, CreateSparseMatrix)
%createCostMatrixGC creates the cost matrix for gap closing in SPT.
% This method creates a cost matrix whose elements represent the cost for
% connecting trajectory segments produced by the frame-to-frame step in the
% typical smi.SPT workflow.
%
% INPUTS:
%   SMD: Single Molecule Data structure (see smi_core.SingleMoleculeData)
%        containing the localizations that we wish to stitch into
%        trajectories.
%   SMF: Single Molecule Fitting structure defining many of the parameters
%        we'll just to populate cost matrix elements.
%       (see smi_core.SingleMoleculeFitting)
%   RhoOff: Density of dark emitters, given as an image with the same
%           aspect ratio as the SMD coordinate system.
%   NonLinkMarker: A marker in the output CostMatrix that indicates we
%                  don't want to select that element in the linear
%                  assignment problem.
%                  (scalar, ~=inf, ~=nan, and typically < 0)(Default = -1)
%   CreateSparseMatrix: This boolean flag will determine whether or not we
%                       should define the output CM as a sparse matrix
%                       (and represent it in MATLAB as a sparse type) or
%                       as a "regular" matrix with a NonLinkMarker for
%                       uninteresting costs.
%                       (boolean flag, 0 or 1)(Default = 1)
%
% OUTPUTS:
%   CostMatrix: The cost matrix whose elements represent the cost for
%               connecting the end of one trajectory to the start of
%               another trajectory in a future frame.
%               (2*NTraj x 2*NTraj numeric array, where NTraj is the
%               number of trajectories in the input SMD structure)
%   StartEndIndices: Array of SMD indices corresponding to the start and
%                    end localizations of trajectories.  These indices map
%                    to the CostMatrix elements as follows: 
%                    CostMatrix(mm, nn) contains the cost of linking the
%                    SMD localization with index StartEndIndices(mm, 2) to
%                    that with index StartEndIndices(nn, 1). 
%                    (NTraj x 2 numeric array)
%
% CITATION:

% Created by
%   Elton Jhamba (Lidke Lab, 2018)
%   Hanieh Mazloom-Farsibaf, Michael Wester (Lidke Lab, 2019)
%   Rewritten for sparse matrices, David J. Schodt (Lidke Lab, Spring 2020)
%   Rewritten for smite, David J. Schodt (Lidke Lab, 2021)


% Set defaults as needed.
if (~exist('NonLinkMarker', 'var') || isempty(NonLinkMarker))
    NonLinkMarker = -1;
end
if (~exist('CreateSparseMatrix', 'var') || isempty(CreateSparseMatrix))
    CreateSparseMatrix = true;
end

% Extract some arrays from the SMD/SMF structure.  Doing this outside of
% for loops can speed things up for very large SMD structures (although for
% small SMD structures this has the potential to slow things down, but then
% we don't care about speed).
X = SMD.X;
Y = SMD.Y;
X_SE = SMD.X_SE;
Y_SE = SMD.Y_SE;
Photons = SMD.Photons;
FrameNum = SMD.FrameNum;
ConnectID = SMD.ConnectID;
MaxDistGC = SMF.Tracking.MaxDistGC;
MaxZScoreDist = SMF.Tracking.MaxZScoreDist;
MaxZScorePhotons = SMF.Tracking.MaxZScorePhotons;
MaxFrameGap = SMF.Tracking.MaxFrameGap;
K_on = SMF.Tracking.K_on;
K_off = SMF.Tracking.K_off;
DiffusionCoefficients = SMF.Tracking.D;

% Define various parameters that will be useful later on.
NTraj = max(ConnectID);
CMSize = 2 * NTraj * [1, 1];

% Determine the starting and ending indices within SMD of each trajectory.
% Also, compute some other quantities that we'll use later.
% NOTE: For PhotonStDev, a standard deviation of 0 likely means the track
%       is only one localization, so setting those values to inf will
%       ensure we can still connect them into longer trajectories.
StartEndIndices = zeros(NTraj, 2);
PhotonMean = zeros(NTraj, 1);
PhotonStDev = PhotonMean;
for ii = 1:NTraj
    % Determine the start/end indices.
    CurrentTrajBool = (ConnectID == ii);
    CurrentFrames = FrameNum(CurrentTrajBool);
    StartEndIndices(ii, :) = ...
        [find((FrameNum==min(CurrentFrames)) & CurrentTrajBool), ...
        find((FrameNum==max(CurrentFrames)) & CurrentTrajBool)];
    
    % Compute the mean and standard deviation of the photon counts for each
    % trajectory.
    PhotonMean(ii) = mean(Photons(CurrentTrajBool));
    PhotonStDev(ii) = std(Photons(CurrentTrajBool));
end
PhotonStDev(PhotonStDev == 0) = inf;

% Initialize the cost matrix index array and element array (this is the
% best way to create a sparse matrix, but we can also use this for the
% non-sparse, "regular" matrix type).
% NOTE: Since the birth and death blocks are fully-populated (i.e., at
%       half of the matrix is non-zero), we can allocate the entire set of
%       CMElements (since appending new values to the end might temporarily
%       lead to even more memory usage than just doing this from the
%       start).
CMIndices = [repelem((1:CMSize(1)).', CMSize(1)), ...
    repmat((1:CMSize(1)).', [CMSize(1), 1])];
CMElements = NonLinkMarker * ones(CMSize(1)^2, 1);

% Fill in the NTraj x NTraj upper-left block (the link block) and the
% auxillary (bottom-left) block.
CostTurningOff = -log(1 - exp(-K_off));
CostTurningBackOn = -log(1 - exp(-K_on));
for ee = 1:NTraj
    % Isolate the end of the ee-th trajectory.
    EndIndexCurrent = StartEndIndices(ee, 2);
    EndFrameCurrent = FrameNum(EndIndexCurrent);
    XEndCurrent = X(EndIndexCurrent);
    X_SEEndCurrent = X_SE(EndIndexCurrent);
    YEndCurrent = Y(EndIndexCurrent);
    Y_SEEndCurrent = Y_SE(EndIndexCurrent);
    DEndCurrent = DiffusionCoefficients(EndIndexCurrent);
    MeanPhotonsCurrent = PhotonMean(ee);
    StDevPhotonsCurrent = PhotonStDev(ee);
    
    % Loop through the trajectory beginnings and populate the cost matrix.
    for bb = 1:NTraj
        if (ee == bb)
            % No need to run the rest of the code, we don't care about this
            % cost.
            continue
        end
        
        % Isolate the index corresponding to the beginning of the bb-th
        % trajectory.
        % NOTE: We won't be granted any time savings by defining separate
        %       like XBeginCurrent here (as we had for XEndCurrent above)
        %       since each of those would only get used once.
        StartIndexCurrent = StartEndIndices(bb, 1);
        
        % Determine how many frames have elapsed between the end of
        % trajectory ee and the start of trajectory bb.
        DeltaFrame = FrameNum(StartIndexCurrent) - EndFrameCurrent;
        if (DeltaFrame <= 0)
            continue
        end
        
        % Compute the distance between the end of trajectory ee and the
        % start of trajectory bb as well as other relevant differences.
        XJump = XEndCurrent - X(StartIndexCurrent);
        YJump = YEndCurrent - Y(StartIndexCurrent);
        Separation = sqrt(XJump^2 + YJump^2);
        PhotonsDev = abs(MeanPhotonsCurrent - PhotonMean(bb));
        
        % Define the standard deviations of the distribution of
        % observed X and Y separations between two localizations in
        % separated in time by DeltaFrame frames, assuming they came
        % from the same emitter which experienced Brownian motion with
        % diffusion constant D.
        % NOTE: I think it makes more sense to use D==DEndCurrent, however
        %       in some cases (e.g., connecting very small trajectories)
        %       this proved to cause some issues.  Instead, I'll try using
        %       the average of the two diffusion constants.
        DSumCurrent = DEndCurrent + DiffusionCoefficients(StartIndexCurrent);
        Sigma_X = sqrt(DSumCurrent*DeltaFrame ...
            + X_SEEndCurrent^2 + X_SE(StartIndexCurrent)^2);
        Sigma_Y = sqrt(DSumCurrent*DeltaFrame ...
            + Y_SEEndCurrent^2 + Y_SE(StartIndexCurrent)^2);
        
        % Compute the cost corresponding to linking these two trajectories
        % (unless the MaxDist and MaxFrameGap aren't satisified, in which
        % case we don't care to calculate this cost).
        ZScorePhotons = PhotonsDev ...
            / sqrt(StDevPhotonsCurrent^2+PhotonStDev(bb)^2);
        if ((DeltaFrame<=MaxFrameGap) ...
                && (Separation<=MaxDistGC) ...
                && (abs(XJump/Sigma_X)<=MaxZScoreDist) ...
                && (abs(YJump/Sigma_Y)<=MaxZScoreDist) ...
                && (ZScorePhotons<=MaxZScorePhotons))
            % Define the log-likelihood of the observed X, Y from
            % FrameNumber and FrameNumber+1 having come from the Normal
            % distributions defined by Sigma_X and Sigma_Y (i.e., this is
            % -log(Normal(mean = 0, Sigma_X) * Normal(mean = 0, Sigma_Y))
            NegLogLikelihoodOfXandY = log(2*pi*Sigma_X*Sigma_Y) ...
                + (XEndCurrent-X(StartIndexCurrent))^2 / (2*Sigma_X^2) ...
                + (YEndCurrent-Y(StartIndexCurrent))^2 / (2*Sigma_Y^2);
            
            % Compute the negative log-likelihood of these two trajectories
            % arising from the same emitter. To clarify, this is
            % -log(NormalX * NormalY
            %   * P(traj ee turning off)
            %   * P(traj ee not turning on for DeltaFrame-1 frames)
            %   * P(traj ee turning back on as traj bb)
            % NOTE: There are implicit DeltaT's multiplying all transition
            %       rates, where DeltaT = 1 frame.
            % NOTE: The additional 0.5 multiplying the gap-closing costs
            %       comes from our choice to set the "auxillary" (bottom
            %       right) block of the cost matrix equal to the transpose
            %       of the "gap-closing" block.  With that choice, we have
            %       argued (but not proven!) that any element selected in
            %       the gap-closing block during the linear assignment
            %       problem will be selected in the "auxillary" block as
            %       well (and vice versa), and thus the factor of 0.5
            %       ensures that the total cost of elements selected in the
            %       LAP will be consistent with the physically reasonable
            %       costs we've defined otherwise.
            % NOTE: The usage of sub2ind() has the rows and columns
            %       reversed from normal usage.  This is an artifact
            %       resulting from differing conventions used in MATLAB:
            %       usually, MATLAB is column oriented, but our usage of
            %       CMIndices here (and in sparse()) is row oriented.
            CMElements(sub2ind(CMSize, bb, ee)) = ...
                0.5 * (NegLogLikelihoodOfXandY ...
                + CostTurningOff ...
                + (DeltaFrame-1)*K_on ...
                + CostTurningBackOn);
            
            % Store the corresponding element of the "auxillary" block.
            CMElements(sub2ind(CMSize, ee+NTraj, bb+NTraj)) = ...
                CMElements(sub2ind(CMSize, bb, ee));
        end
    end
end

% Rescale the trajectory coordinates to match the size of RhoOff (which 
% can be an image with the same aspect ratio as SMD coordinates).
Scale = size(RhoOff) ./ [SMD.YSize, SMD.XSize];
Y = min(size(RhoOff, 1), ...
    max(1, ceil((SMD.Y(StartEndIndices(:, 2))-0.5)*Scale(1) + 0.5)));
X = min(size(RhoOff, 2), ...
    max(1, ceil((SMD.X(StartEndIndices(:, 2))-0.5)*Scale(2) + 0.5)));

% Fill in the "birth" block (lower left) of the cost matrix.
% NOTE: We set FirstFrame = 1 instead of min(SMD.FrameNum) based on the
%       assumption that our experiment started at time corresponding to
%       FrameNum = 1, even if we don't have any localizations in that
%       frame.
FirstFrame = 1;
OnesArray = ones(1, NTraj);
for bb = 1:NTraj
    % Find the starting frame for the bb-th trajectory.
    StartIndexCurrent = StartEndIndices(bb, 1);
    StartFrameCurrent = FrameNum(StartIndexCurrent);
    
    % Compute the cost of "birth" for this trajectory (i.e., this is
    % -log(P(traj bb turning on)
    %   * P(traj bb not turning on for StartFrame-FirstFrame frames))
    % NOTE: There are implicit factors of DeltaT = 1 frame multiplying all
    %       transition rates.
    % NOTE: The usage of sub2ind() has the rows and columns reversed from
    %       normal usage.  This is an artifact resulting from differing
    %       conventions used in MATLAB: usually, MATLAB is column oriented,
    %       but our usage of CMIndices here (and sparse()) is row oriented.
    FrameGap = min(MaxFrameGap, StartFrameCurrent-FirstFrame);
    CostTurningOn = -log(RhoOff(Y(bb), X(bb)) * (1-exp(-K_on)));
    CMElements(sub2ind(CMSize, bb*OnesArray, (NTraj+1):(2*NTraj))) = ...
        CostTurningOn + FrameGap*K_on;
end

% Fill in the "death" block (upper-right) of the cost matrix.
LastFrame = SMD.NFrames;
CostTurningOff = -log(1 - exp(-K_off));
for ee = 1:NTraj
    % Find the ending frame for the ee-th trajectory.
    EndIndexCurrent = StartEndIndices(ee, 2);
    EndFrameCurrent = FrameNum(EndIndexCurrent);
    
    % Compute the cost of "death" for this trajectory (i.e., this is
    % -log(P(traj ee turning off)
    %   * P(traj ee not turning back on for LastFrame-EndFrame frames)
    % NOTE: There are implicit factors of DeltaT = 1 frame multiplying all
    %       transition rates.
    % NOTE: The usage of sub2ind() has the rows and columns reversed from
    %       normal usage.  This is an artifact resulting from differing
    %       conventions used in MATLAB: usually, MATLAB is column oriented,
    %       but our usage of CMIndices here (and sparse()) is row oriented.
    FrameGap = min(MaxFrameGap, LastFrame-EndFrameCurrent);
    CMElements(sub2ind(CMSize, (NTraj+1):(2*NTraj), ee*OnesArray)) = ...
        CostTurningOff + FrameGap*K_on;
end

% Remove all of the remaining NonLinkMarker elements.
KeepBool = (CMElements ~= NonLinkMarker);
CMElements = CMElements(KeepBool);
CMIndices = CMIndices(KeepBool, :);
clear('KeepBool')

% Create the cost matrix.
if CreateSparseMatrix
    % Create the output CostMatrix as a sparse type.
    CostMatrix = sparse(CMIndices(:, 1), CMIndices(:, 2), ...
        double(CMElements));
else
    % Create the output CostMatrix as a full sized matrix.
    CostMatrix = NonLinkMarker * ones(CMSize);
    CostMatrix(sub2ind(CMSize, CMIndices(:, 1), CMIndices(:, 2))) = ...
        CMElements;
end


end
./MATLAB/+smi/@SPT/unitTestFFGC.m
function [Success] = unitTestFFGC()
%unitTestFFGC tests the frame-to-frame and gap closing processes.
% This method was written with the intention of being a general smi.SPT
% testing script to test the internal SPT components (e.g., frame-to-frame
% connection, gap closing, and associated methods).  The idea behind this
% unit test is to test the tracking components without concern for the
% underlying localizations (i.e., we start from perfect localizations).


% Simulate Tracking Data (create a simulated SMD structure).
SPTSim = smi_sim.SimSPT;
SPTSim.SimParams.ParticleDensity = 0.01;
SPTSim.SimParams.Intensity = 500;
SPTSim.createSimulation()
SMD = SPTSim.SMD;
SMF = smi_core.SingleMoleculeFitting;
SMF.Data.DataROI = [1, 1, SMD.YSize, SMD.XSize];
SMF.Fitting.PSFSigma = 1.3;
[~, RawData] = smi_sim.GaussBlobs.gaussBlobImage(SMD, SMF, 5);

% Perform the frame-to-frame connection process.
SMF = smi_core.SingleMoleculeFitting();
SMF.Tracking.D = SPTSim.SimParams.D * ones(size(SMD.FrameNum));
SMF.Tracking.K_off = SPTSim.SimParams.KOnToOff;
SMF.Tracking.K_on = SPTSim.SimParams.KOffToOn;
SMF.Tracking.MaxFrameGap = 20;
SMF.Tracking.MaxDistGC = 10;
SMF.Tracking.MaxDistFF = 2 * SMF.Tracking.MaxDistGC ...
    / sqrt(SMF.Tracking.MaxFrameGap);
SMD.ConnectID = zeros(numel(SMD.X), 1); 
RhoOnMean = mean(smi_core.SingleMoleculeData.computeDensity(SMD));
RhoOffMean = (SPTSim.SimParams.KOnToOff/SPTSim.SimParams.KOffToOn) * RhoOnMean;
SMF.Tracking.Rho_off = RhoOffMean;
for ff = min(SMD.FrameNum):(max(SMD.FrameNum)-1)
    [CM] = smi.SPT.createCostMatrixFF(SMD, SMF, RhoOffMean, ff, -1);
    [Link12] = smi.SPT.solveLAP(CM);
    [SMD] = smi.SPT.connectTrajFF(SMD, Link12, ff);
end

% Perform the gap-closing process.
[CM] =smi.SPT.createCostMatrixGC(SMD, SMF, RhoOffMean, -1, 1); 
[Link12] = smi.SPT.solveLAP(CM);
[SMD] = smi.SPT.connectTrajGC(SMD, Link12);
TR = smi_core.TrackingResults.convertSMDToTR(SMD);

% Make a movie.
MovieMaker = smi_vis.GenerateMovies;
MovieMaker.TR = TR;
MovieMaker.RawData = RawData;
MovieMaker.gui()

% Indicate success (this should be done in a better way, just setting it to
% 1 here isn't very useful).
Success = 1;


end
./MATLAB/+smi/@SPT/SPT.m
classdef SPT < handle
    % SPT contains methods useful for single-particle tracking analysis.
    %   This class contains a collection of analysis/visualization methods
    %   useful for the analysis of single-particle tracking data.
    %
    % REQUIRES:
    %   Image Processing Toolbox
    %   Statistics and Machine Learning Toolbox

    % Created by:
    %   David J. Schodt (Lidke lab, 2021)
    
    
    properties
        % Structure of parameters (see smi_core.SingleMoleculeFitting)
        SMF
        
        % Directory containing channel reg. transforms (char array)
        % NOTE: This property is only used in obj.batchTrack().
        TransformDir = '';
        
        % Pattern to match for transform files in TransformDir.
        % (see obj.batchTrack() for usage)
        % NOTE: This is used in the MATLAB built-in method dir(), which
        %       allows for a wildcard (*) in the name, but not a full
        %       regexp.
        TransformPattern = 'RegistrationTransform*.mat';
        
        % Indicate we should search for files to track. (Default = true)
        % NOTES: This is only used in obj.batchTrack().  If true,
        %        obj.batchTrack() will search for the files matching
        %        obj.FilePattern in obj.SMF.Data.FileDir.  If false, the
        %        files in obj.SMF.Data.FileName will be used instead.
        FindFiles = true;
        
        % Pattern to match for file names in obj.SMF.FileDir.
        % (see obj.batchTrack() for usage)
        % NOTE: This is used in the MATLAB built-in method dir(), which
        %       allows for a wildcard (*) in the name, but not a full
        %       regexp.
        FilePattern = '*.mat';
        
        % Diffusion estimator class for when UseTrackByTrackD is set.
        % NOTE: This is used here so that the user can change properties of
        %       the DiffusionEstimator class as needed when using
        %       obj.SMF.Tracking.TrajwiseD
        DiffusionEstimator
        
        % Structure of parameters used when generating movies.
        % NOTE: This only gets used when calling obj.saveResults() when
        %       obj.GenerateMovies = true.
        MovieParams
        
        % Marker to ignore entries in cost matrices (Default = -1)
        % NonlinkMarker can't be inf or NaN.
        NonLinkMarker = -1;
        
        % Flag to indicate movies should be made (Default = true)
        GenerateMovies = true;
        
        % Flag to indicate plots should be made (Default = true)
        GeneratePlots = true;
        
        % Flag to indicate test run (Default = false)
        IsTestRun = false;
        
        % Flag to make some outputs in physical units (Default = false)
        UnitFlag = false;
        
        % Flag to indicate sparse matrix usage (Default = true)
        % For now, this only applies to gap-closing.
        UseSparseMatrices = true;
        
        % Verbosity of the main analysis workflow. (Default = 1)
        Verbose = 1;
    end
    
    properties (SetAccess = protected)
        % Single Molecule Data structure (see smi_core.SingleMoleculeData)
        % NOTE: SMD contains the localizations in SMDPreThresh for which
        %       ThreshFlag was equal to 0 (i.e., the localizations which
        %       we wish to keep)
        SMD
        
        % Pre-threshold SMD structure (see smi_core.SingleMoleculeData)
        SMDPreThresh

        % SMD concatenated across all data in obj.batchTrack().
        SMDBatch = struct([]);
        
        % Tracking Results structure (see smi_core.TrackingResults)
        TR
        
        % Tracking Results structure before channel registration.
        TRPreCR = struct([]);
        
        % 'SMD' before channel registration is applied.
        SMDPreCR = struct([]);
        
        % Pre-threshold pre-channel registration 'SMD'.
        SMDPreThreshPreCR = struct([]);
        
        % Scaled raw data.
        ScaledData
        
        % Density of dark emitters. (see obj.estimateDensities() for usage)
        RhoOff

        % Internally used smi.SMLM instance.
        SMLM = smi.SMLM(smi_core.SingleMoleculeFitting, false);
    end
    
    properties (Hidden)       
        % Copy of the SMF structure.
        % This is used for a few random tests/things like
        % obj.TryLowPValueLocs which, when enabled, requires us to modify
        % the SMF provided by the user.  We will want to revert to the
        % user's original SMF if that's done.
        SMFCopy
        
        % Regular expression for filename timestamps.
        % NOTE: This is used in obj.batchTrack()
        TimeStampRegExp = '\d{4,}-\d{1,2}-\d{1,2}-\d{1,2}-\d{1,2}-\d{1,2}';
        
        % Delimiter in the timestamp regular expression.
        % NOTE: This is used in obj.batchTrack()
        TimeStampDelimiter = '-';
    end
    
    methods
        
        function obj = SPT(SMF, StartGUI)
            %SPT is the class constructor for SPT.
            %
            % INPUTS:
            %   SMF: Single Molecule Fitting structure.
            %        (Default = smi_core.SingleMoleculeFitting with some
            %        minor changes to parameters).
            %   StartGUI: Flag to decide if GUI should be opened
            %             automatically. (Default = true)
            
            % Set defaults if needed.
            if (~exist('SMF', 'var') || isempty(SMF))
                SMF = smi_core.SingleMoleculeFitting;
            end
            if (~exist('StartGUI', 'var') || isempty(StartGUI))
                StartGUI = true;
            end
            
            % Store the SMF as a class property.
            % NOTE: There's some strangeness related to property
            %       instantiation in the SMF which causes our input value
            %       of ResultsDir to be ovewritten by a default.  Until I
            %       fix this, I'm adding the (hopefully) temporary fix
            %       below.
            obj.SMF = SMF;
            obj.SMF.Data.ResultsDir = SMF.Data.ResultsDir;
            
            % Create an instance of the diffusion estimator class.
            obj.DiffusionEstimator = smi_stat.DiffusionEstimator;
            obj.DiffusionEstimator.FitTarget = 'LikelihoodOfJumps';
            obj.DiffusionEstimator.FitIndividualTrajectories = true;
            obj.DiffusionEstimator.FrameLagRange = [2, 2];
            obj.DiffusionEstimator.UnitFlag = false;
            
            % Set some default movie parameters.
            obj.MovieParams = smi_vis.GenerateMovies.prepDefaults();
            
            % Start the GUI if needed.
            if StartGUI
                obj.gui();
            end
        end
        
        function set.SMF(obj, SMFInput)
            %set method for the property SMF.
            % We want to ensure some fields of the SMF are always turned
            % off for tracking. Also, we want to just make a copy of the
            % SMF instead of keeping the original reference to an SMF
            % class instance.
            SMFInput.DriftCorrection.On = false;
            SMFInput.FrameConnection.On = false;
            obj.SMF = smi_core.SingleMoleculeFitting.reloadSMF(SMFInput);
        end
        
        [TR, SMD, SMDPreThresh] = performFullAnalysis(obj);
        [TR, SMD, SMDPreThresh, FileList, TransformList] = batchTrack(obj);
        autoTrack(obj)
        generateTrajectories(obj)
        updateTrackingParams(obj, IsBatch)
        saveResults(obj)
        gui(obj)
        
    end
    
    methods (Static)
        [Success] = unitTestFFGC()
        [SMD] = genTrajFF(SMD, SMF, RhoOff, NonLinkMarker);
        [SMD] = genTrajGC(SMD, SMF, RhoOff, ...
            NonLinkMarker, UseSparseMatrices);
        [CostMatrix] = createCostMatrixFF(SMD, SMF, RhoOff, ...
            FrameNumber, NonLinkMarker);
        [CostMatrix, StartEndIndices] = createCostMatrixGC(SMD, SMF, ...
            RhoOff, NonLinkMarker, CreateSparseMatrix);
        [Assign12, Cost12] = solveLAP(CostMatrix, NonlinkMarker);
        [SMD] = connectTrajFF(SMD, Link12, FrameNumber);
        [SMD] = connectTrajGC(SMD, Link12);
        [KOn, KOff] = estimateRateParameters(SMD);
        [RhoOff, RhoOn] = estimateDensities(SMD, SMF);
    end
    
    methods (Static, Hidden)
        % These methods are kept 'Hidden' because they are either not
        % likely to be useful to users or may be risky/misleading to use in
        % the wrong context.
        
        [DiffusionStruct] = ...
            estimateDiffCoeffs(TR, DiffusionEstimator, DReset)
        [Converged] = checkConvergence(NewParams, PreviousParams, ...
            MaxRelativeChange);
        
    end
    
    
end
./MATLAB/+smi/@BaGoL/BaGoL.m
classdef BaGoL < handle
% BaGoL Implements a Bayesian Grouping of Localizations (BaGoL)
%
% Single molecule localization based super-resolution data can contain
% repeat localizations from the same emitter. These localizations can be
% grouped to give better localization precision.  BaGoL explores the
% possible number of emitters and their positions that can explain the
% observed localizations and uncertainties (data). An 'emitter' is a
% blinking/binding point source that generates a single 'localization'
% each time there is a blinking/binding event. Localizations must be
% frame connected.
%
% The core algorithm uses Reversible Jump Markov Chain Monte Carlo to
% add, remove and move emitters and to explore the allocation of
% localizations to emitters. The localization precisions are assumed to be
% accurate. The prior distribution is parameterized by either a Poisson 
% or Gamma distribution function which can be either given as an input or 
% learned via the hierarchical Bayes approach.
%
% The primary BaGoL outputs are a 'Posterior Image' and MAPN coordinates
% that can also be used to generate a 'MAPN image'. The Posterior Image
% shows a probability distribution of emitter locations that is a weighted
% average over the number of emitters, emitter locations, and
% allocation of localizations to emitters. The Maximum a Posteriori
% Number of emitters (MAPN) result uses only the information from
% the most likely number of emitters within the chain.  MAPN emitter 
% coordinates and their uncertainties are returned and images from these 
% coordinates are generated similarly to a traditional SR reconstruction.
%
% This class implements the pre/post-processing steps needed to analyze
% a spatially extended data set typical of super-resolution experiments.
% This includes breaking data into subregions and collating the results
% from the subregions.
%
%
% USAGE:
%   B=BaGoL()       % create object
%   B.SMD=....      % set properties
%   B.analyze_all() % run complete analysis
%
% The class also has several methods for visualizing and saving results.
%See 'doc BaGoL' for the complete list of methods.
%
% PROPERTIES:
%   SMD:        A structure containing the fields:
%       X:          Vector of X localization positions (Pixel)(Nx1)
%       Y:          Vector of Y localization positions (Pixel)(Nx1)
%       Z:          Vector of Z localization positions (Pixel)(Nx1)(Optional)
%       X_SE:       Vector of X localization standard error (Pixel)(Nx1)
%       Y_SE:       Vector of Y localization standard error (Pixel)(Nx1)
%       Z_SE:       Vector of Z localization standard error (Pixel)(Nx1)(Optional)
%       FrameNum:   Vector of localization frame numbers (Nx1)
%       PixelSize:  Camera pixel size (nm/Pixel) 
%   Xi:         Loc./emitter [lambda] (Poisson) or [k theta] (Gamma).
%               When learning Xi this is used to initialize a chain. If
%               two initial values are given it uses a gamma and otherwise
%               a poisson prior.
%   Alpha_Xi:   Shape parameter of Xi gamma hyper prior
%   Alpha_Xi:   Scale parameter of Xi gamma hyper prio
%   ROIsize:    ROI size for RJMCMC (nm) (Default=200)
%   Overlap:    Allowed overlap between subregions (nm)(Default=50)
%   Drift:      Expected magnitude of drift (nm/frame)(Default=0)
%   SE_Adjust:  Adjustement of localization precisions (nm) (Default=0)
%   N_Burnin:   Number of samples in burn in of RJMCMC chain (Default=2000)
%   N_Trials:   Number of samples in RJMCMC chain post burn in (Default=3000)
%   P_Jumps:    Proposal probabilities for RJMCMC Jumps
%               [Move, Allocate, Add, Remove]
%               sum(P_Jumps) must equal 1.
%               (Default = [0.25, 0.25, 0.25, 0.25])
%   PixelSize:  The pixel size for output posterior images (nm) (Default=1)
%   PImageFlag: Generate Posterior image. 0 or 1. (Default=0)
%   HierarchFlag: Use hierarchical Bayse to learn Xi. 0 or 1. (Default=0)
%   NSamples:   Number of RJMCMC samples before sampling Xi (Default=10)
%   PImageSize: Size of the output posterior images (nm)
%   ChainFlag:  Save RJMCMC chain. 0 or 1. (Default=0)
%   XStart:     X starting coordinate of output posterior images (nm)
%   YStart:     Y starting coordinate of output posterior images (nm)
%
%   ClusterSMD: An array of SMD structures for each cluster
%   MAPN:       SMD output structure containing fields:
%       X:      Vector of X emitter positions (nm)(Kx1)
%       Y:      Vector of Y emitter positions (nm)(Kx1)
%       Z:      Vector of Z emitter positions (nm)(Kx1)
%       X_SE:   Vector of X localization standard error (nm)(Kx1)
%       Y_SE:   Vector of Y localization standard error (nm)(Kx1)
%       Z_SE:   Vector of Z localization standard error (nm)(Kx1)
%       Nmean:  Mean number of localizations per emitter (Kx1)
%   PImage:     Posterior Image
%   Chain:      Cell array of RJMCMC chains for pre-clusters (See BaGoL_RJMCMC)
%   XiChain:    Chain of Xi (locs per emitters dist. either Poisson or gamma)
%   SaveName:   Final results are saved under this name (Default: BaGoL)
%
% REQUIRES:
%   MATLAB 2016 or higher versions.
%   Statistics and Machine learning toolbox.
%
% CITATION: "High-Precision Estimation of Emitter Positions using Bayesian
%           Grouping of Localizations", Mohamadreza Fazel, Michael J. Wester,
%           David J. Schodt, Sebastian Restrepo Cruz, Sebastian Strauss,
%           Florian Schueder, Thomas Schlichthaerle, Jennifer M. Gillette,
%           Diane S. Lidke, Bernd Rieger, Ralf Jungmann and Keith A. Lidke,
%           Nature Communications, 13(7152), November 22, 2022, 1--11,
%           (DOI: 10.1038/s41467-022-34894-2).

% Created by:
%   Mohamadreza Fazel, Lidke Lab 2019
%
    properties
        SMD % Structure containing localization coordinates and uncertainties
        ClusterSMD % SMD array corresponding to subregions   
        MAPN % MAPN output coordinates and uncertainties.
        PImage; % Posterior image
        PImageFlag = 1; % Generate Posterior image. 0 or 1. (Default=1)
        PImageSize = []; % Size of Posterior image (nm)
        PixelSize = 2; % Pixel size for posterior images (nm) (Default=2)
        XStart = []; % X starting coordinate of posterior images (nm)
        YStart = []; % Y starting coordinate of posterior images (nm)
        P_Jumps=[0.25 0.25 0.25 0.25]; % Proposal probabilities for RJMCMC Jumps 
        N_Burnin=2000; % Number of samples in burn in of RJMCMC chain (Default=2000)
        N_Trials=3000; % Number of samples in RJMCMC chain post burn in (Default=3000)
        NSamples = 10; % Number of samples in other params before taking a Xi sample
        ROIsize=200; % ROI size for RJMCMC (nm)(Default=200)
        Overlap=20; % Allowed overlap between subregions (nm)(Default=20)  
        Drift = 0; % Expected magnitude of drift velocity (nm/frame)(Default=0) 
        SE_Adjust = 0; % Localization precision adjustment (nm) (Default=0)
        Xi=20; % Loc./emitter params [lambda] (Poisson) or [k, theta] (Gamma) (Default=20)
        Alpha_Xi = 1; %Shape parameter of Xi hyper prior (Default = 1)
        Beta_Xi = 50; %Scale parameter of Xi hyper prior (Default = 50)
        ChainFlag = 0; % Save RJCMC chain. 0 or 1. (Default=0)
        HierarchFlag = 0; % Use a Hierarchial Prior to learn XI
        Chain = {}; % Cell array of RJMCMC chains for clusters
        XiChain; % Chain of samples for Xi. [lambda]->Poisson, [k, theta]-> gamma
        SaveName = 'BaGoL'; % Final results are saved under this name
        Cutoff; %preclustering parameter used in hierarchical clustering (nm) (Default = ROIsize)
    end
    
    methods
        
        function obj=analyze_all(obj)
        % analyze_all Implements complete BaGoL analysis of SR dataset
        %
        % This  method performs all steps necessary to analyze a
        % super-resolution data set with BaGoL. Internally, it initializes
        % output structures, generates ROIs for RJMCMC, then loops over 
        % ROIs and collates the output. 
        %
        % This method sequentially calls: 
        %   ROIs = obj.genROIs()
        %   obj.assignROIs(...)
        %       BaGoL_RJMCMC(...)
        %       genPosterior(...)
        %       genMAPN(...)
        %
        % USAGE:
        %   B.analyze_all
        %
            
            %auto calculate posterior image size
            if isempty(obj.XStart)
               obj.initPostIm(); 
            end
            
            Ind = obj.SMD.X_SE == 0 | obj.SMD.Y_SE == 0;
            obj.SMD.X(Ind) = [];
            obj.SMD.Y(Ind) = [];
            obj.SMD.X_SE(Ind) = [];
            obj.SMD.Y_SE(Ind) = [];
            obj.SMD.FrameNum(Ind) = [];
%             obj.XStart = obj.XStart;
%             obj.YStart = obj.YStart;
            if isempty(obj.Cutoff)
                obj.Cutoff = obj.ROIsize;
            end
            if isempty(obj.SMD.FrameNum)
                obj.SMD.FrameNum = zeros(size(obj.SMD.X));
            else
                obj.SMD.FrameNum = single(obj.SMD.FrameNum);
            end
            ROIs = obj.genROIs();
            if obj.PImageFlag == 1
                if isempty(obj.PImageSize) || ~isscalar(obj.PImageSize)
                    error('PImageSize must be given as a scalar');
                end
                SZ = ceil(obj.PImageSize/obj.PixelSize);
                PostIm = zeros(SZ,'single');
            end
            %obj.assignROIs(ROIs);
            obj.precluster(ROIs);
            obj.MAPN.X = [];
            obj.MAPN.Y = [];
            obj.MAPN.Z = [];
            obj.MAPN.X_SE = [];
            obj.MAPN.Y_SE = [];
            obj.MAPN.Z_SE = [];
            obj.MAPN.AlphaX = [];
            obj.MAPN.AlphaY = [];
            obj.MAPN.AlphaX_SE = [];
            obj.MAPN.AlphaY_SE = [];
            obj.MAPN.Nmean = [];
            
            ClustNumHeirar = length(obj.ClusterSMD);
            if isempty(obj.SMD.FrameNum)
               MaxAlpha = 0; 
            elseif max(obj.SMD.FrameNum~=0)
               MaxAlpha = obj.Drift; 
            else
               MaxAlpha = 0; 
            end
            warning('OFF', 'stats:kmeans:FailedToConvergeRep');
            
            if obj.HierarchFlag == 0
                %using a calibrated Xi distribution (HierarchFlag=0)
                if obj.ChainFlag == 1
                    obj.Chain = cell(length(obj.ClusterSMD),1);
                end
                for nn = 1:ClustNumHeirar
                    if nn/10 == floor(nn/10)
                        fprintf('Subregion: %g out of %g \n',nn,ClustNumHeirar);
                    end
                    
                    AnimFlag = 0;
                    [TChain]=smi.BaGoL.BaGoL_RJMCMC(obj.ClusterSMD(nn),obj.Xi,MaxAlpha,obj.P_Jumps,obj.N_Trials,obj.N_Burnin,AnimFlag);

                    if obj.PImageFlag == 1
                        PostIm = obj.genPosterior(PostIm,SZ,TChain,ROIs,nn);
                    end
                    obj.genMAPN(TChain,ROIs,nn);
                    if obj.ChainFlag == 1
                        obj.Chain{nn} = TChain; 
                    end
                end
            else
                %learning Xi (HierarchFlag=1)
                tXi = obj.Xi;
                obj.Chain = cell(length(obj.ClusterSMD),1);
                NChain = floor(obj.N_Trials/obj.NSamples);
                NIter = floor((obj.N_Trials+obj.N_Burnin)/obj.NSamples);
                NBurn = floor(obj.N_Burnin/obj.NSamples);
                NPoints = zeros(length(obj.ClusterSMD),1);
                tK = zeros(length(obj.ClusterSMD),1);
                for nn = 1:length(obj.ClusterSMD)
                    obj.Chain{nn}.Chain(NChain).N = [];
                    obj.Chain{nn}.Chain(NChain).X = [];
                    obj.Chain{nn}.Chain(NChain).Y = [];
                    obj.Chain{nn}.Chain(NChain).AlphaX = [];
                    obj.Chain{nn}.Chain(NChain).AlphaY = [];
                    obj.Chain{nn}.Chain(NChain).ID = [];
                    NPoints(nn)=length(obj.ClusterSMD(nn).X);
                end
                %tmp is a temporary structure to store some parameters
                %before saving them in the returned chain. The returned chain 
                %is sparsed by only saving the last values in the tmp struct. 
                tmp(ClustNumHeirar,1).MuX = 0;
                tmp(ClustNumHeirar,1).MuY = 0;
                tmp(ClustNumHeirar,1).AlphaX = 0;
                tmp(ClustNumHeirar,1).AlphaY = 0;
                
                PDFgrids = cell(ClustNumHeirar,1);
                for nn = 1:ClustNumHeirar
                    DX = 1;
                    X_min = min(obj.ClusterSMD(nn).X-3*obj.ClusterSMD(nn).X_SE);
                    X_max = max(obj.ClusterSMD(nn).X+3*obj.ClusterSMD(nn).X_SE);
                    X_range = X_min:DX:X_max;
                    Y_min = min(obj.ClusterSMD(nn).Y-3*obj.ClusterSMD(nn).Y_SE);
                    Y_max = max(obj.ClusterSMD(nn).Y+3*obj.ClusterSMD(nn).Y_SE);
                    Y_range = Y_min:DX:Y_max;

                    [Xg,Yg] = meshgrid(X_range,Y_range);
                    PDFgrid = zeros(size(Xg),'single');
                    for pp = 1:length(obj.ClusterSMD(nn).X)
                        PDFgrid = PDFgrid + single(normpdf(Xg,obj.ClusterSMD(nn).X(pp),obj.ClusterSMD(nn).X_SE(pp))...
                            .*normpdf(Yg,obj.ClusterSMD(nn).Y(pp),obj.ClusterSMD(nn).Y_SE(pp))); 
                    end
                    PDFgrids{nn}.PDFgrid = PDFgrid;
                end
                
                %If the chain is initialized with a single paramter use a
                %Poisson prior otherwise gamma prior (default is Poisson).
                IsPoiss = length(obj.Xi)==1;
                if IsPoiss
                    obj.XiChain = zeros(NIter,1);
                else
                    obj.XiChain = zeros(NIter,2);
                end
                
                for mm = 1:NIter
                    if mm/100 == floor(mm/100)
                        fprintf('Iteration %g out of %g over all subregions\n',mm,NIter);
                    end
                    for nn=1:ClustNumHeirar
                        if mm == 1
                            %For the first sample, the locations are intitialized to random values
                            [K,MuX,MuY,AlphaX,AlphaY,ID]=smi.BaGoL.BaGoL_RJMCMC_Hierarchical(obj.ClusterSMD(nn) ...
                                ,PDFgrids{nn}.PDFgrid,MaxAlpha,obj.P_Jumps,obj.NSamples,tXi);
                        else
                            %For jumps other than the first one, the previous values in the chain are used
                            [K,MuX,MuY,AlphaX,AlphaY,ID]=smi.BaGoL.BaGoL_RJMCMC_Hierarchical(obj.ClusterSMD(nn) ...
                                ,PDFgrids{nn}.PDFgrid,MaxAlpha,obj.P_Jumps,obj.NSamples,tXi,tmp(nn).MuX,...
                                tmp(nn).MuY,tmp(nn).AlphaX,tmp(nn).AlphaY);
                        end
                        %tmp is a temporary structure to save some params
                        tmp(nn).MuX = MuX;
                        tmp(nn).MuY = MuY;
                        tmp(nn).AlphaX = AlphaX;
                        tmp(nn).AlphaY = AlphaY;
                        %Emitters inside overlapping regions are removed before 
                        %sampling Xi.
                        Ind = removeOverlap(obj,ROIs,MuX,MuY,nn);
                        tK(nn) = length(Ind);
                        NPoints(nn) = sum(ismember(ID,Ind));
                        if mm > NBurn 
                            obj.Chain{nn}.Chain(mm-NBurn).N = K;
                            obj.Chain{nn}.Chain(mm-NBurn).X = MuX;
                            obj.Chain{nn}.Chain(mm-NBurn).Y = MuY;
                            obj.Chain{nn}.Chain(mm-NBurn).AlphaX = AlphaX;
                            obj.Chain{nn}.Chain(mm-NBurn).AlphaY = AlphaY;
                            obj.Chain{nn}.Chain(mm-NBurn).ID = ID;
                        end
                    end
                    %Sampling Xi for either Poisson or gamma 
                    if IsPoiss
                        tXi = smi.BaGoL.samplePoiss(NPoints,tK,tXi,obj.Alpha_Xi,obj.Beta_Xi);
                        obj.XiChain(mm,:) = tXi;
                    else
                        tXi = smi.BaGoL.sampleGam(NPoints,tK,tXi,obj.Alpha_Xi,obj.Beta_Xi);
                        obj.XiChain(mm,:) = tXi;
                    end
                    
                end
                
                %Generating MAPN coordinates and posterior image
                for nn = 1:ClustNumHeirar
                     TChain = obj.Chain{nn}.Chain;
                     obj.genMAPN(TChain,ROIs,nn);
                     if obj.PImageFlag == 1
                         PostIm = obj.genPosterior(PostIm,SZ,TChain,ROIs,nn);
                     end
                end
            end
            
            warning('ON', 'stats:kmeans:FailedToConvergeRep');
            if obj.PImageFlag == 1
                obj.PImage = PostIm;
            end
            
            if obj.ChainFlag == 1
                for mm = length(obj.ClusterSMD):-1:1
                     if isempty(obj.Chain{mm})
                         obj.Chain(mm) = []; 
                         obj.ClusterSMD(mm) = [];
                     end
                end
            end
        end
    end
    
    methods (Static) 
       [SMD,SMC]=genCluster(StuctType,Scale,Ndist,PSF,MeanPhoton,Prec_Cutoff,DriftVec,PlotFlag); 
       [SMD,SMD_combined]=frameConnect(SMDin,LOS,MaxDistance,MaxFrameGap,FitType);
       saveMAPN(Directory,FileType,MAPN)
       errPlot(SMD);
       SMD=loadPICASSOh5(DataDir,FileName)
       [Chain]=BaGoL_RJMCMC(SMD,Xi,MaxAlpha,PMove,NChain,NBurnin,DEBUG)
       [K,X,Y,AlphaX,AlphaY,ID]=BaGoL_RJMCMC_Hierarchical(SMD,PDFgrid,AlphaSTD,P_Jumps,NSamples,Xi,MuX,MuY,AlphaX,AlphaY)
       [SRIm,MapIm]=makeIm(SMD,MAPN,SZ,PixSize,XStart,YStart)
       Xi = sampleGam(NPoints,K,Xi,Alpha,Beta);
       Xi = samplePoiss(NPoints,K,Xi,Alpha,Beta);
       [Alpha,XShift,YShift,Aligned,Chain] = align_template (Temp,Input,Start,Cutoff,NChain,PlotFlag)
       [ImageOut,Image] = scalebar (Image,PixelSize,Length,Location)
       [Im]=scaleIm (Im,Percentile)
       [ParamPoiss,ParamGam]=fitLambda(NMean,Percent)
       dispIm()
       [Coords,Ind] = SEfilter(ROIs)
       Im=genSRMAPNOverlay(SMD,MAPN,XSize,YSize,PixelSize,SaveDir,XStart,YStart,RadiusScale,ScaleBarLength)
       BGL = hierBaGoL_analysis(SMD, FileNameIn, SaveDir, BaGoLParams)
       BGL = hierBaGoL_run(Files, DataROI, Results_BaGoL, BaGoLParams, ROIs)
    end
    
end

./MATLAB/+smi/@BaGoL/plotNND_PDF.m
function plotNND_PDF(obj,SaveDir)
%plotNND_PDF makes and saves the NND PDF histogram of MAPN coordinates.
% obj.plotNND(SaveDir)
%
% Calculates the nearest neighbor distribution from the MAPN coordinates and
% creates a PDF histogram, also displaying the random nearest neighbor PDF that
% would occur for the same density of points.  This plot is scaled on the
% x-axis in two different ways: by 99% of the data and 99% of the random PDF.
% If the optional argument SaveDir is provided, the plots produced are saved to
% that directory as PNGs.
%
% INPUTS:
%    SaveDir: Save directory (Optional)
%
% OUTPUT:
%     None
%

% Created by:
%    Michael Wester and Mohamadreza Fazel (LidkeLab 2021 and 2019)

NBins=30;
[~,Dis]=knnsearch([obj.MAPN.X,obj.MAPN.Y],[obj.MAPN.X,obj.MAPN.Y],'k',2);
Dis = Dis(:,2);
% Scale the histogram by 99% of the data.
P = prctile(Dis,99);

% PDF for a random NN distribution.  Details at
%    https://en.wikipedia.org/wiki/Mean_inter-particle_distance
% density (#/nm^2)
%Area = (max(obj.MAPN.X)-min(obj.MAPN.X)) * (max(obj.MAPN.Y)-min(obj.MAPN.Y));
Area = obj.PImageSize^2;   % PImageSize = Posterior Image Size (nm)
maxD = max(Dis(Dis < P));
rho = numel(obj.MAPN.X) / Area;   % (#/nm^2)
a = 1 / sqrt(pi * rho);   % (nm)
r = 0 : maxD/1000 : maxD;   % (nm)
PDF = 2/a * (r/a) .* exp(-(r/a).^2);

figure
hold on
h = histogram(Dis(Dis<P),NBins);
h.Normalization = 'PDF';
plot(r, PDF, 'r-', 'LineWidth', 2);
xlabel('NND (nm)','FontSize',15);
ylabel('PDF','FontSize',15)
legend('data', 'random')
hold off

if nargin > 1
   print(gcf,fullfile(SaveDir,'NNDScaledData'),'-dpng'); 
   Dis = double(Dis);
   if size(Dis,2) > 1
      Dis = Dis';
   end
   save(fullfile(SaveDir,'NND.txt'),'Dis','-ascii')
end

% Scale the histogram by 99% of the random curve.
% Note: integrate(PDF(r), r, 0, inf) = 1 and
%       integrate(PDF(r), r, 0, R) = - exp(-(r/a)^2)|r=R + exp(-(r/a)^2)|r=0
%                                  = 1 - exp(-(R/a)^2) =>
%       f = 1 - exp(-(R/a)^2) => R = a*sqrt(-log(1 - f))   for f in [0, 1]
f = 0.99;
R = a * sqrt(-log(1 - f));
r = 0 : R/1000 : R;   % (nm)
PDF = 2/a * (r/a) .* exp(-(r/a).^2);

figure
hold on
h = histogram(Dis(Dis<R),NBins);
h.Normalization = 'PDF';
plot(r, PDF, 'r-', 'LineWidth', 2);
xlabel('NND (nm)','FontSize',15);
ylabel('PDF','FontSize',15)
legend('data', 'random')
hold off

if nargin > 1
   print(gcf,fullfile(SaveDir,'NNDScaledRandom'),'-dpng'); 
end

end

./MATLAB/+smi/@BaGoL/initPostIm.m
function initPostIm(obj)
%initPostIm Find the Posterior Image size and position

DX = obj.PixelSize;
obj.XStart = min(obj.SMD.X-3*obj.SMD.X_SE);
obj.YStart = min(obj.SMD.Y-3*obj.SMD.Y_SE);

X_max = max(obj.SMD.X+3*obj.SMD.X_SE);
Y_max = max(obj.SMD.Y+3*obj.SMD.Y_SE);

% No pre-clustering version
%obj.PImageSize=ceil(max((X_max-obj.XStart/DX),(Y_max-obj.YStart/DX)));
% Pre-clustering version from Mohamad
%obj.PImageSize=ceil(max((X_max-obj.XStart)/DX,(Y_max-obj.YStart)/DX));
obj.PImageSize=ceil(max((X_max+obj.XStart/DX),(Y_max+obj.YStart/DX)));

end

./MATLAB/+smi/@BaGoL/genMAPN.m
function genMAPN(obj,Chain,ROIs,ii)
%genMAPN Generates the MAPN coordinates from the most repeated model in the chain.
% obj = obj.genMAPN(Chain,ROIs,ii)
% 
% The states of the chain with most repeated number of emitters (model) 
% are identified. The coordinates from the identified states are 
% extracted and analyzed with the kmeans clustering algorithm to find the
% clusters within the retrieved coordinates. The center of mass of the
% found clusters and their standard deviations are taken as the emitter
% locations and precisions, respectively. The kmeans algorithm is run with 
% multiple sets of seeds, which depends on the number of emitters, and the 
% configuration with the least cost is used. For some of the seeds, kmeans 
% may fail to converge and throws a warning which is not an issue. The 
% locations inside the overlapping regions (see genROIs()) are then 
% eliminated from the list of emitter coordinates and the reminder is 
% returned.
%
% INPUTS:
%    Chain: RJMCMC chain for a cluster (See BaGoL_RJMCMC())
%    ROIs:  2D Array of SMD structures (see genROIs())
%    ii:    Index of cluster associated to the input chain
%
% OUTPUTS:
%    NONE
%

% Created by:
%    Mohamadreza Fazel (LidkeLab 2019)

    TChain = Chain;
    N = [];
    XChain = [];
    YChain = [];
    AlphaX_Chain = [];
    AlphaY_Chain = [];
    NChain = [];
    for nn = 1:length(TChain)
        if TChain(nn).N == 0
            continue;
        end
        N = cat(1,N,length(TChain(nn).X));
    end
    Frequency = hist(N,(0:max(N)));
    Frequency(1) = [];
    MostFrequent = find(Frequency==max(Frequency));
    MostFrequent = MostFrequent(1);
   
    for nn = 1:length(TChain)
        if TChain(nn).N == MostFrequent
            NSum = zeros(MostFrequent,1);
            XChain = cat(1,XChain,TChain(nn).X);
            YChain = cat(1,YChain,TChain(nn).Y);
            AlphaX_Chain = cat(1,AlphaX_Chain,TChain(nn).AlphaX);
            AlphaY_Chain = cat(1,AlphaY_Chain,TChain(nn).AlphaY);
            for pp = 1: MostFrequent(1)
                NSum(pp) = sum(single(TChain(nn).ID)==pp); 
            end
            NChain = cat(1,NChain,NSum);
        end
    end
    XChain = XChain(:);
    YChain = YChain(:);
    Points(:,1)=XChain;
    Points(:,2)=YChain;
    if ~isempty(obj.SMD.Z)
        Points(:,3)=ZChain;                     
    end
    Iters = ceil(MostFrequent/3)+1;
    NSeed = randi([0,length(XChain)/MostFrequent-1],[Iters,1]);
    KSeed = zeros(MostFrequent,2,Iters);
    for jj = 1:Iters
        Nt = NSeed(jj);
        KSeed(:,:,jj) = [XChain(Nt*MostFrequent+1:(Nt+1)*MostFrequent),YChain(Nt*MostFrequent+1:(Nt+1)*MostFrequent)];
    end
    ID = kmeans(Points,MostFrequent,'Replicates',Iters,'MaxIter',300);
    
    Map.X = [];
    Map.Y = [];
    Map.X_SE = [];
    Map.Y_SE = [];
    Map.AlphaX = [];
    Map.AlphaY = [];
    Map.AlphaX_SE = [];
    Map.AlphaY_SE = [];
    Map.Nmean = [];
    for nn = 1:MostFrequent
        TX = mean(XChain(ID==nn)); 
        TY = mean(YChain(ID==nn));
        TX_SE = std(XChain(ID==nn));
        TY_SE = std(YChain(ID==nn));
        TAlphaX = mean(AlphaX_Chain(ID==nn));
        TAlphaY = mean(AlphaY_Chain(ID==nn));
        TAlphaX_SE = std(AlphaX_Chain(ID==nn));
        TAlphaY_SE = std(AlphaY_Chain(ID==nn));
        TNmean = mean(NChain(ID==nn));
        Map.X = cat(1,Map.X,TX);
        Map.Y = cat(1,Map.Y,TY);
        Map.X_SE = cat(1,Map.X_SE,TX_SE);
        Map.Y_SE = cat(1,Map.Y_SE,TY_SE);
        Map.AlphaX = cat(1,Map.AlphaX,TAlphaX);
        Map.AlphaY = cat(1,Map.AlphaY,TAlphaY);
        Map.AlphaX_SE = cat(1,Map.AlphaX_SE,TAlphaX_SE);
        Map.AlphaY_SE = cat(1,Map.AlphaY_SE,TAlphaY_SE);
        Map.Nmean = cat(1,Map.Nmean,TNmean);
    end
    Ind = obj.removeOverlap(ROIs,Map.X,Map.Y,ii);
    obj.MAPN.X = cat(1,obj.MAPN.X,Map.X(Ind));
    obj.MAPN.Y = cat(1,obj.MAPN.Y,Map.Y(Ind));
    obj.MAPN.X_SE = cat(1,obj.MAPN.X_SE,Map.X_SE(Ind));
    obj.MAPN.Y_SE = cat(1,obj.MAPN.Y_SE,Map.Y_SE(Ind));
    obj.MAPN.AlphaX = cat(1,obj.MAPN.AlphaX,Map.AlphaX(Ind));
    obj.MAPN.AlphaY = cat(1,obj.MAPN.AlphaY,Map.AlphaY(Ind));
    obj.MAPN.AlphaX_SE = cat(1,obj.MAPN.AlphaX_SE,Map.AlphaX_SE(Ind));
    obj.MAPN.AlphaY_SE = cat(1,obj.MAPN.AlphaY_SE,Map.AlphaY_SE(Ind));
    if ~isempty(obj.SMD.Z)
        obj.MAPN.Z = cat(1,obj.MAPN.Z,Map.Z(Ind));
        obj.MAPN.Z_SE = cat(1,obj.MAPN.Z_SE,Map.Z_SE(Ind));
    end
    obj.MAPN.Nmean = cat(1,obj.MAPN.Nmean,Map.Nmean(Ind));
end

./MATLAB/+smi/@BaGoL/dispIm.m
function dispIm()
%dispIm GUI to display BaGoL output images with some useful tools.
% BaGoL.dispIm()
%
% When called, a GUI pops up and multiple images can be uploaded using the
% "Choose Image" button. The "Backward" and "Forward" buttons allow going
% back and forth between the loaded images. Tools from the menu bar, such as
% zoom in and zoom out can be used to adjust the displayed images. The
% adjustments are maintained when moving back and forth between the images.
%

% Created by:
%    Mohamadreza Fazel (LidkeLab 2019)

Im={};
map={};
Num = 1;
guiFig = figure('Visible','on','Position',[250,100,710,800],'Name',...
    'Image display','NumberTitle','off','Interruptible','off');

HAxis1 = axes('Units','normalize','YTick',[],'XTick',[],'Position',[.05,0.02,0.9,0.88]);

fileButton1 = uicontrol('Style', 'pushbutton','String','Choose Image',...
    'Unit','normalize','Enable','on','Position', [0.1 0.92 0.15 0.06],'Callback',@getFileList1);

 ForwardButton = uicontrol('Style', 'pushbutton','String','Forward',...
    'Unit','normalize','Enable','on','Position', [0.5 0.92 0.15 0.06],'Callback',@forward);
 BackwardButton = uicontrol('Style', 'pushbutton','String','Backward',...
    'Unit','normalize','Enable','on','Position', [0.75 0.92 0.15 0.06],'Callback',@backward);

function getFileList1(~,~) % Choose data file(s) and list them in the File List box
[filename, pathname]=uigetfile('Y:\*.png;*.tif','MultiSelect','on');
Im = cell(1,length(filename));
map = Im;
for ii = 1:length(filename)
[ImT,MapT] = imread(fullfile(pathname,filename{ii}));
Im{ii}=ImT;
map{ii}=MapT;
end
axes(HAxis1);imshow(Im{1},map{1});
end

function forward(~,~)
Num = Num+1;
if Num > length(Im)
    Num = 1; 
end
HAxis1.Children.CData = Im{Num};
end

function backward(~,~)
        Num = Num-1;
if Num == 0
    Num = length(Im);
end
HAxis1.Children.CData = Im{Num};
end
end

./MATLAB/+smi/@BaGoL/sampleGam.m
function Xi = sampleGam(NPoints,K,Xi,Alpha,Beta)
%sampleGam() infers parameters of gamma prior on number of locs per emitters
%
%Here, the prior parameters are learned using a hierarchical Bayes skim.
%
% INPUT:
%   NPoints: Number of localizations within ROIs
%   K:       Number of found emitters within ROIs
%   Xi:      Current parameter values of the Prior
%   Alpha:   Shape parameter of Lambda hyper-prior (Default = 1)
%   Bets:    Scale parameter of Lambda hyper-prior (Default = 50)
%
% OUTPUT: 
%   Xi:  Updated shape and scale parameters for gamma prior on number
%            of emitters

% Created by:
%   Mohamadreza Fazel (Lidke lab, 2022)
% 

Eta = Xi(1);
Gamma = Xi(2);

if nargin < 4
    Alpha = 1;
end
if nargin < 5
    Beta = 50;
end
Alpha_Prop = 3000;

Ind = NPoints > 0;
NPoints = NPoints(Ind);
K = K(Ind);

%10 samples are taken in a row and only the last one is returned
for ii = 1:10
    
    %Sample Eta
    Eta_Prop = gamrnd(Alpha_Prop,Eta/Alpha_Prop);
    
    LogLikeR1 = log(gampdf(NPoints,K*Eta_Prop,Gamma)); 
    LogLikeR2 = log(gampdf(NPoints,K*Eta,Gamma));
    if sum(isinf(LogLikeR1) & isinf(LogLikeR2)) 
        Ind = isinf(LogLikeR1) & isinf(LogLikeR2);
        LogLikeR1(Ind) = 0;
        LogLikeR2(Ind) = 0;
    end
    LogLikeR2(isinf(LogLikeR1)) = 0;
    LogLikeR1(isinf(LogLikeR1)) = 0;
    LogLikeR = sum(LogLikeR1 - LogLikeR2);
    
    LogPriorR = log(gampdf(Eta_Prop,Alpha,Beta)) - log(gampdf(Eta,Alpha,Beta));
    LogPropR = log(gampdf(Eta,Alpha_Prop,Eta_Prop/Alpha_Prop)) ...
        - log(gampdf(Eta_Prop,Alpha_Prop,Eta/Alpha_Prop));

    if LogLikeR + LogPriorR + LogPropR > log(rand())
       Eta = Eta_Prop; 
    end

    %Sample Gamma
    Gamma_Prop = gamrnd(Alpha_Prop,Gamma/Alpha_Prop);
    LogLikeR1 = log(gampdf(NPoints,K*Eta,Gamma_Prop)); 
    LogLikeR2 = log(gampdf(NPoints,K*Eta,Gamma));
    if sum(isinf(LogLikeR1) & isinf(LogLikeR2)) 
        Ind = isinf(LogLikeR1) & isinf(LogLikeR2);
        LogLikeR1(Ind) = 0;
        LogLikeR2(Ind) = 0;
    end
    LogLikeR2(isinf(LogLikeR1)) = 0;
    LogLikeR1(isinf(LogLikeR1)) = 0;
    LogLikeR = sum(LogLikeR1 - LogLikeR2);
    LogPriorR = log(gampdf(Gamma_Prop,Alpha,Beta)) - log(gampdf(Gamma,Alpha,Beta));
    LogPropR = log(gampdf(Gamma,Alpha_Prop,Gamma_Prop/Alpha_Prop)) ...
        - log(gampdf(Gamma_Prop,Alpha_Prop,Gamma/Alpha_Prop));

    if LogLikeR + LogPriorR + LogPropR > log(rand())
       Gamma = Gamma_Prop; 
    end

end
Xi(1) = Eta;
Xi(2) = Gamma;

end
./MATLAB/+smi/@BaGoL/hierBaGoL_analysis.m
function BGL = hierBaGoL_analysis(SMD, FileNameIn, SaveDir, BaGoLParams)
%Bayesian Grouping of Localizations (BaGoL)
%
%  This function is adapted from EGFR_dSTORM.m in the BaGoL distribution.
%
%  BaGoL is run for a part of the region of the data with a broad gamma   
%  prior to find the distribution of the number of localizations per  
%  emitter.  In the second run of BaGoL, the entire region is processed 
%  using the found distribution as a prior.

% Requirements and Setup:
%   1. MATLAB 2016 or higher versions
%   2. Statistics and Machine Learning Toolbox
%   3. BaGoL class
%
% Description of how to run...
%   1. Set the parameters in the following section via hierBaGoL_wrapper.
%   2. Results are placed in ResultsDir.  The main results (the .mat file
%      containing the BGL object which includes the input SMD structure,
%      output MAPN structure, the posterior image [PImage], the Xi chain, etc.,
%         BaGoL_Results_*_ResultsStruct.mat
%      and the .mat file which contains the MAPN coordinates, etc.,
%         MAPN_*.mat
%      ) are placed at the top level, while various plots are placed in the
%      subdirectory identified by the dataset that was processed.
%
% Results include:
%   Saved Results:
%     See above as well.
%     BaGoL_X-SE.png:            Histogram of X-localization precisions after
%                                grouping. 
%     BaGoL_Y-SE.png:            Histogram of Y-Localization precisions after
%                                grouping.
%     LocsScatter-MAPN.fig:      Plot of time color-coded localizations and
%                                MAPN-coordinates.
%     MAPN.mat:                  Structure containing the MAPN-coordinates of
%                                emitters.
%     MAPN-Im.png:               MAPN image which is the image of localizations
%                                from the most likely model. 
%     MAPN_NmeanHist.png:        Histogram of the number of localizations per
%                                emitter found for the MAPN results.
%     NND.png:                   Histogram of nearest neighbor distances from
%                                MAPN-coordinates. 
%     NNDScaledData.png:         PDFs of nearest neighbor distances + random
%                                at the same density scaled by 99% of the data.
%     NNDScaledRandom.png:       PDFs of nearest neighbor distances + random
%                                at the same density scaled by 99% of the
%                                random PDF.
%     Overlay_SR_Map_circle.png: Overlay of the SR and MAPN coordinates where 
%                                every coordinate is represented by a circle  
%                                located at the given location and a radius 
%                                of double of the given precision.  Input
%                                localizations (data) are shown by green
%                                circles and found emitter locations are shown
%                                by magenta circles.
%     Overlay_SR_Map.png:        Overlay of grayscale SR-image and color MAPN
%                                image.
%     Overlay_SR_Post.png:       Overlay of grayscale SR-image and color
%                                posterior image. 
%     Post-Im.png:               Posterior image or histogram image of the
%                                chain (weighted average over all models).
%     SR_Im.png:                 Traditional super-resolution image. 
%     Xi.png:                    Distribution of localizations per emitter.
%     XiChain.png                Plot of the Xi chain after burnin.
%   Output available on work space:
%     MAPN: Clusters information are stored in this property:
%     MAPN.X: X-Centers (nm)
%     MAPN.Y: Y-Centers (nm)
%     MAPN.X_SE: X-Centers precisions (nm)
%     MAPN.Y_SE: Y-Centers precisions (nm)
%     MAPN.AlphaX: X-Drifts of clusters (nm/frame)
%     MAPN.AlphaY: Y-Drifts of clusters (nm/frame)
%     MAPN.AlphaX_SE: X-Drift precisions (nm/frame)
%     MAPN.AlphaY_SE: Y-Drift precisions (nm/frame)
%     MAPN.Nmean: Mean number of binding events per docking strand or
%                 localizations per emitter
%
% INPUTS:
%    SMD           Single Molecule Data structure containg X, Y, X_SE, Y_SE
%    FileNameIn    name of file containing coordinate SMD structure
%    SaveDir       directory in which saved results are put
%    BaGoLParams   structure with the following parameters:
%       ImageSize         Image size (pixel)
%       PixelSize         Pixel size (nm)
%       OutputPixelSize   Pixel size for posterior images (nm)
%       SE_Adjust         Precision inflation applied to SE (nm)
%       ClusterDrift      Expected magnitude of drift (nm/frame)
%       ROIsz             ROI size for RJMCMC (nm)
%       OverLap           Size of overlapping region (nm)
%       Cutoff            Pre-clustering cutoff (nm) [default = ROIsz]
%       Xi                Loc./emitter parameters for [lambda] (Poisson) or
%                         [k theta] (Gamma) prior
%       DataROI           [Xmin, Xmax, Ymin, Ymax] (pixel)
%       N_Burnin          Length of Burn-in chain
%       N_Trials          Length of post-burn-in chain
%       NSamples          Number of samples (in N_Burnin and N_Trials) before
%                         sampling Xi
%       Y_Adjust          Apply coordinate transform for y-coordinates if
%                         non-empty in the form Y = Y_Adjust - Y (pixels)
%       
%
%    k and theta are the shape and scale parameters for the Gamma probability
%    distribution function.
%
%    DataROI is defined when running BaGoL's over only part of the
%    image.  If DataROI is empty, use the whole image.
%
% OUTPUTS:
%    BGL           BaGoL object containing the results of the analysis
%    ...           various plots, images and saved results detailed above

% Created by
%    Mohamadreza Fazel (2019) and Michael J. Wester (2022), Lidke Lab

%% Important Parameters
SZ        = BaGoLParams.ImageSize;   % Image size (pixel)
PixelSize = BaGoLParams.PixelSize;   % Pixel size (nm)
DataROI   = BaGoLParams.DataROI;     % Optional analysis ROI (nm)
Y_Adjust  = BaGoLParams.Y_Adjust;    % LL vs UL origin transform
ImSize    = SZ*PixelSize;            % Image size (nm)
Xi        = BaGoLParams.Xi;          % [k, theta] parameters for gamma prior
XStart    = 0;
YStart    = 0;

% --------- Initialize BaGoL

%% Load data
%load(fullfile(DataDir, FileNameIn));
% The above data is assumed to be an SMD structure.  Note that X/Y and
% X_SE/Y_SE units are pixels, later to be transformed into nm for the BaGoL
% analysis.
if ~exist('SMD', 'var')
   error('SMD structure expected!');
end
% If Y_Adjust is non-empty (y-coordinate origin is in the upper left and y
% increases downward), adjust the Y values so their origin is in the lower left
% and y increases upward.
%if ~isempty(Y_Adjust)
%   SMD.Y = Y_Adjust - SMD.Y; 
%end

% Eliminate trailing _Results* from the FileName for saving results.
FileName = regexprep(FileNameIn, '\.mat$', '');
FileName = regexprep(FileName, '_Results$', '');
FileName = regexprep(FileName, '_ResultsStruct', '');
% Save the BaGoL _ResultsStruct.mat file in SaveDir and the rest of the BaGoL
% outputs in SaveDirLong.  This arrangement is chosen so that Results_BaGoL
% holds only uniquely named files/directories for the situation where several
% _ResultsStruct.mat files reside in the same (higher level) directory,
% therefore the results of multiple BaGoL runs will share common space in
% Results_BaGoL.
if ~isfolder(SaveDir)
   mkdir(SaveDir); 
end
SaveDirLong = fullfile(SaveDir, FileName);
if ~isfolder(SaveDirLong)
   mkdir(SaveDirLong);
end

%% Filter localizations
% BaGoL works better with non-negative coordinates.
Verbose = 2;
SMD = smi_helpers.Filters.filterNonNeg(SMD, Verbose);

% Make the run on a smaller subregion.
%DataROI = [80 120 120 160];%Region to find Xi (pixel) [XStart XEnd YStart YEnd]

%% Examine a ROI if desired
if ~isempty(DataROI)
   if ~isempty(Y_Adjust)
      SMD.Y = Y_Adjust - SMD.Y;
   end
   Ind = SMD.X >= DataROI(1) & SMD.X <= DataROI(2) & ...
         SMD.Y >= DataROI(3) & SMD.Y <= DataROI(4);
   if ~isempty(Y_Adjust)
      SMD.Y = Y_Adjust - SMD.Y;
   end
   % Convert to nm as BaGoL is expecting nm.
   ImSize = (DataROI(2) - DataROI(1))*PixelSize; 
   XStart = DataROI(1)*PixelSize;
   YStart = DataROI(3)*PixelSize;

   n_Ind = sum(Ind);
   fprintf('DataROI localizations kept = %d out of %d\n', n_Ind, numel(Ind));
   if n_Ind == 0
      error('No localizations kept!');
   end
else
   % This should be all the localizations not previously filtered out.
   Ind = SMD.FrameNum > 0;
end

% FULL plot (full set of SMD localizations).
figure;
hold on;
plot(SMD.X, SZ - SMD.Y, 'k.');
title('ALL localizations');
xlabel('x (pixels)');
ylabel('y (pixels)');
hold off;
saveas(gcf, fullfile(SaveDirLong, 'FULL'), 'png');

% Convert from pixels to nm.
SMD.X = PixelSize*SMD.X(Ind);
SMD.Y = PixelSize*SMD.Y(Ind);
SMD.Z = [];
SMD.X_SE = PixelSize*SMD.X_SE(Ind);
SMD.Y_SE = PixelSize*SMD.Y_SE(Ind);
SMD.Z_SE = [];
if isfield('SMD', 'NFrames')
   SMD.FrameNum = ...
      SMD.NFrames*single((SMD.DatasetNum(Ind)-1))+single(SMD.FrameNum(Ind));
end

% ROI plot (localizations only in ROI).
figure;
hold on;
plot(SMD.X/PixelSize, SZ - SMD.Y/PixelSize, 'k.');
title('ROI localizations');
xlabel('x (pixels)');
ylabel('y (pixels)');
hold off;
saveas(gcf, fullfile(SaveDirLong, 'ROI'), 'png');

%% Set the class properties
BGL = smi.BaGoL;
BGL.SMD = SMD;
   % Use a Hierarchial Prior to learn Xi if 1
BGL.HierarchFlag = 1;
   % Save the chain if 1
BGL.ChainFlag = 0;
   % Number of samples before sampling Xi
BGL.NSamples = BaGoLParams.NSamples;
   % Generate Posterior image if 1
BGL.PImageFlag = 1;
   % Size of the output posterior images
BGL.PImageSize = ImSize;
   % Size of the subregions to be processed
BGL.ROIsize = BaGoLParams.ROIsz;
   % Overlapping region size between adjacent regions
BGL.Overlap = BaGoLParams.OverLap;
   % Parameters for prior distribution (gamma in this case)
BGL.Cutoff = BaGoLParams.Cutoff;
   % Pre-clustering cutoff (nm) [default = ROIsz]
BGL.Xi = Xi;
   % Length of Burn-in chain
BGL.N_Burnin = BaGoLParams.N_Burnin;
   % Length of post-burn-in chain
BGL.N_Trials = BaGoLParams.N_Trials;
   % Expected magnitude of drift (nm/frame)
BGL.Drift = BaGoLParams.ClusterDrift;
   % Pixel size for the posterior image
BGL.PixelSize = BaGoLParams.OutputPixelSize;
   % Localization precision adjustment (nm)
BGL.SE_Adjust = BaGoLParams.SE_Adjust;
if ~isempty(DataROI)
   BGL.XStart = XStart;
   BGL.YStart = YStart;
end

% ---------- Run BaGoL

% Analyzing the data
BGL.analyze_all()

% ---------- Save Results and Plots

% This file can be huge for many localizations, so only produce it if the
% number of input localizations is not too large.  Most of the space is taken
% up by the Chain.
if numel(SMD.X) <= 100000
   fprintf('Saving BGL ...\n');
   try
%     BGL.Chain  = [];
%     BGL.PImage = [];
%     BGL.SMD    = [];
      save(fullfile(SaveDir, ...
              sprintf('BaGoL_Results_%s_ResultsStruct', FileName)), 'BGL');
   catch ME
      fprintf('### PROBLEM with saving BGL ###\n');
      fprintf('%s\n', ME.identifier);
      fprintf('%s\n', ME.message);
   end
end

% This file contains just the MAPN coordinates, so much smaller than the
% ResultsStruct file and should always be saved.  Also, save a few extra
% parameters that are handy for displaying ROIs.
fprintf('saveMAPN ...\n');
try
   MAPN = BGL.MAPN;
   PImageSize = BGL.PImageSize;
   PixelSizeSAVE = PixelSize;
   PixelSize = BaGoLParams.OutputPixelSize;
   save(fullfile(SaveDir, sprintf('MAPN_%s', FileName)), 'MAPN', ...
        'XStart', 'YStart', 'PImageSize', 'PixelSize');
   PixelSize = PixelSizeSAVE;
catch ME
   fprintf('### PROBLEM with saveMAPN ###\n');
   fprintf('%s\n', ME.identifier);
   fprintf('%s\n', ME.message);
end

% In general, the number of pixels that make up the scale bar is (from
% scalebar.m)
%    barlength = round(Length / PixelSize);
% where Length is the desired scale bar length in um (SMITE) or nm (BaGoL),
% and the input camera PixelSize is in corresponding units (um/pixel or
% nm/pixel).
%
% For SMITE Gaussian images, the SMD coordinates (pixels) are magnified by
% SRImageZoom (see +smi_vis/@GenerateImages/gaussianImage.m where
%    SMDin.X = SMD.X * SRImageZoom, etc.
% ), so the true scale bar length in original coordinates is thus
%    ScalebarLength / SRImageZoom
% which by default (see +smi_vis/@GenerateImages/gaussianImage.m:
%    ScalebarLength   scalebar length (um) [default: 10 um]
% and +smi/@SMLM/SMLM.m:
%    SRImageZoom  = 20 % magnification factor for SR     images generated
%    SRCircImZoom = 25 % magnification factor for circle images generated
% ) is 10 um / 20 = 0.5 um = 500 nm.
% For circle images, the default is 10 um / 25 = 0.4 um = 400 nm.
%
% Now for BaGoL Gaussian and circle plots, the input SMD structure from SMITE
% provided to BaGoL has pixel coordinates.  These are converted into nm via
% SMD.PixelSize (see "Convert from pixels to nm" above where there are lines
% like
%    SMD.X = PixelSize * SMD.X(Ind);
% in which PixelSize = BaGoLParams.PixelSize, that is, the input pixel size,
% meaning the camera number of nm per pixel).  To produce the Gaussian/circle
% plots, it is necessary to convert nm into the OutputPixelSize, which
% confusingly is called PixelSize in BaGoL (+smi/@BaGoL/hierBaGoL_analysis.m):
%    BGL.PixelSize = BaGoLParams.OutputPixelSize;
% For example, in +smi/@BaGoL/genSRMAPNOverlay.m, there are lines like
%    X = ((SMD.X - Xstart) / PixelSize);
% Therefore, the true scale bar length for these BaGoL plots will be simply
% ScaleBarLength (as the conversion to output pixels is done properly in
% scalebar.m).  ScaleBarLength defaults to 0.5 um = 500 nm (see line below).
ScaleBarLength = 500;   % nm
fprintf('ScaleBarLength = %g nm, OutputPixelSize = %g nm\n', ...
        ScaleBarLength, BaGoLParams.OutputPixelSize);

fprintf('saveBaGoL ...\n');
try
   BGL.saveBaGoL(ScaleBarLength, SaveDirLong, 1);
catch ME
   fprintf('### PROBLEM with saveBaGoL ###\n');
   fprintf('%s\n', ME.identifier);
   fprintf('%s\n', ME.message);
end

fprintf('plotMAPN ...\n');
try
   BGL.plotMAPN(SaveDirLong, 'on');
catch ME
   fprintf('### PROBLEM with plotMAPN ###\n');
   fprintf('%s\n', ME.identifier);
   fprintf('%s\n', ME.message);
end

fprintf('plotNND_PDF ...\n');
try
   BGL.plotNND_PDF(SaveDirLong)
catch ME
   fprintf('### PROBLEM with plotNND_PDF ###\n');
   fprintf('%s\n', ME.identifier);
   fprintf('%s\n', ME.message);
end

fprintf('genSRMAPNOverlay ...\n');
try
   MAPN = BGL.MAPN;
   MAPN.X_SE = max(1, MAPN.X_SE);
   MAPN.Y_SE = max(1, MAPN.Y_SE);
   RadiusScale = 2;
   if isempty(DataROI)
      BGL.genSRMAPNOverlay(BGL.SMD, MAPN, ImSize, ImSize, 'rescale', ...
                           SaveDirLong, 0, 0, RadiusScale, ScaleBarLength);
   else
      BGL.genSRMAPNOverlay(BGL.SMD, MAPN, ImSize, ImSize, 'rescale',    ...
                           SaveDirLong, XStart, YStart, RadiusScale,        ...
                           ScaleBarLength);
   end
catch ME
   fprintf('### PROBLEM with genSRMAPNOverlay ###\n');
   fprintf('%s\n', ME.identifier);
   fprintf('%s\n', ME.message);
end

%BGL.errPlot(BGL.MAPN);
%saveas(gcf, fullfile(SaveDirLong, 'MAPN_SE'), 'fig');

fprintf('XiChain ...\n');
try
   if numel(Xi) == 1
      plot(BGL.XiChain(:, 1), 'k.');
   else
      plot(BGL.XiChain(:, 1) .* BGL.XiChain(:, 2), 'k.');
   end
   hold on
   title('Xi chain');
   xlabel(sprintf('RJMCMC jumps sampled every %d', BaGoLParams.NSamples));
   ylabel('\lambda (localizations per emitter)');
   hold off
   saveas(gcf, fullfile(SaveDirLong, 'XiChain'), 'png');
catch ME
   fprintf('### PROBLEM with XiChain ###\n');
   fprintf('%s\n', ME.identifier);
   fprintf('%s\n', ME.message);
end

fprintf('MAPN_NmeanHistogram ...\n');
try
   h = histogram(MAPN.Nmean);
   hold on
   lo = BGL.N_Burnin/BGL.NSamples + 1;
   AB = median(BGL.XiChain(lo : end, :));
   X = h.BinLimits(1) : 0.1 : h.BinLimits(2); 
   plot(X, sum(h.Data(:)) * h.BinWidth * gampdf(X, AB(1), AB(2)));
%  plot(X, sum(BGL.XiChain(lo : end, 1) .* BGL.XiChain(lo : end, 2)) .* ...
%              gampdf(X, AB(1), AB(2)));
   title('MAPN localizations per emitter');
   xlabel('localizations per emitter');
   ylabel('frequency');
   legend('MAPN.Nmean', 'gampdf(XiChain)', 'Location', 'NorthEast');
   hold off
   saveas(gcf, fullfile(SaveDirLong, 'MAPN_NmeanHist'), 'png');
catch ME
   fprintf('### PROBLEM with MAPN_NmeanHist ###\n');
   fprintf('%s\n', ME.identifier);
   fprintf('%s\n', ME.message);
end

close all

fprintf('Producing prior.txt ...\n');
try
   L = BGL.XiChain;
   L = L(BGL.N_Burnin/BGL.NSamples + 1 : end, :);
   l = L(:, 1) .* L(:, 2);
   m = mean(l);
   v = var(l);
   theta = v / m;
   k = m / theta;
   fid = fopen(fullfile(SaveDirLong, 'prior.txt'), 'w');
   fprintf(fid, '(k, theta) = (%f, %f)\n', k, theta);
   fclose(fid);
catch ME
   fprintf('### PROBLEM with producing prior.txt ###\n');
   fprintf('%s\n', ME.identifier);
   fprintf('%s\n', ME.message);
end

end

./MATLAB/+smi/@BaGoL/importLLSMD.m
function importLLSMD(obj,SMD,PixelSize)
%importLLSMD Imports a Lidke Lab SMD and converts to BaGoL format
%
% The Lidke Lab standard has SMD in units of pixels.  This converts 
% SMD fields from Pixels to nm. The BaGoL SMD property is updated with the
% result. 
%
% INPUTS:
%   SMD:    SMD Structure with fields: 
%       X:      (Pixels)
%       Y:      (Pixels)
%       X_SE:   (Pixels)
%       Y_SE:   (Pixels)
%       FrameNum: (Frames)
%   PixelSize:  Camera back-projected pixel size (nm/Pixel)
% 

obj.SMD=[];
obj.SMD.X=SMD.X*PixelSize;
obj.SMD.Y=SMD.Y*PixelSize;
obj.SMD.X_SE=SMD.X_SE*PixelSize;
obj.SMD.Y_SE=SMD.Y_SE*PixelSize;
obj.SMD.FrameNum=SMD.FrameNum; 


end
./MATLAB/+smi/@BaGoL/genROIs.m
function ROIs = genROIs(obj)
%genROIs takes the input coordinates and splits them into smaller regions.
% ROIs = obj.genROIs()
%
% genROIs() uses the ROIsize and overlap size (see BaGoL properties) to
% break down the input localizations into smaller regions of interest.
% These regions are overlapped with their adjacent regions to avoid edge
% artifacts. The coordinates, precisions, frame numbers associated to each
% ROI are saved inside an element of the output structure array.
%
% INPUT:
%       X:        Vector of X localization positions (nm)(Nx1)
%       Y:        Vector of Y localization positions (nm)(Nx1)
%       Z:        Vector of Z localization positions (nm)(Nx1)(Optional)
%       X_SE:     Vector of X localization standard errors (nm)(Nx1)
%       Y_SE:     Vector of Y localization standard errors (nm)(Nx1)
%       Z_SE:     Vector of Z localization standard errors (nm)(Nx1)(Optional)
%       FrameNum: Vector of localization frame numbers (Nx1)
%
% OUTPUT:
%    ROIs: 2D Array of SMD structures with fields:
%       X:        Vector of X localization positions (nm)(Mx1)
%       Y:        Vector of Y localization positions (nm)(Mx1)
%       Z:        Vector of Z localization positions (nm)(Mx1)(Optional)
%       X_SE:     Vector of X localization standard errors (nm)(Mx1)
%       Y_SE:     Vector of Y localization standard errors (nm)(Mx1)
%       Z_SE:     Vector of Z localization standard errors (nm)(Mx1)(Optional)
%       FrameNum: Vector of localization frame numbers (Mx1)
%       Xsize:    Size of the region along X (nm)  
%       Ysize:    Size of the region along Y (nm)
%

% Created by:
%    Mohamadreza Fazel (LidkeLab 2019)

XPix = max(obj.SMD.X);
YPix = max(obj.SMD.Y);
MinX = min(obj.SMD.X);
MinY = min(obj.SMD.Y);
if MinX < obj.ROIsize && MinX > 0
    MinX = 0;
end
if MinY < obj.ROIsize && MinY > 0
    MinY = 0; 
end
Xsub = ceil((XPix-MinX)/obj.ROIsize); %number of the sub-regions along the X-axis
Ysub = ceil((YPix-MinY)/obj.ROIsize); %number of the sub-regions along the Y-axis
ROIs = [];
for ix = 1:Xsub
    for iy = 1:Ysub
        ROIex = obj.ROIsize + 2*obj.Overlap;
        ROIey = obj.ROIsize + 2*obj.Overlap;
        sy = obj.ROIsize*(iy-1)-obj.Overlap;
        ey = obj.ROIsize*iy+obj.Overlap;
        sx = obj.ROIsize*(ix-1)-obj.Overlap;
        ex = obj.ROIsize*ix+obj.Overlap;
        if iy == 1 
            ROIey = obj.ROIsize + obj.Overlap;
            sy = 0;
            ey = obj.ROIsize + obj.Overlap;
        end
        if ix == 1
            ROIex = obj.ROIsize + obj.Overlap;
            sx = 0;
            ex = obj.ROIsize + obj.Overlap;
        end
        if iy == Ysub
            %ey = YPix;
            ROIey = YPix-obj.ROIsize*(Ysub-1)+obj.Overlap;
        end
        if ix == Xsub
            %ex = XPix;
            ROIex = XPix-obj.ROIsize*(Xsub-1)+obj.Overlap;
        end
        if Xsub == 1
            ROIex = XPix;
        end
        if Ysub == 1
            ROIey = YPix;
        end
        Ind = obj.SMD.X-MinX >= sx & obj.SMD.X-MinX <= ex ...
             & obj.SMD.Y-MinY >= sy & obj.SMD.Y-MinY <= ey;
        ROIs(iy,ix).X = obj.SMD.X(Ind);
        ROIs(iy,ix).Y = obj.SMD.Y(Ind);
        
        if isfield(obj.SMD,'Z') 
            if ~isempty(obj.SMD.Z)
                ROIs(iy,ix).Z = obj.SMD.Z(Ind);
            else
                ROIs(iy,ix).Z = [];
            end
        else
            ROIs(iy,ix).Z = [];
            obj.SMD.Z=[];
        end
        
        ROIs(iy,ix).X_SE = obj.SMD.X_SE(Ind);
        ROIs(iy,ix).Y_SE = obj.SMD.Y_SE(Ind);
        
        if isfield(obj.SMD,'Z') 
            if ~isempty(obj.SMD.Z)
                ROIs(iy,ix).Z_SE = obj.SMD.Z_SE(Ind);
            else
                ROIs(iy,ix).Z_SE = [];
            end
        else
            ROIs(iy,ix).Z_SE = [];
        end
        
        if ~isempty(obj.SMD.FrameNum)
            ROIs(iy,ix).FrameNum = obj.SMD.FrameNum(Ind);
        else
            ROIs(iy,ix).FrameNum = []; 
        end
        ROIs(iy,ix).Xsize = ROIex;
        ROIs(iy,ix).Ysize = ROIey;
    end
end
end

./MATLAB/+smi/@BaGoL/scalebar.m
function [ImageOut] = scalebar(Image,PixelSize,Length,Location)
%scalebar Add scalebar to image.
% [ImageOut,Image] = BaGoL.scalebar(Image,PixelSize,Length,Location)
%   
% INPUTS:
%    Image:      Input image
%    PixelSize:  Pixel size of input image (nm) 
%    Length:     Desired length of the scalebar (nm)
%    Location:   Desired location of scalebar on image. Options are
%                {'topleft', 'topright', 'bottomleft', 'bottomright'}.
%                (Default = 'bottomright')
%
% OUTPUTS:
%    Imageout:   Output image with scalebar superimposed
%
% REQUIRES:
%    Statistics Toolbox
%

% Created by:
%    Sandeep Pallikkuth (LidkeLab 2017)       

if nargin<3
    msg1='Not enough input. Please input image, pixel size, scalebar length and scale bar location !';
    error(msg1);
elseif nargin<4
    Location='bottomright';
end

% Processing input image
sizein=size(Image);     % determine size of image
channels=length(sizein);    
in=Image;

% Scalebar Color
sbcolor=[255 255 255];    %white scalebar

% Calculate scale bar length
if PixelSize>Length
    disp('Input scalebar length smaller than pixel size. Scalebar length re-sized to 10 pixels');
    barlength=10;
else
    barlength=round(Length/PixelSize);
end

%fprintf( ...
% 'scalebar: size = %d, PixelSize = %g nm, Length = %d nm, barlength = %d\n',...
%        sizein(1), PixelSize, Length, barlength);

% Calculate scale bar width
barwidth=round(sizein(2)*0.015);

if channels==3
    switch Location
        case 'bottomright'
            in(round(0.9*sizein(1))-barwidth:round(0.9*sizein(1)),round(0.9*sizein(2))-barlength:round(0.9*sizein(2)),1)=sbcolor(1);
            in(round(0.9*sizein(1))-barwidth:round(0.9*sizein(1)),round(0.9*sizein(2))-barlength:round(0.9*sizein(2)),2)=sbcolor(2);
            in(round(0.9*sizein(1))-barwidth:round(0.9*sizein(1)),round(0.9*sizein(2))-barlength:round(0.9*sizein(2)),3)=sbcolor(3);
        case 'bottomleft'
            in(round(0.9*sizein(1))-barwidth:round(0.9*sizein(1)),round(0.1*sizein(2)):round(0.1*sizein(2))+barlength,1)=sbcolor(1);
            in(round(0.9*sizein(1))-barwidth:round(0.9*sizein(1)),round(0.1*sizein(2)):round(0.1*sizein(2))+barlength,2)=sbcolor(2);
            in(round(0.9*sizein(1))-barwidth:round(0.9*sizein(1)),round(0.1*sizein(2)):round(0.1*sizein(2))+barlength,3)=sbcolor(3);
        case 'topright'
            in(round(0.1*sizein(1))-barwidth:round(0.1*sizein(1)),round(0.9*sizein(2))-barlength:round(0.9*sizein(2)),1)=sbcolor(1);
            in(round(0.1*sizein(1))-barwidth:round(0.1*sizein(1)),round(0.9*sizein(2))-barlength:round(0.9*sizein(2)),2)=sbcolor(2);
            in(round(0.1*sizein(1))-barwidth:round(0.1*sizein(1)),round(0.9*sizein(2))-barlength:round(0.9*sizein(2)),3)=sbcolor(3);
        case 'topleft'
            in(round(0.1*sizein(1))-barwidth:round(0.1*sizein(1)),round(0.1*sizein(2)):round(0.1*sizein(2))+barlength,1)=sbcolor(1);
            in(round(0.1*sizein(1))-barwidth:round(0.1*sizein(1)),round(0.1*sizein(2)):round(0.1*sizein(2))+barlength,2)=sbcolor(2);
            in(round(0.1*sizein(1))-barwidth:round(0.1*sizein(1)),round(0.1*sizein(2)):round(0.1*sizein(2))+barlength,3)=sbcolor(3);
    end
else
    switch Location
        case 'bottomright'
            in(round(0.9*sizein(1))-barwidth:round(0.9*sizein(1)),round(0.9*sizein(2))-barlength:round(0.9*sizein(2)),1)=sbcolor(1);
        case 'bottomleft'
            in(round(0.9*sizein(1))-barwidth:round(0.9*sizein(1)),round(0.1*sizein(2)):round(0.1*sizein(2))+barlength,1)=sbcolor(1);
        case 'topright'
            in(round(0.1*sizein(1))-barwidth:round(0.1*sizein(1)),round(0.9*sizein(2))-barlength:round(0.9*sizein(2)),1)=sbcolor(1);
        case 'topleft'
            in(round(0.1*sizein(1))-barwidth:round(0.1*sizein(1)),round(0.1*sizein(2)):round(0.1*sizein(2))+barlength,1)=sbcolor(1);
    end
end    

ImageOut=in;


end


./MATLAB/+smi/@BaGoL/align_template.m
function [Alpha,XShift,YShift,Aligned,Chain] = align_template(Temp,Input,Start,Cutoff,NChain,PlotFlag)
%align_template Aligns a set of points to a template.
% [Alpha,XShift,YShift,Aligned,Chain] = BaGoL.align_template(Temp,Input,Start,Cutoff,NChain,PlotFlag)
%
% This method finds the shift and rotation of a set of points that minimizes
% the sum of distances of pairs from the sample to the template. Pair
% distances above a cutoff and unmatched points use the cost at the 
% cutoff distance. 
%
% INPUTS:
%   Temp:       SMD Structure of the template with fields
%       X:      X positions of the template (nm)(Nx1)
%       Y:      Y positions of the template (nm)(Nx1)
%   Input:      SMD Structure of the sample with fields
%       X:      X positions of the sample (nm)(Mx1)
%       Y:      Y positions of the sample (nm)(Mx1)
%   Start:      Structure of starting values for shift and rotation
%       Theta:  (radians)
%       ShiftX: (nm)
%       ShiftY: (nm)    
%    Cutoff:   Saturation distance for cost function (nm) 
%    NChain:   Number of jumps in MCMC algorithm. (Default = 5000)
%    PlotFlag: 0 or 1, Show an animation of the accepted jumps. (Default = 0)
%
% OUTPUTS:
%    Alpha:    The rotation angle. (radians)
%    XShift:   The translation along the X-axis. (nm)
%    YShift:   The translation along the Y-axis. (nm)
%    Aligned:  Structure containing the aligned coordinates
%       X:     (Mx1) (nm)
%       Y:     (Mx1) (nm)
%    Chain:    Structure array of accepted jumps in parameter space 
%       Theta:      Angle (radians) (NChain x 1)
%       XShift:     Sample shift in X (NChain x 1)
%       YShift:     Sample shift in Y (NChain x 1)

% Created by:
%    Mohamadreza Fazel (LidkeLab 2019)

if nargin < 4
   error('There must be at leat 4 inputs.') 
end

if nargin < 5
   NChain = 5000;
   PlotFlag = 0;
end

if nargin < 6
   PlotFlag = 0; 
end

Aligned.X = [];
Aligned.Y = [];

TempX = Temp.X - mean(Temp.X);
TempY = Temp.Y - mean(Temp.Y);

XLim = [min(TempX)-10 max(TempX)+10];
YLim = [min(TempY)-10 max(TempY)+10];

X = Input.X';
Y = Input.Y';
X = X - mean(X);
Y = Y - mean(Y);

Points = [X;Y];
[~,Dis] = knnsearch(Points',[TempX',TempY']);
Dis = abs(Dis);
Dis(Dis>Cutoff) = Cutoff;
Cost_Current = sum(Dis);

Start_Theta = Start.Theta;
Start_ShiftX = Start.ShiftX;
Start_ShiftY = Start.ShiftY;

Theta = zeros(NChain,1);
DelX = zeros(NChain,1);
DelY = zeros(NChain,1);

Theta(1) = Start_Theta;
DelX(1) = Start_ShiftX;
DelY(1) = Start_ShiftY;
if PlotFlag
    figure;hold;
    V1 = VideoWriter('Alignment','MPEG-4');
    V1.FrameRate = 10; 
    open(V1) 
end
for nn = 2:NChain
    
    if nn < NChain/2
        Theta_P = Theta(nn-1)+randn();
        DelX_P = DelX(nn-1) + 0.5*randn();
        DelY_P = DelY(nn-1) + 0.5*randn();
    else
        Theta_P = Theta(nn-1)+0.1*randn();
        DelX_P = DelX(nn-1) + 0.02*randn();
        DelY_P = DelY(nn-1) + 0.02*randn();
    end
    R = [cos(Theta_P),sin(Theta_P);-sin(Theta_P),cos(Theta_P)];
    
    Points = [X;Y];
    Points = R*Points;
    Points(1,:) = Points(1,:)+DelX_P;
    Points(2,:) = Points(2,:)+DelY_P;
    
    [~,Dis]=knnsearch(Points',[TempX',TempY']);
    Dis = abs(Dis);
    Dis(Dis>Cutoff) = 20;
    Cost_Proposed = sum(Dis);
    
    if Cost_Current - Cost_Proposed > -rand()
        if PlotFlag
            plot(TempX,TempY,'*')
            hold;
            plot(Points(1,:),Points(2,:),'*')
            title(sprintf('Step:%g',nn))
            xlim(XLim);ylim(YLim)
            SP = sprintf('Data: %g',nn);
            legend(SP)
            Frame = getframe(gcf);
            writeVideo(V1,Frame);
            hold off
        end
        Theta(nn) = Theta_P;
        DelX(nn) = DelX_P;
        DelY(nn) = DelY_P;
        Cost_Current = Cost_Proposed;
    else
        Theta(nn) = Theta(nn-1);
        DelX(nn) = DelX(nn-1);
        DelY(nn) = DelY(nn-1);
    end
    
end
if PlotFlag
    close(V1)
end
Chain.Theta = Theta;
Chain.XShift = DelX;
Chain.YShift = DelY;

Alpha = mean(Theta(round(NChain/2),:));
XShift = mean(DelX(round(NChain/2),:));
YShift = mean(DelY(round(NChain/2),:));

R = [cos(Alpha),sin(Alpha);-sin(Alpha),cos(Alpha)];
Points = [X;Y];
Points = R*Points;
Points(1,:) = Points(1,:)+XShift;
Points(2,:) = Points(2,:)+YShift;

Aligned.X = cat(1,Aligned.X,Points(1,:)'+mean(Temp.X));
Aligned.Y = cat(1,Aligned.Y,Points(2,:)'+mean(Temp.Y));

end

./MATLAB/+smi/@BaGoL/samplePoiss.m
function Xi = samplePoiss(NPoints,K,Xi,Alpha,Beta)
%samplePoiss() infers parameter of Poisson prior on number of locas per emitters
%
%Here, the prior parameters are learned using a hierarchical Bayes skim.
%
% INPUT:
%   NPoints: Number of localizations within ROIs
%   K:       Number of found emitters within ROIs
%   Xi:      Current parameter values of the Prior
%   Alpha:   Shape parameter of Lambda hyper-prior (Default = 1)
%   Bets:    Scale parameter of Lambda hyper-prior (Default = 50)
%
% OUTPUT: 
%   Xi:  Updated mean for Poisson prior on number of emitters
%

% Created by:
%   Mohamadreza Fazel (Lidke lab, 2022)
% 

if nargin < 4
    Alpha = 1;
end
if nargin < 5
    Beta = 100;
end
Alpha_Prop = 3000;

%10 samples are taken in a row and the last one is returned
for ii = 1:10
    
    %Sample Lambda
    Xi_Prop = gamrnd(Alpha_Prop,Xi/Alpha_Prop);
    LogLikeR = sum(log(poisspdf(NPoints,K*Xi_Prop)) - log(poisspdf(NPoints,K*Xi)));
    LogPriorR = log(gampdf(Xi_Prop,Alpha,Beta)) - log(gampdf(Xi,Alpha,Beta));
    LogPropR = log(gampdf(Xi,Alpha_Prop,Xi_Prop/Alpha_Prop)) ...
        - log(gampdf(Xi_Prop,Alpha_Prop,Xi/Alpha_Prop));

    if LogLikeR + LogPriorR + LogPropR > log(rand())
       Xi = Xi_Prop; 
    end

end

end
./MATLAB/+smi/@BaGoL/saveMAPN.m
function saveMAPN(Directory,FileType,MAPN)
%saveMAPN Saves the MAPN coordinates 
% BaGoL.saveMAPN(Directory,FileType,MAPN)
%
% The MAPN SMD structure is saved to a file with several file type
% options. 
%
% The 'mat' file format saves the MAPN SMD directly with variable name
% 'MAPN'.  
%
% The 'PICASSOh5' h5-file is in a format readable by the PICASSO 
% software package.  See:
%
% Schnitzbauer, et al, "Super-resolution microscopy with DNA-PAINT",
% Nature Protocol, 2017.
%
% The 'hdf5' file type is for testing only. 
%
% INPUT:
%    Directory: Save directory
%    FileType:  Save format: 'mat', 'PICASSOh5' or 'hdf5'
%    MAPN:      MAPN SMD structure containing the coordinates to be saved
%
% OUTPUTS:
%    None
%

% Created By:
%    Mohmadreza Fazel (LidkeLab 2019)

switch FileType
    case 'mat'
        save(fullfile(Directory,'MAPN'),'MAPN');
    case 'PICASSOh5'
        SZ = size(MAPN.X);
        h5create(fullfile(Directory,'MAPN.h5'),'/MAPN.X',SZ);
        h5create(fullfile(Directory,'MAPN.h5'),'/MAPN/Y',SZ);
        h5create(fullfile(Directory,'MAPN.h5'),'/MAPN.X_SE',SZ);
        h5create(fullfile(Directory,'MAPN.h5'),'/MAPN.Y_SE',SZ);
        h5create(fullfile(Directory,'MAPN.h5'),'/MAPN.Nmean',SZ);
        h5create(fullfile(Directory,'MAPN.h5'),'/MAPN.AlphaX',SZ);
        h5create(fullfile(Directory,'MAPN.h5'),'/MAPN.AlphaY',SZ);
        h5create(fullfile(Directory,'MAPN.h5'),'/MAPN.AlphaX_SE',SZ);
        h5create(fullfile(Directory,'MAPN.h5'),'/MAPN.AlphaY_SE',SZ);
        h5write(fullfile(Directory,'MAPN.h5'),'/MAPN/X',MAPN.X);
        h5write(fullfile(Directory,'MAPN.h5'),'/MAPN/Y',MAPN.Y);
        h5write(fullfile(Directory,'MAPN.h5'),'/MAPN/X_SE',MAPN.X_SE);
        h5write(fullfile(Directory,'MAPN.h5'),'/MAPN/Y_SE',MAPN.Y_SE);
        h5write(fullfile(Directory,'MAPN.h5'),'/MAPN/Nmean',MAPN.Nmean);
        h5write(fullfile(Directory,'MAPN.h5'),'/MAPN/AlphaX',MAPN.AlphaX);
        h5write(fullfile(Directory,'MAPN.h5'),'/MAPN/AlphaY',MAPN.AlphaY);
        h5write(fullfile(Directory,'MAPN.h5'),'/MAPN/AlphaX_SE',MAPN.AlphaX_SE);
        h5write(fullfile(Directory,'MAPN.h5'),'/MAPN/AlphaY_SE',MAPN.AlphaY_SE);
        if ~isempty(MAPN.Z) && isfield(MAPN,'Z')
            h5create(fullfile(Directory,'MAPN.h5'),'/MAPN/Z',SZ);
            h5create(fullfile(Directory,'MAPN.h5'),'/MAPN/Z_SE',SZ);
            h5create(fullfile(Directory,'MAPN.h5'),'/MAPN/AlphaZ',SZ);
            h5create(fullfile(Directory,'MAPN.h5'),'/MAPN/AlphaZ_SE',SZ);
            h5write(fullfile(Directory,'MAPN.h5'),'/MAPN/Z',MAPN.Z);
            h5write(fullfile(Directory,'MAPN.h5'),'/MAPN/Z_SE',MAPN.Z_SE);
            h5write(fullfile(Directory,'MAPN.h5'),'/MAPN/AlphaZ',MAPN.AlphaZ);
            h5write(fullfile(Directory,'MAPN.h5'),'/MAPN/AlphaZ_SE',MAPN.AlphaZ_SE);
        end
    case 'hdf5'
        %Getting dtructure Info
        FileName = 'MAPN.hdf5';
        Dataset = 'locs';
        MAPN=rmfield(MAPN,'N');
        Fields = fieldnames(MAPN);
        for ii = length(Fields):-1:1
             MAPN=setfield(MAPN,Fields{ii},single(getfield(MAPN,Fields{ii})));
        end
        NFields = length(Fields);
        Dims = length(getfield(MAPN,Fields{1}));
        %Creating an empty hdf5-file in the given directory
        File = H5F.create(fullfile(Directory,FileName), 'H5F_ACC_TRUNC', ...
                'H5P_DEFAULT', 'H5P_DEFAULT');
        %Creating single data types
        SingleType = H5T.copy('H5T_NATIVE_FLOAT');
        SZt = H5T.get_size(SingleType);
        SZ = SZt*ones(1,NFields);
        %Computer offsets to each field. The first offset is always zero.
        offset(1) = 0;
        offset(2:NFields) = cumsum(SZ(1:NFields-1));
        %Creating compound datatype for memory
        Memtype = H5T.create('H5T_COMPOUND',sum(SZ));
        for ii = 1:NFields
            H5T.insert(Memtype,Fields{ii},offset(ii),SingleType); 
        end
        %Create the compound datatype for the file.
        FileType = H5T.create('H5T_COMPOUND', sum(SZ));
        for ii = 1:NFields
            H5T.insert(FileType,Fields{ii},offset(ii),SingleType); 
        end
        % Create dataspace. Setting the maximum size to [] sets 
        %  the maximum size to be current size
        Space = H5S.create_simple(1,fliplr(Dims),[]);
        %Creat the dataset and write the compound data to it
        Dset = H5D.create(File, Dataset, FileType, Space, 'H5P_DEFAULT');
        H5D.write(Dset,Memtype,'H5S_ALL','H5S_ALL','H5P_DEFAULT',MAPN);
        %Close and release resources
        H5D.close(Dset);
        H5S.close(Space);
        H5T.close(FileType);
        H5F.close(File);
end
end

./MATLAB/+smi/@BaGoL/plotMAPN.m
function plotMAPN(obj,SaveDir,PlotVis)
%plotCluster: Plots the MAPN positions together with input localizations
% obj.plotCluster(FlagOrDir,FlagPlot)
%
% The first plot is color-coded frame numbers and the MAPN position.
% The second plot is plot of data points before and after filtering and the
% MAPN coordinates.  The plots are saved in the directory given (optional)
% in fig-format.
%
% INPUTS:
%   SaveDir: Save directory (Optional) 
%   PlotVis: Show the plots (Default=off) (Optional)
%
% OUTPUT:
%    None
%

% Created by:
%    Mohamadreza Fazel (LidkeLab 2019)
%

if nargin < 3
   PlotVis = 'off'; 
end

    figure('Visible',PlotVis);hold;
    P1 = scatter(obj.ClusterSMD(1).X,obj.ClusterSMD(1).Y,[],obj.ClusterSMD(1).FrameNum);
    for mm = 2:length(obj.ClusterSMD)
        scatter(obj.ClusterSMD(mm).X,obj.ClusterSMD(mm).Y,[],obj.ClusterSMD(mm).FrameNum)
    end
    P2 = plot(obj.MAPN.X,obj.MAPN.Y,'*k');
    colorbar();xlabel('X(nm)','FontSize',16);ylabel('Y(nm)','FontSize',16)
    axis equal;
    legend([P1,P2],{'Localizations','Groups centers'})    
    saveas(gcf,fullfile(SaveDir,'LocsScatter-MAPN.fig')) 

end

./MATLAB/+smi/@BaGoL/BaGoL_RJMCMC_Hierarchical.m
function [K,Mu_X,Mu_Y,Alpha_X,Alpha_Y,Z]=BaGoL_RJMCMC_Hierarchical(SMD,PDFgrid,...
               SigAlpha,PMove,NSamples,Xi,Mu_X,Mu_Y,Alpha_X,Alpha_Y)
%BaGoL_RJMCMC_Hierarchical BaGoL's core RJMCMC algorithm that takes
%NSamples samples from the posterior using RJMCMC and return the last
%sample to be used in the hierarchical Bayes approach.
% [Chain]=BaGoL.BaGoL_RJMCMC(SMD,Xi,MaxAlpha,PMove,NChain,NBurnin,DEBUG)
%
% This is the core BaGoL algorithm. It uses Reversible Jump Markov Chain 
% Monte Carlo to add, remove and move emitters, and to explore the 
% allocation of localizations to emitters.  
%
% The number of localizations per emitter distribution is parameterized by  
% either a Poisson or Gamma distribution function. For the Poisson 
% distribution, the parameter [lambda] is the mean number of localizations 
% per emitter. For the Gamma distribution, [k, theta] are the shape and 
% scale parameters. k*theta is the mean localizations per emitter. 
%
% A linear drift of individual emitters can be included by allowing
% MaxAlpha to be non-zero. Drift velocities are given a uniform prior for
% each dimension from -MaxAlpha to MaxAlpha. 
%
% The output chain is a structure array of the post burn-in states for the
% input subregion. Each element of the array contains fields 
% associated to a single accepted proposal. A description of the fields is
% given below. 
%
% INPUTS:
%    SMD:      SMD structure with the following fields:
%       X:     X localization coordinates. (nm) (Nx1)
%       Y:     Y localization coordinates. (nm) (Nx1)
%       X_SE:  X localization precisions.  (nm) (Nx1)
%       Y_SE:  Y localization precisions.  (nm) (Nx1)
%       FrameNum:   localization frame numbers. (Nx1)
%    Xi:       Loc./emitter params [lambda] (Poisson) or [k theta] (Gamma) 
%    SigAlpha: Sigma of drift velocity. (nm) (Default = 0)
%    PMove:    Probabilities of proposing different moves in RJMCMC:
%              [1] Move Mu, Alpha
%              [2] Reallocation of Z
%              [3] Add
%              [4] Remove
%              (1x4) (Default = [0.25, 0.25, 0.25, 0.25])
%    NChain:   Length of the chain after the burn in. (Default = 2000)
%    NBurnin:  Length of the chain for burn in. (Default = 3000)
%    DEBUG:    0 or 1. Show an animation of the chain. (Default = 0)
%
% OUTPUT:
%    Chain:    Structure array of post burn-in states of the RJMCMC Chain. 
%       N: Number of emitters (Scalar)
%       X: X coordinate of emitters (Kx1)
%       Y: Y coordinate of emitters (Kx1)
%       AlphaX: Corresponding X drift velocities (Kx1)
%       AlphaY: Corresponding Y drift velocities (Kx1)
%       ID: Allocation parameter representing assigning a localization to 
%           an emitter. The order is the same as SMD.X (see above) (Nx1) 
%
% CITATION: "Sub-Nanometer Precision using Bayesian Grouping of Localizations"
%           Mohamadreza Fazel, Michael J. Wester, Sebastian Restrepo Cruz,
%           Sebastian Strauss, Florian Schueder, Thomas Schlichthaerle, 
%           Jennifer M. Gillette, Diane S. Lidke, Bernd Rieger,
%           Ralf Jungmann, Keith A. Lidke
%

% Created by: 
%    Mohamadreza Fazel and Keith A. Lidke (Lidkelab 2020)

%DEBUG=0;

X_min = min(SMD.X-3*SMD.X_SE);
Y_min = min(SMD.Y-3*SMD.Y_SE);

CDF = cumsum(PDFgrid(:)/sum(PDFgrid(:)));
PDFgrid = PDFgrid/sum(PDFgrid(:));
Area = sum(sum(PDFgrid>max(PDFgrid(:))/1000));

if nargin<4
    PMove = [.25 .25 .25 .25]; %PMove = [Theta Z Birth Death]
end
if nargin<5
    NSamples = 10;
end

N=length(SMD.X);
if nargin<7
%Intial K Guess
    K=ceil(N/prod(Xi));
else
    K=length(Mu_X); 
end
if nargin<7
%Initial Locations
    Mu_X =SMD.X(randi(N,[1 K]))';
    Mu_Y =SMD.Y(randi(N,[1 K]))';
end
if nargin<9
%Initial Alphas
    Alpha_X = zeros([1 K]);
    Alpha_Y = zeros([1 K]);
end

% Intial Allocation
Z=Gibbs_Z(SMD,K,Mu_X,Mu_Y,Alpha_X,Alpha_Y);


if N < 100
   LengN = 100; 
else
   LengN = N; 
end
%Calculating the Prior
if length(Xi)>1
   Gamma_K=Xi(1);
   Gamma_Theta=Xi(2);
   Pk=gampdf(N,(1:LengN)*Gamma_K,Gamma_Theta);
else
   Pk=poisspdf(N,(1:LengN)*Xi); 
end
Pk = Pk/sum(Pk);

% Run Chain
for nn=1:NSamples
    %Get move type:
    JumpType=length(PMove)+1-sum(rand<cumsum(PMove));
    K = length(Mu_X);
    for ii = K:-1:1
        if sum(Z==ii)==0
            Mu_X(ii)=[];
            Mu_Y(ii)=[];
            Alpha_X(ii)=[];
            Alpha_Y(ii)=[];
            K = length(Mu_X);%K-1;
            Z(Z>ii) = Z(Z>ii) - 1;
        end 
    end
    switch JumpType
        case 1  %Move Mu, Alpha 
            Mu_XTest=Mu_X;
            Mu_YTest=Mu_Y;
            Alpha_XTest=Alpha_X;
            Alpha_YTest=Alpha_Y;
            
            for ID=1:K  
                %Get new Mu and Alpha using Gibbs
                if SigAlpha>0
                   [Mu_XTest(ID),Alpha_XTest(ID)]=Gibbs_MuAlpha(ID,Z,SMD.X,SMD.FrameNum,SMD.X_SE,SigAlpha);
                   [Mu_YTest(ID),Alpha_YTest(ID)]=Gibbs_MuAlpha(ID,Z,SMD.Y,SMD.FrameNum,SMD.Y_SE,SigAlpha);
                else
                   [Mu_XTest(ID)]=Gibbs_Mu(ID,Z,SMD.X,SMD.X_SE);
                   [Mu_YTest(ID)]=Gibbs_Mu(ID,Z,SMD.Y,SMD.Y_SE);
                end 
            end
            
            Mu_X = Mu_XTest;
            Mu_Y = Mu_YTest;
            Alpha_X = Alpha_XTest;
            Alpha_Y = Alpha_YTest;

        case 2  %Reallocation of Z
            
            [ZTest]=Gibbs_Z(SMD, K,Mu_X,Mu_Y,Alpha_X,Alpha_Y);
            %Always accepted
            Z = ZTest;
                                    
        case 3  %Add
                        
%           Sample the Emitter location from SR data
            ID = find(CDF>rand(),1);
            if isempty(ID)
                ID = length(CDF); 
            end
            [Ydraw,Xdraw]=ind2sub(size(PDFgrid),ID);
            Mu_XTest = cat(2,Mu_X,Xdraw+X_min-1);
            Mu_YTest = cat(2,Mu_Y,Ydraw+Y_min-1);      

            if SigAlpha>0
                Alpha_XTest = cat(2,Alpha_X,SigAlpha*randn());
                Alpha_YTest = cat(2,Alpha_Y,SigAlpha*randn());
            else
                Alpha_XTest = cat(2,Alpha_X,0);
                Alpha_YTest = cat(2,Alpha_Y,0);
            end
            
            %Gibbs allocation
            [ZTest]=Gibbs_Z(SMD,K+1,Mu_XTest,Mu_YTest,Alpha_XTest,Alpha_YTest);
                        
            %Prior Raio
            PR = Pk(K+1)/Pk(K);
            
            LAlloc_Current = p_Alloc(SMD,Mu_X,Mu_Y,Alpha_X,Alpha_Y,ones(1,K)/K);
            LAlloc_Test = p_Alloc(SMD,Mu_XTest,Mu_YTest,Alpha_XTest,Alpha_YTest,ones(1,K+1)/(K+1));
            AllocR = exp(LAlloc_Test-LAlloc_Current);
            
            %Posterior Ratio
            A = PR*AllocR/(Area*PDFgrid(ID));
            
            Accept = isinf(LAlloc_Current) & LAlloc_Current < 0;
            
            if rand<A || Accept
                Z=ZTest;
                K=K+1;
                Mu_X=Mu_XTest;
                Mu_Y=Mu_YTest;
                Alpha_X=Alpha_XTest;
                Alpha_Y=Alpha_YTest;
            end
            
        case 4  %Remove
            
            if K==1 %Then update chain and return
                continue;
            end
            
            %pick emitter to remove:
            ID =randi(K);
            
            Mu_XTest = Mu_X;
            Mu_YTest = Mu_Y;
            Alpha_XTest = Alpha_X;
            Alpha_YTest = Alpha_Y;
            
            %Remove from list
            Mu_XTest(ID) = [];
            Mu_YTest(ID) = [];
            Alpha_XTest(ID) = [];
            Alpha_YTest(ID) = [];
            
            %Gibbs allocation
            [ZTest]=Gibbs_Z(SMD,K-1,Mu_XTest,Mu_YTest,Alpha_XTest,Alpha_YTest);
            
            %Prior Raio
            PR = Pk(K-1)/Pk(K);
            
            %Probability Ratio of Proposed Allocation and Current Allocation 
            LAlloc_Current = p_Alloc(SMD,Mu_X,Mu_Y,Alpha_X,Alpha_Y,ones(1,K)/K);
            LAlloc_Test = p_Alloc(SMD,Mu_XTest,Mu_YTest,Alpha_XTest,Alpha_YTest,ones(1,K-1)/(K-1));
            AllocR = exp(LAlloc_Test-LAlloc_Current);
            
            %Posterior Ratio
            A = PR*AllocR;
            
            if rand<A
                Z=ZTest;
                K=K-1;
                Mu_X=Mu_XTest;
                Mu_Y=Mu_YTest;
                Alpha_X=Alpha_XTest;
                Alpha_Y=Alpha_YTest;
            end
                        
    end    
    
    DEBUG = 0;
    if DEBUG==1 %for testing
        figure(1111)
        scatter(SMD.X,SMD.Y,[],Z)
        hold on
        plot(Mu_X,Mu_Y,'ro','linewidth',4)
        set(gca,'Ydir','reverse')
        legend(sprintf('Jump: %g',nn))
        xlabel('X(nm)')
        ylabel('Y(nm)')
        hold off
        pause(.001)
    elseif DEBUG == 2
        RadiusScale = 2;
        CircleRadius = sqrt((SMD.X_SE.^2 + SMD.Y_SE.^2) / 2) * RadiusScale;
        figure(1111)
        for oo = 1:max(Z)
            ID = Z==oo;
            Theta = linspace(0, 2*pi, 25)';
            Theta = repmat(Theta,[1,sum(ID)]);
            CircleX = repmat(CircleRadius(ID)',[25,1]).*cos(Theta) + repmat(SMD.X(ID)',[25,1]);
            CircleY = repmat(CircleRadius(ID)',[25,1]).*sin(Theta) + repmat(SMD.Y(ID)',[25,1]);
            A=plot(CircleX,CircleY);
            if oo == 1;hold on;end
            if ~isempty(A)
                set(A,'color',A(1).Color);
            end
        end
        plot(Mu_X,Mu_Y,'ro','linewidth',4)
        legend(sprintf('Jump: %g',nn))
        xlabel('X(nm)')
        ylabel('Y(nm)')
       
        hold off
        pause(.001)
    end
end

end

function [ZTest]=Gibbs_Z(SMD,K,Mu_X,Mu_Y,Alpha_X,Alpha_Y)
    %This function calculates updated allocations (Z)
    
    T=SMD.FrameNum;
    N=length(T);
    PX=zeros(N,K);
    PY=zeros(N,K);
   
    X=repmat(SMD.X,size(Mu_X));
    Y=repmat(SMD.Y,size(Mu_X));
    T=repmat(T,size(Mu_X));
    X_SE=repmat(SMD.X_SE,size(Mu_X));
    Y_SE=repmat(SMD.Y_SE,size(Mu_X));
    MUX=repmat(Mu_X,size(SMD.X));
    MUY=repmat(Mu_Y,size(SMD.Y));
    AX=repmat(Alpha_X,size(SMD.X));
    AY=repmat(Alpha_Y,size(SMD.Y));
    
    PX=normpdf(X-(MUX+AX.*T),0,X_SE);
    PY=normpdf(Y-(MUY+AY.*T),0,Y_SE);
    P=PX.*PY+eps;
    PNorm=P./repmat(sum(P,2),[1 K]);

    if sum(sum(isnan(P)))
       [ZTest] = knnsearch([Mu_X',Mu_Y'],[SMD.X,SMD.Y]); 
    else 
        ZTest=K+1-sum(repmat(rand(N,1),[1,K])<(cumsum(PNorm,2)+eps),2);
    end
     
end

function [Mu,Alpha]=Gibbs_MuAlpha(ID,Z,X,T,Sigma,SigAlpha)
    %This function calculates updated Mu and Alpha (1D)
    
    if length(X)==1
        Mu=Gibbs_Mu(ID,Z,X,Sigma);
        Alpha = 0;
        return;
    end
    
    if sum(Z==ID)==0
        Mu = X(randi(length(X)));
        Alpha = -SigAlpha+2*SigAlpha*rand();
    else
        %Get the localizations from the IDth emitter
        Xs=X(Z==ID);
        Sigs = Sigma(Z==ID);
        Ts=T(Z==ID);

        A = sum(Sigs.^-2);
        B = sum(Ts./Sigs.^2);
        D = sum((Ts.^2)./(Sigs.^2));

        %MLE estimates of Mu and Alpha

        [Alpha,Center] = calAlpha(Xs,Sigs,Ts,SigAlpha);
        MA=[Center;Alpha];

        %Covariance matrix Sigma
        COV = pinv([A, B;B,D+1/SigAlpha^2]);

        %This draws [Mu,Alpha] from a multivariate normal
        MuAlpha=mvnrnd(MA,COV);
        Mu=MuAlpha(1);
        Alpha=MuAlpha(2);

        if Mu == Center
           Mu = Center + sqrt(A)*randn(); 
        end
    end
    
end

function [Mu]=Gibbs_Mu(ID,Z,X,Sigma)
    %This function calculates updated Mu (1D)
    
    %Get the localizations from the IDth emitter
    if sum(Z==ID) == 0
        Mu = X(randi(length(Z)));
    else
        Xs=X(Z==ID);
        Sigs = Sigma(Z==ID);
        A = sum(Xs./(Sigs.^2));
        B = sum(Sigs.^-2);
        XMLE = A/B;
        X_SE = 1/sqrt(B);
        Mu=normrnd(XMLE,X_SE);
    end
end

function [Alpha,Center] = calAlpha(Xs,Sigs,Frames,SigAlpha)
    Frames = single(Frames);
    A = sum(Xs./Sigs.^2);
    B = sum(Frames./Sigs.^2);
    C = sum(Sigs.^-2);
    AlphaTop = sum((C*Xs-A).*Frames./Sigs.^2);
    AlphaBottom = sum((C*Frames-B).*Frames./Sigs.^2)+C/SigAlpha^2;
    Alpha = AlphaTop/AlphaBottom;
    Center = (A-Alpha*B)/C;
end

function LogL = p_Alloc(SMD,Mu_X,Mu_Y,Alpha_X,Alpha_Y,Ws)
%This function calculated the probability of a given allocation set.
    X=SMD.X;
    Y=SMD.Y;
    T = repmat(SMD.FrameNum,[1,length(Mu_X)]);
    SigmaX=SMD.X_SE;
    SigmaY=SMD.Y_SE;
    
    Lx = length(X);
    Lmu = length(Mu_X);
    LogL = log(sum(repmat(Ws,[Lx,1]).*normpdf(repmat(X,[1,Lmu]),...
            repmat(Mu_X,[Lx,1])+repmat(Alpha_X,[Lx,1]).*T,...
            repmat(SigmaX,[1,Lmu])).*normpdf(repmat(Y,[1,Lmu]),...
            repmat(Mu_Y,[Lx,1])+repmat(Alpha_Y,[Lx,1]).*T,...
            repmat(SigmaY,[1,Lmu])),2));
   
    LogL = sum(LogL);
    
end

./MATLAB/+smi/@BaGoL/SEfilter.m
function [Coords,Ind] = SEfilter(ROIs)
%SEfilter filters out NaNs and localizations with zero precisions 
% obj.NNDfilter(obj,SMD)
%
% INPUTS:
%   ROIs: structure containing X and Y coorinates. (nm)
%
% OUTPUT:
%   Coords: Structure containing filtered X and Y coordinates
%   Ind: Index of filtered localizations
%
% Created by:
%   Mohamadreza Fazel (Lidke Lab, 2022)
%
    [y,~]=size(ROIs.X);
     if y == 1
         XYT = [ROIs.X',ROIs.Y'];
         XYT_SE = [ROIs.X_SE',ROIs.Y_SE'];
     else
         XYT = [ROIs.X,ROIs.Y];
         XYT_SE = [ROIs.X_SE,ROIs.Y_SE];
     end  
        
     if isempty(XYT)
        Coords = [];
        Ind = [];
     else
         Ind1 = ~isnan(XYT(:,1)) & ~isnan(XYT(:,2));
         Ind2 = XYT_SE(:,1) ~=0 & XYT_SE(:,2) ~=0;
         Ind = Ind1 & Ind2;
         Coords = single(XYT(Ind,1:2));
     end
end
./MATLAB/+smi/@BaGoL/genCluster.m
function [SMD,SMC]=genCluster(StuctType,Scale,Ndist,PSF,MeanPhoton,Prec_Cutoff,DriftVec,PlotFlag) 
%genCluster Simulates localization data from several types of emitter patterns 
% [SMD,SMC]=BaGoL.genCluster(StuctType,Scale,Ndist,PSF,MeanPhoton,Prec_Cutoff,DriftVec,PlotFlag) 
%
%  Generates synthetic localization data in the form used by BaGoL.
%   
%  Localization data is generated from emitter positions arranged in an 
%  MxN grid, an N-mer arranged in circle, or a user input set of emitter 
%  positions. Uncertainties of the positions are calculated from the 
%  number of photons collected from each localization and converting to a 
%  localization precision using PSF_Sigma/sqrt(N_Photons).  The number of 
%  photons for each localization is drawn from an exponential distribution 
%  parameterized by the mean number of photons. The number of localizations
%  per emitter is taken from a Poisson distribution with a given mean
%  (lambda). The number of frames is the same as the length of drift vector.
%
% INPUTS:
%    StuctType:    'MxNgrid', 'Nmer', 'user'. M,N must be integers
%    Scale:         Spatial scale (nm). Options are: 
%       'MxNGrid':      Smallest nearest neighbor distance in grid
%       'Nmer':         Radius of circular N-mer
%       'user':         SMD input with X,Y fields for emitter position
%    Ndist:         Mean number of localizations per emitter taken from a Poisson
%    PSF:           PSF_Sigma (nm)
%    MeanPhotons:   Mean Photons from an exponential distribution
%    Prec_Cutoff:   Precision threshold for generated localizations (nm)
%    DriftVec:      Linear drift, D is dimensionality (nm) (DxFrame)(Default = 0)
%    PlotFlag:      0 or 1. Plots generated localizations. (Default = 0)
%
% OUTPUTS:
%    SMD:           SMD (Single Molecule Data) structure with fields:
%       SMD.X         x-coordinate (nm) (Kx1)
%       SMD.X_SE      x-precision  (nm) (Kx1)
%       SMD.Y         y-coordinate (nm) (Kx1)
%       SMD.Y_SE      y-precision  (nm) (Kx1)
%       SMD.Z         z-coordinate (nm) (Kx1) (OPTIONAL)
%       SMD.Z_SE      z-precision  (nm) (Kx1) (OPTIONAL)
%       SMD.FrameNum: time stamp of localization (used for drift)
%       SMD.ID        Emitter index  
%    SMC:           SMD (Single Molecule Data) structure with fields:
%       SMC.X         Emitter True X Postions (nm)(Nx1)
%       SMC.Y         Emitter True Y Postions (nm)(Nx1)
%       SMC.Z         Emitter True Z Postions (nm)(Nx1)
%

% Created by:
%    Mohamadreza Fazel (Lidkelab 2019)   

if isscalar(Ndist)
    Ndist = Ndist*(1+expcdf((PSF/Prec_Cutoff)^2,MeanPhoton));
end
if ~exist('DriftVec','var')
   DriftVec = zeros(1,1000); 
end
if ~exist('PlotFlag','var')
   PlotFlag = 0;  
end

STR = StuctType(end-2:end);
MaxFrame = length(DriftVec);
SMD.X = [];
SMD.Y = [];
SMD.Z = [];
SMD.X_SE = [];
SMD.Y_SE = [];
SMD.Z_SE = [];
SMD.FrameNum = [];
SMD.ID = [];
SMC.X = [];
SMC.Y = [];
if strcmp(STR,'rid')
    N = str2double(StuctType(1))*str2double(StuctType(3));
    XC = Scale:Scale:str2double(StuctType(1))*Scale;
    YC = Scale:Scale:str2double(StuctType(3))*Scale;
    SMC.X = repmat(XC,1,length(YC));
    for mm = 1:length(YC)
        SMC.Y = cat(2,SMC.Y,YC(mm)*ones(1,length(XC)));
    end
    SMC.Z = [];
    for nn = 1:N
        NThisEmitter = poissrnd(Ndist);
        if NThisEmitter == 0
            NThisEmitter = poissrnd(Ndist);
        end
        FrameNum = randperm(MaxFrame,NThisEmitter);
        for mm = 1:length(FrameNum)
            Photons = exprnd(MeanPhoton); 
            Prec = PSF/sqrt(Photons);
            SMD.X = cat(1,SMD.X,SMC.X(nn)+Prec*randn()+DriftVec(FrameNum(mm),1));
            SMD.Y = cat(1,SMD.Y,SMC.Y(nn)+Prec*randn()+DriftVec(FrameNum(mm),2));
            SMD.X_SE = cat(1,SMD.X_SE,Prec);
            SMD.Y_SE = cat(1,SMD.Y_SE,Prec);
            SMD.FrameNum = cat(1,SMD.FrameNum,FrameNum(mm));
            SMD.ID = cat(1,SMD.ID,nn);
        end
    end
    Ind = SMD.X_SE < 40 & SMD.Y_SE < 40;
    SMD.X = SMD.X(Ind);
    SMD.Y = SMD.Y(Ind);
    SMD.X_SE = SMD.X_SE(Ind);
    SMD.Y_SE = SMD.Y_SE(Ind);
    SMD.FrameNum = SMD.FrameNum(Ind);
    SMD.ID = SMD.ID(Ind);
elseif strcmp(STR,'mer') || strcmp(STR,'Mer')
    N = str2double(StuctType(1:end-3));
    Theta = linspace(0,2*pi,N+1)';
    Theta(end) = [];
    Theta = Theta + (Theta(2)-Theta(1))/2;
    R = Scale*ones(N,1);
    [XC,YC] = pol2cart(Theta,R);
    SMC.X = XC + 2*Scale;
    SMC.Y = YC + 2*Scale;
    SMC.Z = [];
    for nn = 1:N
        NThisEmitter = poissrnd(Ndist);
        if NThisEmitter == 0
            NThisEmitter = poissrnd(Ndist);
        end
        FrameNum = randperm(MaxFrame,NThisEmitter);
        for mm = 1:length(FrameNum)
            Photons = exprnd(MeanPhoton); 
            Prec = PSF/sqrt(Photons);
            SMD.X = cat(1,SMD.X,SMC.X(nn)+Prec*randn()+DriftVec(FrameNum(mm),1));
            SMD.Y = cat(1,SMD.Y,SMC.Y(nn)+Prec*randn()+DriftVec(FrameNum(mm),2));
            SMD.X_SE = cat(1,SMD.X_SE,Prec);
            SMD.Y_SE = cat(1,SMD.Y_SE,Prec);
            SMD.FrameNum = cat(1,SMD.FrameNum,FrameNum(mm)); 
            SMD.ID = cat(1,SMD.ID,nn);
        end
    end
    Ind = SMD.X_SE < 40 & SMD.Y_SE < 40;
    SMD.X = SMD.X(Ind);
    SMD.Y = SMD.Y(Ind);
    SMD.X_SE = SMD.X_SE(Ind);
    SMD.Y_SE = SMD.Y_SE(Ind);
    SMD.FrameNum = SMD.FrameNum(Ind);
    SMD.ID = SMD.ID(Ind);
elseif strcmp(STR,'ser') 
    SMC.X = Scale.X;
    SMC.Y = Scale.Y;
    SMC.Z = [];
    for nn = 1:length(SMC.X)
        NThisEmitter = poissrnd(Ndist);
        if NThisEmitter == 0
            NThisEmitter = poissrnd(Ndist);
        end
        FrameNum = randperm(MaxFrame,NThisEmitter);
        for mm = 1:length(FrameNum)
            Photons = exprnd(MeanPhoton); 
            Prec = PSF/sqrt(Photons);
            SMD.X = cat(1,SMD.X,SMC.X(nn)+Prec*randn())+DriftVec(FrameNum(mm));
            SMD.Y = cat(1,SMD.Y,SMC.Y(nn)+Prec*randn())+DriftVec(FrameNum(mm));
            SMD.X_SE = cat(1,SMD.X_SE,Prec);
            SMD.Y_SE = cat(1,SMD.Y_SE,Prec);
            SMD.FrameNum = cat(1,SMD.FrameNum,FrameNum(mm)); 
            SMD.ID = cat(1,SMD.ID,nn);
        end
    end
    Ind = SMD.X_SE < 40 & SMD.Y_SE < 40;
    SMD.X = SMD.X(Ind);
    SMD.Y = SMD.Y(Ind);
    SMD.X_SE = SMD.X_SE(Ind);
    SMD.Y_SE = SMD.Y_SE(Ind);
    SMD.FrameNum = SMD.FrameNum(Ind);
    SMD.ID = SMD.ID(Ind);
end

IndR = SMD.X_SE > Prec_Cutoff | SMD.Y_SE > Prec_Cutoff;
SMD.X(IndR) = [];
SMD.Y(IndR) = [];
SMD.X_SE(IndR) = [];
SMD.Y_SE(IndR) = [];
SMD.FrameNum(IndR) = [];
SMD.ID(IndR) = [];

if PlotFlag
    Ang = 0:0.05:2*pi+0.05;
    for nn = 1:length(SMD.X)
        Prec = 2*sqrt((SMD.X_SE(nn)^2+SMD.Y_SE(nn)^2)/2);
        XCir = Prec*cos(Ang)+SMD.X(nn);
        YCir = Prec*sin(Ang)+SMD.Y(nn);
        if nn == 1
            figure; 
        end
        plot(XCir,YCir,'color',[0 0.4470 0.7410])
        axis equal
        if nn == 1
            hold; 
        end
    end
    plot(SMC.X,SMC.Y,'ok','linewidth',1.5)
end

end



./MATLAB/+smi/@BaGoL/hierBaGoL_run.m
function BGL = hierBaGoL_run(Files, DataROI, Results_BaGoL, BaGoLParams, ROIs)
%hierBaGoL_run runs one or more BaGoL analyses.
% It is called by hierBaGoL_wrapper and calls hierBaGoL_analysis on each
% individual dataset to be processed, so acts as a dispatch intermediary.
% A single dataset is run directly, while a set of datasets are run in
% parallel using a parfor loop.
%
% INPUTS:
%    Files            cell array of full filepaths of SMLM datasets (containing
%                     one SMD structure per file) to be processed by BaGoL
%    DataROI          array of ROIs, one per file (pixels):
%                     [Xmin, Xmax, Ymin, Ymax]
%    Results_BaGoL    output directory name for BaGoL results; the results will
%                     be saved in SaveDir = fullfile(DataDir, Results_BaGoL),
%                     where DataDir is deduced from the input file path
%    BaGoLParams      see hierBaGoL_analysis for details
%    ROIs             for a single file of type _ROIs.mat, the ROIs selected
%                     via ClusterInterface.defineROIs using
%                     smi_helpers.ROITools.getROI are obtained
% OUTPUTS:
%    BGL              BaGoL object containing the results of the analysis
%    See hierBaGoL_analysis for details.

if ~exist('ROIs', 'var')
   ROIs = false;   % *_ROIs.mat file was NOT input
end

if ~iscell(Files)
   Files = { Files };
end
n_files = numel(Files);

if ROIs
   % May be only (re)running a partial set.
   n_files_included = 0;
   for i = 1 : n_files
      if any(DataROI(i, :))
         n_files_included = n_files_included + 1;
      end
   end
else
   n_files_included = n_files;
end

fprintf('Files to analyze = %d\n', n_files_included);

if ~isempty(DataROI) && size(DataROI, 1) ~= n_files
   error('DataROI must either be [] or contain %d rows!', n_files);
end
% SE_Adjust is the standard error inflation (pixel), provided either as a
% constant (for all datasets) or an array, one per dataset
if numel(BaGoLParams.SE_Adjust) ~= 1 && numel(BaGoLParams.SE_Adjust) ~= n_files
   error('DataROI must contain 1 or %d values!', n_files);
end

if n_files > 0
   status = zeros(n_files, 1);

   if n_files == 1
      fprintf('(%d) %s ...\n', 1, Files{1});
      [DataDir, File, Ext] = fileparts(Files{1});
      SaveDir = fullfile(DataDir, Results_BaGoL);

      % Run hierBaGoL_analysis.
      %try
         data = load(Files{1});
         BaGoLParams.DataROI = DataROI;
         warning('OFF', 'stats:kmeans:FailedToConvergeRep');
         BGL = smi.BaGoL.hierBaGoL_analysis(data.SMD, File, SaveDir, ...
                                            BaGoLParams);
         status(1) = 1;
      %catch ME
      %   fprintf('### PROBLEM with %s ###\n', Files{i});
      %   fprintf('%s\n', ME.identifier);
      %   fprintf('%s\n', ME.message);
      %   status(i) = -1;
      %end
      fprintf('DONE (%d) %s.\n', 1, Files{1});
      fprintf('\n');
   else
      % When using parfor, dispatch the dataset analyses to as many workers as
      % available.
      delete(gcp('nocreate'));
      MachineInfo = parcluster();
      NumWorkers = MachineInfo.NumWorkers;
      parpool('local', min(NumWorkers, n_files_included));

      parfor i = 1 : n_files
         if ~ROIs || (ROIs && any(DataROI(i, :)))
            fprintf('(%d) %s ...\n', i, Files{i});
         end
         [DataDir, File, Ext] = fileparts(Files{i});
         SaveDir = fullfile(DataDir, Results_BaGoL);

         % Set up BGLParams for parallel processing via a parfor loop.
         BGLParams = BaGoLParams;

         % Run hierBaGoL_analysis.
         try
            if ROIs
               if any(DataROI(i, :))
                  filename = regexprep(Files{i}, '_ROI_[0-9][0-9]\.', '.');
                  filename = regexprep(filename, ['Analysis', filesep], '');
                  % Assume SMD files are of the form
                  % Cell_nn_Label_0n_Results.mat and RoI files are of the form
                  % Cell_nn_Label_01_Results_ROIs.mat
                  data = load(filename);
               else
                  continue;
               end
            else
               data = load(Files{i});
            end
            % If DataROI is defined, override the default value given in
            % BaGoLParams.
            if ~isempty(DataROI)
               BGLParams.DataROI = DataROI(i, :);
               fprintf( ...
                  'DataROI: [Xmin, Xmax, Ymin, Ymax] = [%g, %g, %g, %g]\n', ...
                       BGLParams.DataROI);
            end

            if numel(BaGoLParams.SE_Adjust) == 1          
               BGLParams.SE_Adjust = BaGoLParams.SE_Adjust;
            else
               BGLParams.SE_Adjust = BaGoLParams.SE_Adjust(i);
            end
            fprintf('SE_Adjust = %g\n', BGLParams.SE_Adjust);

            warning('OFF', 'stats:kmeans:FailedToConvergeRep');
            BGL = smi.BaGoL.hierBaGoL_analysis(data.SMD, File, SaveDir, ...
                                               BGLParams);
            status(i) = 1;
         catch ME
            fprintf('### PROBLEM with %s ###\n', Files{i});
            fprintf('%s\n', ME.identifier);
            fprintf('%s\n', ME.message);
            status(i) = -1;
         end
         fprintf('DONE (%d) %s.\n', i, Files{i});
         fprintf('\n');
      end
   end

   fprintf('BaGoL status by file (-1 PROBLEM, 0 NOT DONE, 1 DONE):\n');
   for i = 1 : n_files
      if ~ROIs || (ROIs && any(DataROI(i, :)))
         fprintf('[%2d] %2d   %s\n', i, status(i), Files{i});
      end
   end
end
warning('ON', 'stats:kmeans:FailedToConvergeRep');

./MATLAB/+smi/@BaGoL/loadPICASSOh5.m
function SMD=loadPICASSOh5(DataDir,FileName)
%loadH5 Loads a dataset saved in H5-format by the PICASSO software.
% SMD=BaGoL.loadPICASSOh5(DataDir,FileName)
%
% Loads data from PICASSO h5 file and returns a SMD structure, which is
% readable by BaGoL.
% Note: PICASSO data may not be frame connected. 
%
% See Schnitzbauer, et al, "Super-resolution microscopy with DNA-PAINT",
% Nature Protocol, 2017.
%
% INPUTS:
%    DataDir:  The data directory.
%    FileName: Name of the file to be loaded.
%
% OUTPUT:
%    SMD:      SMD structure (see BaGoL properties)
%

% Created by:
%    Mohamadreza Fazel (LidkeLab 2019)

if ~strcmp('h5',FileName(end-1:end)) && ~strcmp('f5',FileName(end-1:end))
    error('File type has to be given at the end of file name.'); 
end
SM=h5read(fullfile(DataDir,FileName),'/locs');
SMD.X = SM.x;
SMD.Y = SM.y;
SMD.X_SE = SM.lpx;
SMD.Y_SE = SM.lpy;
if isfield(SM,'z')
    SMD.Z = SM.z;
    SMD.Z_SE = SM.lpz;
else
    SMD.Z = [];
    SMD.Z_SE = [];
end
SMD.FrameNum = SM.frame;

end

./MATLAB/+smi/@BaGoL/makeIm.m
function [SRIm]=makeIm(SMD,SZ,PixSize,XStart,YStart,BoxSize)
%makeIm: Produces a Gaussian blob image from the list of input coordinates.
% [SRIm]=BaGoL.makeIm(SMD,SZ,PixSize,XStart,YStart)
%
% Each input coordinate and standard error is used to add a normalized, 
% 2D Gaussian blob to an intially empty image. The size and image region
% is given by the input parameters. 
%
% For computational speed, this operation is done by calculating all blobs 
% within small boxes of the same size in one operation and then copying the 
% results into the output image. 
% 
% INPUTS:
%   SMD:     SMD structure with fields:
%       X:        Vector of X SR-localization positions (nm)(Nx1)
%       Y:        Vector of Y SR-localization positions (nm)(Nx1)
%       X_SE:     Vector of X SR-localization standard errors (nm)(Nx1)
%       Y_SE:     Vector of Y SR-localization standard errors (nm)(Nx1)
%   SZ:      Size of the generated image (square) (nm) 
%   PixSize: Pixel size of the output image (nm)
%   XStart:  Start of generated image in the X-axis (nm), (Default = 0)
%   XStart:  Start of generated image in the Y-axis (nm), (Default = 0)
%   BoxSize: Box size for single Gaussian blobs (nm) (OPTIONAL) (Default=10*median(X_SE)) 
%
% OUTPUTS: 
%   SRIm:    Output image.
%

% Created by:
%    Mohamadreza Fazel (LidkeLab, 2019)

%% SR-Image

if nargin < 5
    MinX = 0; 
    MinY = 0;
else
    MinX = -XStart;
    MinY = -YStart;
end

if nargin < 6
    BoxSize = floor(15*median([SMD.X_SE;SMD.Y_SE])/PixSize); %Size of box in pixels
else
    BoxSize = round(BoxSize/PixSize); 
end
if floor(BoxSize/2)~=BoxSize/2
    BoxSize = BoxSize + 1; 
end

XBox = single(floor((SMD.X+MinX)/PixSize)-floor(BoxSize/2));
YBox = single(floor((SMD.Y+MinY)/PixSize)-floor(BoxSize/2));
X = single((SMD.X+MinX) - PixSize*floor((SMD.X+MinX)/PixSize) + PixSize*floor(BoxSize/2)-1);
Y = single((SMD.Y+MinY) - PixSize*floor((SMD.Y+MinY)/PixSize) + PixSize*floor(BoxSize/2)-1);

[Xg,Yg,~]=meshgrid((PixSize/2:PixSize:BoxSize*PixSize-PixSize/2),...
    (PixSize/2:PixSize:BoxSize*PixSize-PixSize/2),(1:length(SMD.X)));
Xg = single(Xg);
Yg = single(Yg);
MuX = ones(size(Xg),'single');
SigX = ones(size(Xg),'single');
MuY = MuX;
SigY = SigX;
for ii = 1:length(SMD.X)
     SigX(:,:,ii) = SMD.X_SE(ii);
     SigY(:,:,ii) = SMD.Y_SE(ii);
     MuX(:,:,ii) = X(ii);
     MuY(:,:,ii) = Y(ii);
end
Im = normpdf(Xg,MuX,SigX).*normpdf(Yg,MuY,SigY);
ExtendSZ=100;  %imae size extension
SRImT = zeros(ceil(SZ/PixSize)+ExtendSZ,'single');
for ii = 1:length(SMD.X) 
    try
        SRImT(YBox(ii)+(ExtendSZ/2+1):YBox(ii)+BoxSize+(ExtendSZ/2),...
            XBox(ii)+(ExtendSZ/2+1):XBox(ii)+BoxSize+(ExtendSZ/2)) = ...
            SRImT(YBox(ii)+(ExtendSZ/2+1):YBox(ii)+BoxSize+(ExtendSZ/2),...
            XBox(ii)+(ExtendSZ/2+1):XBox(ii)+BoxSize+(ExtendSZ/2)) + Im(:,:,ii);
    catch
    end
end
SRIm = SRImT((ExtendSZ/2+1):end-(ExtendSZ/2),(ExtendSZ/2+1):end-(ExtendSZ/2));

end

./MATLAB/+smi/@BaGoL/errPlot.m
function errPlot(SMD) 
%errPlot Plots the input precisions, where circles represent the errors.
% BaGoL.errPlot(SMD) 
%
% The plot contains circles that represent localizations within the SMD. 
% For each localization, the center of the circle is located at X,Y and 
% the radii of circles are 2 sigma where sigma is taken as
% sigma=sqrt(X_SE^2+Y_SE^2). 
%
% INPUT:
%    SMD: Structure containing the following fields:
%       X:      Vector of X localization positions (nm)(Nx1)
%       Y:      Vector of Y localization positions (nm)(Nx1)
%       X_SE:   Vector of X localization standard errors (nm)(Nx1)
%       Y_SE:   Vector of Y localization standard errors (nm)(Nx1)
%
% OUTPUT:
%    None.
%

% Created by:
%    Mohamadreza Fazel (LidkeLab 2019)

Ang = 0:0.1:2*pi+0.25;
XCir = zeros(length(Ang),length(SMD.X),'single');
YCir = XCir;
for nn = 1:length(SMD.X)
    Prec = 2*sqrt((SMD.X_SE(nn)^2+SMD.Y_SE(nn)^2)/2);
    XCir(:,nn) = Prec*cos(Ang')+SMD.X(nn);
    YCir(:,nn) = Prec*sin(Ang')+SMD.Y(nn);
end
figure;
plot(XCir,YCir,'m','linewidth',1.1)
axis equal
end

./MATLAB/+smi/@BaGoL/README.md
### +smi/@BaGoL

BaGoL Implements a Bayesian Grouping of Localizations (BaGoL)

Single molecule localization based super-resolution data can contain
repeat localizations from the same emitter. These localizations can be
grouped to give better localization precision.  BaGoL explores the
possible number of emitters and their positions that can explain the
observed localizations and uncertainties (data). An 'emitter' is a
blinking/binding point source that generates a single 'localization'
each time there is a blinking/binding event. Localizations must be
frame connected.

The core algorithm uses Reversible Jump Markov Chain Monte Carlo to
add, remove and move emitters and to explore the allocation of
localizations to emitters. The localization precisions are assumed to be
accurate. The prior distribution is parameterized by either a Poisson 
or Gamma distribution function which can be either given as an input or 
learned via the hierarchical Bayes approach.

The primary BaGoL outputs are a 'Posterior Image' and MAPN coordinates
that can also be used to generate a 'MAPN image'. The Posterior Image
shows a probability distribution of emitter locations that is a weighted
average over the number of emitters, emitter locations, and
allocation of localizations to emitters. The Maximum a Posteriori
Number of emitters (MAPN) result uses only the information from
the most likely number of emitters within the chain.  MAPN emitter 
coordinates and their uncertainties are returned and images from these 
coordinates are generated similarly to a traditional SR reconstruction.

This class implements the pre/post-processing steps needed to analyze
a spatially extended data set typical of super-resolution experiments.
This includes breaking data into subregions and collating the results
from the subregions.

REQUIRES:
- MATLAB 2016 or higher versions.
- Statistics and Machine learning toolbox.

CITATION: "High-Precision Estimation of Emitter Positions using Bayesian
          Grouping of Localizations", Mohamadreza Fazel, Michael J. Wester,
          David J. Schodt, Sebastian Restrepo Cruz, Sebastian Strauss,
          Florian Schueder, Thomas Schlichthaerle, Jennifer M. Gillette,
          Diane S. Lidke, Bernd Rieger, Ralf Jungmann and Keith A. Lidke,
          Nature Communications, **13**(7152), November 22, 2022, 1--11,
          (DOI: 10.1038/s41467-022-34894-2).

---

USAGE:
```
  B=BaGoL()       % create object
  B.SMD=....      % set properties
  B.analyze_all() % run complete analysis
```
The class also has several methods for visualizing and saving results.
See 'doc BaGoL' for the complete list of methods.

```
PROPERTIES:
  SMD:        A structure containing the fields:
      X:          Vector of X localization positions (Pixel)(Nx1)
      Y:          Vector of Y localization positions (Pixel)(Nx1)
      Z:          Vector of Z localization positions (Pixel)(Nx1)(Optional)
      X_SE:       Vector of X localization standard error (Pixel)(Nx1)
      Y_SE:       Vector of Y localization standard error (Pixel)(Nx1)
      Z_SE:       Vector of Z localization standard error (Pixel)(Nx1)(Optional)
      FrameNum:   Vector of localization frame numbers (Nx1)
      PixelSize:  Camera pixel size (nm/Pixel) 
  Xi:         Loc./emitter [lambda] (Poisson) or [k theta] (Gamma).
              When learning Xi this is used to initialize a chain. If
              two initial values are given it uses a gamma and otherwise
              a poisson prior.
  Alpha_Xi:   Shape parameter of Xi gamma hyper prior
  Alpha_Xi:   Scale parameter of Xi gamma hyper prio
  ROIsize:    ROI size for RJMCMC (nm) (Default=200)
  Overlap:    Allowed overlap between subregions (nm)(Default=50)
  Drift:      Expected magnitude of drift (nm/frame)(Default=0)
  SE_Adjust:  Adjustement of localization precisions (nm) (Default=0)
  N_Burnin:   Number of samples in burn in of RJMCMC chain (Default=2000)
  N_Trials:   Number of samples in RJMCMC chain post burn in (Default=3000)
  P_Jumps:    Proposal probabilities for RJMCMC Jumps
              [Move, Allocate, Add, Remove]
              sum(P_Jumps) must equal 1.
              (Default = [0.25, 0.25, 0.25, 0.25])
  PixelSize:  The pixel size for output posterior images (nm) (Default=1)
  PImageFlag: Generate Posterior image. 0 or 1. (Default=0)
  HierarchFlag: Use hierarchical Bayse to learn Xi. 0 or 1. (Default=0)
  NSamples:   Number of RJMCMC samples before sampling Xi (Default=10)
  PImageSize: Size of the output posterior images (nm)
  ChainFlag:  Save RJMCMC chain. 0 or 1. (Default=0)
  XStart:     X starting coordinate of output posterior images (nm)
  YStart:     Y starting coordinate of output posterior images (nm)

  ClusterSMD: An array of SMD structures for each cluster
  MAPN:       SMD output structure containing fields:
      X:      Vector of X emitter positions (nm)(Kx1)
      Y:      Vector of Y emitter positions (nm)(Kx1)
      Z:      Vector of Z emitter positions (nm)(Kx1)
      X_SE:   Vector of X localization standard error (nm)(Kx1)
      Y_SE:   Vector of Y localization standard error (nm)(Kx1)
      Z_SE:   Vector of Z localization standard error (nm)(Kx1)
      Nmean:  Mean number of localizations per emitter (Kx1)
  PImage:     Posterior Image
  Chain:      Cell array of RJMCMC chains for pre-clusters (See BaGoL_RJMCMC)
  XiChain:    Chain of Xi (locs per emitters dist. either Poisson or gamma)
  SaveName:   Final results are saved under this name (Default: BaGoL)
```

---

methods:
- **[analyze_all](BaGoL.m)** Implements complete BaGoL analysis of SR dataset

- **[BaGoL_RJMCMC](BaGoL_RJMCMC.m)**:
  This the core BaGoL algorithm. It uses Reversible Jump Markov Chain 
  Monte Carlo to add, remove and move emitters, and to explore the 
  classification of localizations to emitters.
- **[BaGoL_RJMCMC_Hierarchical](BaGoL_RJMCMC_Hierarchical.m)**:
  BaGoL's core RJMCMC algorithm that takes
  NSamples samples from the posterior using RJMCMC and return the last 
  sample to be used in the hierarchical Bayes approach
- **[SEfilter](SEfilter.m)**:
  filters out NaNs and localizations with zero precisions
- **[align_template](align_template.m)**:
  Aligns a set of points to a template
- **[assignROIs](assignROIs.m)**:
  applies SE_Adjust and filters zero precisions or nans in the data
- **[dispIm](dispIm.m)**:
  GUI to display BaGoL output images with some useful tools
- **[errPlot](errPlot.m)**:
  Plots the input precisions, where circles represent the errors
- **[frameConnect](frameConnect.m)**:
  Connects coordinates from a blinking event across consecutive frames
- **[genCluster](genCluster.m)**:
  Simulates localization data from several types of emitter patterns
- **[genMAPN](genMAPN.m)**:
  Generates the MAPN coordinates from the most repeated model in the chain
- **[genMAPNIm](genMAPNIm.m)**:
  Produces a Gaussian blob image from either SMD or MAPN
- **[genPosterior](genPosterior.m)**:
  Updates Posterior Image using RJMCMC chain for a subregion (ROI)
- **[genROIs](genROIs.m)**:
  takes the input coordinates and splits them into smaller regions
- **[genSRMAPNOverlay](genSRMAPNOverlay.m)**:
  generates a multicolor overlay containing circles with radii
  proportional to the average localization precision
- **[hierBaGoL_analysis](hierBaGoL_analysis.m)**:
  This function is adapted from EGFR_dSTORM.m in the BaGoL distribution
- **[hierBaGoL_run](hierBaGoL_run.m)**:
  runs one or more BaGoL analyses  (see
  [MATLAB/examples/hierBaGoL_wrapper.m](../../examples/hierBaGoL_wrapper.m)).
- **[importLLSMD](importLLSMD.m)**:
  Imports a Lidke Lab SMD and converts to BaGoL format
- **[initPostIm](initPostIm.m)**:
  Find the Posterior Image size and position
- **[loadPICASSOh5](loadPICASSOh5.m)**:
  Loads a dataset saved in H5-format by the PICASSO software
- **[makeIm](makeIm.m)**:
  Produces a Gaussian blob image from the list of input coordinates
- **[plotMAPN](plotMAPN.m)**:
  Plots the MAPN positions together with input localizations
- **[plotNND](plotNND.m)**:
  Makes and saves the NND histogram of MAPN coordinates
- **[plotNND_PDF](plotNND_PDF.m)**:
  makes and saves the NND PDF histogram of MAPN coordinates
- **[precluster](precluster.m)**:
  Finds the independent clusters for analysis with RJMCMC
- **[removeOverlap](removeOverlap.m)**:
  Finds coordinates located in overlapping regions
- **[sampleGam](sampleGam.m)**:
  infers parameters of gamma prior on number of localizations per emitter
- **[samplePoiss](samplePoiss.m)**:
  infers parameter of Poisson prior on number of localizations per emitter
- **[saveBaGoL](saveBaGoL.m)**:
  Saves plots of NND, precisions, Xi, SR, MAPN, Posterior, Overlay images
- **[saveMAPN](saveMAPN.m)**:
  Saves the MAPN coordinates
- **[scaleIm](scaleIm.m)**:
  Scales and clips the image intensity to improve image contrast
- **[scalebar](scalebar.m)**:
  Add scalebar to image

./MATLAB/+smi/@BaGoL/genPosterior.m
function [PostIm] = genPosterior(obj,PostIm,SZ,Chain,ROIs,ii)
%genPosterior Updates Posterior Image using RJMCMC chain for a subregion (ROI)
% [PostIm] = obj.genPosterior(PostIm,SZ,Chain,ROIs,ii)
%
% genPosterior() updates the Posterior Image with emitters from all the 
% states of the given chain. The coordinates that overlap with other ROIs 
% (see genROIs()) are first eliminated from the list of coordinates. The 
% final list of coordinates are then used to update the posterior image. 
% For each coordinate in the chain, the corresponding pixel in the
% Posterior Image is incremented by one. Therefore, the Posterior Image is
% the histogram image of the chain.
%
% INPUTS:
%    PostIm: Posterior Image to be updated
%    SZ:     Size of Posterior Image (nm)[Scalar]
%    Chain:  RJMCMC chain for the cluster (See BaGoL_RJMCMC())
%    ROIs:   2D Array of SMD structures (see genROIs())
%    ii:     Index of cluster associated with the input chain.
%
% OUTPUTS: 
%    PostIm: Updated Posterior Image
%

% Created by:
%    Mohamadreza Fazel (LidkeLab 2019)

XChain = [];
YChain = [];

for nn = 1:length(Chain)
    if ~isempty(Chain(nn).X)
        XChain = cat(1,XChain,Chain(nn).X(:));
        YChain = cat(1,YChain,Chain(nn).Y(:));
    end
end
Ind = obj.removeOverlap(ROIs,XChain,YChain,ii);

if isempty(obj.XStart)
    MinX = -((obj.PImageSize - (max(obj.SMD.X)-min(obj.SMD.X)))/2 - min(obj.SMD.X)); 
    MinY = -((obj.PImageSize - (max(obj.SMD.Y)-min(obj.SMD.Y)))/2 - min(obj.SMD.Y));
else
    MinX = -obj.XStart;
    MinY = -obj.YStart;
end
YInd = floor((YChain(Ind)+MinY)/obj.PixelSize);
XInd = floor((XChain(Ind)+MinX)/obj.PixelSize);

IndRemove = XInd>SZ | XInd < 1 | YInd>SZ | YInd < 1;
XInd(IndRemove) = [];
YInd(IndRemove) = [];

LinInd = sub2ind([SZ,SZ],YInd,XInd);
[Counts,Pixel]=hist(LinInd,unique(LinInd));
IndRemove = Counts == 0;
Counts(IndRemove) = [];
Pixel(IndRemove) = [];
PostIm(Pixel) = PostIm(Pixel) + Counts';

end

./MATLAB/+smi/@BaGoL/frameConnect.m
function [SMD,SMD_combined]=frameConnect(SMD,LOS,MaxDistance,MaxFrameGap,FitType)
%frameConnect Connects coordinates from a blinking event across consecutive frames. 
% [SMD,SMD_combined]=BaGoL.frameConnect(SMD,LOS,MaxDistance,MaxFrameGap,FitType)
%
% INPUTS:
%    SMD:            Single Molecule Data (SMD). It is a structure including
%                    all localization properties such as X,Y,Photons,...
%    LOS:            Level of Significance (Default = 0.01)
%    MaxDistance:    Maximum distance between two localizations for being
%                    connected (Pixels) (Default = 1)
%    MaxFrameGap:    Maximum Frame Gap between two localizations for being
%                    connected (Frame) (Default = 4)
%    FitType:        'Gaussian2D', 'Gaussian3D', 'SinglePSF', or 'DoublePSF',
%                    (Default = 'Gaussian2D')
%
% OUTPUTS:
%    SMD:            Single Molecule Data; this function creates one more field
%                    to this structure: SMD.ConnectID
%    SMD_combined:   Single Molecule Data of connected localization.
%                    It includes only these fields (X,Y,X_SE,Y_SE,NCombined,
%                    FrameNum,Photons,Bg)
%
% REQUIRES:
%     Statistics Toolbox
%     mex file of c_code: c_FrameConnect on MATLAB's path or current directory
%

% Created by:
%    Hanieh Mazloom-Farsibaf (LidkeLab 2017)

%check input
if nargin<1
    error('You have to enter input Single Molecule Data (SMD) structure')
end
if nargin<2
    LOS=0.01;
end
if nargin <3
    MaxDistance=1;
end
if nargin<4
    MaxFrameGap=4;
end
if nargin<5
    FitType='GaussianBasic';
end
if isempty(SMD)
    error('Input Structure should include at least X,Y,I,Bg for all localizations')
end

%set the parameters for c_FrameConnect
LOS=single(LOS);

%Label the localizations based on frame Connection function
%0 if they didn't pass Threshold and ~=0 if they passed. Its values
%are an integer number for each cluster of localizations combined as
%a higher precesion.
ConnectID=zeros(size(SMD.X,1),1);
SMD.ConnectID=ConnectID;
MaxConID=0;
if ~isfield(SMD,'DatasetNum')
    SMD.DatasetNum = ones(size(SMD.X));
end
if ~isfield(SMD,'ThreshFlag')
    SMD.ThreshFlag = zeros(size(SMD.X));
end
if ~isfield(SMD,'Bg')
    SMD.Bg = zeros(size(SMD.X));
end
if ~isfield(SMD,'LogL')
    SMD.LogL = ones(size(SMD.X));
end

%create output for c_FrameConnect
Coordout_all=[];  % coordinate of combined localization (x,y,or z)
CoordSEout_all=[];
Fout_all=[];     % last frame number which emitter is combined
Nout_all=[];     % number of localizations combined
P_Aveout_all=[];
P_ave_SEout_all=[];
P_Addout_all=[];

% start Frame Connection loop for each sequence with a bunch of frames
SMD_combined.DatasetNum=[];
for ii=1:max(SMD.DatasetNum) %loop over data sets (FileName is the number of sequence.)
    
    mask = (SMD.DatasetNum==ii & SMD.ThreshFlag==0); % extract one sequence from whole saved image
    
    if sum(mask)==0;continue;end
    
    X=SMD.X(mask);
    Y=SMD.Y(mask);
    Photons=single(SMD.Photons(mask));
    Bg=SMD.Bg(mask);
    X_SE=SMD.X_SE(mask);
    Y_SE=SMD.Y_SE(mask);
    LogL=single(SMD.LogL(mask));
    FrameNum=uint32(SMD.FrameNum(mask));
    Bg=single(Bg);
    
    switch FitType
        case {'GaussianBasic'}
            Coord_in=single(cat(2,X,Y));
            Coord_SE_in=single(cat(2,X_SE,Y_SE));
            P_Ave_in=[];
            P_Ave_SE_in=[];
            P_Add_in=single(cat(2,Photons,Bg,LogL));
        case {'GaussianZ'}
            Z=SMD.Z(mask);
            Z_SE=SMD.Z_SE(mask);
            Coord_in=single(cat(2,X,Y,Z));
            Coord_SE_in=single(cat(2,X_SE,Y_SE,Z_SE));
            P_Ave_in=[];
            P_Ave_SE_in=[];
            P_Add_in=single(cat(2,Photons,Bg,LogL));
        case {'GaussianSigma'}
            Coord_in=single(cat(2,X,Y));
            Coord_SE_in=single(cat(2,X_SE,Y_SE));
            P_Ave_in=single(SMD.PSFSigma(mask));
            P_Ave_SE_in=single(SMD.PSFSigma_SE(mask).^2);
            P_Add_in=single(cat(2,Photons,Bg,LogL));
        case {'GaussianSigmaXY'}
            Sx=SMD.PSFSigmaX(mask);
            Sx_SE=SMD.PSFSigmaX_SE(mask);
            Sy=SMD.PSFSigmaY(mask);
            Sy_SE=SMD.PSFSigmaY_SE(mask);
            Coord_in=single(cat(2,X,Y));
            Coord_SE_in=single(cat(2,X_SE,Y_SE));
            P_Ave_in=single(cat(2,Sx,Sy));
            P_Ave_SE_in=single(cat(2,Sx_SE.^2,Sy_SE.^2));
            P_Add_in=single(cat(2,Photons,Bg,LogL));
         case {'SinglePSF'}
            Z=SMD.Z(mask);
            Z_SE=SMD.Z_SE(mask);
            Coord_in=single(cat(2,X,Y,Z));
            Coord_SE_in=single(cat(2,X_SE,Y_SE,Z_SE));
            P_Ave_in=[];
            P_Ave_SE_in=[];
            P_Add_in=single(cat(2,Photons,Bg,LogL));
        otherwise
            error('No FitType Given');
    end
    
    % test frame connection hypothesis histogram (using c-function)
    [Coordout, CoordSEout, Nout, Fout,P_Aveout,P_ave_SEout,P_Addout,ConnectID]=c_FrameConnect_BaGoL(LOS,Coord_in,Coord_SE_in,FrameNum,P_Ave_in,P_Ave_SE_in,P_Add_in,MaxDistance,MaxFrameGap,MaxConID);
    
    SMD.ConnectID(mask)=ConnectID;
    Coordout_all=cat(1,Coordout_all,Coordout);
    CoordSEout_all=cat(1,CoordSEout_all,CoordSEout);
    Nout_all=cat(1,Nout_all,Nout);
    Fout_all=cat(1,Fout_all,Fout);
    if P_Aveout~=0
        P_Aveout_all=cat(1,P_Aveout_all,P_Aveout);
        P_ave_SEout_all=cat(1,P_ave_SEout_all,P_ave_SEout);
    end
    P_Addout_all=cat(1,P_Addout_all,P_Addout);
    MaxConID=max(ConnectID);
    SMD_combined.DatasetNum=cat(1,SMD_combined.DatasetNum,ii*ones(length(Nout), 1));
end

SMD_combined.X=Coordout_all(:,1);
SMD_combined.Y=Coordout_all(:,2);
SMD_combined.X_SE=(CoordSEout_all(:,1));
SMD_combined.Y_SE=(CoordSEout_all(:,2));
SMD_combined.NCombined=Nout_all;
SMD_combined.FrameNum=Fout_all;
SMD_combined.Photons=P_Addout_all(:,1);
SMD_combined.Bg=P_Addout_all(:,2);
SMD_combined.LogL=P_Addout_all(:,3);

if (strcmp(FitType,'GaussianZ') ||strcmp(FitType,'SinglePSF') )
    SMD_combined.Z=Coordout_all(:,3);
    SMD_combined.Z_SE=sqrt(CoordSEout_all(:,3));
end


if (strcmp(FitType,'GaussianSigma'))
    SMD_combined.PSFSigma=P_Aveout_all;
    SMD_combined.PSFSigma_SE=P_ave_SEout_all;
end
if (strcmp(FitType,'GaussianSigmaXY'))
    SMD_combined.PSFSigmaX=P_Aveout_all(:,1);
    SMD_combined.PSFSigmaY=P_Aveout_all(:,2);
    SMD_combined.PSFSigmaX_SE=P_ave_SEout_all(:,1);
    SMD_combined.PSFSigmaY_SE=P_ave_SEout_all(:,2);
end

end

./MATLAB/+smi/@BaGoL/assignROIs.m
function assignROIs(obj,ROIs)
%assignROIs applies SE_Adjust and filters zero precisions or nans in the data   
%
% INPUTS:
%    ROIs: 2D Array of SMD structures (See genROIs())
%
% OUTPUT:
%    obj: BaGoL object populated with cluster coordinates in field ClusterSMD.
%      ClusterSMD: 
%       X:        Vector of X localization positions (nm)(Mx1)
%       Y:        Vector of Y localization positions (nm)(Mx1)
%       Z:        Vector of Z localization positions (nm)(Mx1)(Optional)
%       X_SE:     Vector of X localization standard errors (nm)(Mx1)
%       Y_SE:     Vector of Y localization standard errors (nm)(Mx1)
%       Z_SE:     Vector of Z localization standard errors (nm)(Mx1)(Optional)
%       FrameNum: Vector of localization frame numbers (Mx1)
%       ix:       Index of the ROI that a cluster comes from along the X axis
%       iy:       Index of the ROI that a cluster comes from along the Y axis
%

% Created by:
%    Mohamadreza Fazel (LidkeLab 2022)

obj.ClusterSMD = [];
[Ys,Xs] = size(ROIs);
for iy = 1:Ys
    for ix = 1:Xs
        
       [Coords,Ind] = smi.BaGoL.SEfilter(ROIs(iy,ix));
       
        if size(Coords,1) <= 1
            continue; 
        end
        
        Len = length(obj.ClusterSMD);
        TX_SE = ROIs(iy,ix).X_SE(Ind);
        TY_SE = ROIs(iy,ix).Y_SE(Ind);
        if ~isempty(ROIs(iy,ix).FrameNum)
            TFrame = ROIs(iy,ix).FrameNum(Ind);
        end
        
        obj.ClusterSMD(Len+1).X = Coords(:,1);
        obj.ClusterSMD(Len+1).Y = Coords(:,2);
        obj.ClusterSMD(Len+1).X_SE = TX_SE(:)+obj.SE_Adjust;
        obj.ClusterSMD(Len+1).Y_SE = TY_SE(:)+obj.SE_Adjust;
        if isempty(ROIs(iy,ix).Z)
            obj.ClusterSMD(Len+1).Z = [];
            obj.ClusterSMD(Len+1).Z_SE = [];
        else
            obj.ClusterSMD(Len+1).Z = ROIs(iy,ix).Z(:);
            obj.ClusterSMD(Len+1).Z_SE = ROIs(iy,ix).Z_SE(:);
        end
        if ~isempty(ROIs(iy,ix).FrameNum)
            obj.ClusterSMD(Len+1).FrameNum = TFrame(:);
        else
            obj.ClusterSMD(Len+1).FrameNum = [];
        end
            obj.ClusterSMD(Len+1).ix = ix;
            obj.ClusterSMD(Len+1).iy = iy;
    end
end

end

./MATLAB/+smi/@BaGoL/precluster.m
function precluster(obj,ROIs)
%precluster Finds the independent clusters for analysis with RJMCMC
% obj.precluster(ROIs)
% 
% precluster loops through the subregions, applies the NND filtering 
% (if applicable) and then uses hierarchical clustering to find independent
% clusters that will be analyzed individually by BaGoL_RJMCMC. The
% SMD structures for each structure is then saved inside the ClusterSMD
% structure, which is a property of BaGoL, see below.
%
% INPUTS:
%    ROIs: 2D Array of SMD structures (See genROIs())
%
% OUTPUT:
%    obj: BaGoL object populated with cluster coordinates in field ClusterSMD.
%      ClusterSMD: 
%       X:        Vector of X localization positions (nm)(Mx1)
%       Y:        Vector of Y localization positions (nm)(Mx1)
%       Z:        Vector of Z localization positions (nm)(Mx1)(Optional)
%       X_SE:     Vector of X localization standard errors (nm)(Mx1)
%       Y_SE:     Vector of Y localization standard errors (nm)(Mx1)
%       Z_SE:     Vector of Z localization standard errors (nm)(Mx1)(Optional)
%       FrameNum: Vector of localization frame numbers (Mx1)
%       ix:       Index of the ROI that a cluster comes from along the X axis
%       iy:       Index of the ROI that a cluster comes from along the Y axis
%

% Created by:
%    Mohamadreza Fazel (LidkeLab 2020)

obj.ClusterSMD = [];
[Ys,Xs] = size(ROIs);
for iy = 1:Ys
    for ix = 1:Xs
        
    %[Coords,Ind] = obj.NNDfilter(ROIs(iy,ix));
    [Coords,Ind] = smi.BaGoL.SEfilter(ROIs(iy,ix));

        %clustering - give back array of SMD - one per cluster
        % There are three functions for hierarchical clustering that we have to 
        % use in turn. The first one is pdist which calculates the 
        % distance between every possible pair of the data points. This is the 
        % input to the next function which is linkage. The output of linkage
        % is a data structure defining a hierarchical clustering tree based on
        % the pdist results.
        if size(Coords,1) <= 1
            continue; 
        end
        try
            Dist = pdist(Coords,'euclid');
            TC = linkage(Dist,'single');
            IndClust = cluster(TC,'Cutoff',obj.Cutoff,'Criterion','distance');
        catch
            IndClust = ones(size(Dist(:,1)),'single');
        end
                    
        % cluster is the third function that we need to use. The input to this
        % function is the output of the previous one. This function has several
        % methods that we need to decide which one is suitable for our purpose. 
        % For example, the method 'distance' uses the data based on the
        % distance between the data points.
        NClust = max(IndClust); 
        MeanX = zeros(NClust,1);
        MeanY = zeros(NClust,1);
        for nn = 1:NClust
            MeanX(nn) = mean(Coords(IndClust==nn,1));
            MeanY(nn) = mean(Coords(IndClust==nn,2));
        end
        Len = length(obj.ClusterSMD);
        TX_SE = ROIs(iy,ix).X_SE(Ind);
        TY_SE = ROIs(iy,ix).Y_SE(Ind);
        if ~isempty(ROIs(iy,ix).FrameNum)
            TFrame = ROIs(iy,ix).FrameNum(Ind);
        end
        for nn = 1:max(IndClust)
            Indtrue = IndClust==nn;
            obj.ClusterSMD(Len+nn).X = Coords(Indtrue,1);
            obj.ClusterSMD(Len+nn).Y = Coords(Indtrue,2);
            obj.ClusterSMD(Len+nn).X_SE = TX_SE(Indtrue)+obj.SE_Adjust;
            obj.ClusterSMD(Len+nn).Y_SE = TY_SE(Indtrue)+obj.SE_Adjust;
            if isempty(ROIs(iy,ix).Z)
                obj.ClusterSMD(Len+nn).Z = [];
                obj.ClusterSMD(Len+nn).Z_SE = [];
            else
                obj.ClusterSMD(Len+nn).Z = ROIs(iy,ix).Z(Indtrue);
                obj.ClusterSMD(Len+nn).Z_SE = ROIs(iy,ix).Z_SE(Indtrue);
            end
                if ~isempty(ROIs(iy,ix).FrameNum)
                    obj.ClusterSMD(Len+nn).FrameNum = TFrame(Indtrue);
                else
                    obj.ClusterSMD(Len+nn).FrameNum = [];
                end
                obj.ClusterSMD(Len+nn).ix = ix;
                obj.ClusterSMD(Len+nn).iy = iy;
        end
    end
end

end

./MATLAB/+smi/@BaGoL/saveBaGoL.m
function saveBaGoL(obj,L,SaveDir,OverlayFlag)
%Saves plots of NND, precisions, Xi, SR, MAPN, Posterior, Overlay images
%
%The first plot is the histogram of the nearest neighbor distances of MAPN
%coordinates. The second and third plots are, respectively, the histograms
%of MAPN X-precisions and MAPN Y-precisions. The fourth plot is the
%histogram of the number of localizations allocated to each emitter.
%The first image is the image reconstructed using the MAPN coordinates. The
%second image is reconstructed using the raw input coordinates. 
%The third image is the landscape image of the posterior. The last image is 
%the ovelay of SR-image and the posterior. Finally, the 
% MAPN-coordinates are saved in a mat-file.
%
%INPUT:
%   SaveDir: Save directory of plots and images (optional)
%   L: Length of scale bars on generated images (nm) (Default=100) (optional)
%   OverlayFlag: binary parameter that makes overlay color images (Default=0) 
%
%OUTPUT:
%   NONE
%
%Created by:
%   Mohamadreza Fazel (Lidke Lab, 2020)
%

if nargin < 4
   OverlayFlag = 0; 
end
if nargin < 3
    if  ~isdir('Result_BaGoL')
       mkdir('Result_BaGoL'); 
    end
    SaveDir = 'Result_BaGoL';
end

if nargin>1
   Length = L; %nm 
else
   Length = 100; %nm 
end

try
MAPN = obj.MAPN;
save(fullfile(SaveDir,'MAPN'),'MAPN')
catch ME
fprintf('### PROBLEM with saving MAPN ###\n');
fprintf('%s\n', ME.identifier);
fprintf('%s\n', ME.message);
end

%Saving NND-plot
try
NBins=30;
[~,Dis]=knnsearch([obj.MAPN.X,obj.MAPN.Y],[obj.MAPN.X,obj.MAPN.Y],'k',2);
Dis = Dis(:,2);
P = prctile(Dis,99);
figure('Visible','off')
hist(Dis(Dis<P),NBins)
xlabel('NND(nm)','FontSize',18)
ylabel('Frequency','FontSize',18)
print(gcf,fullfile(SaveDir,'NND'),'-dpng')
catch ME
fprintf('### PROBLEM with saving NND ###\n');
fprintf('%s\n', ME.identifier);
fprintf('%s\n', ME.message);
end

%Saving precisions-plots
try
X_SE = obj.MAPN.X_SE;
figure('Visible','off')
P = prctile(X_SE,99);
hist(X_SE(X_SE<P),NBins)
xlabel('X-SE(nm)','FontSize',18)
ylabel('Frequency','FontSize',18)
print(gcf,fullfile(SaveDir,'BaGoL_X-SE'),'-dpng')
catch ME
fprintf('### PROBLEM with saving BaGoL_X-SE ###\n');
fprintf('%s\n', ME.identifier);
fprintf('%s\n', ME.message);
end

try
Y_SE = obj.MAPN.Y_SE;
figure('Visible','off')
P = prctile(Y_SE,99);
hist(Y_SE(Y_SE<P),NBins)
xlabel('Y-SE(nm)','FontSize',18)
ylabel('Frequency','FontSize',18)
print(gcf,fullfile(SaveDir,'BaGoL_Y-SE'),'-dpng')
catch ME
fprintf('### PROBLEM with saving BaGoL_Y-SE ###\n');
fprintf('%s\n', ME.identifier);
fprintf('%s\n', ME.message);
end

%Saving hierarchical parameters
try
if obj.HierarchFlag == 1
   LChain = floor(obj.N_Trials/obj.NSamples);
   if length(obj.Xi)==2
       Lambda = obj.XiChain(end-LChain:end,2).*obj.XiChain(end-LChain:end,1);
   else
        Lambda = obj.XiChain(end-LChain:end);
   end
   figure('Visible','off')
   histogram(Lambda,'normalization','pdf')
   xlabel('\xi');ylabel('pdf')
   xlim([0 max(Lambda)+20])
   print(gcf,fullfile(SaveDir,'Xi'),'-dpng')
else
    Nmean = obj.MAPN.Nmean;
    P = prctile(Nmean,99);
    figure('Visible','off')
    histogram(Nmean(Nmean<P),0:max(Nmean)+15,'Normalization','pdf')
    hold;
    if length(obj.Xi)>1
        Xp = 0:0.2:max(Nmean)+15;
        plot(Xp,gampdf(Xp,obj.Xi(1),obj.Xi(2)),'r','linewidth',1.5)
    else
        Xp = 0:ceil(max(Nmean)+15);
        plot(Xp,poisspdf(Xp,obj.Xi),'r','linewidth',1.5)
    end
    legend({'Found \xi','Used dist.'},'FontSize',15)
    xlabel('\xi','FontSize',18);ylabel('PDF','FontSize',18)
    print(gcf,fullfile(SaveDir,'Xi'),'-dpng')
end
catch ME
fprintf('### PROBLEM with saving Xi ###\n');
fprintf('%s\n', ME.identifier);
fprintf('%s\n', ME.message);
end

%Saving MAPN-image
try
ImFlag = 1;
PixelSize = obj.PixelSize;
[MapIm]=obj.genMAPNIm(ImFlag);
MapIm = smi.BaGoL.scaleIm(MapIm,98);
tMapIm = MapIm;
MapIm = smi.BaGoL.scalebar(MapIm,PixelSize,Length);
imwrite(MapIm,hot(256),fullfile(SaveDir,'MAPN-Im.png'));
catch ME
fprintf('### PROBLEM with saving MAPN-Im.png ###\n');
fprintf('%s\n', ME.identifier);
fprintf('%s\n', ME.message);
end

%Saving SR-image
try
ImFlag = 2;
[SRIm]=obj.genMAPNIm(ImFlag);
SRIm = smi.BaGoL.scaleIm(SRIm,98);
tSRIm = SRIm;
SRIm = smi.BaGoL.scalebar(SRIm,PixelSize,Length);
imwrite(SRIm,hot(256),fullfile(SaveDir,'SR-Im.png'));
catch ME
fprintf('### PROBLEM with saving SR-Im.png ###\n');
fprintf('%s\n', ME.identifier);
fprintf('%s\n', ME.message);
end

%Saving posterior image
try
if obj.PImageFlag == 1
    PIm = smi.BaGoL.scaleIm(obj.PImage,98);
    tPIm = PIm;
    PIm = smi.BaGoL.scalebar(PIm,PixelSize,Length);
    imwrite(PIm,hot(256),fullfile(SaveDir,'Post-Im.png'));
end
catch ME
fprintf('### PROBLEM with saving Post-Im.png ###\n');
fprintf('%s\n', ME.identifier);
fprintf('%s\n', ME.message);
end

% Color coding: SR (green), Posterior (blue), MAPN (red).
% When there are just 2 colors with one of them green, the blue and red are
% mixed together to make magenta for easier visualization.
if OverlayFlag
    Scale = 255;

    try
    %Overlay of filtered SR image (green) and posterior image (magenta)
    overlayIm = zeros([size(SRIm),3]);
    %overlayIm(:,:,1) = (2*tPIm/Scale+tSRIm/Scale)/3;
    overlayIm(:,:,1) = tPIm/Scale/3;
    overlayIm(:,:,2) = tSRIm/Scale/3;
    overlayIm(:,:,3) = tPIm/Scale/3;
    overlayIm(:,:,1) = smi.BaGoL.scalebar(overlayIm(:,:,1)*Scale,PixelSize,Length);
    overlayIm(:,:,2) = smi.BaGoL.scalebar(overlayIm(:,:,2)*Scale,PixelSize,Length);
    overlayIm(:,:,3) = smi.BaGoL.scalebar(overlayIm(:,:,3)*Scale,PixelSize,Length);
    imwrite(overlayIm, fullfile(SaveDir,'Overlay_gSR_mPost.png'), 'PNG');
    catch ME
    fprintf('### PROBLEM with saving Overlay_SR_Post.png ###\n');
    fprintf('%s\n', ME.identifier);
    fprintf('%s\n', ME.message);
    end

    try
    %Overlay of filtered SR image (green) and MAPN image (magenta)
    overlayIm = zeros([size(tMapIm),3]);
    %overlayIm(:,:,1) = (2*tMapIm/Scale+tSRIm/Scale)/3;
    overlayIm(:,:,1) = tMapIm/Scale/3;
    overlayIm(:,:,2) = tSRIm/Scale/3;
    overlayIm(:,:,3) = tMapIm/Scale/3;
    overlayIm(:,:,1) = smi.BaGoL.scalebar(overlayIm(:,:,1)*Scale,PixelSize,Length);
    overlayIm(:,:,2) = smi.BaGoL.scalebar(overlayIm(:,:,2)*Scale,PixelSize,Length);
    overlayIm(:,:,3) = smi.BaGoL.scalebar(overlayIm(:,:,3)*Scale,PixelSize,Length);
    %overlayIm = 10*overlayIm/Scale;
    imwrite(overlayIm, fullfile(SaveDir,'Overlay_gSR_mMap.png'), 'PNG');
    catch ME
    fprintf('### PROBLEM with saving Overlay_SR_Map.png ###\n');
    fprintf('%s\n', ME.identifier);
    fprintf('%s\n', ME.message);
    end

    try
    %Overlay of posterior image (cyan) and MAPN image (red)
    overlayIm = zeros([size(tMapIm),3]);
    %overlayIm(:,:,1) = (2*tMapIm/Scale+tPIm/Scale)/3;
    overlayIm(:,:,1) = tMapIm/Scale/3;
    overlayIm(:,:,2) = tPIm/Scale/3;
    overlayIm(:,:,3) = tPIm/Scale/3;
    overlayIm(:,:,1) = smi.BaGoL.scalebar(overlayIm(:,:,1)*Scale,PixelSize,Length);
    overlayIm(:,:,2) = smi.BaGoL.scalebar(overlayIm(:,:,2)*Scale,PixelSize,Length);
    overlayIm(:,:,3) = smi.BaGoL.scalebar(overlayIm(:,:,3)*Scale,PixelSize,Length);
    imwrite(overlayIm, fullfile(SaveDir,'Overlay_cPost_rMap.png'), 'PNG');
    catch ME
    fprintf('### PROBLEM with saving Overlay_Post_Map.png ###\n');
    fprintf('%s\n', ME.identifier);
    fprintf('%s\n', ME.message);
    end

    try
    %Overlay of SR image (green), posterior image (blue) and MAPN image (red)
    overlayIm = zeros([size(tSRIm),3]);
    overlayIm(:,:,1) = tMapIm/Scale/3;
    overlayIm(:,:,2) = tSRIm/Scale/3;
    overlayIm(:,:,3) = tPIm/Scale/3;
    overlayIm(:,:,1) = smi.BaGoL.scalebar(overlayIm(:,:,1)*Scale,PixelSize,Length);
    overlayIm(:,:,2) = smi.BaGoL.scalebar(overlayIm(:,:,2)*Scale,PixelSize,Length);
    overlayIm(:,:,3) = smi.BaGoL.scalebar(overlayIm(:,:,3)*Scale,PixelSize,Length);
    imwrite(overlayIm, fullfile(SaveDir,'Overlay_gSR_bPost_rMap.png'), 'PNG');
    catch ME
    fprintf('### PROBLEM with saving Overlay_SR_Post_Map.png ###\n');
    fprintf('%s\n', ME.identifier);
    fprintf('%s\n', ME.message);
    end
end

%MAPN = obj.MAPN;
%save(fullfile(SaveDir,'MAPN'),'MAPN')
close all;

end

./MATLAB/+smi/@BaGoL/BaGoL_RJMCMC.m
function [Chain]=BaGoL_RJMCMC(SMD,Xi,SigAlpha,PMove,NChain,NBurnin,DEBUG)
%BaGoL_RJMCMC BaGoL's core RJMCMC algorithm
% [Chain]=BaGoL.BaGoL_RJMCMC(SMD,Xi,MaxAlpha,PMove,NChain,NBurnin,DEBUG)
%
% This the core BaGoL algorithm. It uses Reversible Jump Markov Chain 
% Monte Carlo to add, remove and move emitters, and to explore the 
% classification of localizations to emitters.  
%
% Prior information on the distribution of localizations per emitter is 
% required. The prior distribution is parameterized by either a Poisson or 
% Gamma distribution function.  For the Poisson distribution, the parameter
% [lambda] is the mean number of localizations per emitter.  For the Gamma
% distribution, [k, theta] are the shape and scale parameters.  k*theta
% is the mean localizations per emitter. 
%
% A linear drift of individual emitters can be included by allowing
% MaxAlpha to be non-zero. Drift velocities are given a uniform prior for
% each dimension from -MaxAlpha to MaxAlpha. 
%
% The output chain is a structure array of the post burn-in states 
% for the input subregion. Each element of the array contains fields 
% associated to a single accepted proposed parameter value. A description 
% of the fields is given below. 
%
% INPUTS:
%    SMD:      SMD structure with the following fields:
%       X:     X localization coordinates. (nm) (Nx1)
%       Y:     Y localization coordinates. (nm) (Nx1)
%       X_SE:  X localization precisions.  (nm) (Nx1)
%       Y_SE:  Y localization precisions.  (nm) (Nx1)
%       FrameNum:   localization frame numbers. (Nx1)
%    Xi:       Loc./emitter params [lambda] (Poisson) or [k theta] (Gamma) 
%    SigAlpha: Sigma of drift velocity. (nm) (Default = 0)
%    PMove:    Probabilities of proposing different moves in RJMCMC:
%              [1] Move Mu, Alpha
%              [2] Reallocation of Z
%              [3] Add
%              [4] Remove
%              (1x4) (Default = [0.25, 0.25, 0.25, 0.25])
%    NChain:   Length of the chain after the burn in. (Default = 2000)
%    NBurnin:  Length of the chain for burn in. (Default = 3000)
%    DEBUG:    0 or 1. Show an animation of the chain. (Default = 0)
%
% OUTPUT:
%    Chain:    Structure array of post burn-in states of the RJMCMC Chain. 
%       N: Number of emitters (Scalar)
%       X: X coordinate of emitters (Kx1)
%       Y: Y coordinate of emitters (Kx1)
%       AlphaX: Corresponding X drift velocities (Kx1)
%       AlphaY: Corresponding Y drift velocities (Kx1)
%       ID: Allocation parameter representing assigning a localization to 
%           an emitter. The order is the same as SMD.X (see above) (Nx1) 
%
% CITATION: "Sub-Nanometer Precision using Bayesian Grouping of Localizations"
%           Mohamadreza Fazel, Michael J. Wester, Sebastian Restrepo Cruz,
%           Sebastian Strauss, Florian Schueder, Thomas Schlichthaerle, 
%           Jennifer M. Gillette, Diane S. Lidke, Bernd Rieger,
%           Ralf Jungmann, Keith A. Lidke
%

% Created by: 
%    Mohamadreza Fazel and Keith A. Lidke (Lidkelab 2020)

%DEBUG=0;

DX = 1;
X_min = min(SMD.X-3*SMD.X_SE);
X_max = max(SMD.X+3*SMD.X_SE);
X_range = X_min:DX:X_max;
Y_min = min(SMD.Y-3*SMD.Y_SE);
Y_max = max(SMD.Y+3*SMD.Y_SE);
Y_range = Y_min:DX:Y_max;

[Xg,Yg] = meshgrid(X_range,Y_range);
PDFgrid = zeros(size(Xg));
for pp = 1:length(SMD.X)
    PDFgrid = PDFgrid + normpdf(Xg,SMD.X(pp),SMD.X_SE(pp)).*normpdf(Yg,SMD.Y(pp),SMD.Y_SE(pp)); 
end

CDF = cumsum(PDFgrid(:)/sum(PDFgrid(:)));
PDFgrid = PDFgrid/sum(PDFgrid(:));
Area = sum(sum(PDFgrid>max(PDFgrid(:))/1000));

Chain(NChain).N = [];
Chain(NChain).X = [];
Chain(NChain).Y = [];
Chain(NChain).AlphaX = [];
Chain(NChain).AlphaY = [];
Chain(NChain).ID = [];

if nargin<3
    MaxAlpha=0;
end

if nargin<4
    PMove = [.25 .25 .25 .25]; %PMove = [Theta Z Birth Death]
end

if nargin<5
    NChain = 3e3; %Total
end

if nargin<6
    NBurnin = 2e3;
end

%Storage of Chain
N=length(SMD.X);

%Intial K Guess
K=ceil(N/prod(Xi));

%Initial Locations
Mu_X =SMD.X(randi(N,[1 K]))';
Mu_Y =SMD.Y(randi(N,[1 K]))';

%Initial Alphas
Alpha_X = zeros([1 K]);
Alpha_Y = zeros([1 K]);

if N < 100
   LengN = 100; 
else
   LengN = N; 
end
%Calculating the Prior
if length(Xi)>1
   Gamma_K=Xi(1);
   Gamma_Theta=Xi(2);
   Pk=gampdf(N,(1:LengN)*Gamma_K,Gamma_Theta);
else
   Pk=poisspdf(N,(1:LengN)*Xi); 
end
Pk = Pk/sum(Pk);

% Intial Allocation
Z=Gibbs_Z(SMD,K,Mu_X,Mu_Y,Alpha_X,Alpha_Y);


% Run Chain
for nn=1:NChain+NBurnin
    %Get move type:
    JumpType=length(PMove)+1-sum(rand<cumsum(PMove));
    K = length(Mu_X);
    for ii = K:-1:1
        if sum(Z==ii)==0
            Mu_X(ii)=[];
            Mu_Y(ii)=[];
            Alpha_X(ii)=[];
            Alpha_Y(ii)=[];
            K = length(Mu_X);%K-1;
            Z(Z>ii) = Z(Z>ii) - 1;
        end 
    end
    switch JumpType
        case 1  %Move Mu, Alpha 
            Mu_XTest=Mu_X;
            Mu_YTest=Mu_Y;
            Alpha_XTest=Alpha_X;
            Alpha_YTest=Alpha_Y;
            
            for ID=1:K  
                %Get new Mu and Alpha using Gibbs
                if SigAlpha>0
                   [Mu_XTest(ID),Alpha_XTest(ID)]=Gibbs_MuAlpha(ID,Z,SMD.X,SMD.FrameNum,SMD.X_SE,SigAlpha);
                   [Mu_YTest(ID),Alpha_YTest(ID)]=Gibbs_MuAlpha(ID,Z,SMD.Y,SMD.FrameNum,SMD.Y_SE,SigAlpha);
                else
                   [Mu_XTest(ID)]=Gibbs_Mu(ID,Z,SMD.X,SMD.X_SE);
                   [Mu_YTest(ID)]=Gibbs_Mu(ID,Z,SMD.Y,SMD.Y_SE);
                end 
            end
            
            Mu_X = Mu_XTest;
            Mu_Y = Mu_YTest;
            Alpha_X = Alpha_XTest;
            Alpha_Y = Alpha_YTest;
            
            if nn>NBurnin %Then record in chain
                
                Chain(nn-NBurnin).N = K;
                Chain(nn-NBurnin).X = Mu_X';
                Chain(nn-NBurnin).Y = Mu_Y';
                Chain(nn-NBurnin).AlphaX = Alpha_X';
                Chain(nn-NBurnin).AlphaY = Alpha_Y';
                Chain(nn-NBurnin).ID = Z;
                
            end

        case 2  %Reallocation of Z
            
            [ZTest]=Gibbs_Z(SMD, K,Mu_X,Mu_Y,Alpha_X,Alpha_Y);
            %Always accepted
            Z = ZTest;
                        
            if nn>NBurnin %Then record in chain
                
                Chain(nn-NBurnin).N = K;
                Chain(nn-NBurnin).X = Mu_X';
                Chain(nn-NBurnin).Y = Mu_Y';
                Chain(nn-NBurnin).AlphaX = Alpha_X';
                Chain(nn-NBurnin).AlphaY = Alpha_Y';
                Chain(nn-NBurnin).ID = Z;
                
            end
            
        case 3  %Add
                        
%           Sample the Emitter location from SR data
            ID = find(CDF>rand(),1);
            if isempty(ID)
                ID = length(CDF); 
            end
            [Ydraw,Xdraw]=ind2sub(size(PDFgrid),ID);
            Mu_XTest = cat(2,Mu_X,Xdraw+X_min-1);
            Mu_YTest = cat(2,Mu_Y,Ydraw+Y_min-1);      

            if SigAlpha>0
                Alpha_XTest = cat(2,Alpha_X,SigAlpha*randn());
                Alpha_YTest = cat(2,Alpha_Y,SigAlpha*randn());
            else
                Alpha_XTest = cat(2,Alpha_X,0);
                Alpha_YTest = cat(2,Alpha_Y,0);
            end
            
            %dirrect sampling of allocations
            [ZTest]=Gibbs_Z(SMD,K+1,Mu_XTest,Mu_YTest,Alpha_XTest,Alpha_YTest);
                        
            %Prior Raio
            PR = Pk(K+1)/Pk(K);
            
            LAlloc_Current = p_Alloc(SMD,Mu_X,Mu_Y,Alpha_X,Alpha_Y,ones(1,K)/K);
            LAlloc_Test = p_Alloc(SMD,Mu_XTest,Mu_YTest,Alpha_XTest,Alpha_YTest,ones(1,K+1)/(K+1));
            AllocR = exp(LAlloc_Test-LAlloc_Current);
            
            %Posterior Ratio
            A = PR*AllocR/(Area*PDFgrid(ID));
            
            Accept = isinf(LAlloc_Current) & LAlloc_Current < 0;
            
            if rand<A || Accept
                Z=ZTest;
                K=K+1;
                Mu_X=Mu_XTest;
                Mu_Y=Mu_YTest;
                Alpha_X=Alpha_XTest;
                Alpha_Y=Alpha_YTest;
            end
            
            if nn>NBurnin %Then record in chain
                
                Chain(nn-NBurnin).N = K;
                Chain(nn-NBurnin).X = Mu_X';
                Chain(nn-NBurnin).Y = Mu_Y';
                Chain(nn-NBurnin).AlphaX = Alpha_X';
                Chain(nn-NBurnin).AlphaY = Alpha_Y';
                Chain(nn-NBurnin).ID = Z;
                
            end
            
        case 4  %Remove
            
            if K==1 %Then update chain and return
                if nn>NBurnin %Then record in chain
                    
                    Chain(nn-NBurnin).N = K;
                    Chain(nn-NBurnin).X = Mu_X';
                    Chain(nn-NBurnin).Y = Mu_Y';
                    Chain(nn-NBurnin).AlphaX = Alpha_X';
                    Chain(nn-NBurnin).AlphaY = Alpha_Y';
                    Chain(nn-NBurnin).ID = Z;
                    
                end
                continue;
            end
            
            %pick emitter to remove:
            ID =randi(K);
            
            Mu_XTest = Mu_X;
            Mu_YTest = Mu_Y;
            Alpha_XTest = Alpha_X;
            Alpha_YTest = Alpha_Y;
            
            %Remove from list
            Mu_XTest(ID) = [];
            Mu_YTest(ID) = [];
            Alpha_XTest(ID) = [];
            Alpha_YTest(ID) = [];
            
            %Gibbs allocation
            [ZTest]=Gibbs_Z(SMD,K-1,Mu_XTest,Mu_YTest,Alpha_XTest,Alpha_YTest);
            
            %Prior Raio
            PR = Pk(K-1)/Pk(K);
            
            %Probability Ratio of Proposed Allocation and Current Allocation 
            LAlloc_Current = p_Alloc(SMD,Mu_X,Mu_Y,Alpha_X,Alpha_Y,ones(1,K)/K);
            LAlloc_Test = p_Alloc(SMD,Mu_XTest,Mu_YTest,Alpha_XTest,Alpha_YTest,ones(1,K-1)/(K-1));
            AllocR = exp(LAlloc_Test-LAlloc_Current);
            
            %Posterior Ratio
            A = PR*AllocR;
            
            if rand<A
                Z=ZTest;
                K=K-1;
                Mu_X=Mu_XTest;
                Mu_Y=Mu_YTest;
                Alpha_X=Alpha_XTest;
                Alpha_Y=Alpha_YTest;
            end
            
            if nn>NBurnin %Then record in chain
                
                Chain(nn-NBurnin).N = K;
                Chain(nn-NBurnin).X = Mu_X';
                Chain(nn-NBurnin).Y = Mu_Y';
                Chain(nn-NBurnin).AlphaX = Alpha_X';
                Chain(nn-NBurnin).AlphaY = Alpha_Y';
                Chain(nn-NBurnin).ID = Z;
                
            end
            
    end    
    
    %DEBUG = 0;
    if DEBUG==1 %for testing
        figure(1111)
        scatter(SMD.X,SMD.Y,[],Z)
        hold on
        plot(Mu_X,Mu_Y,'ro','linewidth',4)
        legend(sprintf('Jump: %g',nn))
        xlabel('X(nm)')
        ylabel('Y(nm)')
        hold off
        pause(.001)
    elseif DEBUG == 2
        RadiusScale = 2;
        CircleRadius = sqrt((SMD.X_SE.^2 + SMD.Y_SE.^2) / 2) * RadiusScale;
        figure(1111)
        for oo = 1:max(Z)
            ID = Z==oo;
            Theta = linspace(0, 2*pi, 25)';
            Theta = repmat(Theta,[1,sum(ID)]);
            CircleX = repmat(CircleRadius(ID)',[25,1]).*cos(Theta) + repmat(SMD.X(ID)',[25,1]);
            CircleY = repmat(CircleRadius(ID)',[25,1]).*sin(Theta) + repmat(SMD.Y(ID)',[25,1]);
            A=plot(CircleX,CircleY);
            if oo == 1;hold on;end
            if ~isempty(A)
                set(A,'color',A(1).Color);
            end
        end
        plot(Mu_X,Mu_Y,'ro','linewidth',4)
        legend(sprintf('Jump: %g',nn))
        xlabel('X(nm)')
        ylabel('Y(nm)')
       
        hold off
        pause(.001)
    end
end

end

function [ZTest]=Gibbs_Z(SMD,K,Mu_X,Mu_Y,Alpha_X,Alpha_Y)
    %This function calculates updated allocations (Z)
    
    T=SMD.FrameNum;
    N=length(T);
    PX=zeros(N,K);
    PY=zeros(N,K);
   
    X=repmat(SMD.X,size(Mu_X));
    Y=repmat(SMD.Y,size(Mu_X));
    T=repmat(T,size(Mu_X));
    X_SE=repmat(SMD.X_SE,size(Mu_X));
    Y_SE=repmat(SMD.Y_SE,size(Mu_X));
    MUX=repmat(Mu_X,size(SMD.X));
    MUY=repmat(Mu_Y,size(SMD.Y));
    AX=repmat(Alpha_X,size(SMD.X));
    AY=repmat(Alpha_Y,size(SMD.Y));
    
    PX=normpdf(X-(MUX+AX.*T),0,X_SE);
    PY=normpdf(Y-(MUY+AY.*T),0,Y_SE);
    P=PX.*PY+eps;
    PNorm=P./repmat(sum(P,2),[1 K]);

    if sum(sum(isnan(P)))
       [ZTest] = knnsearch([Mu_X',Mu_Y'],[SMD.X,SMD.Y]); 
    else 
        ZTest=K+1-sum(repmat(rand(N,1),[1,K])<(cumsum(PNorm,2)+eps),2);
    end

end

function [Mu,Alpha]=Gibbs_MuAlpha(ID,Z,X,T,Sigma,SigAlpha)
    %This function calculates updated Mu and Alpha (1D)
    
    if length(X)==1
        Mu=Gibbs_Mu(ID,Z,X,Sigma);
        Alpha = 0;
        return;
    end
    
    if sum(Z==ID)==0
        Mu = X(randi(length(X)));
        Alpha = -SigAlpha+2*SigAlpha*rand();
    else
        %Get the localizations from the IDth emitter
        Xs=X(Z==ID);
        Sigs = Sigma(Z==ID);
        Ts=T(Z==ID);

        A = sum(Sigs.^-2);
        B = sum(Ts./Sigs.^2);
        D = sum((Ts.^2)./(Sigs.^2));

        %MLE estimates of Mu and Alpha

        [Alpha,Center] = calAlpha(Xs,Sigs,Ts,SigAlpha);
        MA=[Center;Alpha];

        %Covariance matrix Sigma
        COV = pinv([A, B;B,D+1/SigAlpha^2]);

        %This draws [Mu,Alpha] from a multivariate normal
        MuAlpha=mvnrnd(MA,COV);
        Mu=MuAlpha(1);
        Alpha=MuAlpha(2);

        if Mu == Center
           Mu = Center + sqrt(A)*randn(); 
        end
    end
    
end

function [Mu]=Gibbs_Mu(ID,Z,X,Sigma)
    %This function calculates updated Mu (1D)
    
    %Get the localizations from the IDth emitter
    if sum(Z==ID) == 0
        Mu = X(randi(length(Z)));
    else
        Xs=X(Z==ID);
        Sigs = Sigma(Z==ID);
        A = sum(Xs./(Sigs.^2));
        B = sum(Sigs.^-2);
        XMLE = A/B;
        X_SE = 1/sqrt(B);
        Mu=normrnd(XMLE,X_SE);
    end
end

function [Alpha,Center] = calAlpha(Xs,Sigs,Frames,SigAlpha)
    Frames = single(Frames);
    A = sum(Xs./Sigs.^2);
    B = sum(Frames./Sigs.^2);
    C = sum(Sigs.^-2);
    AlphaTop = sum((C*Xs-A).*Frames./Sigs.^2);
    AlphaBottom = sum((C*Frames-B).*Frames./Sigs.^2)+C/SigAlpha^2;
    Alpha = AlphaTop/AlphaBottom;
    Center = (A-Alpha*B)/C;
end

function LogL = p_Alloc(SMD,Mu_X,Mu_Y,Alpha_X,Alpha_Y,Ws)
%This function calculated the probability of a given allocation set.
    X=SMD.X;
    Y=SMD.Y;
    T = repmat(SMD.FrameNum,[1,length(Mu_X)]);
    SigmaX=SMD.X_SE;
    SigmaY=SMD.Y_SE;
    
    Lx = length(X);
    Lmu = length(Mu_X);
    LogL = log(sum(repmat(Ws,[Lx,1]).*normpdf(repmat(X,[1,Lmu]),...
            repmat(Mu_X,[Lx,1])+repmat(Alpha_X,[Lx,1]).*T,...
            repmat(SigmaX,[1,Lmu])).*normpdf(repmat(Y,[1,Lmu]),...
            repmat(Mu_Y,[Lx,1])+repmat(Alpha_Y,[Lx,1]).*T,...
            repmat(SigmaY,[1,Lmu])),2));
   
    LogL = sum(LogL);
    
end

./MATLAB/+smi/@BaGoL/genSRMAPNOverlay.m
function OverlayImageCircle ...
  = genSRMAPNOverlay(SMD, MAPN, XSize, YSize, PixelSize, ...
                      SaveDir, Xstart, Ystart, RadiusScale, ScaleBarLength)
%genSRMAPNOverlay generates a multicolor overlay containing circles with radii
% proportional to the average localization precision (the generalized mean
% between the X and Y precisions) for each localization from an SMD and a BaGoL
% MAPN structure.  The overlay is saved as a png-file with the identifier
% Overlay_SR_Map_circle.
%
% INPUTS:
%    SMD            SMD structure with the following fields (nm):
%                      X, Y, X_SE, Y_SE
%    MAPN           MAPN structure with the following fields (nm):
%                      X, Y, X_SE, Y_SE
%    XSize          x-size of image (nm)
%    YSize          y-size of image (nm)
%    PixelSize      either pixel linear dimension (nm), or string 'rescale'
%                   where an appropriate pixel size will be calculated.
%    SaveDir        directory in which to save the overlay image file
%    XStart:        X starting coordinate of the output image
%    YStart:        Y starting coordinate of the output image
%    RadiusScale    [OPTIONAL, Default = 1] scalar to multiply the localization
%                   precision by
%    ScaleBarLength [OPTIONAL, Default = 1000] length of scale bar on generated
%                   image (nm)
%
% OUTPUT:
%    OverlayCircleImage   overlay image with scalebar
%                   If genSRMAPNOverlay is called with no output argument,then
%                   this image will be saved in SaveDir as
%                   Overlay_SR_Map_circle.png

% Created by:
%    Michael J. Wester, Mohamadreza Fazel (2021) and David J. Schodt (Lidke Lab, 2018)

if ~exist('RadiusScale', 'var')
   RadiusScale = 1;
end
if ~exist('ScaleBarLength', 'var')
   ScaleBarLength = 1000;
end
if ~exist('Xstart', 'var')
   Xstart = 0;
end
if ~exist('Ystart', 'var')
   Ystart = 0;
end
if ~exist('PixelSize','var') || strcmp(PixelSize,'rescale')
    %If not given, the pixel size will be calculated here based on the
    %smallest precision.
    MinPixelsPerCircle = 16;
    CircleRadius = sqrt((MAPN.X_SE.^2+MAPN.Y_SE.^2) / 2) .* RadiusScale;
    SmallestCircumference= 2 * pi * min(CircleRadius);
    if SmallestCircumference == 0
       error('Precision cannot be zero'); 
    end
    PixelSize = SmallestCircumference/MinPixelsPerCircle;
end

% Compute parameters needed for the circle images (these are computed for
% the MAPN dataset and then left the same for the SMD).
BitDepth = 8; % specific to the save type: this is for a 8 bit png
ImageSize = ceil([XSize, YSize]/PixelSize);
if ((ImageSize(1)*ImageSize(2)*3) > (2^32 - 1))
    % imwrite() won't work for an image this large so we'll
    % have to settle with something smaller.
    % NOTE: The 3 corresponds to the 3 color channels that will
    %       be in the final overlay image.
    ImageSize = floor(2^16 * [1, 1] / sqrt(3));
    PixelSize = max([XSize,YSize])/size(ImageSize,1);
end
fprintf('ImageSize = %d x %d\n', ImageSize);

for ii = 1 : 2
   CircleImage = zeros(ImageSize, 'uint8'); % create the 0 image
   if ii == 1
      X = ((SMD.X-Xstart) / PixelSize);
      Y = ((SMD.Y-Ystart) / PixelSize);
      X_SE = (SMD.X_SE / PixelSize);
      Y_SE = (SMD.Y_SE / PixelSize);
   else
      X = ((MAPN.X-Xstart) / PixelSize);
      Y = ((MAPN.Y-Ystart) / PixelSize);
      X_SE = (MAPN.X_SE / PixelSize);
      Y_SE = (MAPN.Y_SE / PixelSize);
   end

   % Loop through each localization and construct the circle image.
   for mm = 1:numel(X)
       % Create the binary circle image by creating ~2*circumference
       % points for each circle (the extra points help make the circle
       % appear smooth).
       CircleRadius = sqrt((X_SE(mm)^2 + Y_SE(mm)^2) / 2) * RadiusScale;
       Theta = linspace(0, 2*pi, ceil(4 * pi * CircleRadius));
       CircleX = CircleRadius*cos(Theta) + X(mm);
       CircleY = CircleRadius*sin(Theta) + Y(mm);
       for nn = 1:numel(Theta)
           % Place the computed points for each circle in the binary image.
           ImageRow = round(CircleY(nn)); % row in the image
           ImageCol = round(CircleX(nn)); % column in the image
           if ((ImageRow<ImageSize(1)) && (ImageRow>1) ...
                   && (ImageCol<ImageSize(2)) && (ImageCol>1))
               % This point lies within the bounds of the image.
               CircleImage(ImageRow, ImageCol) = 2^BitDepth - 1;
               if ii == 2
                   CircleImages(ImageRow, ImageCol,1) = 0;
               end
           end
       end
   end
   CircleImages(1:ImageSize(1), 1:ImageSize(2), ii) = CircleImage;
end

% Produce a green (G) and magenta (R+B) color overlay for the two
% images, with the first image being green.
% If the input stack wasn't a float, make the output OverlayImage a uint8.
OverlayImageCircle = ...
    zeros([size(CircleImages, 1), size(CircleImages, 2), 3], 'uint8');
% Scale the color channels individually to [0, 1].
OverlayImageCircle(:, :, 1) = CircleImages(:, :, 2) ...
    ./ max(max(CircleImages(:, :, 2))); % red
OverlayImageCircle(:, :, 2) = CircleImages(:, :, 1) ...
    ./ max(max(CircleImages(:, :, 1))); % green
OverlayImageCircle(:, :, 3) = CircleImages(:, :, 2) ...
    ./ max(max(CircleImages(:, :, 2))); % blue
% For non-float images, we need to rescale the pixel values.
if ~isfloat(OverlayImageCircle)
    OverlayImageCircle = OverlayImageCircle * 255;
end

OverlayImageCircleName = sprintf('Overlay_SR_Map_circle.png');
% Add in a scalebar accounting for the size
% AdjustedScaleBarLength = ScaleBarLength * ImageSize(1) / XSize;
OverlayImageCircle = ...
   smi.BaGoL.scalebar(OverlayImageCircle, PixelSize, ScaleBarLength);
if nargout == 0
   imwrite(OverlayImageCircle, jet, fullfile(SaveDir, OverlayImageCircleName));
end

end

./MATLAB/+smi/@BaGoL/genMAPNIm.m
function [SRIm]=genMAPNIm(obj,ImFlag)
%makeIm: Produces a Gaussian blob image from either SMD or MAPN.
% [SRIm]=obj.genMAPNIm(ImFlag)
%
% Each input coordinate and standard error is used to add a normalized, 
% 2D Gaussian blob to an intially empty image. The size and image region
% is given by the input parameters. 
%
% For computational speed, this operation is done by calculating all blobs 
% within small boxes of the same size in one operation and then copying the 
% results into the output image. 
% 
% INPUTS:
%   ImFlag: Type of image to make. (Default = MAPN Image)
%      1: Retrieves the MAPN coordinates from obj and makes the MAPN image
%      2: Retrieves the SMD coordinates from obj and makes the SR image
%
% OUTPUTS: 
%   SRIm:    Output image.
%

% Created by:
%    Mohamadreza Fazel (LidkeLab, 2020)

%% SR-Image

MinX = -obj.XStart;
MinY = -obj.YStart;
if nargin==1||ImFlag==1
    SMR = obj.MAPN;
elseif ImFlag == 2
    SMR = obj.SMD;
else
    error('ImFlag must be either 1 or 2.')
end
BoxSize = floor(15*median([SMR.X_SE;SMR.Y_SE])/obj.PixelSize); %Size of box in pixels
if floor(BoxSize/2)~=BoxSize/2
    BoxSize = BoxSize + 1; 
end

XBox = single(floor((SMR.X+MinX)/obj.PixelSize)-floor(BoxSize/2));
YBox = single(floor((SMR.Y+MinY)/obj.PixelSize)-floor(BoxSize/2));
X = single((SMR.X+MinX) - obj.PixelSize*floor((SMR.X+MinX)/obj.PixelSize) + obj.PixelSize*floor(BoxSize/2)-1);
Y = single((SMR.Y+MinY) - obj.PixelSize*floor((SMR.Y+MinY)/obj.PixelSize) + obj.PixelSize*floor(BoxSize/2)-1);

[Xg,Yg,~]=meshgrid((obj.PixelSize/2:obj.PixelSize:BoxSize*obj.PixelSize-obj.PixelSize/2),...
    (obj.PixelSize/2:obj.PixelSize:BoxSize*obj.PixelSize-obj.PixelSize/2),(1:length(SMR.X)));
Xg = single(Xg);
Yg = single(Yg);
MuX = ones(size(Xg),'single');
SigX = ones(size(Xg),'single');
MuY = MuX;
SigY = SigX;
for ii = 1:length(SMR.X)
     SigX(:,:,ii) = SMR.X_SE(ii);
     SigY(:,:,ii) = SMR.Y_SE(ii);
     MuX(:,:,ii) = X(ii);
     MuY(:,:,ii) = Y(ii);
end
Im = normpdf(Xg,MuX,SigX).*normpdf(Yg,MuY,SigY);
ExtendSZ=100;  %imae size extension
SRImT = zeros(ceil(obj.PImageSize/obj.PixelSize)+ExtendSZ,'single');
for ii = 1:length(SMR.X) 
    try
        SRImT(YBox(ii)+(ExtendSZ/2+1):YBox(ii)+BoxSize+(ExtendSZ/2),...
            XBox(ii)+(ExtendSZ/2+1):XBox(ii)+BoxSize+(ExtendSZ/2)) = ...
            SRImT(YBox(ii)+(ExtendSZ/2+1):YBox(ii)+BoxSize+(ExtendSZ/2),...
            XBox(ii)+(ExtendSZ/2+1):XBox(ii)+BoxSize+(ExtendSZ/2)) + Im(:,:,ii);
    catch
    end
end
SRIm = SRImT((ExtendSZ/2+1):end-(ExtendSZ/2),(ExtendSZ/2+1):end-(ExtendSZ/2));
end

./MATLAB/+smi/@BaGoL/plotNND.m
function plotNND(obj,SaveDir)
%plotNND Makes and saves the NND histogram of MAPN coordinates
% obj.plotNND(SaveDir)
%
%  Calculates the nearest neighbor distribution from the MAPN coordinates 
%  and creates a histogram. If SaveDir input is given, it also saves the
%  plot to that directory as a PNG. 
%
% INPUTS:
%    SaveDir: Save directory (Optional)
%
% OUTPUT:
%     None
%

% Created by:
%    Mohamadreza Fazel (LidkeLab 2020)

NBins=30;
[~,Dis]=knnsearch([obj.MAPN.X,obj.MAPN.Y],[obj.MAPN.X,obj.MAPN.Y],'k',2);
Dis = Dis(:,2);
P = prctile(Dis,99);
figure
hist(Dis(Dis<P),NBins)
xlabel('NND(nm)','FontSize',15);ylabel('Frequency','FontSize',15)
if nargin > 1
   print(gcf,fullfile(SaveDir,'NND'),'-dpng'); 
   Dis = double(Dis);
   if size(Dis,2) > 1
      Dis = Dis';
   end
   save(fullfile(SaveDir,'NND.txt'),'Dis','-ascii')
end
end

./MATLAB/+smi/@BaGoL/removeOverlap.m
function Ind = removeOverlap(obj,ROIs,X,Y,ii)
%removeOverlap Finds coordinates located in overlapping regions.
% Ind = obj.removeOverlap(ROIs,X,Y,ii)
%
% removeOverlap() finds the coordinates in the given list that are inside 
% the overlapping regions between the adjacent ROIs and returns the index 
% of the coordinates that are not inside the overlapping regions. obj is 
% not modified by this method.
%
% Uses the class propoerty 'Overlap' and the location of the ROI to which
% the cluster of index ii belongs to make the calculation. 
%
% INPUTS:
%    ROIs:  2D Array of SMD structures (See genROIs())
%    X:     Vector of X coordinates (Mx1)
%    Y:     Vector of Y coordinates (Mx1)
%    ii:    Index of cluster 
%
% OUTPUT:
%    Ind:   The indices of the emitters that are inside the non-overlapping
%           regions.
%

% Created by:
%    Mohamadreza Fazel (LidkeLab 2019)

ix = obj.ClusterSMD(ii).ix;
iy = obj.ClusterSMD(ii).iy;
XPix = max(obj.SMD.X);
YPix = max(obj.SMD.Y);
[Ysub,Xsub] = size(ROIs); 
MinX = min(obj.SMD.X);
MinY = min(obj.SMD.Y);
if MinX < obj.ROIsize
    MinX = 0;
end
if MinY < obj.ROIsize
    MinY = 0; 
end
sy = obj.ROIsize*(iy-1);
ey = obj.ROIsize*iy;
sx = obj.ROIsize*(ix-1);
ex = obj.ROIsize*ix;
if iy == Ysub
    ey = YPix;
end
if ix == Xsub
    ex = XPix;
end                    
Ind = find(X - MinX >= sx & X - MinX < ex ...
      & Y - MinY >= sy & Y - MinY < ey);
end

./MATLAB/+smi/@BaGoL/scaleIm.m
function ImOut=scaleIm(Im,Percentile)
%scaleIm Scales and clips the image intensity to improve image contrast
% ImOut=BaGoL.scaleIm(Im,Percentile)
%
% The input image is linearly scaled between zero and a percentile of 
% intensity of non-zero pixels. Values above that percentile are set to the 
% value of the intensity at that percentile.  
%
% INPUT:
%    Im:         The input image
%    Percentile: Percentile used for scaling. (Default = 99)
%
% OUTPUT:
%    Imout:      Clipped and Scaled Image
%

% Created by:
%    Mohmadreza Fazel (LidkeLab 2019)
%
    if nargin < 2
        Percentile = 99;
    end
    ImOut=Im;
    P=prctile(Im(Im>0),Percentile);
    ImOut(ImOut>P)=P;
    ImOut=255*ImOut/P;
end

./MATLAB/+smi/README.md
### +smi

+smi is the namespace for the core user top-level classes of ***smite***:
- [@BaGoL](@BaGoL/README.md):     Bayesian Grouping of Localizations
- [@Publish](@Publish/README.md): batch processing of SR data
- [@SMLM](@SMLM/README.md):       Single Molecule Localization Microscopy
- [@SPT](@SPT/README.md):         Single-Particle Tracking analysis

./MATLAB/+smi/@Publish/computeBFShifts.m
function [LocalShiftMag, LocalShift1To2, ImageROIs] = ...
    computeBFShifts(FocusImStruct1, FocusImStruct2, SubROISize)
%computeBFShifts computes subROI shifts from brightfield data.
% This method will compute sub-ROI shifts between the brightfield images
% present in FocusImStruct1 and 2.
%
% INPUT:
%   FocusImStruct1: Structure containing the focus images for the first
%                   label (see the loaded structure BFStruct in, e.g.,
%                   smi.Publish.processLabel()).
%   FocusImStruct2: Structure containing the focus images for the second
%                   label (see the loaded structure BFStruct in, e.g.,
%                   smi.Publish.processLabel()).  This can also be given as
%                   just a reference image (e.g., a float array) in which
%                   case each image in FocusImStruct1 will be compared to
%                   the provided reference image.
%   SubROISize: Size of the subregions. (pixels)(Default = [32; 32])
%   ImageROIs: ROIs of the regions corresponding to the pixel offsets.
%              (NROIsx4 array)([YStart, XStart, YEnd, XEnd])
%
% OUTPUT:
%   LocalShiftMag: Magnitude of the shift differences between labels 1 and
%                  2. (pixels)
%   LocalShift1To2: Vector shifts between labels 1 and 2.
%
% CITATION:

% Created by:
%   David J. Schodt (Lidke Lab, 2022)


% Set defaults.
if (~exist('SubROISize', 'var') || isempty(SubROISize))
    SubROISize = [32; 32];
end

% Loop through datasets and compute the shifts between the labels.
% NOTE: For now, I'm using the very last image taken just before the
%       sequence starts. It might be useful to use the median over the
%       PreSeqImages, but I'm avoiding that just in case there is a
%       dramatic sample drift.
CorrParams.SuppressWarnings = true;
LocalShift1To2 = ...
    zeros(prod(size(FocusImStruct1(1).Data.PreSeqImages(:, :, end)) ...
    ./ SubROISize.'), numel(FocusImStruct1), 2);
if isstruct(FocusImStruct2)
    for ii = 1:numel(FocusImStruct1)
        [LocalShift1To2(:, ii, :), ~, ImageROIs] = ...
            smi.Publish.estimateLocalImShifts(...
            FocusImStruct1(ii).Data.PreSeqImages(:, :, end), ...
            FocusImStruct2(ii).Data.PreSeqImages(:, :, end), ...
            SubROISize, CorrParams);
    end
else
    % Misleading option: FocusImStruct2 can be given as a reference image
    % so that every image in FocusImStruct1 is compared to the same
    % reference.
    for ii = 1:numel(FocusImStruct1)
        [LocalShift1To2(:, ii, :), ~, ImageROIs] = ...
            smi.Publish.estimateLocalImShifts(...
            FocusImStruct1(ii).Data.PreSeqImages(:, :, end), ...
            FocusImStruct2, ...
            SubROISize, CorrParams);
    end
end
LocalShiftMag = sqrt(sum(LocalShift1To2.^2, 3));


end
./MATLAB/+smi/@Publish/genSROverlays.m
function [] = genSROverlays(ResultsCellDir, SaveDir, AnalysisID, ...
    Mask, MaskName)
%genSROverlays generates various types of  SR overlay images.
% This method will generate different types of overlay images for
% super-resolution (SR) data.  A multicolor overlay of the Gaussian SR
% images will be generated and saved as a .png file with the identifier
% _GaussianOverlay_ placed in the filename.  A multicolor overlay of the
% histogram SR images will be generated and saved as a .png file with the
% identifier _HistogramOverlay_ in the filename.  A multicolor overlay
% containing circles with radii proportional to the average localization
% precision (the generalized mean between the X and Y precisions) for each
% localization will be generated and saved as a .png file with the
% identifier _CircleOverlay_ in the filename.
%
% INPUTS:
%   ResultsCellDir: Directory containing the sub-directories for each label
%   SaveDir: Directory in which the resulting .png overlay images will be
%            saved.
%   AnalysisID: Analysis ID used to help identify the correct files.
%               (Default = '')
%   Mask: Optional mask to be applied to the overlays. (Logical array, same
%         aspect ratio as SR images).
%   MaskName: Optional identifier for the mask (e.g., '20nm').
%             (Default = '')

% Created by:
%   David J. Schodt (Lidke Lab, 2018)


% Set defaults/modify inputs.
if ~exist('AnalysisID', 'var')
    AnalysisID = '';
elseif ~isempty(AnalysisID)
    AnalysisID = ['_', AnalysisID];
end
if (~exist('Mask', 'var') || isempty(Mask))
    Mask = true;
end
if (~exist('MaskName', 'var') || isempty(MaskName))
    MaskName = '';
end

% Get the names of the directories containing the results for each label,
% throwing warnings if appropriate.
LabelDirNames = smi_helpers.getDirectoryNames(ResultsCellDir, 'Label*');
NLabels = numel(LabelDirNames);
if (NLabels > 4)
    warning('genSROverlay: 3 labels max')
    return
end
if (NLabels < 2)
    warning('genSROverlay: 2 labels min')
    return
end

% Load the Gaussian and histogram images for each label and store them in a
% single array.
GaussianImages = [];
CircleImages = [];
for ii = 1:NLabels
    % Create a list of sub-directories under the current label (there could
    % be multiple for a given label, e.g. an extra for a photobleaching
    % round of imaging).
    DatasetDirNames = smi_helpers.getDirectoryNames(...
        fullfile(ResultsCellDir, LabelDirNames{ii}), ...
        sprintf('Data*%s', AnalysisID));

    % If more than two datasets exists for this label, throw an error
    % (we can have two: one desired result, one photobleaching result)
    % since it's not clear which dataset to use.
    if (numel(DatasetDirNames) > 2)
        error('More than two datasets exist for %s', LabelDirNames{ii})
    end

    % Load our images into the appropriate arrays.
    DatasetDirNames = ...
        DatasetDirNames(contains(DatasetDirNames, AnalysisID));
    DatasetDirNames = ...
        DatasetDirNames(~contains(DatasetDirNames, 'bleach', ...
        'IgnoreCase', true));
    DatasetNames = erase(DatasetDirNames, AnalysisID);
    for jj = 1:numel(DatasetDirNames)
        % Create the appropriate filepaths and read in the images.
        FileDirectory = fullfile(ResultsCellDir, LabelDirNames{ii});
        FileNameCircle = sprintf('%s%s_CircleImage.png', ...
            DatasetNames{jj}, AnalysisID);
        FileNameGaussian = sprintf('%s%s_GaussImage.png', ...
            DatasetNames{jj}, AnalysisID);
        CircleImages = cat(3, CircleImages, sum(imread(fullfile(...
            FileDirectory, DatasetDirNames{jj}, FileNameCircle)), 3));
        GaussianImages = cat(3, GaussianImages, ...
            sum(imread(fullfile(FileDirectory, FileNameGaussian)), 3));
    end
end

% Generate our color overlay images (3 channel images).
[OverlayImageGaussian, ColorOrderTagGaussian] = ...
    smi_vis.GenerateImages.overlayNImages(GaussianImages);
[OverlayImageCircle, ColorOrderTagCircle] = ...
    smi_vis.GenerateImages.overlayNImages(CircleImages);

% Save the overlay images in the top level directory.
CellName = ResultsCellDir(regexp(ResultsCellDir, 'Cell*'):end);
CellNameClean = erase(CellName, '_');
OverlayImageGaussianName = sprintf('%s%s_GaussianOverlay_%s.png', ...
    CellNameClean, AnalysisID, ColorOrderTagGaussian);
imwrite(OverlayImageGaussian, fullfile(SaveDir, OverlayImageGaussianName));
OverlayImageCircleName = sprintf('%s%s_CircleOverlay_%s.png', ...
    CellNameClean, AnalysisID, ColorOrderTagCircle);
imwrite(OverlayImageCircle, fullfile(SaveDir, OverlayImageCircleName));

% Prepare and save masked overlays.
if ~all(Mask(:))
    Mask = imresize(Mask, size(OverlayImageGaussian, 1:2));
    MaskedGaussian = Mask .* OverlayImageGaussian;
    MaskedGaussianName = sprintf('%s%s%sMask_GaussianOverlay_%s.png', ...
        CellNameClean, AnalysisID, MaskName, ColorOrderTagGaussian);
    imwrite(MaskedGaussian, fullfile(SaveDir, MaskedGaussianName));
    Mask = imresize(Mask, size(OverlayImageCircle, 1:2));
    MaskedCircle = Mask .* OverlayImageCircle;
    MaskedCircleName = sprintf('%s%s%sMask_CircleOverlay_%s.png', ...
        CellNameClean, AnalysisID, MaskName, ColorOrderTagCircle);
    imwrite(MaskedCircle, fullfile(SaveDir, MaskedCircleName));
end


end
./MATLAB/+smi/@Publish/performFullAnalysis.m
function [] = performFullAnalysis(obj)
%performFullAnalysis is the main run method for the smi.Publish class.
% This method is the main run method for the smi.Publish class, meaning
% that it can be used to perform the standard analysis expected for use of
% this class.


% Define the results directory, which will be in the top level directory
% obj.CoverslipDir for easy access.
if isempty(obj.SaveBaseDir)
    obj.SaveBaseDir = fullfile(obj.CoverslipDir, 'Results');
end

% Define the path to the log file (a file containing info. about
% errors/warnings that happened during analysis).
StartTime = smi_helpers.genTimeString();
if isempty(obj.LogFilePath)
    FileSuffix = smi_helpers.arrayMUX(...
        {obj.SMF.Data.AnalysisID, StartTime}, ...
        isempty(obj.SMF.Data.AnalysisID));
    obj.LogFilePath = fullfile(obj.SaveBaseDir, ...
        ['Log_', FileSuffix, '.mat']);
end
LogFileDir = fileparts(obj.LogFilePath);
if ~isfolder(LogFileDir)
    % The directory containing the log file doesn't exist yet, so we'll
    % make it now.
    mkdir(LogFileDir)
end
save(obj.LogFilePath, 'StartTime')

% Determine the names of the sub-directories of interest within
% obj.CoverslipDir.  These correspond to individual cells imaged during the
% experiment.
CellNamesFound = smi_helpers.getDirectoryNames(obj.CoverslipDir, 'Cell*');
CellNames = CellNamesFound;
NCellsFound = numel(CellNamesFound);
if ~isempty(obj.CellList)
    KeepCells = ones(NCellsFound, 1, 'logical');
    for ii = 1:NCellsFound
        CellNumber = sscanf(CellNames{ii}, 'Cell_%d');
        if ~ismember(CellNumber, obj.CellList)
            KeepCells(ii) = false;
        end
    end
    CellNames = CellNames(KeepCells);
end
NCells = numel(CellNames);
if (obj.Verbose > 1)
    fprintf(['Publish.performFullAnalysis(): %i ', ...
        'cell directories found:\n'], NCellsFound)
    for ii = 1:NCellsFound
        fprintf('\t%s\n', CellNamesFound{ii})
    end
    fprintf(['Publish.performFullAnalysis(): %i ', ...
        'cell directories to be analyzed:\n'], NCells)
    for ii = 1:NCells
        fprintf('\t%s\n', CellNames{ii})
    end
elseif (obj.Verbose == 1)
    fprintf(['Publish.performFullAnalysis(): analyzing %i ', ...
        'cell directories...\n'], NCells)
end

% Loop through the cell directories and analyze the contents.
for ii = 1:NCells
    % Determine if this cell should be analyzed.
    if ~isempty(obj.CellList)
        CellNumber = sscanf(CellNames{ii}, 'Cell_%d');
        if ~ismember(CellNumber, obj.CellList)
            continue
        end
    end
    if (obj.Verbose > 1)
        fprintf(['Publish.performFullAnalysis(): analyzing ', ...
            'cell directory %i of %i: %s...\n'], ii, NCells, CellNames{ii})
    end
    obj.processCell(CellNames{ii});
end

% Generate misc. stats. comparing all cells that were analyzed.
if obj.GenerateOverlayStats
    obj.genOverlayResults()
end

% Indicate completion of the analysis/generation of results.
EndTime = smi_helpers.genTimeString();
ErrorLog = obj.ErrorLog;
save(obj.LogFilePath, 'EndTime', 'ErrorLog', '-append')
if obj.Verbose
    fprintf('Results have been published to %s\n', obj.CoverslipDir);
end

% Save the results.
obj.saveResults()


end
./MATLAB/+smi/@Publish/Publish.m
classdef Publish < handle
    % Publish contains methods useful for batch processing of SR data.
    %   This class contains a collection of analysis/visualization methods
    %   useful for batch-processing of super-resolution data, particularly
    %   for data with multiple labels stored in independent files (e.g.,
    %   sequential super-resolution of two labels on multiple cells).
    %
    % NOTE: This class is designed around .h5 files containing raw data
    %       stored in directories separating distinct cells and labels,
    %       with the directory names following the scheme
    %       Cell*\Label*\Data*.h5
    %
    % REQUIRES: MATLAB 2018a or later (for Publish.genAlignStats())
    %           Image Processing Toolbox
    %           Statistics and Machine Learning Toolbox
    %           Curve Fitting Toolbox
    %
    % CITATION:

    % Created by:
    %   David J. Schodt (Lidke Lab 2021), originally based on the script
    %       PublishSEQSR_SAC.m in SR_demo


    properties
        % Structure of parameters (see smi_core.SingleMoleculeFitting)
        SMF

        % Directory containing the Cell*\Label*\Data*.h5 sub-directories.
        CoverslipDir

        % Base directory for saving (Default set in performFullAnalysis())
        SaveBaseDir

        % Log file for errors (Default set in performFullAnalysis())
        LogFilePath

        % Label(s) to be analyzed (Default = [], analyze all labels)
        LabelID = [];

        % Cell(s) to be analyzed (Default = [], analyze all cells)
        CellList = [];

        % Zoom factor for output SR images (Default = 20)
        SRImageZoom = 20;

        % Zoom factor for circle images (Default = 50)
        SRCircleImageZoom = 50;

        % Flag to indicate SR results should be generated (Default = true)
        GenerateSR = true;

        % Flag to generate various imaging stats (Default = true)
        GenerateImagingStats = true;

        % Flag to generate overlay info. between channels (Default = false)
        GenerateOverlayStats = false;

        % Flag to perform analysis on bleaching results (Default = false)
        AnalyzeBleaching = false;

        % Apply brightfield drift correction (Default = false)
        % NOTE: If SMF.DriftCorrection.On=true, brightfield DC is still
        %       applied just before the post-processing DC.
        UseBrightfieldDC = false

        % Max. brightfield shift used to define overlay masks (pixels)
        % NOTE: This is defined in terms of brightfield pixels, e.g., units
        %       of obj.SMF.Data.PixelSize.
        MaxBrightfieldShift = inf

        % Shift localizations based on brightfield results (Default = false)
        ShiftToReg = false;

        % Verbosity of the main analysis workflow. (Default = 1)
        Verbose = 1;

        % Structure containing several analysis results.
        ResultsStruct = struct([]);
    end

    properties (SetAccess = 'protected', Hidden)
        % Instance of SMLM class (for internal use).
        SMLM

        % Log of errors encountered during analysis.
        ErrorLog = {};

        % Data related to brightfield registration loaded from data files.
        AlignRegStructs = {};

        % Set of brightfield focus images loaded from data files.
        FocusImageStructs = {};

        % Set of brightfield masks generated from FocusImageStructs.
        BFMasks = {};
    end

    methods
        function obj = Publish(SMF, CoverslipDir)
            %Publish is the class constructor for the smi.Publish class.

            % Set defaults if needed.
            if (~exist('SMF', 'var') || isempty(SMF))
                SMF = smi_core.SingleMoleculeFitting;
            end
            if (~exist('CoverslipDir', 'var') || isempty(CoverslipDir))
                CoverslipDir = '';
            end

            % Store the inputs as class properties.
            obj.SMF = SMF;
            obj.CoverslipDir = CoverslipDir;
        end

        function set.SMF(obj, SMFInput)
            %set method for the property SMF.
            obj.SMF = smi_core.SingleMoleculeFitting.reloadSMF(SMFInput);
        end

        function saveResults(obj)
            % This method saves the PublishedResultsStruct into the Results
            % directory.
            ResultsStruct = obj.ResultsStruct;
            save(fullfile(obj.SaveBaseDir, 'ResultsStruct.mat'), ...
                'ResultsStruct', '-v7.3');
        end

        [AlignResultsStruct] = genAlignResults(obj, FilePath, SaveDir);
        genOverlayResults(obj)
        performFullAnalysis(obj)
        processCell(obj, CellName)
        processLabel(obj, CellName, LabelName)

    end

    methods (Static)
        genSROverlays(ResultsCellDir, SaveDir, AnalysisID, Mask, MaskName)
        [OverlayImage, ColorOrderTag] = overlayNImages(ImageStack);
        genOverlayPlots(ImageShift, RegError, MaxCorr, BPPixelSize, SaveDir)
        [ImagesStruct] = genAlignMovies(AlignRegData, SaveDir);
        [StatsStruct] = genAlignStats(AlignRegStruct, SMD, SaveDir);
        [XCorrStruct] = genAlignXCorr(AlignRegStruct, SaveDir);
        makeOverlayPlots(ImageShift, RegError, MaxCorr, ...
            SRPixelSize, BPPixelSize, SaveDir)
        [PlotAxes, RegError] = plotXYRegError(PlotAxes, SMD);
        [Shift, IntShift, ImageROIs, ImageStats] = ...
            estimateLocalImShifts(Image1, Image2, SubROISize, ...
            CorrParams, ShiftParams);
        [SubPixelOffsets, SMDROIs, SMDStats] = ...
            estimateLocalCoordShifts(SMD1, SMD2, SubROISize);
        [RegCorrection] = computeRegCorrection(SMF);
        [SMD, BestRegInd] = shiftToBestReg(SMD, RefImage, FocusImages);
        [Mask] = ...
            defineShiftMask(LocalImShifts, ImageROIs, MaxShift, ImSize);
        [Mask, Shifts, ImageROIs] = ...
            genBFMask(FocusImageStruct, RefImage, MaxBrightfieldShift);
        [LocalShiftMag, LocalShift1To2, ImageROIs] = ...
            computeBFShifts(FocusImStruct1, FocusImStruct2, SubROISize);
    end


end
./MATLAB/+smi/@Publish/processLabel.m
function processLabel(obj, CellName, LabelName)
%processLabel processes the SR data for the specified label.
% This method will find the data in
%
% INPUTS:
%   CellName: Char. array/string of the Cell* directory (i.e., the distinct
%             Cell* names in the directory structure
%             *\Cell*\Label*\Data*.h5)

% Created by:
%   David J. Schodt (Lidke Lab 2021)


% Specify the directory containing this labels data and create a list of
% the data files.
DataDir = fullfile(obj.CoverslipDir, CellName, LabelName);
obj.SMF.Data.FileDir = DataDir;
DataFileStruct = dir(fullfile(DataDir, 'Data*'));
DataFileNames = {DataFileStruct.name};
NDataFiles = numel(DataFileNames);
if (obj.Verbose > 1)
    fprintf('\tPublish.processLabel(): %i files found:\n', NDataFiles)
    for ii = 1:NDataFiles
        fprintf('\t\t%s\n', DataFileNames{ii})
    end
end

% Grab some useful information from the file name.
CellNumber = regexp(CellName, '\d*', 'match');
CellNumber = str2double(CellNumber{1});
LabelNumber = regexp(LabelName, '\d*', 'match');
LabelNumber = str2double(LabelNumber{1});

% Load and analyze the data for the current label, looping through datasets
% if needed.
for ii = 1:NDataFiles
    % Determine if this was a bleaching round and decide if we should
    % analyze it.
    if (contains(DataFileNames{ii}, 'bleach') && ~obj.AnalyzeBleaching)
        continue
    end

    % Load the focus images taken before/after each sequence (these may be
    % used later).
    % NOTE: This only works correctly if we have one file per label 
    %       (excluding 'bleaching' files).
    FilePath = fullfile(DataDir, DataFileNames{ii});
    H5FileStruct = h5info(FilePath);
    try
        FileGroupList = {H5FileStruct.Groups.Groups.Groups(1).Groups.Name};
        FocusImagesPresent = any(contains(FileGroupList, 'FocusImages'));
    catch ME
        warning(['Publish,processLabel(): ', 'No Focus Images present: ', ...
                 FilePath]);
        FocusImagesPresent = false;
    end
    if FocusImagesPresent
        % If the FocusImages field is present, we'll use those.
        FocusImageStruct = smi_core.LoadData.readH5File(...
            FilePath, 'FocusImages');
        FocusImages = cell(numel(FocusImageStruct), 1);
        for nn = 1:numel(FocusImageStruct)
            FocusImages{nn} = FocusImageStruct(nn).Data.PreSeqImages;
        end
    else
        % If the FocusImages field isn't present (older data), we can still
        % try to make use of the last brightfield image taken before each
        % sequence.  The AlignReg structure has a similar organization, so
        % we can just add a new field and store it in
        % obj.FocusImageStructs.
        try
           AlignReg = smi_core.LoadData.readH5File(FilePath, 'AlignReg');
           for nn = 1:numel(AlignReg)
               FocusImages{nn} = AlignReg(nn).Data.Image_Current;
               AlignReg(nn).Data.PreSeqImages = AlignReg(nn).Data.Image_Current;
           end
           FocusImageStruct = AlignReg;
       catch ME
           warning(['Publish.processLabel(): ', ...
                    'H5 file does not contain AlignReg structure. ', ...
                    FilePath]);
           FocusImageStruct = [];
       end
    end
    if ~isempty(FocusImageStruct)
        obj.FocusImageStructs{CellNumber, LabelNumber} = FocusImageStruct;
    end

    % Display some message to the Command Window to show progression
    % through the workflow.
    if obj.Verbose
        fprintf('\tPublish.processLabel(): Analyzing %s...\n', ...
            fullfile(DataDir, DataFileNames{ii}))
    end

    % Define the save directory for this specific file.
    SaveDir = fullfile(obj.SaveBaseDir, CellName, LabelName);

    % Generate figures associated with the brightfield registration of the
    % cell (if that data exists).
    try
        H5FileStruct = h5info(FilePath);
        FileGroupList = ...
            {H5FileStruct.Groups.Groups.Groups(1).Groups.Name};
    catch ME
        warning(['Publish.processLabel(): ', ...
                 'H5 file not of expected structure. ', ...
                 FilePath]);
        FileGroupList = {};
    end
    if obj.GenerateImagingStats
        % Generate the results.
        if any(contains(FileGroupList, 'AlignReg'))
            if (obj.Verbose > 1)
                fprintf(['\t\tPublish.processLabel(): ', ...
                    'Generating cell registration results...\n'])
            end
            [~, FileNameNoExt] = fileparts(DataFileNames{ii});
            ImagingStatsSaveDir = fullfile(SaveDir, FileNameNoExt);
            [AlignResultsStruct] = ...
                obj.genAlignResults(FilePath, ImagingStatsSaveDir);
            AlignReg = AlignResultsStruct.AlignReg; % grab for later.
            obj.AlignRegStructs{CellNumber, LabelNumber} = AlignReg;

            % Store information from the AlignResultsStruct into a field
            % associated with the current dataset in the
            % PublishedResultsStruct.
            FieldNames = fieldnames(AlignResultsStruct);
            obj.ResultsStruct(CellNumber, LabelNumber).Cell = CellName;
            obj.ResultsStruct(CellNumber, LabelNumber).Label = LabelName;
            for jj = 1:numel(FieldNames)
                obj.ResultsStruct(CellNumber, LabelNumber). ...
                    (FieldNames{jj}) = AlignResultsStruct.(FieldNames{jj});
            end
        end
    end

    % Generate the super-resolution results using the smi.SMLM class.
    obj.SMLM.SMF.Data.FileDir = DataDir;
    obj.SMLM.SMF.Data.FileName = DataFileNames(ii);
    if obj.GenerateSR
        if (obj.Verbose > 1)
            fprintf(['\t\tPublish.processLabel(): ', ...
                'Analyzing file %s...\n'], ...
                fullfile(DataDir, DataFileNames{ii}))
        end

        % Place this in a try/catch so that we can still proceed with
        % the other analyses if this fails.
        try
            % Perform SR analysis, but don't save the results yet!
            obj.SMLM.SMF.Data.ResultsDir = SaveDir;
            obj.SMLM.FullvsTest = true;
            if (obj.UseBrightfieldDC && FocusImagesPresent)
                % If we're using brightfield DC, we need to apply it before
                % using the post-processing DC algorithm.
                obj.SMLM.SMF.DriftCorrection.On = false;
                obj.SMLM.analyzeAll();

                % Perform the brightfield DC.
                Params.CorrParams.SuppressWarnings = true;
                AlignReg = smi_core.LoadData.readH5File(FilePath, 'AlignReg');
                obj.AlignRegStructs{CellNumber, LabelNumber} = AlignReg;
                obj.SMLM.SMD = ...
                    smi_core.DriftCorrection.driftCorrectBF(...
                    obj.SMLM.SMD, obj.SMLM.SMF, ...
                    AlignReg(1).Data.Image_Reference, ...
                    obj.FocusImageStructs{CellNumber, LabelNumber}, Params);

                % Run the post-processing drift correction if needed.
                if obj.SMF.DriftCorrection.On
                    DC = smi_core.DriftCorrection;
                    DC.SMF = obj.SMF;
                    DC.BFRegistration = true;
                    obj.SMLM.SMD = DC.driftCorrectKNN(obj.SMLM.SMD);
                end
            else
                if ((obj.Verbose>0) && obj.UseBrightfieldDC ...
                        && ~FocusImagesPresent)
                    warning(['Brightfield drift-correction cannot be ', ...
                        'applied: FocusImages not present in .h5 file'])
                end
                obj.SMLM.analyzeAll();
            end

            % Re-shift the XY coordinates w.r.t. the best registration
            % dataset.
            if obj.ShiftToReg
                % Check if the alignment results are available, loading
                % them if not.
                if (~exist('AlignReg', 'var') || isempty(AlignReg))
                    AlignReg = smi_core.LoadData.readH5File(FilePath, 'AlignReg');
                    obj.AlignRegStructs{CellNumber, LabelNumber} = AlignReg;
                end

                % Determine which focus image has the least shift w.r.t.
                % the reference (in XY, ignoring Z).
                RefImage = AlignReg(1).Data.Image_Reference;
                obj.SMLM.SMD = obj.shiftToBestReg(obj.SMLM.SMD, ...
                    RefImage, FocusImages);
            end

            % Save the SR results.
            obj.SMLM.saveResults();

            % Copy the results into a more accessible directory (it's nice
            % to have them all in one place for certain analyses).
            [~, FileName] = fileparts(DataFileNames{ii});
            FileNameSaved = [FileName, ...
                smi_helpers.arrayMUX({'_', ''}, ...
                isempty(obj.SMLM.SMF.Data.AnalysisID)), ...
                obj.SMLM.SMF.Data.AnalysisID];
            ResultsFile = dir(fullfile(obj.SMLM.SMF.Data.ResultsDir, ...
                FileNameSaved, '*Results.mat'));
            if ~isempty(ResultsFile)
                ResultsStructDir = ...
                    fullfile(obj.SaveBaseDir, 'ResultsStructs');
                if ~isfolder(ResultsStructDir)
                    mkdir(ResultsStructDir)
                end
                NewName = [CellName, '_', LabelName, ...
                    '_', FileNameSaved, '_Results.mat'];
                copyfile(fullfile(ResultsFile.folder, ResultsFile.name), ...
                    fullfile(ResultsStructDir, NewName));
            end

            % If needed, perform brightfield masking.
            if (~isinf(obj.MaxBrightfieldShift) && (obj.MaxBrightfieldShift>0))
                if (~exist('AlignReg', 'var') || isempty(AlignReg))
                    AlignReg = smi_core.LoadData.readH5File(FilePath, 'AlignReg');
                    obj.AlignRegStructs{CellNumber, LabelNumber} = AlignReg;
                end
                [Mask, Shifts, ImageROIs] = obj.genBFMask(...
                    obj.FocusImageStructs{CellNumber, LabelNumber}, ...
                    AlignReg(1).Data.Image_Reference, ...
                    obj.MaxBrightfieldShift);
                obj.BFMasks{CellNumber, LabelNumber} = Mask;
                MaskName = sprintf('%inm', ...
                    round(obj.MaxBrightfieldShift * obj.SMF.Data.PixelSize * 1e3));
                save(fullfile(obj.SMLM.SMF.Data.ResultsDir, ...
                    sprintf('%s_%s_%s_Mask.mat', CellName, LabelName, MaskName)), ...
                    'Mask', 'Shifts', 'ImageROIs')
                SMDMasked = ...
                    smi_core.SingleMoleculeData.maskSMD(obj.SMLM.SMD, Mask);
                MaskedResultName = erase(ResultsFile.name, 'Results.mat');
                MaskedResultName = [MaskedResultName, ...
                    'SingleLabelMask', MaskName, '_Results.mat'];
                SMD = SMDMasked;
                SMF = obj.SMF.packageSMF();
                save(fullfile(obj.SMLM.SMF.Data.ResultsDir, FileNameSaved, ...
                    MaskedResultName), 'SMD', 'SMF', '-v7.3')
                NewName = [CellName, '_', LabelName, ...
                    '_', FileNameSaved, '_SingleLabelMask', MaskName, '_Results.mat'];
                save(fullfile(ResultsStructDir, NewName), ...
                    'SMD', 'SMF', '-v7.3')
                obj.SMLM.SMD = SMDMasked;
                obj.SMLM.generatePlots(obj.SMLM.ResultsDir, ...
                    obj.SMLM.ResultsSubDir, ...
                    ['SingleLabelMask', MaskName], ...
                    obj.SMLM.ShowPlots, obj.SMLM.PlotDo);
            end
        catch MException
            if obj.Verbose
                warning(['Publish.processLabel(): ', ...
                    'Unable to generate SR images for %s\n%s, %s'], ...
                    DataFileNames{ii}, ...
                    MException.identifier, MException.message)
            end

            % Store the error information in the log file.
            obj.ErrorLog = [obj.ErrorLog; ...
                {CellName, LabelName, MException}];
            ErrorLog = obj.ErrorLog;
            save(obj.LogFilePath, 'ErrorLog', '-append')
        end
    end
end


end

./MATLAB/+smi/@Publish/makeOverlayPlots.m
function [] = makeOverlayPlots(ImageShift, RegError, MaxCorr, ...
    BPPixelSize, SaveDir)
%makeOverlayPlots makes interesting plots from two color overlays
% This method will estimate shifts and registration errors from the data
% used to generate the two images in ImageStack.
%
% INPUTS:
%   ImageShift: A two column array with each row containing the [row, col]
%               offsets between two images as determined from findshift().
%               (SR pixels)
%   RegError: The estimated brightfield registration errors for datasets
%             used to generate the images corresponding to the shift
%             contained in ImageShift.  RegError is a cell array, with the
%             row index of the cell array corresponding to a row in
%             ImageShift and the column index corresponding to the label
%             number. (raw data pixels)
%   MaxCorr: The maximum correlation coefficients from brightfield
%            registration for the datasets used to generate the second
%            label in the overlay images in consideration.  MaxCorr is a
%            cell array, with the row index of the cell array corresponding
%            to a row in ImageShift and the column index corresponding to
%            the label number.
%   BPPixelSize: Size of a pixel in the raw data as projected onto the
%                sample plane. (microns)(default = 0.1)
%   SaveDir: Directory in which output plots will be saved.

% Created by:
%   David J. Schodt (Lidke Lab, 2018)


% Set defaults if needed.
if (~exist('BPPixelSize', 'var') || isempty(BPPixelSize))
    BPPixelSize = 0.1; % microns
end

% Convert ImageShift and RegError to units of nanometers.
ImageShift = ImageShift * BPPixelSize * 1e3; % pixel -> micron -> nanometer
RegError = cellfun(@(x) x * BPPixelSize * 1e3, RegError, ...
    'UniformOutput', false); % pixel -> micron -> nanometer

% Make a scatterplot of the image shifts.
FigureHandle = figure();
PlotAxes = axes(FigureHandle);
hold(PlotAxes, 'on');
NOverlays = size(ImageShift, 1); % number of overlay images considered
ColorMap = colormap(PlotAxes, parula(NOverlays));
for ii = 1:NOverlays
    % Plot the shift between the two images.
    plot(PlotAxes, ImageShift(ii, 2), ImageShift(ii, 1), ...
        'Marker', 'x', 'MarkerEdgeColor', ColorMap(ii, :), ...
        'MarkerSize', 10, 'LineWidth', 1, 'LineStyle', 'none')
end
ColorBar = colorbar(PlotAxes); % add a color bar to show image number
ColorBar.Ticks = linspace(min(ColorBar.Limits), max(ColorBar.Limits), ...
    NOverlays);
ColorBar.TickLabels = 1:NOverlays;
ColorBar.Label.String = 'Image Number';
plot(PlotAxes, [0, 0], PlotAxes.YLim, 'k--')
plot(PlotAxes, PlotAxes.XLim, [0, 0], 'k--')
xlabel(PlotAxes, 'X (nm)')
ylabel(PlotAxes, 'Y (nm)')
title(PlotAxes, 'Image Shifts')

% Save the scatterplot of ImageShift and RegError.
saveas(FigureHandle, ...
    fullfile(SaveDir, 'ImageShiftScatterPlot.png'), 'png');
saveas(FigureHandle, ...
    fullfile(SaveDir, 'ImageShiftScatterPlot.fig'));
close(FigureHandle);

% Plot the magnitude of ImageShift vs. MaxCorr as well as the magnitude of
% ImageShift vs. the magnitude of RegError.
if ~(isempty(MaxCorr) || isempty(RegError))
    FigureHandle = figure();
    SubplotAxesTop = subplot(2, 1, 1, 'Parent', FigureHandle);
    hold(SubplotAxesTop, 'on');
    SubplotAxesBottom = subplot(2, 1, 2, 'Parent', FigureHandle);
    hold(SubplotAxesBottom, 'on');
    for ii = 1:NOverlays
        % Compute the magnitude of the current ImageShift and make a repeated
        % array of this value (to plot vs. the longer arrays MaxCorr and
        % RegError).
        CurrentImageShiftMag = sqrt((ImageShift(ii, 1))^2 ...
            + (ImageShift(ii, 2))^2);
        CurrentImageShiftMag = repelem(CurrentImageShiftMag, ...
            numel(MaxCorr{ii, 1})).';
        
        % Plot the magnitude of ImageShift vs. the MaxCorr.
        plot(SubplotAxesTop, CurrentImageShiftMag, MaxCorr{ii, 1}, ...
            'Marker', 'x', 'MarkerEdgeColor', ColorMap(ii, :), ...
            'LineStyle', 'none')
        plot(SubplotAxesTop, CurrentImageShiftMag, MaxCorr{ii, 2}, ...
            'Marker', 'o', 'MarkerEdgeColor', ColorMap(ii, :), ...
            'LineStyle', 'none')
        
        % Compute the magnitude of the current RegError.
        CurrentRegErrorLabel1 = RegError{ii, 1};
        CurrentRegErrorMagLabel1 = sqrt((CurrentRegErrorLabel1(:, 1)).^2 ...
            + (CurrentRegErrorLabel1(:, 2)).^2);
        CurrentRegErrorLabel2 = RegError{ii, 2};
        CurrentRegErrorMagLabel2 = sqrt((CurrentRegErrorLabel2(:, 1)).^2 ...
            + (CurrentRegErrorLabel2(:, 2)).^2);
        
        % Plot the magnitude of RegError vs. the magnitude of ImageShift.
        plot(SubplotAxesBottom, ...
            CurrentImageShiftMag, CurrentRegErrorMagLabel1, ...
            'Marker', 'x', 'MarkerEdgeColor', ColorMap(ii, :), ...
            'LineStyle', 'none')
        plot(SubplotAxesBottom, ...
            CurrentImageShiftMag, CurrentRegErrorMagLabel2, ...
            'Marker', 'o', 'MarkerEdgeColor', ColorMap(ii, :), ...
            'LineStyle', 'none')
    end
    ColorBar = colorbar(SubplotAxesTop); % add a color bar to show image number
    ColorBar.Ticks = linspace(min(ColorBar.Limits), max(ColorBar.Limits), ...
        NOverlays);
    ColorBar.TickLabels = 1:NOverlays;
    ColorBar.Label.String = 'Image Number';
    ColorBar = colorbar(SubplotAxesBottom); % add a color bar
    ColorBar.Ticks = linspace(min(ColorBar.Limits), max(ColorBar.Limits), ...
        NOverlays);
    ColorBar.TickLabels = 1:NOverlays;
    ColorBar.Label.String = 'Image Number';
    CrossPlot = plot(SubplotAxesTop, NaN, NaN, 'kx'); % 'dummy' points
    CirclePlot = plot(SubplotAxesTop, NaN, NaN, 'ko');
    legend(SubplotAxesTop, [CrossPlot, CirclePlot], {'Label 1', 'Label 2'}, ...
        'Location', 'best');
    CrossPlot = plot(SubplotAxesBottom, NaN, NaN, 'kx'); % 'dummy' points
    CirclePlot = plot(SubplotAxesBottom, NaN, NaN, 'ko');
    legend(SubplotAxesBottom, [CrossPlot, CirclePlot], {'Label 1', 'Label 2'}, ...
        'Location', 'best');
    xlabel(SubplotAxesTop, 'Image Shift Magnitude (nm)')
    xlabel(SubplotAxesBottom, 'Image Shift Magnitude (nm)')
    ylabel(SubplotAxesTop, 'Max. Corr. Coeff.')
    ylabel(SubplotAxesBottom, 'Reg. Error Magnitude (nm)')
    
    % Save the plots of ImageShift vs. MaxCorr/RegError.
    saveas(FigureHandle, ...
        fullfile(SaveDir, 'ImageShiftRegErrorMaxCorr.png'), 'png');
    saveas(FigureHandle, ...
        fullfile(SaveDir, 'ImageShiftRegErrorMaxCorr.fig'));
    close(FigureHandle);
    
    % Plot the magnitude of RegError vs. the cross-correlation maxima.
    FigureHandle = figure();
    PlotAxes = axes(FigureHandle);
    hold(PlotAxes, 'on');
    for ii = 1:NOverlays
        CurrentRegErrorLabel1 = RegError{ii, 1};
        CurrentRegErrorMagLabel1 = sqrt((CurrentRegErrorLabel1(:, 1)).^2 ...
            + (CurrentRegErrorLabel1(:, 2)).^2);
        CurrentRegErrorLabel2 = RegError{ii, 2};
        CurrentRegErrorMagLabel2 = sqrt((CurrentRegErrorLabel2(:, 1)).^2 ...
            + (CurrentRegErrorLabel2(:, 2)).^2);
        plot(PlotAxes, MaxCorr{ii, 1}, CurrentRegErrorMagLabel1, 'bx')
        plot(PlotAxes, MaxCorr{ii, 2}, CurrentRegErrorMagLabel2, 'bo')
    end
    CrossPlot = plot(PlotAxes, NaN, NaN, 'bx'); % 'dummy' points for legend
    CirclePlot = plot(PlotAxes, NaN, NaN, 'bo');
    legend(PlotAxes, [CrossPlot, CirclePlot], {'Label 1', 'Label 2'}, ...
        'Location', 'best');
    xlabel(PlotAxes, 'Cross-Correlation Maximum')
    ylabel(PlotAxes, 'Registration Error Magnitude (nm)')
    title(PlotAxes, 'Registration Errors vs. Cross-Correlation Maxima')
    
    % Save the registration error vs. cross-corr. max.
    saveas(FigureHandle, ...
        fullfile(SaveDir, 'RegErrorVsCrossCorr.png'), 'png');
    saveas(FigureHandle, ...
        fullfile(SaveDir, 'RegErrorVsCrossCorr.fig'));
    close(FigureHandle);
end


end
./MATLAB/+smi/@Publish/plotXYRegError.m
function [PlotAxes, RegError] = plotXYRegError(PlotAxes, SMD)
%plotXYRegError plots the x,y registration error in a scatter plot
% This method will produce a parametric plot for the intra-dataset
% registration errors in x and y.
%
% INPUT:
%    SMD: Single Molecule Data structure containing the results from
%         a previous single molecule analysis.
%
% OUTPUT:
%    PlotAxes: Figure handle for the figure containing the parametric
%               plots.
%    RegError: A two column array with the first column being the
%              registration error in x, second column in y
%
% REQUIRES: 
%   Statistics and Machine Learning Toolbox (to use pdist() and 
%       squareform()). 
%
% CITATION:

% Created by:
%   David J. Schodt (Lidke Lab, 2018)


% Check inputs/set defaults.
if ~exist('SMD', 'var')
    error(['You must enter an SMR structure', ...
        'to plot the registration errors.'])
end
if (~exist('PlotAxes', 'var') || isempty(PlotAxes))
    PlotFigure = figure();
    PlotAxes = axes(PlotFigure);
end

% Extract relevant parameters from the SMD structure.
DriftX = SMD.DriftX;
DriftY = SMD.DriftY;
NDatasets = SMD.NDatasets;

% Compute the intra-dataset registration errors (the displacement of the
% starting point of the drift model from [0; 0]), defining the initial
% registration error to be [0; 0].
RegError = zeros(NDatasets, 2);
for ii = 2:NDatasets
    RegError(ii, :) = [DriftX(1, ii), DriftY(1, ii)];
end

% Create the scatter plot.
plot(PlotAxes, RegError(:, 1), RegError(:, 2), '.')
hold(PlotAxes, 'on')

% Plot a circle with diameter equal to the maximum pairwise distance
% between any two points, centered on the line connecting those two points.
PairwiseDistance = triu(squareform(pdist(RegError)));
[MaxDist, Index] = max(PairwiseDistance(:));
[Point1Row, Point2Row] = ind2sub(size(PairwiseDistance), Index);
MaxCircleCenter = (RegError(Point1Row, :)+RegError(Point2Row, :)) / 2;
Theta = linspace(0, 2*pi, 1000);
PwMaxCircle = (MaxDist/2)*[cos(Theta); sin(Theta)] + MaxCircleCenter.';
plot(PlotAxes, PwMaxCircle(1, :), PwMaxCircle(2, :), 'r:')

% Plot a circle centered at the center of mass of the errors with radius
% equal to the standard deviation of the distance of the errors from [0; 0]
RegErrorDistance = sqrt(sum(RegError.^2, 2));
RegErrorStd = std(RegErrorDistance);
CenterOfMass = (1/NDatasets) * sum(RegError);
StdCircle = RegErrorStd*[cos(Theta); sin(Theta)] + CenterOfMass.';
plot(PlotAxes, StdCircle(1, :), StdCircle(2, :), 'k-.')

% Modify the appearance of the plot to improve readability.
PlotAxes.XLim = [-1, 1] * sqrt(2) * MaxDist;
PlotAxes.YLim = [-1, 1] * sqrt(2) * MaxDist;
PlotAxes.PlotBoxAspectRatioMode = 'manual';
title(PlotAxes, 'X and Y Registration Errors')
xlabel(PlotAxes, 'X Registration Error (pixels)')
ylabel(PlotAxes, 'Y Registration Error (pixels)')
legend(PlotAxes, {'Registration Error', ...
    sprintf('max. pairwise dist. = %.3f pixels', MaxDist), ...
    sprintf('st. dev. = %.3f pixels', RegErrorStd)}, 'Location', 'best');


end
./MATLAB/+smi/@Publish/estimateLocalCoordShifts.m
function [SubPixelOffsets, SMDROIs, SMDStats] = ...
    estimateLocalCoordShifts(SMD1, SMD2, SubROISize)
%estimateLocalCoordShifts estimates local shifts between two SMDs.
%
% INPUT:
%   SMD1: Single Molecule Data structure containing localizations that will
%         be compared to SMD2 localizations.
%   SMD2: Single Molecule Data structure containing localizations that will
%         be compared to SMD1 localizations.
%   SubROISize: The size of local regions in which the shift will be
%               computed, ideally evenly divides [m, n].
%               (Pixels)(2x1 array)(Default = [SMD1.YSize, SMD1.XSize])
%   MaxOffset: Max offset for which the cross correlation is computed
%              between the two images. 
%              (Pixels)(Default = ceil(SubROISize / 4))
%
% OUTPUT:
%   SubPixelOffsets: The pixel offset of SMD2 relative to SMD1.
%                    (NROIsx2 array)
%   SMDROIs: ROIs of the regions corresponding to the pixel offsets.
%            (NROIsx4 array)([YStart, XStart, YEnd, XEnd])
%   SMDStats: Structure containing some stats about the sub-ROIs.
%
% REQUIRES: 
%   matlab-instrument-control, to use findStackOffset()
%
% CITATION:

% Created by:
%   David J. Schodt (Lidke Lab, 2021)


% Set defaults if needed.
DataSize = [SMD1.YSize, SMD1.XSize];
if (~exist('SubROISize', 'var') || isempty(SubROISize))
    SubROISize = DataSize.';
end

% Split the images up into the sub-ROIs.
[SubSMDs1, SMDROIs] = smi_helpers.subdivideSMD(SMD1, SubROISize);
SubSMDs2 = smi_helpers.subdivideSMD(SMD2, SubROISize);

% Loop through each ROI and compute the local shift.
NROIs = size(SMDROIs, 1);
SubPixelOffsets = NaN(NROIs, 2);
for nn = 1:NROIs
    % If both SMDs have localizations, estimate the shift.
    if ((numel(SubSMDs1(nn).X)>0) && (numel(SubSMDs1(nn).Y)>0))
        SubPixelOffsets(nn, :) = ...
            smi_core.DriftCorrection.regViaDC(SubSMDs1(nn), SubSMDs2(nn));
    end
end

% If needed, compute some imaging stats. which might be useful to return.
if (nargin > 2)
    SMDStats.NLoc1 = cellfun(@(X) numel(X), {SubSMDs1.X}).';
    SMDStats.NLoc2 = cellfun(@(X) numel(X), {SubSMDs2.X}).';
end


end
./MATLAB/+smi/@Publish/defineShiftMask.m
function [Mask] = defineShiftMask(LocalImShifts, ImageROIs, MaxShift, ImSize)
%generateShiftMask generates a mask from the array of shifts LocalImShifts.
%
% INPUT:
%   LocalImShifts: Array of shifts computed in estimateLocalImShifts().
%   ImageROIs: ROIs corresponding to LocalImShifts output by
%              estimateLocalImShifts().
%   MaxShift: Maximum shift allowed by output mask. 
%             (same units as LocalImShifts)
%   ImSize: Size of the output mask. (Default determined from
%           LocalImShifts).
%
% OUTPUT:
%   Mask: Logical array to be used to mask images. (ImSize logical array)
%
% CITATION:

% Created by:
%   David J. Schodt (Lidke Lab, 2022)


% Set defaults.
ImageROISize = max(ImageROIs(:, 3:4));
if (~exist('ImSize', 'var') || isempty(ImSize))
    ImSize = ImageROISize;
end
if (~exist('MaxShift', 'var') || isempty(MaxShift))
    MaxShift = inf;
end

% Generate the binary mask.
Mask = zeros(ImageROISize, 'logical');
LocalShiftMag = sqrt(sum(LocalImShifts.^2, 2));
for ii = 1:size(LocalImShifts, 1)
    Mask(ImageROIs(ii, 1):ImageROIs(ii, 3), ImageROIs(ii, 2):ImageROIs(ii, 4)) = ...
        (LocalShiftMag(ii) <= MaxShift);
end

% If needed, upsample the mask.
Mask = imresize(Mask, max(ImSize ./ ImageROISize));


end
./MATLAB/+smi/@Publish/estimateLocalImShifts.m
function [Shift, IntShift, ImageROIs, ImageStats] = ...
    estimateLocalImShifts(Image1, Image2, SubROISize, ...
    CorrParams, ShiftParams)
%estimateLocalImShifts estimates local shifts between two images.
%
% INPUT:
%   Image1: The stack to which Image2 is compared to, i.e. 
%           Stack1 is the reference stack. (mxn float array)
%   Image2: The stack for which the offset relative to Image1 
%           is to be determined. (mxn float array)
%   SubROISize: The size of local regions in which the shift will be
%               computed, ideally evenly divides [m, n].
%               (Pixels)(2x1 array)(Default = size(Image1))
%   CorrParams: Structure of parameters passed to smi_stat.findOffset().
%   ShiftParams: Structure of parameters passed to smi_stat.shiftImage()
%
% OUTPUT:
%   Shift: Sub-pixel offset of Image2 relative to Image1. (NROIsx2 array)
%   IntShift: Integer shift of Image2 relative to Image1. (NROIsx2 float)
%   ImageROIs: ROIs of the regions corresponding to the pixel offsets.
%              (NROIsx4 array)([YStart, XStart, YEnd, XEnd])
%   ImageStats: Structure containing some stats about the ImageROIs.
%
% CITATION:

% Created by:
%   David J. Schodt (Lidke Lab, 2021)


% Set defaults if needed.
ImageSize = size(Image1);
if (~exist('SubROISize', 'var') || isempty(SubROISize))
    SubROISize = ImageSize.';
end
if (~exist('CorrParams', 'var') || isempty(CorrParams))
    CorrParams = struct([]);
end
if (~exist('ShiftParams', 'var') || isempty(ShiftParams))
    ShiftParams = struct([]);
end

% Split the images up into the sub-ROIs.
[DividedImages1, ImageROIs] = ...
    smi_helpers.subdivideImage(Image1, SubROISize);
DividedImages2 = smi_helpers.subdivideImage(Image2, SubROISize);

% Loop through each ROI and compute the local shift.
NROIs = size(ImageROIs, 1);
Shift = zeros(NROIs, 2);
IntShift = zeros(NROIs, 2);
for nn = 1:NROIs
    [ShiftCurrent, IntShiftCurrent] = smi_stat.findOffsetIter(...
        DividedImages1{nn}, DividedImages2{nn}, [], [], ...
        CorrParams, ShiftParams);
    Shift(nn, :) = ShiftCurrent(1:2);
    IntShift(nn, :) = IntShiftCurrent(1:2);
end

% If needed, compute some imaging stats. which might be useful to return.
if (nargin > 3)
    ImageStats.Image1Sums = cellfun(@(Image) sum(Image(:)), DividedImages1);
    ImageStats.Image2Sums = cellfun(@(Image) sum(Image(:)), DividedImages2);
end


end
./MATLAB/+smi/@Publish/README.md
### +smi/@Publish

Publish contains methods useful for batch processing of SR data.
  This class contains a collection of analysis/visualization methods
  useful for batch-processing of super-resolution data, particularly
  for data with multiple labels stored in independent files (e.g.,
  sequential super-resolution of two labels on multiple cells).

NOTE: This class is designed around .h5 files containing raw data
      stored in directories separating distinct cells and labels,
      with the directory names following the scheme
      Cell*\Label*\Data*.h5

REQUIRES:
- MATLAB 2018a or later (for Publish.genAlignStats())
- Image Processing Toolbox
- Statistics and Machine Learning Toolbox
- Curve Fitting Toolbox

---

```
properties:
    % Structure of parameters (see smi_core.SingleMoleculeFitting)
    SMF

    % Directory containing the Cell*\Label*\Data*.h5 sub-directories.
    CoverslipDir

    % Base directory for saving (Default set in performFullAnalysis())
    SaveBaseDir

    % Log file for errors (Default set in performFullAnalysis())
    LogFilePath

    % Label(s) to be analyzed (Default = [], analyze all labels)
    LabelID = [];

    % Cell(s) to be analyzed (Default = [], analyze all cells)
    CellList = [];

    % Zoom factor for output SR images (Default = 20)
    SRImageZoom = 20;

    % Zoom factor for circle images (Default = 50)
    SRCircleImageZoom = 50;

    % Flag to indicate SR results should be generated (Default = true)
    GenerateSR = true;

    % Flag to generate various imaging stats (Default = true)
    GenerateImagingStats = true;

    % Flag to generate overlay info. between channels (Default = false)
    GenerateOverlayStats = false;

    % Flag to perform analysis on bleaching results (Default = false)
    AnalyzeBleaching = false;

    % Apply brightfield drift correction (Default = false)
    % NOTE: If SMF.DriftCorrection.On=true, brightfield DC is still
    %       applied just before the post-processing DC.
    UseBrightfieldDC = false

    % Max. brightfield shift used to define overlay masks (pixels)
    % NOTE: This is defined in terms of brightfield pixels, e.g., units
    %       of obj.SMF.Data.PixelSize.
    MaxBrightfieldShift = inf

    % Shift localizations based on brightfield results (Default = false)
    ShiftToReg = false;

    % Verbosity of the main analysis workflow. (Default = 1)
    Verbose = 1;

    % Structure containing several analysis results.
    ResultsStruct = struct([]);
```

---

methods:
- **[computeBFShifts](computeBFShifts.m)**:
  computes subROI shifts from brightfield data
- **[computeRegCorrection](computeRegCorrection.m)**:
  computes the registration corrections made
- **[defineShiftMask](defineShiftMask.m)**:
  generates a mask from the array of shifts LocalImShifts
- **[estimateLocalCoordShifts](estimateLocalCoordShifts.m)**:
  estimates local shifts between two SMDs
- **[estimateLocalImShifts](estimateLocalImShifts.m)**:
  estimates local shifts between two images
- **[genAlignMovies](genAlignMovies.m)**:
  generates movies related to brightfield registration
- **[genAlignResults](genAlignResults.m)**:
  produces figures/info related to brightfield registration
- **[genAlignStats](genAlignStats.m)**:
  generates interesting plots from AlignRegStruct
- **[genAlignXCorr](genAlignXCorr.m)**:
  generates xcorr curve data for AlignRegStruct
- **[genBFMask](genBFMask.m)**:
  masks overlays based on brightfield shifts
- **[genOverlayResults](genOverlayResults.m)**:
  generates some two-color overlay results
- **[genSROverlays](genSROverlays.m)**:
  generates various types of  SR overlay images
- **[makeOverlayPlots](makeOverlayPlots.m)**:
  makes interesting plots from two color overlays
- **[performFullAnalysis](performFullAnalysis.m)**:
  is the main run method for the smi.Publish class
- **[plotXYRegError](plotXYRegError.m)**:
  plots the x,y registration error in a scatter plot
- **[processCell](processCell.m)**:
  will process data corresponding to CellName
- **[processLabel](processLabel.m)**:
  processes the SR data for the specified label
- **[shiftToBestReg](shiftToBestReg.m)**:
  shifts coordinates based on best alignment results

./MATLAB/+smi/@Publish/genAlignMovies.m
function [ImagesStruct] = genAlignMovies(AlignRegData, SaveDir)
%genAlignMovies generates movies related to brightfield registration.
% This method will create movies which help to visualize the brightfield
% alignment procedure of an acquisition.  Two movies are produced by this
% method.  One is a movie showing overlay images of the in focus
% brightfieldimage reference and the brightfield image at the chosen focus
% after brightfield alignment, and the other contains the scaled difference
% images between the two previously mentioned images.
%
% INPUTS:
%   AlignRegData: Cell array containing the data structures for each
%                 dataset.
%   SaveDir: Directory associated with Dataset in which the analysis
%            results will be saved.
%
% OUTPUTS:
%   ImagesStruct: A structured array containing difference images and
%                 overlay images computed in this method.

% Created by:
%   David J. Schodt (Lidke Lab, 2018)


% Pre-allocate the ImagesStruct;
ImagesStruct = struct();

% Grab the reference image from the last data structure.
ReferenceImage = AlignRegData{end}.Image_Reference;

% Create a stack of the images taken after each registration step has
% completed (i.e. the final brightfield images taken just before proceeding
% with a fluorescence sequence).
NDatasets = numel(AlignRegData);
StackSize = [size(ReferenceImage), NDatasets];
CurrentImages = zeros(StackSize);
for ii = 1:NDatasets
    CurrentImages(:, :, ii) = AlignRegData{ii}.Image_Current;
end

% Prepare video writer objects and set display parameters.
islinux = isunix && ~ismac;
if islinux
   VideoObjectOverlays = VideoWriter(...
       fullfile(SaveDir, 'AlignRegOverlayMovie.avi'), ...
       'Motion JPEG AVI');
   VideoObjectDiffImages = VideoWriter(...
       fullfile(SaveDir, 'AlignRegDiffImageMovie.avi'), ...
       'Motion JPEG AVI');
else
   VideoObjectOverlays = VideoWriter(...
       fullfile(SaveDir, 'AlignRegOverlayMovie.mp4'), ...
       'mpeg-4');
   VideoObjectDiffImages = VideoWriter(...
       fullfile(SaveDir, 'AlignRegDiffImageMovie.mp4'), ...
       'mpeg-4');
end
VideoObjectOverlays.FrameRate = 1; % fps
VideoObjectDiffImages.FrameRate = 1;
VideoObjectOverlays.Quality = 100;
VideoObjectDiffImages.Quality = 100;
VideoObjectOverlays.open();
VideoObjectDiffImages.open();

% Create the movie of the brightfield overlay images after the
% registration corrections.
OverlayImages = zeros([StackSize(1:2), 3, StackSize(3)], 'uint8');
FigureHandle = figure();
PlotAxes = axes(FigureHandle);
for ii = 1:NDatasets
    ImageCurrentFrame = CurrentImages(:, :, ii);
    OverlayImages(:, :, :, ii) = imfuse(...
        ReferenceImage, ImageCurrentFrame, ...
        'falsecolor', 'Scaling', 'independent', ...
        'ColorChannels', [1, 2, 0]);
    imshow(OverlayImages(:, :, :, ii), [], 'Parent', PlotAxes);
    FrameNumDisplay = text(PlotAxes, 10, 10, num2str(ii));
    FrameNumDisplay.Color = [1, 1, 1];
    Frame = getframe(PlotAxes);
    VideoObjectOverlays.writeVideo(Frame);
end
VideoObjectOverlays.close()
cla(PlotAxes)

% Create the movie of the difference images (the difference between the
% scaled reference image and the scaled post correction image).
DiffImages = zeros(StackSize);
for ii = 1:NDatasets
    ImageCurrentFrame = CurrentImages(:, :, ii);
    DiffImages(:, :, ii) = imfuse(ReferenceImage, ImageCurrentFrame, ...
        'diff', 'Scaling', 'independent');
    imshow(DiffImages(:, :, ii), [], 'Parent', PlotAxes);
    FrameNumDisplay = text(PlotAxes, 10, 10, num2str(ii));
    FrameNumDisplay.Color = [1, 1, 1];
    Frame = getframe(PlotAxes);
    VideoObjectDiffImages.writeVideo(Frame);
end
VideoObjectDiffImages.close()
close(FigureHandle)

% Save the overlay and difference image arrays as fields in the
% ImagesStruct.
ImagesStruct.DiffImages = DiffImages;
ImagesStruct.OverlayImages = OverlayImages;


end

./MATLAB/+smi/@Publish/genBFMask.m
function [Mask, Shifts, ImageROIs] = ...
    genBFMask(FocusImageStruct, RefImage, MaxBrightfieldShift)
%genMaskedOverlays masks overlays based on brightfield shifts.
% This method loads brightfield images from the data files, computes shifts
% between those images, and then defines a mask based on those shifts.

% Created by:
%   David J. Schodt (Lidke Lab, 2022)


% Loop through the provided FocusImageStructs and generate the masks.
if (isstruct(FocusImageStruct) && ~isempty(RefImage))
    % In this usage, each focus image is compared to the reference (as
    % opposed to focus images from another label).
    if isinf(MaxBrightfieldShift)
        Mask = ones(size(RefImage), 'logical');
        Shifts = NaN;
        ImageROIs = [1, 1, size(RefImage, 1:2)];
        return
    end
    [Shifts, ~, ImageROIs] = smi.Publish.computeBFShifts(...
        FocusImageStruct, RefImage);

    % Define the brightfield mask.
    Mask = smi.Publish.defineShiftMask(median(Shifts, 2), ...
        ImageROIs, ...
        MaxBrightfieldShift);
elseif iscell(FocusImageStruct)
    % In this usage, 'FocusImageStructs' is actually a cell array of
    % structs corresponding to two labels which will be compared to one
    % another.
    ImSize = size(FocusImageStruct{end}(1).Data.PreSeqImages, 1:2);
    Mask = ones([ImSize, size(FocusImageStruct, 1)], 'logical');
    Shifts = [];
    if isinf(MaxBrightfieldShift)
        ImageROIs = [1, 1, size(RefImage, 1:2)]; % define ImageROIs (MJW)
        return
    end
    for ii = 1:size(FocusImageStruct, 1)
        % Compute the local brightfield shifts from label 1 to 2.
        if (isempty(FocusImageStruct{ii, 1}) ...
                || isempty(FocusImageStruct{ii, 2}))
            continue
        end
        [LocalShiftMag, ~, ImageROIs] = smi.Publish.computeBFShifts(...
            FocusImageStruct{ii, 1}, FocusImageStruct{ii, 2});
        Shifts = cat(3, Shifts, LocalShiftMag);
        LocalShiftMagMedian = median(LocalShiftMag, 2);

        % Define the brightfield mask.
        Mask(:, :, ii) = smi.Publish.defineShiftMask(LocalShiftMagMedian, ...
            ImageROIs, ...
            MaxBrightfieldShift);
    end
end


end

./MATLAB/+smi/@Publish/genOverlayResults.m
function [] = genOverlayResults(obj)
%genOverlayResults generates some two-color overlay results.
% This method will generate several results pertaining to two-color
% overlays of super-resolution data.


% Generate a list of the available overlay data.
ResultsStructDir = fullfile(obj.SaveBaseDir, 'ResultsStructs');
Label1Results = dir(fullfile(ResultsStructDir, '*Label_01*'));
Label1Paths = fullfile(ResultsStructDir, ...
    {Label1Results(~[Label1Results.isdir]).name});
NOverlays = numel(Label1Paths);
if (NOverlays == 0)
    return
end

% Loop through all overlays images and compute the shift between labels.
ImageShift = zeros(NOverlays, 2);
ImageShiftLocal = cell(NOverlays, 3);
AffineTransforms = cell(NOverlays, 1);
SubROIDivisor = 10;
for nn = 1:NOverlays
    % Display a status message in the command line.
    if obj.Verbose
        fprintf(['Publish.performFullAnalysis(): ', ...
            'Computing shift for overlay %i of %i...\n'], ...
            nn, NOverlays);
    end
    
    % Load the results structs into the workspace.
    load(Label1Paths{nn}, 'SMD')
    SMD1 = SMD;
    Label2Path = strrep(Label1Paths{nn}, 'Label_01', 'Label_02');
    if exist(Label2Path, 'file')
        load(Label2Path, 'SMD')
        SMD2 = SMD;
    else
        continue
    end
    
    % Estimate the global shift between the labels.
    ImageShift(nn, :) = smi_core.DriftCorrection.regViaDC(SMD1, SMD2);
    
    % Estimate the local shift bewteen sub-ROIs of the labels.
    [ImageShiftLocal{nn, 1}, ...
        ImageShiftLocal{nn, 2}, ...
        ImageShiftLocal{nn, 3}] = ...
        obj.estimateLocalCoordShifts(SMD1, SMD2, ...
        [1, 1] * SMD1.XSize / SubROIDivisor);
    
    % Compute an affine transform between the coordinates.
    AffineTransforms{nn} = ...
        smi_stat.findCoordAffine([SMD1.X, SMD1.Y], [SMD2.X, SMD2.Y], 50);
end

% Concatenate the max. correlation coefficients from the image in each 
% overlay image (keeping the labels separate) so that we have just one 
% array containing the max. correlation coefficients from all of the
% overlay images produced.  Repeat for the registration errors.
MakeShiftVsCorrPlots = ...
    all(isfield(obj.ResultsStruct, {'RegError', 'MaxCorr'}));
if MakeShiftVsCorrPlots
    ConcatenatedRegError = [{obj.ResultsStruct(:, 1).RegError}.',  ...
        {obj.ResultsStruct(:, 2).RegError}.'];
    ConcatenatedMaxCorr = [{obj.ResultsStruct(:, 1).MaxCorr}.', ...
        {obj.ResultsStruct(:, 2).MaxCorr}.'];
else
    ConcatenatedRegError = [];
    ConcatenatedMaxCorr = [];
end

% Save some of the overlay results.
OverlayInfoStruct.ImageShift = ImageShift;
OverlayInfoStruct.ImageShiftLocal = ImageShiftLocal;
OverlayInfoStruct.RegError = ConcatenatedRegError;
OverlayInfoStruct.MaxCorr = ConcatenatedMaxCorr;
OverlayInfoStruct.PixelSize = obj.SMF.Data.PixelSize;
save(fullfile(obj.SaveBaseDir, 'OverlayInfoStruct.mat'), ...
    'OverlayInfoStruct');
save(fullfile(obj.SaveBaseDir, 'AffineTransforms.mat'), ...
    'AffineTransforms', 'Label1Paths')

% Generate the overlay plots across all cells.
if MakeShiftVsCorrPlots
    obj.makeOverlayPlots(ImageShift, ...
        ConcatenatedRegError, ...
        ConcatenatedMaxCorr, ...
        obj.SMF.Data.PixelSize, ...
        obj.SaveBaseDir)
end


end
./MATLAB/+smi/@Publish/shiftToBestReg.m
function [SMD, BestRegInd] = shiftToBestReg(SMD, RefImage, FocusImages)
%shiftToBestReg shifts coordinates based on best alignment results.
% This method shifts the coordinates SMD.X and SMD.Y based on the "best"
% results in brightfield registration as determined from
% AlignResultsStruct.
%
% INPUTS:
%   SMD: Single Molecule Data structure of localizations.
%   RefImage: Reference image at the focus. (YxX)
%   FocusImages: Cell array of the NDatasets YxX images at the focal plane
%                taken before each SR sequence.  A median image is 
%                generated from each cell array entry to allow each entry
%                to be a stack of images. (NDatasetsx1 cell array)
%
% OUTPUTS:
%   SMD: Input SMD with SMD.X and SMD.Y shifted based on info. in
%        AlignResultsStruct.
%   BestRegInd: Dataset index selected as the "best" registration.

% Created by:
%   David J. Schodt (Lidke Lab 2021)


% Determine which dataset had the best channel registration (i.e., minimum
% XY shift in the focus image).
Shift = zeros(2, numel(FocusImages));
Params.SuppressWarnings = true;
for ii = 1:numel(FocusImages)
    CurrentShift = smi_stat.findOffsetIter(...
        median(FocusImages{ii}, 3), RefImage, [], [], Params);
    Shift(:, ii) = CurrentShift(1:2);
end
[~, BestRegInd] = min(sum(Shift.^2, 1));
SMD.Shift = Shift;

% Make the drift correction reference to dataset BestRegInd.
if ~(isempty(SMD.DriftX) || isempty(SMD.DriftY))
    SMD = smi_core.DriftCorrection.changeInterRef(SMD, BestRegInd);
end

% Shift each dataset based on the shift estimated from brightfield.
for nn = 1:SMD.NDatasets
    CurrentDSBool = (SMD.DatasetNum == nn);
    SMD.Y(CurrentDSBool) = SMD.Y(CurrentDSBool) - Shift(1, nn);
    SMD.X(CurrentDSBool) = SMD.X(CurrentDSBool) - Shift(2, nn);
end


end
./MATLAB/+smi/@Publish/genAlignStats.m
function [StatsStruct] = genAlignStats(AlignRegStruct, SMD, SaveDir)
%genAlignStats generates interesting plots from AlignRegStruct.
% This method will create various plot(s) and analysis data related to the
% brightfield registration process of the acquistion.  A plot will be
% created to show information/statistics derived from the difference image
% between the brightfield image reference and the brightfield image taken
% at the chosen focus during the acquisition. This plot will be saved in
% SaveDir.  Another plot will be created to show the structural similarity
% between the full scale histogram stretched reference image and current
% image for each sequence.  This plot will be saved in SaveDir.
%
% INPUTS:
%   AlignRegStruct: Structured array containing the brightfield
%                   registration data structures for each dataset.
%   SMD: Single Molecule Data structure containing data related to the
%        SR analysis.
%   SaveDir: Directory associated with Dataset in which the analysis
%            results will be saved.
%
% OUTPUTS:
%   StatsStruct: A structured array which will contain the computed
%                statistics/interesting metrics for the input
%                AlignRegStruct.
%
% REQUIRES:
%   MATLAB 2018a or later (to use property 'WindowState' of a figure)
%   MATLAB Image Processing Toolbox 2014a or later (to use ssim())

% Created by:
%   David J. Schodt (Lidke Lab, 2018)


% Pre-allocate our StatsStruct structured array.
StatsStruct = struct();

% Determine the number of sequences contained in this dataset.
NSequences = numel(AlignRegStruct);

% Grab the reference image from the data structure (the index shouldn't
% matter, each dataset should have to same reference image saved).
ReferenceImage = AlignRegStruct(1).Data.Image_Reference;

% Perform a full scale histogram stretch on the reference image scale it to
% [0, 1].
ReferenceImage = (ReferenceImage-min(ReferenceImage(:))) ...
    / (max(ReferenceImage(:))-min(ReferenceImage(:)));

% Create the brightfield difference image for each dataset and plot the
% histogram of it's absolute value.
DiffImages = zeros([size(ReferenceImage), NSequences]);
for ii = 1:NSequences
    % Grab the current image for the ii-th sequence.
    CurrentImage = AlignRegStruct(ii).Data.Image_Current;
    
    % Perform a full scale histogram stretch on the current image.
    CurrentImage = (CurrentImage-min(CurrentImage(:))) ...
        / (max(CurrentImage(:))-min(CurrentImage(:)));
    
    % Create the difference images.
    DiffImages(:, :, ii) = (CurrentImage./max(CurrentImage(:))) ...
        - (ReferenceImage./max(ReferenceImage(:)));
end
MinAbsDiff = min(abs(DiffImages(:)));
MaxAbsDiff = max(abs(DiffImages(:)));
PlotFigure = figure();
PlotFigure.WindowState = 'maximized';
for ii = 1:NSequences
    % Create a subplot in the figure for the current histogram.
    PlotAxes = subplot(NSequences, 1, ii, 'Parent', PlotFigure);
    
    % Plot the histogram of pixel values in the difference image.
    DiffImage = DiffImages(:, :, ii);
    StackedDiffImage = DiffImage(:);
    histogram(PlotAxes, abs(StackedDiffImage), 200);
    hold(PlotAxes, 'on');
    
    % Plot a mean line and a standard deviation line of the histogram.
    plot(PlotAxes, [mean(abs(StackedDiffImage)), ...
        mean(abs(StackedDiffImage))], ...
        PlotAxes.YLim, 'r:', 'LineWidth', 2)
    
    % Modify the appearance of the plot.
    PlotAxes.XLim = [MinAbsDiff, MaxAbsDiff];
    legend(PlotAxes, {sprintf('Sequence %i', ii), ...
        sprintf('Mean = %.4f', mean(abs(StackedDiffImage)))}, ...
        'Location', 'best')
    if (ii == 1)
        title(PlotAxes, ...
            ['Histogram of Absolute Pixelwise Difference of ', ...
            'FSHS Images'], 'FontSize', 15)
    end
    if (ii == ceil(NSequences/2))
        ylabel(PlotAxes, 'Counts', 'FontSize', 15)
    end
    if (ii == NSequences)
        xlabel(PlotAxes, 'Pixelwise Difference', 'FontSize', 15)
    end
end

% Save the plot in the SaveDir and then close the figure.
saveas(PlotFigure, fullfile(SaveDir, 'DiffImageHistogram.png'), 'png');
close(PlotFigure);

% Compute the structural similarity between the full scale histogram
% stretched reference and current images.
SSIM = zeros(NSequences, 1);
for ii = 1:NSequences
    % Grab the current image for the ii-th sequence.
    CurrentImage = AlignRegStruct(ii).Data.Image_Current;
    
    % Perform a full scale histogram stretch on the current image.
    CurrentImage = (CurrentImage-min(CurrentImage(:))) ...
        / (max(CurrentImage(:))-min(CurrentImage(:)));
    
    % Compute the SSIM.
    SSIM(ii) = ssim(CurrentImage, ReferenceImage);
end

% Store the SSIM in the StatsStruct.
StatsStruct.SSIM = SSIM;

% Plot the SSIM and save that plot in SaveDir.
PlotFigure = figure();
PlotAxes = axes(PlotFigure);
hold(PlotAxes, 'on')
plot(PlotAxes, 1:NSequences, SSIM, 'x')
plot(PlotAxes, PlotAxes.XLim, ones(2, 1) * mean(SSIM), '--')
legend(PlotAxes, {'SSIM', sprintf('Mean SSIM = %.4f', mean(SSIM))}, ...
    'Location', 'best')
xlabel(PlotAxes, 'Sequence Number')
ylabel(PlotAxes, 'SSIM')
title(PlotAxes, ...
    'Structural Similarity between Reference Image and Current Image')
saveas(PlotFigure, fullfile(SaveDir, 'SSIM.png'), 'png');
close(PlotFigure);

% Compute the 'registration error' as found from the residual drift that is
% corrected during the drift correction process (if the input SMD wasn't
% empty or SMD.DriftX wasn't empty).
if ~isempty(SMD) && isfield(SMD, 'DriftX') && ~isempty(SMD.DriftX)
    PlotFigure = figure();
    PlotAxes = axes(PlotFigure);
    [~, RegError] = smi.Publish.plotXYRegError(PlotAxes, SMD);
    saveas(PlotFigure, fullfile(SaveDir, 'XYRegError.png'), 'png');
    close(PlotFigure)
    
    % Store the registration error array in the StatsStruct.
    StatsStruct.RegError = RegError;
else
    StatsStruct.RegError = [];
end


end

./MATLAB/+smi/@Publish/genAlignResults.m
function [AlignResultsStruct] = genAlignResults(obj, FilePath, SaveDir)
%genAlignResults produces figures/info related to brightfield registration.
% Create figures associated with the initial brightfield registration of a
% cell process on the sequential microscope.
%
% INPUTS:
%   FilePath: Full file path to the location of the .h5 file containing the
%             raw data.
%   SaveDir: Directory associated with Dataset in which the analysis
%            results will be saved.
%
% OUTPUTS:
%   AlignResultsStruct: A structured array containing the alignment results
%                       computed in this method.
%
% REQUIRES:
%   MATLAB Image Processing Toolbox 2014a or later.

% Created by:
%   David J. Schodt (Lidke Lab, 2018)


% Pre-allocate the AlignResultsStruct structured array.
AlignResultsStruct = struct();

% Grab the alignment registration structure from the dataset.
AlignReg = smi_core.LoadData.readH5File(FilePath, 'AlignReg');

% Load the SMR structure for this dataset.
FileNameStruct = dir(fullfile(SaveDir, '*Results.mat'));
if (~isempty(FileNameStruct) ...
        && isfile(fullfile(FileNameStruct.folder, FileNameStruct.name)))
    load(fullfile(SaveDir, FileNameStruct.name), 'SMD');
else
    SMD = struct([]);
end

% If the AlignReg structure is empty, do not proceed.
if isempty(AlignReg)
    return
end

% If needed, make the requested directory.
if ~isfolder(SaveDir)
    mkdir(SaveDir)
end

% Grab the attributes and data from the AlignReg structure, assuming the
% attributes of the first dataset the same for all datasets.
AlignRegData = {AlignReg.Data};

% Grab the error signal history from the last dataset.
ErrorSignalHistory = AlignRegData{end}.ErrorSignalHistory;

% Plot the cumulative error signal during the acquisition, skipping the
% first correction since it is expected to be quite large.
FigureHandle = figure();
PlotAxes = axes(FigureHandle);
NCorrections = size(ErrorSignalHistory, 1);
XPlotArray = (2:NCorrections).';
ErrorSignalSum = cumsum(ErrorSignalHistory(2:end, :), 1);
stairs(PlotAxes, XPlotArray, ErrorSignalSum(:, 1)*1e3)
hold(PlotAxes, 'on');
axis(PlotAxes, 'tight');
stairs(PlotAxes, XPlotArray, ErrorSignalSum(:, 2)*1e3)
stairs(PlotAxes, XPlotArray, ErrorSignalSum(:, 3)*1e3)
plot(PlotAxes, PlotAxes.XLim, [0, 0], 'k:')
title(PlotAxes, 'Cumulative correction')
xlabel(PlotAxes, 'Correction Number')
ylabel(PlotAxes, 'Cumulative error Signal (nm)')
legend(PlotAxes, {'X', 'Y', 'Z', '0 nm reference'}, 'Location', 'best')
saveas(FigureHandle, fullfile(SaveDir, 'AlignRegHistorySum.png'), 'png');
close(FigureHandle);

% Plot the cumulative correction for each dataset.
FigureHandle = figure();
PlotAxes = axes(FigureHandle);
NDatasets = numel(AlignRegData);
Correction = NaN(NDatasets, 3);
Correction(1, :) = sum(AlignRegData{1}.ErrorSignalHistory, 1);
line(PlotAxes, 1, Correction(1, 1)*1e3, ...
    'Marker', 'x', 'Color', [0 0.4470 0.7410], 'LineWidth', 2)
line(PlotAxes, 1, Correction(1, 2)*1e3, ...
    'Marker', 'o', 'Color', [0.8500 0.3250 0.0980], 'LineWidth', 2)
line(PlotAxes, 1, Correction(1, 3)*1e3, ...
    'Marker', '*', 'Color', [0.9290 0.6940 0.1250], 'LineWidth', 2)
for ii = 2:NDatasets
    Correction(ii, :) = sum(AlignRegData{ii}.ErrorSignalHistory, 1) ...
        - sum(Correction(1:(ii-1), :), 1);
    line(PlotAxes, ii, Correction(ii, 1)*1e3, ...
        'Marker', 'x', 'Color', [0 0.4470 0.7410], 'LineWidth', 2)
    line(PlotAxes, ii, Correction(ii, 2)*1e3, ...
        'Marker', '*', 'Color', [0.8500 0.3250 0.0980], 'LineWidth', 2)
    line(PlotAxes, ii, Correction(ii, 3)*1e3, ...
        'Marker', 'o', 'Color', [0.9290 0.6940 0.1250], 'LineWidth', 2)
end
DummyLines(1) = line(PlotAxes, NaN, NaN, ...
    'LineStyle', 'none', 'Marker', 'x', 'Color', [0 0.4470 0.7410]);
DummyLines(2) = line(PlotAxes, NaN, NaN, ...
    'LineStyle', 'none', 'Marker', '*', 'Color', [0.8500 0.3250 0.0980]);
DummyLines(3) = line(PlotAxes, NaN, NaN, ...
    'LineStyle', 'none', 'Marker', 'o', 'Color', [0.9290 0.6940 0.1250]);
title(PlotAxes, 'Total correction per dataset')
xlabel(PlotAxes, 'Dataset number')
ylabel(PlotAxes, 'Error Signal (nm)')
legend(PlotAxes, DummyLines, {'X', 'Y', 'Z'}, ...
    'Location', 'best')
saveas(FigureHandle, fullfile(SaveDir, 'AlignRegErrorPerDataset.png'), 'png');
close(FigureHandle);

% Plot the error signal during the acquisition, skipping the first
% correction since it is expected to be quite large.
FigureHandle = figure();
PlotAxes = axes(FigureHandle);
NCorrections = size(ErrorSignalHistory, 1);
XPlotArray = (2:NCorrections).';
ErrorSignalPlotArray = ErrorSignalHistory(2:end, :);
plot(PlotAxes, XPlotArray, ErrorSignalPlotArray(:, 1)*1e3)
hold(PlotAxes, 'on');
axis(PlotAxes, 'tight');
plot(PlotAxes, XPlotArray, ErrorSignalPlotArray(:, 2)*1e3)
plot(PlotAxes, XPlotArray, ErrorSignalPlotArray(:, 3)*1e3)
plot(PlotAxes, PlotAxes.XLim, [0, 0], 'k:')
title(PlotAxes, 'Correction history')
xlabel(PlotAxes, 'Correction Number')
ylabel(PlotAxes, 'Error Signal (nm)')
legend(PlotAxes, {'X', 'Y', 'Z', '0 nm reference'}, 'Location', 'best')
saveas(FigureHandle, fullfile(SaveDir, 'AlignRegErrorSignal.png'), 'png');
close(FigureHandle);

% Create interesting movies from the AlignReg data.
[ImagesStruct] = obj.genAlignMovies(AlignRegData, SaveDir);

% Create plots about statistics/information that is derived from the
% alignment result images.
[StatsStruct] = obj.genAlignStats(AlignReg, SMD, SaveDir);

% Create interesting plots from the AlignReg data related to the
% cross-correlation process.
[XCorrStruct] = obj.genAlignXCorr(AlignReg, SaveDir);

% Populate the AlignResultsStruct.
AlignResultsStruct.DiffImages = ImagesStruct.DiffImages;
AlignResultsStruct.OverlayImages = ImagesStruct.OverlayImages;
AlignResultsStruct.SSIM = StatsStruct.SSIM;
AlignResultsStruct.RegError = StatsStruct.RegError;
AlignResultsStruct.MaxCorr = XCorrStruct.MaxCorr;
AlignResultsStruct.MaxCorrFit = XCorrStruct.MaxCorrFit;
AlignResultsStruct.OffsetFitSuccess = XCorrStruct.OffsetFitSuccess;
AlignResultsStruct.MaxIterReached = XCorrStruct.MaxIterReached;
AlignResultsStruct.AlignReg = AlignReg;


end
./MATLAB/+smi/@Publish/computeRegCorrection.m
function [RegCorrection] = computeRegCorrection(SMF)
%computeRegCorrection computes the registration corrections made.
% This method loads the channel registration results in the raw data file
% specified in 'SMF.Data' and computes the total registration correction
% made per dataset.
%
% INPUTS:
%   FilePath: Full filepath to the raw data .h5 file.
%
% OUTPUTS:
%   RegCorrection: Registration correction made per dataset.
%                  NOTE: This is saved in units of micrometers in the raw
%                        data file.  It is converted to pixels using the
%                        value stored in SMF.Data.PixelSize.
%                  (Pixels)(NDatasetsx1)

% Created by:
%   David J. Schodt (Lidke Lab 2021)


% Load the registration results.
AlignReg = smi_core.LoadData.readH5File(...
    fullfile(SMF.Data.FileDir, SMF.Data.FileName{1}), ...
    'AlignReg');

% Compute the total correction made before each dataset.
RegCorrection = NaN(numel(AlignReg), 3);
RegCorrection(1, :) = sum(AlignReg(1).Data.ErrorSignalHistory, 1);
for ii = 2:numel(AlignReg)
    RegCorrection(ii, :) = sum(AlignReg(ii).Data.ErrorSignalHistory, 1) ...
        - sum(RegCorrection(1:(ii-1), :), 1);
end
RegCorrection = RegCorrection / SMF.Data.PixelSize;


end
./MATLAB/+smi/@Publish/genAlignXCorr.m
function [XCorrStruct] = genAlignXCorr(AlignRegStruct, SaveDir)
%genAlignXCorr generates xcorr curve data for AlignRegStruct.
% This method will create various plot(s) and analysis data related to the
% brightfield registration process of the acquistion.  A plot will be
% created containing information about the cross-correlation process used
% to correct for sample drift during brightfield registration.  This plot
% will be saved in the SaveDir.
%
% INPUTS:
%   AlignRegStruct: Structured array containing the brightfield
%                   registration data structures for each dataset.
%   SaveDir: Directory associated with Dataset in which the analysis
%            results will be saved.
%
% OUTPUTS:
%   XCorrStruct: Structured array containing the cross-correlation
%                information computed in this method.

% Created by:
%   David J. Schodt (Lidke Lab, 2018)


% Pre-allocate the XCorrStruct structured array.
XCorrStruct = struct();

% Determine the number of sequences contained in this dataset.
NSequences = numel(AlignRegStruct);

% Grab the reference stack from the first dataset in the AlignRegStruct
% structure (it doesn't have to be from the first dataset, they should all
% contain the same reference stack).
ReferenceStack = AlignRegStruct(1).Data.ReferenceStack;

% Loop through each dataset and grab the stack taken directly before the
% dataset was collected.
XCorrDirName = fullfile(SaveDir, 'XCorrPlots');
if ~isfolder(XCorrDirName)
    mkdir(XCorrDirName);
end
MaxCorr = zeros(numel(AlignRegStruct), 1); % pre-allocate
MaxCorrFit = zeros(numel(AlignRegStruct), 3); % pre-allocate
OffsetFitSuccess = zeros(NSequences, 1, 'logical'); % pre-allocate
MaxIterReached  = zeros(NSequences, 1, 'logical'); % pre-allocate
for ii = 1:NSequences
    % Determine if the last round of registration was succesful (to
    % emphasize on the plot which points might be suspicious/unreliable).
    OffsetFitSuccess(ii) = all(...
        AlignRegStruct(ii).Data.OffsetFitSuccess);
    MaxIterReached(ii) = AlignRegStruct(ii).Data.MaxIterReached;
    
    % Grab the current stack from the ii-th dataset.
    CurrentStack = AlignRegStruct(ii).Data.CurrentStack;
    
    % Grab some misc. parameters needed from the AlignRegStruct.
    % NOTE: these might change from one dataset to the next, so we need
    %       this inside the for loop.
    ZStackMaxDev = AlignRegStruct(ii).Attributes.ZStack_MaxDev;
    ZStackStep = AlignRegStruct(ii).Attributes.ZStack_Step;
    IsInitialRegistration = ...
        AlignRegStruct(ii).Attributes.IsInitialRegistration;
    
    % Define the indices of the ReferenceStack which correspond to the
    % CurrentStack (CurrentStack might be smaller than ReferenceStack, but
    % they share a center image along the z-direction of the stack).
    FocalInd = 1 + ZStackMaxDev/ZStackStep;
    StackSteps = ZStackMaxDev/ZStackStep;
    ZStackRefInds = (FocalInd-StackSteps):(FocalInd+StackSteps);
    
    % Isolate the portion of the ReferenceStack that we'll want to compare
    % our CurrentStack to.
    if IsInitialRegistration
        % If IsInitialRegistration flag was set, the CurrentStack is
        % already the same size as the ReferenceStack so we don't need to
        % isolate the central portion.
        ReferenceSubStack = ReferenceStack;
    else
        ReferenceSubStack = ReferenceStack(:, :, ZStackRefInds);
    end
    
    % Re-compute the scaled cross-correlations between the two stacks.
    CorrParams.PlotFlag = true;
    CorrParams.SuppressWarnings = true;
    NIter = 3;
    [~, ~, CorrData] = smi_stat.findOffsetIter(...
        ReferenceSubStack, CurrentStack, NIter, [], CorrParams);
    
    % Generate the x, y, z cross-correlation fitting plots and save them.
    FigHandle = findobj('Tag', 'CorrWindow');
    saveas(FigHandle, ...
        fullfile(XCorrDirName, sprintf('XCorrSequence%i', ii)), 'png');
    saveas(FigHandle, ...
        fullfile(XCorrDirName, sprintf('XCorrSequence%i', ii)), 'fig');
    close(FigHandle);
    
    % Determine the maximum value of the scaled cross-correlation between
    % the two stacks.
    MaxCorr(ii) = max(CorrData.XCorr3D(:));
    MaxCorrFit(ii, :) = [max(CorrData.XFitAtPeak), ...
        max(CorrData.YFitAtPeak), ...
        max(CorrData.ZFitAtPeak)];
end

% Save the above computed cross-correlation information in the
% XCorrStruct.
XCorrStruct.MaxCorr = MaxCorr;
XCorrStruct.MaxCorrFit = MaxCorrFit;
XCorrStruct.OffsetFitSuccess = OffsetFitSuccess;
XCorrStruct.MaxIterReached = MaxIterReached;

% Determine which sequences did not have a succesful registration and
% create an array of their max-correlations/fits.
% NOTE: I've added the NaN points to ensure something is always in the
%       plot, which will ensure we don't get legend() warnings (NaN's don't
%       actually show up in the plot, but are still given handles visible
%       to legend()).
SequenceArray = (1:NSequences).';
SequenceArrayUnsuccessfulFit = [NaN; SequenceArray(~OffsetFitSuccess)];
SequenceArrayMaxIterReached = [NaN; SequenceArray(MaxIterReached)];
MaxCorrUnsuccessfulFit = [NaN; MaxCorr(~OffsetFitSuccess)];
MaxCorrMaxIterReached = [NaN; MaxCorr(MaxIterReached)];

% Plot the maximum correlation coefficients found throughout the
% acquisition.
FigureHandle = figure();
PlotAxes = subplot(2, 1, 1, 'Parent', FigureHandle);
plot(PlotAxes, SequenceArray, MaxCorr, 'x')
hold(PlotAxes, 'on');
plot(PlotAxes, [1, NSequences], ones(2, 1) * mean(MaxCorr), ':')
plot(PlotAxes, SequenceArrayUnsuccessfulFit, MaxCorrUnsuccessfulFit, ...
    'o', 'MarkerSize', 10, 'LineWidth', 2)
plot(PlotAxes, SequenceArrayMaxIterReached, MaxCorrMaxIterReached, ...
    's', 'MarkerSize', 10, 'LineWidth', 2)
if (min(MaxCorr) ~= max(MaxCorr))
    % Change the YTicks displayed on the plot, unless the min and max are
    % the same value.
    PlotAxes.YTick = [min(MaxCorr), ...
        (max(MaxCorr)+min(MaxCorr)) / 2, ...
        max(MaxCorr)];
end
legend(PlotAxes, ...
    {'Corr. Coeff.', sprintf('Mean = %.4f', mean(MaxCorr)), ...
    'Failed Registration Fit', 'Max. Registration Iter. Reached'}, ...
    'Location', 'best')
xlabel(PlotAxes, 'Sequence Number')
ylabel(PlotAxes, 'Max. Corr.')

% Plot the maximum values of the X, Y, and Z line fits through the peak of
% the cross-correlation volume.
PlotAxes = subplot(2, 1, 2, 'Parent', FigureHandle);
plot(PlotAxes, SequenceArray, MaxCorrFit(:, 1), 'x')
hold(PlotAxes, 'on');
plot(PlotAxes, SequenceArray, MaxCorrFit(:, 2), 'x')
plot(PlotAxes, SequenceArray, MaxCorrFit(:, 3), 'x')
PlotAxes.YTick = [min(MaxCorrFit(:)), ...
    (max(MaxCorrFit(:))+min(MaxCorrFit(:))) / 2, ...
    max(MaxCorrFit(:))];
legend(PlotAxes, {'X Fit', 'Y Fit', 'Z Fit'}, 'Location', 'best');
xlabel(PlotAxes, 'Sequence Number')
ylabel(PlotAxes, 'Max. Corr. Fit')

% Save the plot in the SaveDir and then close the figure.
saveas(FigureHandle, fullfile(SaveDir, 'AlignRegXCorrMaxima.png'), 'png');
close(FigureHandle);


end
./MATLAB/+smi/@Publish/processCell.m
function processCell(obj, CellName)
%processCell will process data corresponding to CellName.
% This method will find the sub-directories for the cell CellName, which
% themselves contain the data for each label of the acquisition, and
% analyze that data.
%
% INPUTS:
%   CellName: Char. array/string of the Cell* directory (i.e., the distinct
%             Cell* names in the directory structure
%             *\Cell*\Label*\Data*.h5)

% Created by:
%   David J. Schodt (Lidke Lab 2021)


% Determine the names of the sub-directories of interest within
% CellName.  These correspond to single labels imaged during the
% super-resolution experiment.
LabelNames = smi_helpers.getDirectoryNames(...
    fullfile(obj.CoverslipDir, CellName), 'Label*');
NLabels = numel(LabelNames);
if (obj.Verbose > 1)
    fprintf('\tPublish.processCell(): %i label directories found:\n', ...
        NLabels)
    for ii = 1:NLabels
        fprintf('\t\t%s\n', LabelNames{ii})
    end
end

% Loop through each of the label directories and process the data.  If the
% processing fails on a given label ii, proceed with the next label anyways
% (these results might still be useful).
obj.SMLM = smi.SMLM(copy(obj.SMF));
obj.SMLM.Verbose = obj.Verbose;
obj.SMLM.SRImageZoom = obj.SRImageZoom;
obj.SMLM.SRCircImZoom = obj.SRCircleImageZoom;
for ii = 1:NLabels
    % If LabelID was specified, skip all labels except those which exist in
    % LabelID.  However, if obj.LabelID is empty, then we wish to analyze
    % all LabelID's available.
    if ~(ismember(ii, obj.LabelID) || isempty(obj.LabelID))
        continue
    end

    % Attempt to process the data for label ii.
    try
        obj.processLabel(CellName, LabelNames{ii});
    catch MException
        if obj.Verbose
            warning(['Publish.processCell(): ', ...
                'Processing failed for %s\n%s, %s'], ...
                fullfile(CellName, LabelNames{ii}), ...
                MException.identifier, MException.message)
        end

        % Store the error information in the log file.
        obj.ErrorLog = [obj.ErrorLog; ...
            {CellName, LabelNames{ii}, MException}];
        ErrorLog = obj.ErrorLog;
        save(obj.LogFilePath, 'ErrorLog', '-append')
    end
end

% If all labels for this cell were processed successfully, create an
% overlay image of the multiple labels, storing the overlay in the top
% level directory for easy access.
if (obj.GenerateSR && (NLabels>1))
    % Prepare overlay masks.
    CellNumber = regexp(CellName, '\d*', 'match');
    CellNumber = str2double(CellNumber{1});
    [Mask, Shifts, ImageROIs] = ...
        obj.genBFMask(obj.FocusImageStructs(CellNumber, :), [], ...
        obj.MaxBrightfieldShift);
    MaskName = sprintf('%inm', ...
        round(obj.MaxBrightfieldShift * obj.SMF.Data.PixelSize * 1e3));
    if (~isinf(obj.MaxBrightfieldShift) && (obj.MaxBrightfieldShift>0))
        save(fullfile(obj.SaveBaseDir, ...
            sprintf('%s_%s_Mask.mat', CellName, MaskName)), ...
            'Mask', 'Shifts', 'ImageROIs')
    end

    % Prepare the overlays.
    try
        obj.genSROverlays(...
            fullfile(obj.SaveBaseDir, CellName), ...
            obj.SaveBaseDir, obj.SMF.Data.AnalysisID, ...
            Mask, MaskName);
    catch MException
        if obj.Verbose
            warning(['Publish.processCell(): Overlay image ', ...
                'generation failed for %s\n%s, %s'], ...
                CellName, MException.identifier, MException.message)
        end

        % Store the error information in the log file.
        obj.ErrorLog = [obj.ErrorLog; ...
            {CellName, LabelNames{1}, MException}];
        ErrorLog = obj.ErrorLog;
        save(obj.LogFilePath, 'ErrorLog', '-append')
    end
end


end
./MATLAB/ptx/smi_cuda_gaussBlobROIStack.m
% smi_cuda_gaussBlobROIStack.ptx contains 2 cuda kernels for creating blob ROI
% stacks
%
% --- kernel_guassiansampleblobs ---
% SYNTAX
% 
% INPUT
%   

./MATLAB/+smi_sim/@GaussBlobs/gaussBlobROIStack.m
function [Model,Data] = gaussBlobROIStack(SZ,SMD,VarianceIm,Covariance,PixType)
%gaussBlobROIStack Generates a stack of 2D images containing a single blob
% 
%   A stack of 2D images is generated with a Guassian blob in each image.
%   A blob centered at 0,0 is the center of the upper-left pixel
%
% INPUTS:
%   SZ:         Box size in pixels
%   SMD:        SMD Structre with fields: 
%       PSFSigma:   Gaussian Sigma in Pixels.  Scalar, 1x2, Nx1 or Nx2 [Y X].  
%       Photons:    Integrated Photons in Blob. Scalar or Nx1. 
%       Bg:         Background (Photons per Pixel). Scalar or Nx1. 
%       X:          Center Location of Blob (Pixels)
%       Y:          Center Location of Blob (Pixels)
%   VarianceIm:     Additional Pixel-Dependent ReadNoise Image given as variance (Default=zeros(SZ,SZ))
%   Covariance: Only used when 'Sample' is selected as PixType
%   PixType:    Method of modeling pixel value, can be 'sample' in which
%               case the pixel value is sampled from a gaussian distribution at
%               the center of the pixel or 'integrate' in which case the
%               pixel value is the integrated value of a gaussian
%               distribution over the pixel size. (Default = 'integrate')
%
% OUTPUTS:
%   Model:      Noise Free Image with background as offset
%   Data:       Poisson Noise Corrupted Images with Readnoise (Optional)
%
% REQUIRES:
%   Statistics and Machine Learning Toolbox
%   Parallel Processing Toolbox
%   NVidia GPU
%   smi_cuda_gaussBlobROIStack.ptx
%   smi_cuda_gaussBlobROIStack.cu
% 
% CITATION:
%   Marjolein Meddens 2017, Lidke Lab

%Check input
if nargin<1
    SZ=8;
end
if nargin <2
    SMD=[];
end


if isempty(SMD)
    NFrames=1000;
    SMD.X=SZ/2*ones(NFrames,1);
    SMD.Y=SZ/2*ones(NFrames,1);
    SMD.Photons=1000*ones(NFrames,1);
    SMD.Bg=5*ones(NFrames,1);
    SMD.PSFSigma=1.3*ones(NFrames,1);
else
    NFrames=length(SMD.X);
end

if nargin<3
    VarianceIm=zeros(SZ,SZ,'single');
end
if nargin <4
    Covariance = 0;
end
if nargin <5
    PixType = 'integrate';
end

% expand scalar inputs
if size(SMD.PSFSigma,2) == 1
    SMD.PSFSigma=[SMD.PSFSigma SMD.PSFSigma];
end
if size(SMD.PSFSigma,1) == 1
    SMD.PSFSigma=repmat(SMD.PSFSigma,[NFrames 2]);
end
if size(SMD.Photons,1) == 1
    SMD.Photons=repmat(SMD.Photons,[NFrames 1]);
end
if size(SMD.Bg,1) == 1
    SMD.Bg=repmat(SMD.Bg,[NFrames 1]);
end
if size(Covariance,1) == 1
    Covariance=repmat(Covariance,[NFrames 1]);
end


%%
% allocate output
Model = zeros(SZ,SZ,NFrames,'single');

% create cuda kernels
k_sample = parallel.gpu.CUDAKernel('smi_cuda_gaussBlobROIStack.ptx','smi_cuda_gaussBlobROIStack.cu','kernel_guassiansampleblobs');
k_integ  = parallel.gpu.CUDAKernel('smi_cuda_gaussBlobROIStack.ptx','smi_cuda_gaussBlobROIStack.cu','kernel_guassianintegrateblobs');

%gpuDevice gives GPU hardware info
g = gpuDevice;
%Find how many loops need to be run so that ROIimStack fits in GPU memory
%Transpose added to prevent an error for an SMD with no localizations.
Nelem = SZ'*SZ*NFrames;
Nloops = ceil(4*4*Nelem/(g.AvailableMemory));
%number of frames in each chunk.
NFramesChunk = ceil(NFrames/Nloops);

%The loop sends one chunk of data at each iteration to the gpu.
for ii = 1:Nloops
    if ii == Nloops
        NFramesThisChunk = NFrames - (NFramesChunk*(Nloops-1));
    else
        NFramesThisChunk = NFramesChunk;
    end
    % crop data for this chunk
    startFr = ((ii-1)*NFramesChunk)+1;
    endFr = ii*NFramesChunk;
    endFr = min(endFr,NFrames);
    Ph = single(SMD.Photons(startFr:endFr));
    Bg = single(SMD.Bg(startFr:endFr));
    xCenters = single(SMD.X(startFr:endFr));
    yCenters = single(SMD.Y(startFr:endFr));
    
    if ~isempty(SMD.PSFSigma)
        xSigma = single(SMD.PSFSigma(startFr:endFr,2));
        ySigma = single(SMD.PSFSigma(startFr:endFr,1));
    end

    Covar = single(Covariance(startFr:endFr));
    % allocate output variables
    subStack = zeros(SZ,SZ,NFramesThisChunk,'single');
    
    switch PixType
        case 'sample'
            % calculate grid size, fill at least as many blocks as there are processors
            if NFramesThisChunk < g.MultiprocessorCount
                NumBlocks = NFramesThisChunk;
            elseif NFramesThisChunk > (g.MultiprocessorCount * k_sample.MaxThreadsPerBlock)
                NumBlocks = ceil(NFramesThisChunk / k_sample.MaxThreadsPerBlock);
            else
                NumBlocks = g.MultiprocessorCount;
            end
            % calculate block size, multiples of 32 are most efficient
            NumThreads = ceil((NFramesThisChunk/32)/NumBlocks)*32;
            % Setting up number of threads and blocks
            k_sample.GridSize(1) = NumBlocks;
            k_sample.ThreadBlockSize(1) = NumThreads;
            % run cuda function
            [subStack] = feval(k_sample,int32(SZ),int32(NFramesThisChunk),xCenters,yCenters,...
                Ph,Bg,xSigma,ySigma,Covar,   subStack);
        case 'integrate'
            % calculate grid size, fill at least as many blocks as there are processors
            if NFramesThisChunk < g.MultiprocessorCount
                NumBlocks = NFramesThisChunk;
            elseif NFramesThisChunk > (g.MultiprocessorCount * k_integ.MaxThreadsPerBlock)
                NumBlocks = ceil(NFramesThisChunk / k_integ.MaxThreadsPerBlock);
            else
                NumBlocks = g.MultiprocessorCount;
            end
            % calculate block size, multiples of 32 are most efficient
            NumThreads = ceil((NFramesThisChunk/32)/NumBlocks)*32;
            % Setting up number of threads and blocks
            k_integ.GridSize(1) = NumBlocks;
            k_integ.ThreadBlockSize(1) = NumThreads;
            % run cuda function
            [subStack] = feval(k_integ,int32(SZ),int32(NFramesThisChunk),...
                xCenters,yCenters,Ph,Bg,xSigma,ySigma,   subStack);
    end
    % retrieve data from gpu
    Model(:,:,startFr:endFr) = gather(subStack);
end

if nargout > 1
    % add poisson noise
    Data = poissrnd(Model); % this is the slowest step, will need gpu implementation
    % add readnoise
    NoiseIm = sqrt(VarianceIm);
    Data = Data + randn(size(Data)).*repmat(NoiseIm,[1 1 NFrames]);
end

end


./MATLAB/+smi_sim/@GaussBlobs/genRandomBlobImage.m
function BlobStack=genRandomBlobImage(SZ,NFrames,Rho,Photons,PSFSigma,Bg)
%genRandomBlobImage Generate a stack of images with randomly placed blobs
%
% INPUTS: 
%   SZ:         Y,X Size of image. Scalar or [1 x 2]. (Default=256)
%   NFrames:    Number of frames. (Default=1000)
%   Rho:        Density of blobs (blobs/pixel) (Default = .001) 
%   Photons:    Photons per blob (Default = 1000)
%   PSFSigma:   Blob 2D Sigma (Default = 1)
%   Bg:         Background (photons/pixel) (Default = 0)
%
% OUTPUTS: 
%   BlobStack:  Output image stack. SZ x SZ x NFrames

if nargin < 1
    SZ=256; 
end
if nargin < 2
    NFrames=1000;
end
if nargin < 3
    Rho=.001;
end
if nargin < 4
    Photons=1000;
end
if nargin < 5
    PSFSigma=1;
end
if nargin < 6
    Bg=0;
end

%setup our SMD and SMF
SMD=smi_core.SingleMoleculeData.createSMD();
SMF=smi_core.SingleMoleculeFitting();

if length(SZ)==2
    SMF.Data.DataROI=[1 1 SZ];
else   
    SMF.Data.DataROI=[1 1 SZ SZ];
end

%create some random data
SMD.NFrames=NFrames;
SMD.NDatasets=1;

for nn=1:SMD.NFrames
    N=poissrnd(Rho*SZ*SZ);
    SMD.FrameNum=cat(1,SMD.FrameNum,nn*ones(N,1));
    SMD.X=cat(1,SMD.X,SZ*rand(N,1));
    SMD.Y=cat(1,SMD.Y,SZ*rand(N,1));
    SMD.Photons=cat(1,SMD.Photons,Photons*ones(N,1));
    SMD.Bg=cat(1,SMD.Bg,Bg*ones(N,1));
    SMD.DatasetNum=cat(1,SMD.DatasetNum,nn*ones(N,1));
    SMD.PSFSigma=cat(1,SMD.PSFSigma,PSFSigma*ones(N,1));
end

BlobStack=smi_sim.GaussBlobs.gaussBlobImage(SMD,SMF);


end
./MATLAB/+smi_sim/@GaussBlobs/README.md
### +smi_sim/@GaussBlobs

GaussBlobs A collection of methods for generating 2D Gaussian Blob Images

This class consists of two static methods that can be used to generate
image stacks containing Gaussian blobs: 
- **[gaussBlobROIStack](gaussBlobROIStack.m)**
  generates a stack of images, each containing a single blob.
- **[gaussBlobImage](gaussBlobImage.m)**
  generates a stack of images with multiple blobs and
  internally uses gaussBlobROIStack.  This function is used in simulation
  and display of 2D single molecule data. 
- **[unitTest](GaussBlobs.m)**

REQUIRES:
- MATLAB 2014a or later versions
- Parallel Procesing Toolbox
- NVidia GPU
- smi_cuda_gaussBlobROIStack.ptx
- smi_cuda_gaussBlobROIStack.cu

./MATLAB/+smi_sim/@GaussBlobs/GaussBlobs.m
 classdef GaussBlobs 
%GaussBlobs A collection of methods for generating 2D Gaussian Blob Images
% 
%   This class consists of two static methods that can be used to generate
%   image stacks containing Gaussian blobs. 
%   
%   gaussBlobROIStack generates a stack of images, each containing a 
%   single blob.
%   
%   gaussBlobImage generates a stack of images with multiple blobs and
%   internally uses gaussBlobROIStack.  This function is used in simulation
%   and display of 2D single molecule data. 
%
% REQUIRES:
%   MATLAB 2014a or later versions
%   Parallel Procesing Toolbox
%   NVidia GPU
%   smi_cuda_gaussBlobROIStack.ptx
%   smi_cuda_gaussBlobROIStack.cu


properties 
end

methods
end

methods (Static)
    [Model,Data] = gaussBlobROIStack(SZ,SMD,VarianceIm,Covariance,PixType)
    %[Model,Data] = gaussBlobImage(SZ,NFrames,SMD,Background,Density,VarianceIm)
    [Model,Data] = gaussBlobImage(SMD,SMF,Bg,Density)
    [BlobStack]=genRandomBlobImage(SZ,NFrames,Rho,Photons,PSFSigma,Bg)
    
    
    function success = unitTest()
    %unitTest Tests static methods using default parameters 
    % REQUIRES:
    %   DipImage
        fprintf('Testing gaussBlobROIStack...\n')
        success = 0;
        SaveDir = fullfile(tempdir, 'smite', 'unitTest', 'GaussBlobs');
        if ~isfolder(SaveDir)
           mkdir(fullfile(tempdir, 'smite'));
           mkdir(fullfile(tempdir, 'smite', 'unitTest'));
           mkdir(fullfile(tempdir, 'smite', 'unitTest', 'GaussBlobs'));
        end
        [Model,Data]=smi_sim.GaussBlobs.gaussBlobROIStack();
        figure; imagesc(sum(Model, 3)); colormap(gca, gray(256));
        saveas(gcf, fullfile(SaveDir, 'GB1.png'));
        figure; imagesc(sum(Data, 3)); colormap(gca, gray(256));
        saveas(gcf, fullfile(SaveDir, 'GB2.png'));
        success = 1;
        %dipshow(Model)
        %dipshow(Data)
%       fprintf('Testing gaussBlobImage...\n')
%       SMF = smi_core.SingleMoleculeFitting();
%       SMD = smi_core.SingleMoleculeData.createSMD();
%       [Model,Data]=smi_sim.GaussBlobs.gaussBlobImage(SMD, SMF);
%       figure; imagesc(sum(Model, 3)); colormap(gca, gray(256));
%       figure; imagesc(sum(Data, 3)); colormap(gca, gray(256));
        %dipshow(Model)
        %dipshow(Data)
    end
end
    
end

./MATLAB/+smi_sim/@GaussBlobs/gaussBlobImage.m
function [Model,Data] = gaussBlobImage(SMD,SMF,Background,ROIBoxType)
%gaussBlobImage Generates a stack of 2D images containing blobs  
%
%   A stack of images containing blobs is generated by first generating a
%   ROI stack containing the blobs using smi_sim.GaussBlobs.gaussBlobROIStack. 
%   The ROI images are then added to the image stack.
%   
%   Background is added during the ROI stack generation, so will only be
%   present around the blobs and not elsewhere in the images. For a image
%   wide offset set SMD.Background to 0 for all blobs and add offset later.
% 
%   A blob centered at 0,0 is at the upper-left corner of upper-left pixel
%   Boxes for blobs close to the edge are cut within the image, and
%   background will be added to full box so off-center from blob
% 
% INPUTS:
%   SMD:        Structure with fields: 
%       X:      Gaussian Blob Center X (Pixels) (Default=spatial Poisson)
%       Y:      Gaussian Blob Center Y (Pixels) (Default=spatial Poisson)
%       PSFSigma:   Gaussian Sigma (Pixels).  Can be scalar, 1x2, Nx1 or Nx2
%                   [Y X]. (Default=1)
%       Photons:    Integrated Photons in Blob (Default=1000)
%       Bg:         Photons per Pixel (Default=5)
%       FrameNum:   Frame number of Gaussian Blob Location
%       NFrames:    
%   SMF:        SMF object with set properties
%       BoxFinding.BoxSize ( Default=6*max(SMD.PSFSigma) )
%   Background:     Background (photons/pixel) (Default=0)
%   ROIBoxType:    Method for calc. box size ['auto','SMF'](Default='auto')
% 
% OUTPUTS:
%   Model:      Noise Free Images
%   Data:       Poisson Noise Corrupted Images with Read Noise
% 
% REQUIRES:
%   Statistics Toolbox
%   Parallel Procesing Toolbox
%   NVidia GPU
% 
% CITATION:
%   Keith Lidke 2017, Lidke Lab

%Set defaults


if nargin<3
   Background=0;
end

if nargin<4
   ROIBoxType='auto';
end

if nargin<2
    SZ=[SMD.YSize SMD.XSize];
    ROIBoxType='auto';
else
    %Get Image size
    SZ=[SMF.Data.DataROI(3)-SMF.Data.DataROI(1)+1, SMF.Data.DataROI(4)-SMF.Data.DataROI(2)+1];    
end

%Get Box Size
switch ROIBoxType
    case 'auto'
        MaxSigma=max(SMD.PSFSigma(:));
        ROISZ=min(min(ceil(MaxSigma*6),SZ(1)),SZ(2));  %Make boxes large enough for 3 sigma
        YStart=max(1,round(SMD.Y-ROISZ/2));
        YStart=min(YStart,SZ(1)-ROISZ+1);
        XStart=max(1,round(SMD.X-ROISZ/2));
        XStart=min(XStart,SZ(2)-ROISZ+1);
    case 'SMF'
        ROISZ=SMF.BoxFinding.BoxSize;
        if ~isempty(SMD.XBoxCorner)||isempty(SMD.YBoxCorner) %calculte
            YStart=max(1,round(SMD.Y-ROISZ/2));
            YStart=min(YStart,SZ(1)-ROISZ+1);
            XStart=max(1,round(SMD.X-ROISZ/2));
            XStart=min(XStart,SZ(2)-ROISZ+1);
        else %use existing
            XStart=SMD.XBoxCorner;
            YStart=SMD.YBoxCorner;
        end 
end

SMD.X=SMD.X-XStart;
SMD.Y=SMD.Y-YStart;

%Make the ROI Stack
if ~isempty(SMD.Z)
    error('Z simulation needs implementation')
end

if nargin<2
    VarianceIm=0;
else
    VarianceIm=SMF.Data.CameraReadNoise.^2;
end

Covariance=0;
PixType='integrate';
[ModelROI] = smi_sim.GaussBlobs.gaussBlobROIStack(ROISZ,SMD,VarianceIm,Covariance,PixType);

%Write ROIs into Image
NBlobs=length(SMD.X);
Model=zeros([SZ SMD.NFrames],'single');

for nn=1:NBlobs
    Model(YStart(nn):YStart(nn)+ROISZ-1,XStart(nn):XStart(nn)+ROISZ-1,SMD.FrameNum(nn))=...
        Model(YStart(nn):YStart(nn)+ROISZ-1,XStart(nn):XStart(nn)+ROISZ-1,SMD.FrameNum(nn))+ModelROI(:,:,nn);
end

Model=Model+Background; 

% Add poisson noise
if nargout>1
    % poissrnd is faster when used in a loop through all frames
    Data = zeros(size(Model),'single');
    for ii = 1:SMD.NFrames
        Data(:,:,ii)=poissrnd(Model(:,:,ii)); %not implemented in gpu yet
    end
    NoiseIm = sqrt(VarianceIm);
    Data=Data+randn(size(Data)).*repmat(NoiseIm,[1 1 SMD.NFrames]);
end

end


./MATLAB/+smi_sim/README.md
### +smi_sim

+smi_sim is the namespace for the simulation classes of ***smite***:
- [@GaussBlobs](@GaussBlobs/README.md): generate 2D Gaussian blob images
- [@SimSMLM](@SimSMLM/README.md):       simulate SMLM data
- [@SimSPT](@SimSPT/README.md):         simulate SPT data

./MATLAB/+smi_sim/@SimSPT/defineDefaultParams.m
function [ParamStruct] = defineDefaultParams()
%defineDefaultParams creates a ParamStruct with all default values set.
% This method creates a structure of parameters 'ParamStruct' with all
% values set to some meaningful default value.
%
% OUTPUTS:
%   ParamStruct: structure array of default parameters.
%                ParticleDensity: Density of particles within the 
%                                 simulation. (particles / pixel^2)
%                                 (Default = 0.005)
%                NFrames: Number of (full) frames in the simulation (i.e.,
%                         if NFrames = 100 and SubframeDensity = 2, we will
%                         simulate 200 subframes). (Default = 100)
%                SubframeDensity: Number of subframes per frame (i.e., each 
%                                 frame of the simulation represents the
%                                 motion blur of the subframes). If 
%                                 mod(NFrames, NSubframes)~=0, remainder 
%                                 frames are thrown away. 
%                                 (1/frame)(Default = 1)
%                FrameSize: Size of the frame within which the trajectories 
%                           are simulated. (pixels)(Default = [32, 32])
%                PSFSigma: Standard deviation of the best Gaussian fit to
%                          simulated emitters. (pixels)(Default = 1.3)
%                InitialDensityMask: Binary mask defining the allowable 
%                                    region for initial particle placement.
%                                    (Default = ones(FrameSize))
%                LabelingEfficiency: Probability of a target being labeled.
%                                    (Default = 1)
%                BoundaryCondition: Boundary condition applied when 
%                                   particles reach a boundary specified by
%                                   FrameSize. This can be 'Periodic', 
%                                   'Reflecting', or 'Free'. 
%                                   (Default = 'Periodic')
%                Intensity: Photons present in the simulated trajectory in
%                           each full frame. 
%                           (photons / frame)(Default = 1000)
%                MinIntensity: Minimum allowed photons.  This is added to
%                              prevent strange effects after noising, e.g.,
%                              if an emitter had a tiny number of photons
%                              in a frame, Poisson noise might result in an
%                              apparent 0 photon count. 
%                              (photons / frame)(Default = 50)
%                Bg: Uniform background signal per full frame stored for
%                    trajectories. (photons / frame)(Default = 5)
%                D: Diffusion coefficients(s) for the Brownian motion 
%                   trajectories. If the size of this array is greater than
%                   or equal to the number of trajectories, the 1:NTraj 
%                   trajectories will have a diffusion constant taken in 
%                   order from this array.  If this array is smaller than 
%                   the number of trajectories, the diffusion constant for
%                   each trajectory will be randomly sampled from this
%                   array. (pixels^2 / frame)(Default = 0.1)
%                InteractionDistance: Distance between particles in a
%                                     dimer.  Distances for oligomers may 
%                                     not be equal to this value.
%                                     (pixels)(Default = 0.5)
%                InteractionProb: Probability that two particles within 
%                                 InteractionDistance of each other in a 
%                                 given frame will be dimerized.  Note that
%                                 this probability is "tested" at each 
%                                 sub-frame of the simulation.
%                                 (Default = 0.5)
%                RestrictToDimers: Restrict oligomerization to only order 2
%                                  (dimers). (Default = true)
%                KDisconnect: Rate parameter for the disconnection of 
%                             oligomers. (1 / frame)(Default = 0.1)
%                KOnToBleach: Rate parameter defining photobleaching.
%                            (1 / frame)(Default = 0.1)
%                KOnToOff: Rate parameter defining the turning off of 
%                          visible emitters. (1 / frame)(Default = 0.2)
%                KOffToOn: Rate parameter defining the turning on of 
%                          dark emitters. (1 / frame)(Default = 0.8)
%                PMiss: Probability of missing a localization of a visible
%                       emitter. (Default = 0.01)
%                Bg: Bg specifies a uniform background present in the raw 
%                    data. (photons)(Default = 5)

% Created by:
%   David J. Schodt (Lidke Lab, 2021)


% Populate the output structure.
ParamStruct.ParticleDensity = 0.005;
ParamStruct.NFrames = 100;
ParamStruct.SubframeDensity = 1;
ParamStruct.FrameSize = [32, 32];
ParamStruct.PSFSigma = 1.3;
ParamStruct.InitialDensityMask = ones(ParamStruct.FrameSize);
ParamStruct.LabelingEfficiency = 1;
ParamStruct.BoundaryCondition = 'Periodic';
ParamStruct.Intensity = 1000;
ParamStruct.MinIntensity = 50;
ParamStruct.Bg = 5;
ParamStruct.D = 0.1;
ParamStruct.InteractionDistance = 0.5;
ParamStruct.InteractionProb = 0.5;
ParamStruct.RestrictToDimers = true;
ParamStruct.KDisconnect = 0.1;
ParamStruct.KOnToBleach = 0.01;
ParamStruct.KOnToOff = 0.2;
ParamStruct.KOffToOn = 0.8;
ParamStruct.PMiss = 0.01;


end
./MATLAB/+smi_sim/@SimSPT/enforcePeriodicBoundary.m
function [Trajectories, ConnectionMapT, IsOn, TrajMap] = ...
    enforcePeriodicBoundary(Trajectories, PeriodicityMapT, ConnectionMapT)
%enforcePeriodicBoundary breaks trajectories that hit a periodic boundary.
% If a trajectory in 'Trajectories' experienced a periodic boundary, this
% method will break that trajectory into two trajectories: one before and
% one after the periodic boundary (i.e., when the particle is translated to
% the other side of the frame, it is treated as a new trajectory).  This
% method will also break apart oligomer events when one of the constituents
% experiences a periodic boundary.
%
% INPUTS:
%   Trajectories: Array of 2D trajectories. (NTrajxNFramesx2)
%   PeriodicityMapT: Binary map indicating when 'Trajectories' experienced
%                    a periodic boundary (1 indicates a periodic boundary
%                    was encountered for that trajectory in that frame).
%                    (see, e.g., smi_sim.SimSPT.simOligomers() for usage)
%                    (NTrajxNFrames)
%   ConnectionMapT: Index mapping indicating oligomerization between
%                   trajectories. (see, e.g.,
%                   smi_sim.SimSPT.simOligomers() for usage)
%                   (NTrajxNFrames)
% OUTPUTS:
%   Trajectories: Input 'Trajectories' after breaking up the trajectories
%                that encountered the periodic boundaries.
%   ConnectionMapT: Input 'ConnectionMapT' after breaking up oligomers that
%                   hit a boundary.
%   IsOn: Flag indicating when the trajectories are "on" (in this case, the
%         post-birth and pre-death frames of a trajectory).  This is
%         returned to improve speed for large simulations, since checking
%         isnan(Trajectories) might be slower than just keeping tracking of
%         those entries as they're made. (NTrajxNFrames)
%   TrajMap: Set of indices mapping the rows of output 'Trajectories' to 
%            their original row in the input 'Trajectories' (e.g., if the
%            input TrajectoriesInput(5, :, :) was split by a periodic
%            boundary into TrajectoriesOutput(5, :, :) and 
%            TrajectoriesOutput(12, :, :), TrajMap(5) = 5 and
%            TrajMap(12) = 5.

% Created by:
%   David J. Schodt (Lidke Lab, 2021)


% Set defaults if needed.
if (~exist('ConnectionMapT', 'var') || isempty(ConnectionMapT))
    ConnectionMapT = zeros(size(PeriodicityMapT));
end

% Enforce the periodic boundaries, setting elements of 'Trajectories' to
% NaN before new trajectories are birthed and after old ones die.
NTrajInitial = size(Trajectories, 1);
NFrames = size(Trajectories, 2);
CurrentTrajID = NTrajInitial;
IsOn = ones(size(PeriodicityMapT), 'logical');
TrajMap = (1:NTrajInitial).';
for dd = 1:NTrajInitial
    % Loop through any periodic boundary encounters and turn trajectories 
    % off in the appropriate frames.
    if any(PeriodicityMapT(dd, :))
        % Determine when this emitter hit the boundary and turn it off from
        % that point forward.
        EventIndices = find(PeriodicityMapT(dd, :));
        NNewTraj = numel(EventIndices);
        IsOn(dd, (EventIndices(1):NFrames)) = false;

        % Continue looping throught the boundary interactions and create a
        % new trajectory each time.
        NewTrajectories = repmat(Trajectories(dd, :, :), [NNewTraj, 1]);
        NewConnections = repmat(ConnectionMapT(dd, :), [NNewTraj, 1]);
        Trajectories(dd, (EventIndices(1):NFrames), :) = NaN;
        ConnectionMapT(dd, (EventIndices(1):NFrames)) = NaN;
        for nn = 1:(NNewTraj-1)
            % Update the trajectory ID counter.
            CurrentTrajID = CurrentTrajID + 1;
            
            % Ensure this particle is off before its birth and after
            % its death.
            IsOn(CurrentTrajID, 1:(EventIndices(nn)-1)) = false;
            IsOn(CurrentTrajID, EventIndices(nn+1):NFrames) = false;
            
            % Set positions and connections to NaN before and after the
            % birth of this new trajectory.
            NewTrajectories(nn, 1:(EventIndices(nn)-1), :) = NaN;
            NewTrajectories(nn, EventIndices(nn+1):NFrames, :) = NaN;
            NewConnections(nn, 1:(EventIndices(nn)-1)) = NaN;
            NewConnections(nn, EventIndices(nn+1):NFrames) = NaN;

            % Update ConnectionMapT to reflect the new trajectory ID.
            CurrentInds = EventIndices(nn):(EventIndices(nn+1)-1);
            ConnectedIDs = NewConnections(nn, CurrentInds);
            for ii = unique(ConnectedIDs(ConnectedIDs ~= 0))
                UpdateInd = find(ConnectionMapT(ii, CurrentInds) == dd);
                ConnectionMapT(ii, EventIndices(nn) + UpdateInd - 1) = ...
                    CurrentTrajID;
            end
        end
        CurrentTrajID = CurrentTrajID + 1;
        IsOn(CurrentTrajID, 1:(EventIndices(NNewTraj)-1)) = false;
        NewTrajectories(NNewTraj, 1:(EventIndices(NNewTraj)-1), :) = NaN;
        Trajectories = cat(1, Trajectories, NewTrajectories);
        TrajMap = [TrajMap; repelem(dd, NNewTraj, 1)];
        NewConnections(NNewTraj, 1:(EventIndices(NNewTraj)-1)) = NaN;
        ConnectionMapT = cat(1, ConnectionMapT, NewConnections);
    end
end


end
./MATLAB/+smi_sim/@SimSPT/convertTrajToSMD.m
function [SMD] = convertTrajToSMD(TrajStruct, SimParams)
%convertTrajToSMD converts a TrajStruct to an SMD.
% This method reorganizes some vital fields in the input 'TrajStruct' and
% stores them into a Single Molecule Data structure 'SMD'.
%
% INPUTS:
%   TrajStruct: Structure containing trajectory data (see
%               smi_sim.SimSPT.simTrajectories())
%   SimParams: Structure of simulation parameters (see
%              smi_sim.SimSPT.defineDefaultParams()).
%
% OUTPUTS:
%   SMD: Single Molecule Data structure (see smi_core.SingleMoleculeData)

% Created by:
%   David J. Schodt (Lidke Lab, 2021)


% Pad the input 'SimParams'.
if (~exist('SimParams', 'var') || isempty(SimParams))
    SimParams = smi_sim.SimSPT.defineDefaultParams();
else
    DefaultParams = smi_sim.SimSPT.defineDefaultParams();
    SimParams = smi_helpers.padStruct(SimParams, DefaultParams);
end

% Prepare the SMD.
SMD = smi_core.SingleMoleculeData.createSMD();
SMD.NFrames = SimParams.NFrames;
SMD.NDatasets = 1;
SMD.XSize = SimParams.FrameSize(2);
SMD.YSize = SimParams.FrameSize(1);
DataSize = size(TrajStruct.Photons);
NObservations = sum(TrajStruct.IsOn, 2);
SMD.ConnectID = repelem((1:DataSize(1)).', NObservations, 1);
ValidTrajInd = find(TrajStruct.IsOn.');
SMD.FrameNum = 1 + mod(ValidTrajInd-1, DataSize(2));
SMD.DatasetNum = ones(size(SMD.FrameNum));
SMD.PSFSigma = SimParams.PSFSigma * ones(size(SMD.FrameNum));
X = TrajStruct.Trajectories(:, :, 1).';
Y = TrajStruct.Trajectories(:, :, 2).';
SMD.X = X(ValidTrajInd);
SMD.Y = Y(ValidTrajInd);
X_SE = TrajStruct.Trajectories_SE(:, :, 1).';
Y_SE = TrajStruct.Trajectories_SE(:, :, 2).';
SMD.X_SE = X_SE(ValidTrajInd);
SMD.Y_SE = Y_SE(ValidTrajInd);
Photons = TrajStruct.Photons.';
SMD.Photons = Photons(ValidTrajInd);
Photons_SE = TrajStruct.Photons_SE.';
SMD.Photons_SE = Photons_SE(ValidTrajInd);
Bg = TrajStruct.Bg.';
SMD.Bg = Bg(ValidTrajInd);
Bg_SE = TrajStruct.Bg_SE.';
SMD.Bg_SE = Bg_SE(ValidTrajInd);


end
./MATLAB/+smi_sim/@SimSPT/simTrajBrownian.m
function [TrajStruct] = simTrajBrownian(InitialPositions, SimParams)
%simTrajBrownian simulates Brownian trajectories.
% This method simulates Brownian random motion of the targets at the
% specified initial conditions.
%
% INPUTS:
%   InitialPositions: Initial positions of the random walkers
%                     (NTrajx2 array)
%   SimParams: Structure of simulation parameters (see
%              smi_sim.SimSPT.defineDefaultParams())
%
% OUTPUTS:
%   TrajStruct: Structure containing information about the simulated
%               trajectories.

% Created by:
%   David J. Schodt (Lidke Lab, 2021)


% Make local copies of some parameters (can improve speed for large
% simulations).
FrameSize = SimParams.FrameSize;
D = SimParams.D;
BoundaryCondition = SimParams.BoundaryCondition;
InteractionDistance = SimParams.InteractionDistance;
InteractionProb = SimParams.InteractionProb;
RestrictToDimers = SimParams.RestrictToDimers;

% Prepare the diffusion coefficients.
NTraj = size(InitialPositions, 1);
NDiffusionCoefficients = numel(D);
if (NDiffusionCoefficients > NTraj)
    D = D(1:NTraj);
else
    D = D(randi(NDiffusionCoefficients, [NTraj, 1]));
end
if isrow(D)
    D = D.';
end

% Simulate the Brownian trajectories.
DSub = D / SimParams.SubframeDensity;
KDisconnectSub = SimParams.KDisconnect / SimParams.SubframeDensity;
NSubframes = SimParams.NFrames * SimParams.SubframeDensity;
Trajectories = zeros(NTraj, NSubframes, 2, 'double');
Trajectories(:, 1, :) = InitialPositions;
PeriodicityMapT = zeros(NTraj, NSubframes, 'logical');
ConnectionMap = zeros(NTraj, 1);
ConnectionMapT = zeros(NTraj, NSubframes);
IsOligoSim = (SimParams.InteractionProb ...
    && ~isinf(SimParams.InteractionDistance));
if any(DSub > 0)
    for ff = 2:NSubframes
        % Sample the proposed trajectory updates from the Normal
        % distribution (Brownian motion).
        TrajectoryUpdates = sqrt(2*DSub) .* randn(NTraj, 1, 2);
        
        % Simulate oligomerization.
        if IsOligoSim
            [Trajectories(:, ff, :), ConnectionMap] = ...
                smi_sim.SimSPT.simOligomers(...
                Trajectories(:, ff-1, :), TrajectoryUpdates, NTraj, ...
                ConnectionMap, InteractionDistance, InteractionProb, ...
                KDisconnectSub, RestrictToDimers);
        else
            Trajectories(:, ff, :) = Trajectories(:, ff-1, :) ...
                + TrajectoryUpdates;
        end
        
        % Apply the boundary conditions.
        [Trajectories(:, ff, :), ...
            PeriodicityMapT(:, ff), ConnectionMap] = ...
            smi_sim.SimSPT.applyBoundaryCondition(Trajectories(:, ff, :), ...
            BoundaryCondition, FrameSize, ConnectionMap);
        ConnectionMapT(:, ff) = ConnectionMap;
    end
else
    % Some simulations might have D set to 0, in which case there's no
    % reason to run the above section of code.
    Trajectories(:, :, 1) = repmat(InitialPositions(:, 1), [1, NSubframes]);
    Trajectories(:, :, 2) = repmat(InitialPositions(:, 2), [1, NSubframes]);
end

% Break up trajectories that experienced a periodic boundary (that is, each
% interaction with the periodic boundary creates a new trajectory starting
% from that interaction).
[Trajectories, ConnectionMapT, IsOn, TrajMap] = ...
    smi_sim.SimSPT.enforcePeriodicBoundary(...
    Trajectories, PeriodicityMapT, ConnectionMapT);
TrajStruct.IsOn = IsOn;
TrajStruct.D = DSub(TrajMap);
DataSize = size(IsOn);
TrajStruct.Photons = zeros(DataSize);
TrajStruct.Photons_SE = inf(DataSize);
TrajStruct.Bg = zeros(DataSize);
TrajStruct.Bg_SE = inf(DataSize);
TrajStruct.ConnectionMapT = ConnectionMapT;
TrajStruct.Trajectories = Trajectories;
TrajStruct.Trajectories_SE = zeros([DataSize, 2]);


end
./MATLAB/+smi_sim/@SimSPT/simOligomers.m
function [Trajectories, ConnectionMap] = simOligomers(...
    Trajectories, TrajectoryUpdates, NTraj, ...
    ConnectionMap, InteractionDistance, InteractionProb, KDisconnect, ...
    RestrictToDimers)
%simOligomers simulates oligomerization between trajectories.
% This method updates 'Trajectories' based on their oligomerization state
% and also creates and destroys oligomers as appropriate.
%
% INPUTS:
%   Trajectories: Array of 2D trajectories. (NTrajx1x2)
%   TrajectoryUpdates: Proposed steps to be made by the 'Trajectories'.
%                      (NTrajx1x2)
%   NTraj: Number of trajectories, passed to improve speed instead of
%          recomputing each time this method is called. (scalar)
%   ConnectionMap: Index mapping indicating oligomerization between
%                  trajectories. For example, if ConnectionMap(mm)==nn,
%                  Trajectories(mm, :, :) is in an oligomer with
%                  Trajectories(nn, :, :). (NTrajx1)
%   InteractionDistance: Distance at or below which trajectories have a
%                        chance to interact with one another. (scalar)
%   InteractionProb: Probability that two trajectories interact when at or
%                    below 'InteractionDistance'. (scalar)
%   KDisconnect: Rate parameter for oligomer disconnection. (scalar)
%   RestrictToDimers: Flag indicating that only dimers are allowed (i.e.,
%                     no higher order oligomers are allowed between
%                     trajectories). (Boolean scalar)
%
% OUTPUTS:
%   Trajectories: Input 'Trajectories' updated based on oligomerization
%                 state and 'TrajectoryUpdates'.
%   ConnectionMap: Input 'ConnectionMap' after updating to reflect new or
%                  broken oligomers.

% Created by:
%   David J. Schodt (Lidke Lab, 2021)


% Force oligomers to move together.
for mm = 1:NTraj
    if ConnectionMap(mm)
        TrajectoryUpdates(mm, :) = TrajectoryUpdates(ConnectionMap(mm), :);
    end
end

% Update the particle positions.
Trajectories = Trajectories + TrajectoryUpdates;

% Update the connection map.
OldConnectionMap = ConnectionMap;
for mm = 1:NTraj
    for nn = (mm+1):NTraj
        % Compute the distance between the two particles currently
        % being compared.
        DeltaX = Trajectories(mm, 1, 1) - Trajectories(nn, 1, 1);
        DeltaY = Trajectories(mm, 1, 2) - Trajectories(nn, 1, 2);
        ParticleSeparation = sqrt(DeltaX^2 + DeltaY^2);
        
        % Determine if these particles should be connected.
        if ((ParticleSeparation<=InteractionDistance) ...
                && (rand()<InteractionProb))
            % If these particles weren't connected in the previous
            % frame, then we will connect them now.
            if ~(RestrictToDimers || ConnectionMap(nn))
                % Oligomers of higher order than 2 are allowed.
                ConnectionMap(nn) = mm;
            elseif ~(ConnectionMap(nn) || ConnectionMap(mm))
                ConnectionMap(nn) = mm;
                ConnectionMap(mm) = nn;
            else
                continue
            end
            
            % Force these two particles to be exactly
            % InteractionDistance apart from one another.
            DistanceDiff = InteractionDistance - ParticleSeparation;
            Theta = atan(DeltaY / DeltaX);
            XShift = sign(DeltaX) * abs(DistanceDiff*cos(Theta)) / 2;
            YShift = sign(DeltaY) * abs(DistanceDiff*sin(Theta)) / 2;
            Trajectories(nn, 1, 1) = Trajectories(nn, 1, 1) - XShift;
            Trajectories(nn, 1, 2) = Trajectories(nn, 1, 2) - YShift;
            Trajectories(mm, 1, 1) = Trajectories(mm, 1, 1) + XShift;
            Trajectories(mm, 1, 2) = Trajectories(mm, 1, 2) + YShift;
        end
    end
end

% Randomly disconnect particle connections.
for nn = 1:NTraj
    if OldConnectionMap(nn)
        % Set the previous connection map for this connection to 0
        % (that way we can skip it when reached by the outer loop).
        OldConnectionMap(OldConnectionMap(nn)) = 0;
        
        % Randomly disconnect the particle connection by comparing
        % rand() to the probability that these particles will
        % disconnect.
        if (rand() < (1-exp(-KDisconnect)))
            % Ensure that the connection is broken for the next
            % frame.
            ConnectionMap(ConnectionMap(nn)) = 0;
            ConnectionMap(nn) = 0;
        end
    end
end


end
./MATLAB/+smi_sim/@SimSPT/applyCoordMask.m
function [Coordinates, MaskedCoordinates] = ...
    applyCoordMask(Coordinates, Mask, FrameSize)
%applyCoordMask applies a (discrete) mask to the provided coordinates.
% This method applies the binary mask in 'Mask' to the input 'Coordinates',
% meaning that all coordinates falling outside of the mask are thrown out.
%
% INPUTS:
%   Coordinates: XY coordinates to be masked. ([Y, X])
%   Mask: Logical array where coordinates within true pixels are kept, and
%         coordinates within false pixels are thrown out. 
%         (YSizexXSize logical array)
%   FrameSize: Size of the frame corresponding to the coordinates in
%              'Coordinates'. This can be used in conjunction with a 'Mask'
%              which has smaller pixels than the coordinates (e.g., 'Mask'
%              could be a 128x128 matrix but coordinates came from
%              FrameSize = [32, 32], allowing for finer scale masking
%              of the coordinates). (Default = size(Mask))
%
% OUTPUTS:
%   Coordinates: Input 'Coordinates' after the 'Mask' has been applied.
%   MaskedCoordinates: Entries of input 'Coordinates' that were masked to
%                      produce the output 'Coordinates'.

% Created by:
%   David J. Schodt (Lidke Lab, 2021)


% Set defaults and check inputs.
if (~exist('Mask', 'var') || isempty(Mask))
    return
end
CoordSize = size(Coordinates);
if ((CoordSize(2)>CoordSize(1)) && (CoordSize(1)==2))
    % This looks like an array organized as [Y; X] instead of the desired
    % [Y, X].
    Coordinates = Coordinates.';
end
MaskSize = size(Mask);
if (~exist('FrameSize', 'var') || isempty(FrameSize))
    FrameSize = MaskSize;
end

% Convert the coordinates to a binary locations on a grid matching the
% input 'Mask'.
BinaryLocations = round(Coordinates .* (MaskSize./FrameSize));
BinaryLocations = max(1, min(BinaryLocations, MaskSize));
LocationIndices = sub2ind(MaskSize, ...
    BinaryLocations(:, 1), BinaryLocations(:, 2));
WithinMask = logical(Mask(LocationIndices));
Coordinates = Coordinates(WithinMask, :);
MaskedCoordinates = Coordinates(~WithinMask, :);


end
./MATLAB/+smi_sim/@SimSPT/SimSPT.m
classdef SimSPT < handle
    %SimSPT contains methods useful for simulating SPT data.
    % SimSPT is a collection of methods that can be used to simulate
    % single-particle tracking (SPT) data, including realistic raw data and
    % ground-truth trajectories.
    
    % Created by:
    %   David J. Schodt (Lidke Lab, 2021) with class structure modeled on
    %       smi_sim.SimSMLM
    
    
    properties
        % Structure of parameters used in the simulation.
        SimParams = struct();
    end
    
    properties (SetAccess = 'protected')
        % obj.TrajStructModel after applying a measurement noise model.
        TrajStruct
        
        % obj.TrajStructSubModel after motion blurring, before noising.
        TrajStructModel
        
        % obj.TrajStructSubLabeled after applying photokinetics model.
        % NOTE: This structure has fields in units of subframes!
        TrajStructSubModel
        
        % obj.TrajStructSubTrue after applying labeling efficiencies.
        % NOTE: This structure has fields in units of subframes!
        TrajStructSubLabeled
        
        % True locations of the underlying diffusing targets.
        % NOTE: This structure has fields in units of subframes!
        TrajStructSubTrue
    end
    
    properties (Dependent)
        % obj.TrajStruct converted to the more useable SMD format.
        SMD
        
        % SMD converted to a Tracking Results structure.
        TR
    end
    
    methods
        function obj = SimSPT(SimParams)
            %SimSPT class constructor.
            
            % Set defaults.
            if (~exist('SimParams', 'var') || isempty(SimParams))
                obj.SimParams = smi_sim.SimSPT.defineDefaultParams();
            else
                obj.SimParams = SimParams;
            end
        end
        
        function set.SimParams(obj, SimParams)
            % This method ensures obj.SimParams has all parameters.
            obj.SimParams = smi_helpers.padStruct(SimParams, ...
                smi_sim.SimSPT.defineDefaultParams());
        end
        
        function [SMD] = get.SMD(obj)
            % This method converts obj.TrajStruct to an SMD.
            SMD = obj.convertTrajToSMD(obj.TrajStruct, obj.SimParams);
        end
        
        function [TR] = get.TR(obj)
            % This method converts obj.SMD to a TR.
            TR = smi_core.TrackingResults.convertSMDToTR(obj.SMD);
        end
        
        createSimulation(obj);
        
    end
    
    methods (Static)
        [TrajStruct] = simTrajectories(SimParams);
        [TrajStruct, KeepInd] = applyLabelingEfficiency(...
            TrajStruct, LabelingEfficiency);
        [TrajStruct] = simEmitterKinetics(TrajStruct, SimParams);
        [TrajStruct, TrajStructModel] = applyMeasurementModel(...
            TrajStruct, SimParams);
        [SimParams] = defineDefaultParams();
        [Coordinates, MaskedCoordinates] = ...
            applyCoordMask(Coordinates, Mask, FrameSize);
        [SMD] = convertTrajToSMD(TrajStruct, SimParams);
        [Files, SimParams, DataParams] = makeExampleSim(...
            SimParams, DataParams, SaveDir);
    end
    
    methods (Static, Hidden)
        [TrajStruct] = simTrajBrownian(InitialPositions, SimParams);
        [Trajectories, PeriodicityMap, ConnectionMap] = ...
            applyBoundaryCondition(...
            Trajectories, BoundaryCondition, FrameSize, ConnectionMap);
        [Trajectories, ConnectionMapT, IsOn, TrajMap] = ...
            enforcePeriodicBoundary(...
            Trajectories, PeriodicityMapT, ConnectionMapT);
        [Trajectories, ConnectionMap] = simOligomers(...
            Trajectories, TrajectoryUpdates, NTraj, ...
            ConnectionMap, InteractionDistance, InteractionProb, ...
            KDisconnect, RestrictToDimers);
    end
    
    
end
./MATLAB/+smi_sim/@SimSPT/simTrajectories.m
function [TrajStruct] = simTrajectories(SimParams)
%simTrajectories simulates trajectories with oligomerization.
% This method simulates Brownian trajectories which may interact with one
% another to form dimers/higher order oligomers.
%
% INPUTS:
%   SimParams: Structure of simulation parameters.
%              (see smi_sim.SimSPT.defineDefaultParams())
%
% OUTPUTS:
%   TrajStruct: Structure containing information about the simulated
%               trajectories.

% Created by:
%   David J. Schodt (Lidke Lab, 2021)


% Ensure that 'SimParams' is complete, i.e., has all parameters.
if (~exist('SimParams', 'var') || isempty(SimParams))
    SimParams = smi_sim.SimSPT.defineDefaultParams();
else
    SimParams = smi_helpers.padStruct(SimParams, ...
        smi_sim.SimSPT.defineDefaultParams());
end

% Scatter the targets uniformly throughout the desired frame.
NTraj = poissrnd(SimParams.ParticleDensity * prod(SimParams.FrameSize));
InitialPositions = rand(NTraj, 2) .* SimParams.FrameSize;

% Apply the initial density mask.
InitialPositions = smi_sim.SimSPT.applyCoordMask(InitialPositions, ...
    SimParams.InitialDensityMask, SimParams.FrameSize);

% Simulate the trajectories and, if needed, oligomerization between them.
TrajStruct = smi_sim.SimSPT.simTrajBrownian(InitialPositions, SimParams);


end
./MATLAB/+smi_sim/@SimSPT/makeExampleSim.m
function [Files, SimParams, DataParams] = makeExampleSim(...
    SimParams, DataParams, SaveDir)
%makeExampleSim prepares a basic two channel SPT simulation.
% This method prepares a basic example simulation of two-channel SPT data.
%
% INPUTS:
%   SimParams: Structure of simulation parameters (see
%              SimSPT.defineDefaultParams()).
%   DataParams: Structure of additional data related parameters, such as 
%               number of simulated datasets and noise characteristics, not
%               covered by 'SimParams'.
%               NDatasets: Number of simulated datasets. (Default = 10)
%               Background: Background photon counts. (Default = 0)
%   SaveDir: Base directory in which simulated data will be saved. 
%            (Default = pwd())
%
% OUTPUTS:
%   Files: Cell array of the filenames saved in 'SaveDir'.  Data are saved
%          as side-by-side images, e.g., for a 128x128 ROI size in each
%          channel, saved data will be 128x256 pixels, with channel 1 in
%          columns 1:128 and channel 2 in columns 129:256.

% Created by:
%   David J. Schodt (Lidke Lab, 2023)


% Set defaults.
if (~exist('SimParams', 'var') || isempty(SimParams))
    SimParams = smi_sim.SimSPT.defineDefaultParams();
else
    SimParams = smi_helpers.padStruct(SimParams, ...
        smi_sim.SimSPT.defineDefaultParams());
end
if (~exist('SaveDir', 'var') || isempty(SaveDir))
    SaveDir = pwd();
end
if ~isfolder(SaveDir)
    mkdir(SaveDir)
end
DefaultDataParams = struct();
DefaultDataParams.NDatasets = 10;
DefaultDataParams.Background = 0;
if (~exist('DataParams', 'var') || isempty(DataParams))
    DataParams = DefaultDataParams;
else
    DataParams = smi_helpers.padStruct(DataParams, DefaultDataParams);
end

% Loop over datasets and prepare the NDatasets simulations.
Files = cell(DataParams.NDatasets, 1);
for nn = 1:DataParams.NDatasets
    % Simulate trajectories.
    SPTSim = smi_sim.SimSPT;
    SPTSim.SimParams = SimParams;
    SPTSim.createSimulation()

    % Split the simulated trajectories randomly into two channels.
    NTraj = numel(SPTSim.TR);
    Inds = (1:NTraj);
    Channel1Inds = randperm(NTraj, ceil(NTraj/2));
    Channel2Inds = setdiff(Inds, Channel1Inds);
    SMD1 = smi_core.SingleMoleculeData.isolateSubSMD(...
        SPTSim.SMD, ismember(SPTSim.SMD.ConnectID, Channel1Inds));
    SMD2 = smi_core.SingleMoleculeData.isolateSubSMD(...
        SPTSim.SMD, ismember(SPTSim.SMD.ConnectID, Channel2Inds));

    % Simulate raw data.
    SMF = smi_core.SingleMoleculeFitting;
    SMF.Data.DataROI = [1, 1, SPTSim.SMD.YSize, SPTSim.SMD.XSize];
    SMF.Fitting.PSFSigma = 1.3;
    [~, RawData1] = smi_sim.GaussBlobs.gaussBlobImage(...
        SMD1, SMF, DefaultDataParams.Background);
    [~, RawData2] = smi_sim.GaussBlobs.gaussBlobImage(...
        SMD2, SMF, DefaultDataParams.Background);
    sequence = [RawData1, RawData2];
    pause(1.1) % pause before next iteration so time stamp is incremented
    Files{nn} = sprintf('Data_%03i_%s.mat', nn, smi_helpers.genTimeString());

    % Save the simulated data.
    save(fullfile(SaveDir, Files{nn}), 'sequence')
end


end

./MATLAB/+smi_sim/@SimSPT/README.md
### +smi_sim/@SimSPT

SimSPT is a collection of methods that can be used to simulate
single-particle tracking (SPT) data, including realistic raw data and
ground-truth trajectories.
Class structure is modeled on smi_sim.SimSMLM .

properties:
- SimParams = struct(); % Structure of parameters used in the simulation.

---

Examples using this class can be found in MATLAB/examples:
- Example_DiffusionEstimator.m
- Example_HMM.m
- Example_SPT.m
- Example_SPTBatch.m
For example,
```
   % Simulate and save some SPT data in the format expected for real data.
   % Simulate some diffusing blobs.
   rng(12)
   SPTSim = smi_sim.SimSPT;
   SPTSim.SimParams.FrameSize = [128, 128];
   SPTSim.SimParams.ParticleDensity = 0.002; % particles / px^2
   SPTSim.SimParams.D = 0.1; % px^2 / s
   SPTSim.SimParams.KOffToOn = 0.9;
   SPTSim.SimParams.KOnToOff = 0.05;
   SPTSim.SimParams.Intensity = 1000;
   SPTSim.createSimulation()
```
See [defineDefaultParams](defineDefaultParams.m)
for definitions of the above parameters.

----

methods:
- **[applyBoundaryCondition](applyBoundaryCondition.m)**:
  applies a boundary condition to Trajectories
- **[applyCoordMask](applyCoordMask.m)**:
  applies a (discrete) mask to the provided coordinates
- **[applyLabelingEfficiency](applyLabelingEfficiency.m)**:
  randomly discards trajectories to mimic labeling
- **[applyMeasurementModel](applyMeasurementModel.m)**:
  simulates measurement effects in trajectories
- **[convertTrajToSMD](convertTrajToSMD.m)**:
  converts a TrajStruct to an SMD
- **[createSimulation](createSimulation.m)**:
  creates simulated trajectories
- **[defineDefaultParams](defineDefaultParams.m)**:
  creates a ParamStruct with all default values set
  (see the actual method for further details)
- **[enforcePeriodicBoundary](enforcePeriodicBoundary.m)**:
  breaks trajectories that hit a periodic boundary
- **[makeExampleSim](makeExampleSim.m)**:
  prepares a basic two channel SPT simulation
- **[simEmitterKinetics](simEmitterKinetics.m)**:
  simulates blinking and photobleaching
- **[simOligomers](simOligomers.m)**:
  simulates oligomerization between trajectories
- **[simTrajBrownian](simTrajBrownian.m)**:
  simulates Brownian trajectories
- **[simTrajectories](simTrajectories.m)**:
  simulates trajectories with oligomerization

./MATLAB/+smi_sim/@SimSPT/applyLabelingEfficiency.m
function [TrajStruct, KeepInd] = applyLabelingEfficiency(...
    TrajStruct, LabelingEfficiency)
%applyLabelingEfficiency randomly discards trajectories to mimic labeling.
% This method will randomly discard trajectories from TrajStruct
% based on the labeling efficiency.  Note that not all fields of 
% TrajStruct will be updated (e.g., the PeriodicityMapT, which will
% not be updated due to complications in doing so).
%
% INPUTS:
%   TrajStruct: Structure with information about the trajectories (see, 
%               e.g., usage in smi_sim.SimSPT.simTrajectories())
%   LabelingEfficiency: Labeling efficiency (i.e., the probability that a
%                       trajectory will be labeled). 
%                       (scalar between 0 and 1)(Default = 1)
%
% OUTPUTS:
%   TrajStruct: Input 'TrajStruct' after discarding unlabeled trajectories.
%   KeepInd: Indices from the original input 'TrajectoryStruct'
%            trajectories that were kept after labeling.

% Created by:
%   David J. Schodt (Lidke Lab, 2021)


% Set defaults.
if (~exist('LabelingEfficiency', 'var') || isempty(LabelingEfficiency))
    LabelingEfficiency = 1;
end

% Simulate labeling.
NTrajectories = size(TrajStruct.Trajectories, 1);
KeepInd = sort(...
    randperm(NTrajectories, round(LabelingEfficiency*NTrajectories)));
TrajStruct.Trajectories = ...
    TrajStruct.Trajectories(KeepInd, :, :);
TrajStruct.IsOn = TrajStruct.IsOn(KeepInd, :);
TrajStruct.D = TrajStruct.D(KeepInd);
TrajStruct.ConnectionMapT = TrajStruct.ConnectionMapT(KeepInd, :);


end
./MATLAB/+smi_sim/@SimSPT/applyBoundaryCondition.m
function [Trajectories, PeriodicityMap, ConnectionMap] = ...
    applyBoundaryCondition(...
    Trajectories, BoundaryCondition, FrameSize, ConnectionMap)
%applyBoundaryCondition applies a boundary condition to Trajectories.
% This method applies the specified 'BoundaryCondition' to the trajectories
% in 'Trajectories'.  For example, for a periodic boundary condition, the
% trajectories will be modified to ensure that localizations outside of
% the frame are periodically wrapped to the opposite side of the frame.
%
% NOTE: The method enforcePeriodicBoundary() can be used after this
%       method is applied to ensure trajectories that interact with a
%       periodic boundary are split into two distinct trajectories (i.e.,
%       two different rows in the array 'Trajectories').
%
% INPUTS:
%   Trajectories: Array of 2D trajectories. (NTrajx1x2)
%   BoundaryCondition: Boundary condition to be applied. (char array)
%                      'free': no changes are made at boundaries.
%                      'reflecting': trajectories bounce off of boundaries.
%                      'periodic': trajectories are periodically wrapped to
%                                  the opposite side of the frame.
%   FrameSize: Size of the frame defining the boundaries.
%              (pixels)(2x1 array)
%   ConnectionMap: Index mapping indicating oligomerization between
%                  trajectories. (see, e.g.,
%                  smi_sim.SimSPT.simOligomers() for usage)
%                  (NTrajx1)
% OUTPUTS:
%   Trajectories: Input 'Trajectories' updated by the boundary conditions.
%   PeriodicityMap: Logical array indicating trajectories for which a
%                   periodic boundary condition was applied. (NTrajx1)
%   ConnectionMap: Input 'ConnectionMap' after breaking up oligomers that
%                  hit a boundary.

% Created by:
%   David J. Schodt (Lidke Lab, 2021) with boundary condition usage
%       modified from the script InteractingParticles.m (unknown author(s)
%       in the Lidke Lab)


% Apply the boundary condition.
PeriodicityMap = zeros(size(ConnectionMap), 'logical');
switch lower(BoundaryCondition)
    case 'periodic'
        TrajModFrameSize = ...
            [mod(Trajectories(:, 1, 1), FrameSize(1)), ...
            mod(Trajectories(:, 1, 2), FrameSize(2))];
        PeriodicityMap = any(TrajModFrameSize ...
            ~= reshape(Trajectories(:, 1, :), [], 2), 2);
        ConnectionMap = ConnectionMap .* ~PeriodicityMap;
        Trajectories(:, 1, 1) = TrajModFrameSize(:, 1);
        Trajectories(:, 1, 2) = TrajModFrameSize(:, 2);
    case 'reflecting'
        Trajectories(:, 1, 1) = Trajectories(:, 1, 1) ...
            + 2*((FrameSize(1)-Trajectories(:, 1, 1)) ...
            .*(Trajectories(:, 1, 1)>FrameSize(1)));
        Trajectories(:, 1, 2) = Trajectories(:, 1, 2) ...
            + 2*((FrameSize(2)-Trajectories(:, 1, 2)) ...
            .*(Trajectories(:, 1, 2)>FrameSize(2)));
        Trajectories(:, 1, :) = Trajectories(:, 1, :) ...
            - 2*Trajectories(:, 1, :).*(Trajectories(:, 1, :)<0);
end


end
./MATLAB/+smi_sim/@SimSPT/simEmitterKinetics.m
function [TrajStruct] = simEmitterKinetics(TrajStruct, SimParams)
%simEmitterKinetics simulates blinking and photobleaching.
% This method modifies the trajectories in 'TrajStruct' to simulate
% blinking (transitions from visible to dark, dark to visible) and
% photobleaching.
%
% INPUTS:
%   TrajStruct: Structure containing trajectory data (see
%               smi_sim.SimSPT.simTrajectories())
%   SimParams: Structure of simulation parameters (see
%              smi_sim.SimSPT.defineDefaultParams())
%
% OUTPUTS:
%   TrajStruct: Input 'TrajStruct' updated based on the simulated emitter
%               kinetics.

% Created by:
%   David J. Schodt (Lidke Lab, 2021)


% Convert some parameters to units of subframes.
KOnToOffSub = SimParams.KOnToOff / SimParams.SubframeDensity;
KOffToOnSub = SimParams.KOffToOn / SimParams.SubframeDensity;
KOnToBleachSub = SimParams.KOnToBleach / SimParams.SubframeDensity;
IntensitySub = SimParams.Intensity / SimParams.SubframeDensity;

% Loop through all of the trajectories and simulate blinking.
NTraj = size(TrajStruct.Trajectories, 1);
NSubframes = SimParams.NFrames * SimParams.SubframeDensity;
IsOn = KOnToOffSub*zeros(NTraj, NSubframes, 'logical') ...
    | ~KOnToOffSub*ones(NTraj, NSubframes, 'logical');
IsBleached = zeros(NTraj, NSubframes, 'logical');
BlinkOn = zeros(NTraj, NSubframes, 'logical');
BlinkOff = zeros(NTraj, NSubframes, 'logical');
if ((KOnToOffSub>0) || (KOnToBleachSub>0))
    % Initialize the (existing) particles to an equilibrium state.
    IsOn(:, 1) = (rand(NTraj, 1) ...
        < (KOffToOnSub/(KOnToOffSub+KOffToOnSub)));
    PhotonsSub = single(IntensitySub * IsOn);
    
    % Loop through frames and simulate the emitter kinetics using SR
    % latches.
    KBRatio = KOnToBleachSub / (KOnToOffSub+KOnToBleachSub);
    for ff = 2:NSubframes
        % Define the set and reset signals.  The set signal is based on the
        % the probability of turning on sometime in frame ff (given that
        % it's not already on or bleached).  The reset signal is based on
        % the probability of blinking off or bleaching in frame ff (given
        % that it's not already off or bleached).
        RandomArray = rand(NTraj, 1);
        SetOn = (~(IsOn(:, ff-1)|IsBleached(:, ff-1)) ...
            & (RandomArray<(1-exp(-KOffToOnSub))));
        ResetOff = (IsOn(:, ff-1) ...
            & (RandomArray<(1-exp(-(KOnToOffSub+KOnToBleachSub)))));
        BlinkOn(:, ff) = SetOn;
        BlinkOff(:, ff) = ResetOff;
        
        % Define the set signal for the bleaching latch. The reset signal
        % is always false since bleaching isn't reversible.
        % NOTE: We can't use the previously sampled RandomArray here since
        %       this is a separate set of "coin flips" from those above.
        SetBleach = (IsOn(:, ff-1) ...
            & ResetOff ...
            & (rand(NTraj, 1)<KBRatio));
        
        % Update the IsOn and IsBleached arrays for the ff-th frame. IsOn
        % is given by the standard SR latch equation in terms of the set
        % and reset signals.  IsBleached is either propagating a previous
        % bleaching signal, or is determining if the "Reset" above was a
        % blinking off or a bleaching event.
        IsOn(:, ff) = (SetOn | (IsOn(:, ff-1)&(~ResetOff)));
        IsBleached(:, ff) = (SetBleach | IsBleached(:, ff-1));
        
        % For emitters that turned on or off, determine how many photons
        % were emitted during the frame they came on/turned off. 
        % NOTE: An emitter turning on or off can be considered a Poisson
        %       arrival event, and as such the event time within the
        %       subframe is just a uniform random number between 0 and 1 (0
        %       is the start of the frame and 1 is the end of the frame).
        TOn = rand(sum(SetOn), 1);
        TurnedOff = (ResetOff & IsOn(:, ff));
        TOff = rand(sum(TurnedOff), 1);
        PhotonsSub(:, ff) = IntensitySub * IsOn(:, ff);
        PhotonsSub(SetOn, ff) = IntensitySub * (1-TOn);
        PhotonsSub(TurnedOff, ff) = IntensitySub * (1-TOff);
    end
else
    PhotonsSub = IntensitySub * ones(NTraj, NSubframes, 'single');
end

% Remove trajectories that were never visible.
% NOTE: TrajectoryStruct.IsOnSub must be checked so that we aren't allowing
%       trajectories to blink on before their birth from a periodic 
%       boundary.
IsOn = (IsOn & TrajStruct.IsOn);
NotAlwaysOff = ~all(~IsOn, 2);
TrajStruct.IsOn = IsOn(NotAlwaysOff, :);
TrajStruct.IsBleached = IsBleached(NotAlwaysOff, :);
TrajStruct.BlinkOn = BlinkOn(NotAlwaysOff, :);
TrajStruct.BlinkOff = BlinkOff(NotAlwaysOff, :);
TrajStruct.D = TrajStruct.D(NotAlwaysOff);
TrajStruct.Photons = PhotonsSub(NotAlwaysOff, :);
TrajStruct.Photons_SE = TrajStruct.Photons_SE(NotAlwaysOff, :);
TrajStruct.Bg = TrajStruct.Bg(NotAlwaysOff, :);
TrajStruct.Bg_SE = TrajStruct.Bg_SE(NotAlwaysOff, :);
TrajStruct.ConnectionMapT = ...
    TrajStruct.ConnectionMapT(NotAlwaysOff, :);
TrajStruct.Trajectories = ...
    TrajStruct.Trajectories(NotAlwaysOff, :, :);
TrajStruct.Trajectories_SE = ...
    TrajStruct.Trajectories_SE(NotAlwaysOff, :, :);


end
./MATLAB/+smi_sim/@SimSPT/applyMeasurementModel.m
function [TrajStruct, TrajStructModel] = ...
    applyMeasurementModel(TrajStruct, SimParams)
%applyMeasurementModel simulates measurement effects in trajectories.
% This method simulates some measurement effects (e.g., motion blur and
% missed localizations of visible emitters) for trajectories in
% 'TrajStructModel'.
%
% INPUTS:
%   TrajStruct: Structure containing trajectory data (see
%               smi_sim.SimSPT.simTrajectories())
%   SimParams: Structure of simulation parameters (see
%              smi_sim.SimSPT.defineDefaultParams())
%
% OUTPUTS:
%   TrajStruct: Input 'TrajStruct' after applying the measurement model.
%   TrajStructModel: Input 'TrajStruct' after motion blurring but before
%                    applying measurement noise.

% Created by:
%   David J. Schodt (Lidke Lab, 2021)


% Simulate motion blur by combining simulated subframes into a single
% frame.
NTraj = size(TrajStruct.Trajectories, 1);
NPadding = mod(SimParams.NFrames, SimParams.SubframeDensity);
if (SimParams.SubframeDensity > 1)
    % Grab a few arrays out of the TrajectoryStruct and pad them to ensure
    % each trajectory length is divisible by SubframeDensity.
    NaNPadArray = NaN(NTraj, NPadding);
    IsOnSub = [TrajStruct.IsOn, zeros(NTraj, NPadding, 'logical')];
    PhotonsSub = [TrajStruct.Photons, zeros(NTraj, NPadding)];
    XSub = [TrajStruct.Trajectories(:, :, 1), NaNPadArray];
    YSub = [TrajStruct.Trajectories(:, :, 2), NaNPadArray];
    
    % Apply the measurement model one trajectory at a time (it's a bit
    % easier this way, although probably slower).
    NaNArray = NaN(NTraj, SimParams.NFrames);
    IsOn = zeros(NTraj, SimParams.NFrames, 'logical');
    Photons = NaNArray;
    X = NaNArray;
    Y = NaNArray;
    XY_SE = NaNArray;
    for nn = 1:NTraj
        % Reshape arrays for this trajectory to assist in conversion from
        % subframes to frames.
        IsOnCurrent = reshape(IsOnSub(nn, :), ...
            SimParams.SubframeDensity, SimParams.NFrames).';
        PhotonsCurrent = reshape(PhotonsSub(nn, :), ...
            SimParams.SubframeDensity, SimParams.NFrames).';
        XYVarCurrent = (SimParams.PSFSigma^2) ./ PhotonsCurrent;
        XCurrent = reshape(XSub(nn, :), ...
            SimParams.SubframeDensity, SimParams.NFrames).';
        YCurrent = reshape(YSub(nn, :), ...
            SimParams.SubframeDensity, SimParams.NFrames).';
        
        % Perform the conversion from subframes to frames (approximate
        % motion blurring). For photons, we can just take the sum. The
        % positions and standard errors will be estimated as though each
        % subframe is another observation of the same Gaussian (like we do
        % in frame connection). Note that this probably isn't the best way
        % to simulate motion blur, as the smearing over subframes will
        % likely give us a higher standard error than we're estimating
        % here.
        IsOn(nn, :) = any(IsOnCurrent, 2);
        Photons(nn, :) = sum(PhotonsCurrent, 2);
        XY_SE(nn, :) = sqrt(1 ./ sum(1./XYVarCurrent, 2));
        X(nn, :) = sum(XCurrent./XYVarCurrent, 2) ...
            ./ sum(1./XYVarCurrent, 2);
        Y(nn, :) = sum(YCurrent./XYVarCurrent, 2) ...
            ./ sum(1./XYVarCurrent, 2);
    end
    TrajStructModel.Photons = Photons;
    TrajStructModel.Photons_SE = sqrt(Photons);
    TrajStructModel.Bg = SimParams.Bg * ones(size(Photons));
    TrajStructModel.Bg_SE = sqrt(TrajStructModel.Bg);
    TrajStructModel.Trajectories = cat(3, X, Y);
    TrajStructModel.Trajectories_SE = repmat(XY_SE, 1, 1, 2);
else
    TrajStructModel = TrajStruct;
    TrajStructModel.Photons_SE = sqrt(TrajStructModel.Photons);
    TrajStructModel.Bg_SE = sqrt(TrajStructModel.Bg);
    TrajStructModel.Trajectories_SE = ...
        repmat(SimParams.PSFSigma ./ sqrt(TrajStructModel.Photons), 1, 1, 2);
end
TrajStructModel.IsOn = (TrajStructModel.IsOn ...
    & (TrajStructModel.Photons>=SimParams.MinIntensity));
TrajStruct = TrajStructModel;
TrajStruct.Photons = poissrnd(TrajStruct.Photons);
TrajStruct.Bg = poissrnd(TrajStruct.Bg);
TrajStruct.Trajectories = TrajStruct.Trajectories ...
    + TrajStructModel.Trajectories_SE.*randn(NTraj, SimParams.NFrames, 2);


end
./MATLAB/+smi_sim/@SimSPT/createSimulation.m
function [] = createSimulation(obj)
%createSimulation creates simulated trajectories.
% This method is the primary user-focused method in the smi_sim.SimSPT
% class, meaning that most users will only need to use this method.  The
% intention is that this method can generate all of the vital results
% needed when simulating trajectories.  Several class properties are copied
% as outputs accessible to the user for convenience (although they can
% still be accessed in the class instance obj)

% Created by:
%   David J. Schodt (Lidke Lab, 2021)


% Simulate diffusing targets and, if needed, oligomerization between those
% diffusing targets.
obj.TrajStructSubTrue = obj.simTrajectories(obj.SimParams);

% Simulate the effect of labeling efficiency.
obj.TrajStructSubLabeled = obj.applyLabelingEfficiency(...
    obj.TrajStructSubTrue, obj.SimParams.LabelingEfficiency);

% Simulate the emitter kinetics (e.g., blinking and bleaching).
obj.TrajStructSubModel = obj.simEmitterKinetics(...
    obj.TrajStructSubLabeled, obj.SimParams);

% Simulate measurement effects (e.g., motion blur, camera noise, etc.)
[obj.TrajStruct, obj.TrajStructModel] = obj.applyMeasurementModel(...
    obj.TrajStructSubModel, obj.SimParams);


end
./MATLAB/+smi_sim/@SimSMLM/simStar.m
function simStar(obj,NWings)
    
    % This function simulates the Siemen star and returns the frames
    % with particles distributed uniformaly on the wings of the star.
    
    % INPUT:
    
    % obj: The object of the SimSMLM() class.
    
    % NWings: The number of wings of the Siemen's star.
    
    % OUTPUTS:
    
    % [SMD_True]: This is a structure with the following fields:
    
    % SMD_True.X: The X-positions of particles generated randomly.
    % (Number of the generated particles x 1)(Pixels)
    
    % SMD_True.Y: The Y-positions of particles generated randomly
    % (Number of the generated particles x 1),(Pixels)
    
    % SMD_True.Z: The Z-positions of particles generated randomly
    % (Number of the generated particles x 1), (um)
    
    
    R = obj.SZ/3; %The length of the wing is a third of the size of the frame
    
    % To facilitate the calculations, we will work in both polar and
    % Cartesian coordinates. The random particles will be generated
    % throughout a cycle and then we remove those that are not
    % inside any wing.
    
    
    if nargin()<2
        NWings=16;
    end
            
    
    Alpha = -pi:2*pi/NWings:pi; %The angle that each wing starts and ends.
    Nn=poissrnd(floor(pi*R^2*obj.Rho)); % Nn are the number of emitters.
    X = 2*(rand(Nn,1)-0.5);
    Y = 2*(rand(Nn,1)-0.5);
    IndZero=find(X.^2 + Y.^2>1);
    X(IndZero)=0;
    Y(IndZero)=0;
    [Theta,~] = cart2pol(X,Y);
    
    for ij = 1:2:NWings
        % i and j represent the ith particle in the jth frame.
        BInd = find(Alpha(ij)<Theta & Theta<Alpha(ij+1));
        X(BInd)=0;
        Y(BInd)=0;
    end
    
    % Delete those particles from the list that are not inside any wing.
    DInd = find(X==0);
    DInd = find(Y==0);
    X(DInd)=[];
    Y(DInd)=[];
    LabelCoords(:,1)=X.*R+obj.SZ/2;
    LabelCoords(:,2)=Y.*R+obj.SZ/2;

    %Saving the generated data in the structure SMD.
    obj.SMD_True = smi_core.SingleMoleculeData.createSMD();
    
    obj.SMD_True.X = LabelCoords(:,1);
    obj.SMD_True.Y = LabelCoords(:,2);
    if isscalar(obj.PSFSigma)
        obj.SMD_True.Z = [];
    end
    obj.SMD_True.XSize = obj.SZ;
    obj.SMD_True.YSize = obj.SZ;

    obj.genModel()
    
end

./MATLAB/+smi_sim/@SimSMLM/genImageStack.m
function [Model, Data] = genImageStack(obj)
%genImageStack generates image stacks without and with Poisson noise.
%
% INPUTS:
%    obj            SimSMLM object
%       SMD_Model   labeled true coordinates with blinks
%       PSFSigma    point spread function sigma size (Pixels)
%       Bg          background count rate (counts/pixel)
%
% OUTPUTS:
%    Model          Gaussian blob image stack that is noiseless
%    Data           [OPTIONAL] Gaussian blob image stack corrupted with Poisson
%                   noise

% Created by:
%    Sajjad Khan and Michael Wester (2021, LidkeLab)

   % Generate the blobs without Poisson noise.  Copy the SMD structure.
   SMD_Model = obj.SMD_Model;
   % Below needed for generating blob images.
   %SMF = smi_core.SingleMoleculeFitting();
   %SMF.BoxFinding.BoxSize = ceil(4 * 2 * obj.PSFSigma);
   % Temporarily convert FrameNum into an absolute frame number for the call
   % to gaussBlobImage.  Need a less resource intensive way to incorporate
   % NDatasets > 1.
   NFrames = obj.NDatasets * obj.NFrames;
   FrameNum = SMD_Model.FrameNum;
   SMD_Model.NDatasets = 1;
   SMD_Model.NFrames = NFrames;
   SMD_Model.FrameNum = (SMD_Model.DatasetNum - 1) * obj.NFrames + FrameNum;
   [Model] = smi_sim.GaussBlobs.gaussBlobImage(SMD_Model);
   % Add in background.
   Model = Model + obj.Bg;

   if nargout > 1
      % Corrupt with Poisson noise.
      Data = poissrnd(single(Model));
      NoisyImage = zeros(size(Data(:, :, 1)));
      Data = Data + randn(size(Data)) .* repmat(NoisyImage, [1, 1, NFrames]);
   end

end

./MATLAB/+smi_sim/@SimSMLM/unitTest.m
function success = unitTest()

   success = 0;

   SaveDir = smi_helpers.mkSMITETmpDir('unitTest', 'SimSMLM');

   obj = smi_sim.SimSMLM();
   obj.SZ = 256;
   obj.Rho = 30;
   obj.NDatasets = 2;
   obj.NFrames = 10;
   obj.ZoomFactor = 2;
   obj.K_OnToOff = 1;
   obj.K_OffToOn = 0.005;
   obj.K_OnToBleach = 0.2;
   obj.EmissionRate = 1000;
   obj.Bg = 15;
   obj.PSFSigma = 1.3;
   obj.StartState = 'Equib';
   obj.LabelingEfficiency = 1;

   NWings = 16;
   obj.simStar(NWings);
   SMD_Data = obj.genNoisySMD(obj.SMD_Model);
   
   [Model, Data] = obj.genImageStack();

   % Display the blobs without noise:
   figure; imagesc(sum(Model, 3)); colormap(gca, gray(256));
   saveas(gcf, fullfile(SaveDir, 'Model.png'));
   %dipshow(Model)
   
    % Display the blobs having Poisson noise:
   figure; imagesc(sum(Data, 3)); colormap(gca, gray(256));
   saveas(gcf, fullfile(SaveDir, 'Data.png'));
   %dipshow(Data)

   success = 1;
    
end

./MATLAB/+smi_sim/@SimSMLM/genModel.m
function genModel(obj)
%genModel generates SMD_Labeled and SMD_Model from SMD_True.
%
% Typical data flows are
%    produce noisy coordinates:
%       SMD_True -> SMD_Labeled -> SMD_Model -> SMD_Data
%    produce noisy image stacks
%       SMD_True -> SMD_Labeled -> SMD_Model -> Model -> Data
% where
%   SMD_True      true locations of localizations
%   SMD_Labeled   obj.LabelingEfficiency applied to SMD_True localizations,
%                 removing localizations that are not labeled
%   SMD_Model     blinks generated for SMD_Labeled localizations applied
%
% INPUTS:
%    obj          smi_sim.SimSMLM object (see SimSMLM for properties)
   
% Created by
%    Sajjad Khan and Michael J. Wester (Lidkelab 2021)

   % Apply labeling efficiency.
   if isempty(obj.LabelingEfficiency)
      error('applyLabelEffic must define LabelingEfficiency!');
   end
   % Transform obj.SMD_True into obj.SMD_Labeled.
   obj.applyLabelEffic();
   
   % Generate blinks (units are pixels).
   if isempty(obj.StartState)
      error('genBlinks must define StartState!');
   end
   % Transform obj.SMD_Labeled into obj.SMD_Model.
   obj.genBlinks(obj.StartState);

end

./MATLAB/+smi_sim/@SimSMLM/genBlinks.m
function genBlinks(obj,StartState)

%This function generates the blinking time traces for a single particle 
%over the given number of the frames considering the input parameters and
%returns the SMD_Model structure. 

 % INPUTS:
 
 % obj: The object of the SimSMLM() class.
 
 % [obj.SMD_Labeled]: This is a structure with the following three fields:
 
 % obj.SMD_Labeled.X: The X-positions of particles generated randomly.
 % (Number of the generated particles x 1)(Pixels)
    
 % obj.SMD_Labeled.Y: The Y-positions of particles generated randomly
 % (Number of the generated particles x 1),(Pixels)
    
 % obj.SMD_Labeled.Z: The Z-positions of particles generated randomly
 % (Number of the generated particles x 1), (um)

 % obj.SparseFlag: If true, turns on using sparse matrices in genBlinks,
 % allowing it to accomodate larger examples.  However, sparse matrices
 % are also slower to manipulate than regular ones especially for
 % smaller examples, so shouldn't be used unless needed, thus the
 % default is false.
 
 % StartState: A string which determine if the particle starts on or
 % starts randomly on or off. It can be either 'on' or 'Equib'.
 
 % OUTPUTS:
 
 % [obj.SMD_Model]: This is a structure with the following fields:
 
 % obj.SMD_Model.X: The X-positions of the particles seen on the frames.
 % (Number of the seen particles x 1),(Pixels)
    
 % obj.SMD_Model.Y: The Y-positions of the particles seen on the frames.
 % (Number of the seen particles x 1),(Pixels)
    
 % obj.SMD_Model.Z: The Z-positions of particles (um)
    
 % obj.SMD_Model.Photons: The intensity of the particles.
 % (Number of the seen particles x 1),(Photon counts)
    
 % obj.SMD_Model.FrameNum:The frames that the particles have been detected.
 % (Number of the seen particles x 1)

 % obj.SMD_Model.NFrames:The number of frames that the particles have been detected.

 % obj.SMD_Model.DatasetNum:The dataset that corresponds to the FrameNum.
 % (Number of the seen particles x 1)

 % obj.SMD_Model.NDatasets: The number of datasets in which to organize the frames.
 
 % obj.SMD_Model.PSFSigma: Point Spread Function Sigma size (Pixels)
 
 % obj.SMD_Model.Bg: Background Count Rate (counts/pixel), this will be empty.

% First making empty vectors that will be filled later.
NLabels = numel(obj.SMD_Labeled.X);
Photons=[];
X=[];
Y=[];
Z=[];
FrameNum=[];
PSFSigma=[];
Bg=[];
TotalNFrames = obj.NDatasets*obj.NFrames;
NOnEvents = zeros(NLabels, 1, 'uint8');   % number of on events

% obj.SMD_Model.ConnectID: SMD_Labeled -> SMD_Model
% ConnectID produces an indexing array that associates each localization in
% SMD_Model with the localization that produced it in SMD_Labeled.  That is,
%
%    obj.SMD_Labeled.X(obj.SMD_Model.ConnectID) == obj.SMD_Model.X
%
% where SMD_Model.ConnectID has the same dimensions as SMD_Model.X/Y/etc.  For
% example,
%
%    obj.SMD_Model.X(k) == obj.SMD_Labeled.X(obj.SMD_Model.ConnectID(k))
%
% for k = 1 : numel(obj.SMD_Model.X).
ConnectID = [];

if obj.SparseFlag
   IntArray = sparse(NLabels, TotalNFrames);
else
   IntArray = zeros(NLabels, TotalNFrames);
end

%The following loop iterates over each particle to generate the blinking
%events for them.

for mm=1:NLabels
    [Temp, NTime] = blinks(obj.K_OnToOff, obj.K_OffToOn, obj.K_OnToBleach, ...
                           TotalNFrames, StartState);
    NOnEvents(mm) = NTime;
    
    %Blinks() makes the blinking events. It takes the following inputs:
    
    %K_OnToOff: Fluorophore turns Off from On state (default:1 frames^-1)
 
    %K_OffToOn: Fluorophore return to On state from Off state (default:0.0005 frames^-1)
 
    %K_OnToBleach: Fluorophore bleaches (default:1/5 frames^-1)
 
    %TotalNFrames: Total number of frames (pixels x pixels)
    
    %StartState: A string which determine if the particle starts on or
    %starts randomly on or off. It can be either 'on' or 'Equib'.
    
    IntArray(mm,:)=Temp';
    %Finding the frames where the particle was ON. Note that the
    %particle might not be on at all and this would be an empty
    %array. In this case, we won't have any FrameNum, Photons or
    %found positions for this particle.
    FrameNumIndiv = find(Temp~=0);
    if ~isempty(FrameNumIndiv) 
        FrameNum = cat(1,FrameNum,FrameNumIndiv);
        Indiv = obj.EmissionRate*Temp(FrameNumIndiv);
        Photons = cat(1,Photons,Indiv);
        %Indiv(:,1)=obj.LabelCoords(mm,1);
        Indiv(:,1)=obj.SMD_Labeled.X(mm);
        X = cat(1,X,Indiv);
        %Indiv(:,1)=obj.LabelCoords(mm,2);
        Indiv(:,1)=obj.SMD_Labeled.Y(mm);
        Y = cat(1,Y,Indiv);
        nF = numel(FrameNumIndiv);
        ConnectID = [ConnectID; repmat(mm, nF, 1)];
    end
end
obj.SMD_Model = obj.SMD_Labeled;
obj.SMD_Model.X = X;
obj.SMD_Model.Y = Y;
if isscalar (obj.PSFSigma) 
    obj.SMD_Model.Z = [];
    obj.SMD_Model.PSFSigma = obj.PSFSigma*ones([length(Photons),1]);
end
obj.SMD_Model.Photons    = Photons;
obj.SMD_Model.Bg         = 0;
obj.SMD_Model.NDatasets  = obj.NDatasets;
obj.SMD_Model.NFrames    = obj.NFrames;
AbsoluteFrameNum = FrameNum;
obj.SMD_Model.DatasetNum = zeros(size(AbsoluteFrameNum));
obj.SMD_Model.FrameNum   = zeros(size(AbsoluteFrameNum));
% Convert absolute frame numbers to per dataset frame numbers.
lo = 1;
for i = 1 : obj.NDatasets
   hi = lo + obj.NFrames - 1;
   indx = find(lo <= AbsoluteFrameNum & AbsoluteFrameNum <= hi);
   obj.SMD_Model.DatasetNum(indx) = i;
   obj.SMD_Model.FrameNum(indx) = AbsoluteFrameNum(indx) - lo + 1;
   lo = lo + obj.NFrames;
end
obj.SMD_Model.ConnectID = ConnectID;
obj.NOnEvents = NOnEvents;
    
    %Nested function to generate blinking events.
    function [IvsT,NTime]=...
       blinks(K_OnToOff,K_OffToOn,K_OnToBleach,NFrames,StartState)
    %Blinks() generates blinking time trace for a single
    %particle over the given number of the frames considering
    %the parameters K_OffToOn, K_OnToOff and K_OnToBleach.
    
    NTime=0; %Number of the times that the particle goes on.
    
    %Based on the input 'StartState' the particle can start in the
    %on-state or it can be started randomly in either on-state or
    %off-state.
    switch StartState
        case 'On'
            T=0; %The time when the particle goes on. T=0 implies
            %that the particle is on from the beginning.
        case 'Equib'
            %Find start state:
            State=rand < (K_OffToOn/(K_OffToOn+K_OnToOff));
            %Randomly determine if the particle starts off or on.
            if State %starts on
                T=0;
            else %starts from off
                T=exprnd(1/K_OffToOn); %The random time when the particle goes on.
            end
    end
    
    %The following while-loop gives the times when the particle
    %goes on, goes off and photobleach.
    
    while T<NFrames
        NTime=NTime+1;
        % TRate (Time rate) is an array of 3 columns, where the first column gives
        % the times when the particle goes on, the second column gives the
        % time when the particle goes off and third column gives the time
        % when particle photobleaches.
        TRate(NTime,1)=T;
        D=exprnd(1/(K_OnToOff+K_OnToBleach)); %Generate blink duratrion
        TRate(NTime,2)=min(T+D,NFrames); %The On-time plus the duration gives the off-time.
        if rand() > (K_OnToOff/(K_OnToOff+K_OnToBleach)) %fluorophore bleaches
           TRate(NTime,3)=rand();
           break;
        end
        %if this condition is met.
        T=T+D+exprnd(1/K_OffToOn); %Advance to the next blinking event.
    end
    
    %Turn blinking events to I vs T
    IvsT=zeros(NFrames,1);
    for nn=1:NTime
        StartT=floor(TRate(nn,1))+1; %index for start frame
        EndT=min(NFrames,floor(TRate(nn,2))+1); %index for start frame
        if StartT==EndT %Blinking happens within one frame
            IvsT(StartT)=TRate(nn,2)-TRate(nn,1);
        else
            %This for-loop goes over the frames where the particle is on.
            for ii=StartT:EndT
                if ii==StartT
                    IvsT(ii)=StartT-TRate(nn,1);
                elseif ii==EndT
                    IvsT(ii)=1-(EndT-TRate(nn,2));
                else
                    IvsT(ii)=1;
                end
            end
        end
    end

    end % Blinks

end % genBlinks

./MATLAB/+smi_sim/@SimSMLM/genNoisySMD.m
function [SMD_Data] = genNoisySMD(obj,SMD_Model)
%genNoisySMD takes the SMD_Model struct as an input, generates the noisy 
% SMD struct and return SMD_Data with the following fields: 
%
% OUTPUTS:
%    SMD_Data.X
%    SMD_Data.Y
%    SMD_Data.X_SE
%    SMD_Data.Y_SE
%    SMD_Data.PSFSigma
%    SMD_Data.FrameNum
%    SMD_Data.Photons
%    SMD_Data.Bg

   % Copy all fields from SMD_Model into SMD_Data.
   if nargin<2
       SMD_Model=obj.SMD_Model;
   end

   SMD_Data = SMD_Model;

   SMD_Data.X_SE=(obj.PSFSigma)./sqrt(SMD_Model.Photons);
   SMD_Data.X=SMD_Data.X+randn(size(SMD_Data.X_SE)).*SMD_Data.X_SE;

   SMD_Data.Y_SE=(obj.PSFSigma)./sqrt(SMD_Model.Photons);
   SMD_Data.Y=SMD_Data.Y+randn(size(SMD_Data.Y_SE)).*SMD_Data.Y_SE;

   %SMD_Data.Photons=SMD_Model.Photons;

   SMD_Data.PSFSigma=SMD_Model.PSFSigma;

   %SMD_Data.FrameNum=SMD_Model.FrameNum;

   SMD_Data.Bg=obj.Bg.*ones([length(SMD_Model.Photons),1]);

end

./MATLAB/+smi_sim/@SimSMLM/SimSMLM.m
classdef SimSMLM < handle
    
    % SimSMLM is a Single Molecule Localization Microscopy data generating
    % class. This class can produce Siemen's star shaped data with particles
    % distributed uniformly throughout the frames. The blinking events are
    % produced based on the given rate parameters (K_OnToOff, K_OffToOn and
    % K_OnToBleach). The data has the same uniform background noise for the
    % whole sequence. The output is corrupted with Poisson noise.
    
    % Typical data flows are
    %    produce noisy coordinates:
    %       SMD_True -> SMD_Labeled -> SMD_Model -> SMD_Data
    %    produce noisy image stacks:
    %       SMD_True -> SMD_Labeled -> SMD_Model -> Model -> Data
    % where
    %   SMD_True      true locations of localizations
    %   SMD_Labeled   obj.LabelingEfficiency applied to SMD_True localizations,
    %                 removing localizations that are not labeled
    %   SMD_Model     blinks generated for SMD_Labeled localizations
    %   SMD_Data      SMD_Model with positional and intensity noise added
    %   Model         Gaussian blob image stack produced from SMD_Model
    %   Data          Model image stack to which Poisson noise has been applied
    %
    % Model and Data are image stacks (n x n x f), where n is the linear size
    % of the image in pixels and f is the total number of frames to be
    % generated (f = obj.NDatasets * obj.NFrames).
    %
    % EITHER, generate an SMD structure with positional and intensity noise.
    % (SMD_Data <- genNoisySMD) OR ALTERNATIVELY, generate the blobs without
    % Poisson noise (Model) and then add it in (Data) [see genImageStack].

    properties
        SZ=256            % Linear size of image (pixels)
        Rho=30            % Fluorophore Density (fluorophore/pixel)
        NDatasets=1       % Number of datasets
        NFrames=1000      % Number of frames per dataset
        ZoomFactor=20     % It can be either smaller or larger than one- CHANGE
        K_OnToOff=1       % Fluorophore turns Off from On state
                          %    (default:1 frames^-1)
        K_OffToOn=0.0005  % Fluorophore return to On state from Off state
                          %    (default:0.0005 frames^-1)
        K_OnToBleach=0.2  % Fluorophore bleached out (default:1/5 frames^-1)
        EmissionRate=1000 % Emission rate (Intensity) of photons (photons/frame)
        Bg=5              % Background Count Rate (counts/pixel)
        PSFSigma=1.3      % Point Spread Function Sigma size (Pixels)
        LabelingEfficiency=1 % Fluorophore labeling efficiency [range: 0 - 1]
        NOnEvents         % Number of on events per localization
        % A string which determine if the particle starts on or starts randomly
        % on or off.  It can be either 'on' or 'Equib'.
        StartState='Equib'
        % SparseFlag, if true, turns on using sparse matrices in genBlinks,
        % allowing it to accomodate larger examples.  However, sparse matrices
        % are also slower to manipulate than regular ones especially for
        % smaller examples, so shouldn't be used unless needed, thus the
        % default is false.
        SparseFlag=false
        Verbose = 1      % Verbosity level

        % Generic note: SMD_* below are SMD structures with various fields
        % filled in as appropriate at that stage.
        SMD_True         % True coordinates produced by sim*
        SMD_Labeled      % True labeled coordinates produced by applyLabelEffic
        SMD_Model        % Coordinates with blinks produced by genBlinks

        % Note SMD_Model.ConnectID: SMD_Labeled -> SMD_Model (see genBlinks)
        % ConnectID produces an indexing array that associates each
        % localization in SMD_Model with the localization that produced it in
        % SMD_Labeled.  That is,
        %
        %    obj.SMD_Labeled.X(obj.SMD_Model.ConnectID) == obj.SMD_Model.X
    end

    methods 
         
        applyLabelEffic(obj)
        genBlinks(obj, StartState)
        [Model, Data] = genImageStack(obj)
        genModel(obj)
        [SMD_Data] = genNoisySMD(obj, SMD_Model)
        simkTets(obj, kk, radius_kTet)
        simStar(obj, NWings)
        
    end 

    properties(SetAccess = protected)

    end

    methods(Static)

        SMD_True = kTet(k, center, radius, startAngle)
        success = unitTest()

    end

end

./MATLAB/+smi_sim/@SimSMLM/genNoisyData.m
function [Data]=genNoisyData(obj,Model)

   [Model] = Model+obj.Bg;
   [Data] = poissrnd(single(Model));
   NoisyImage = zeros(size(Data(:,:,1)));
   [Data] = Data+randn(size(Data)).*repmat(NoisyImage,[1 1 obj.NDatasets*obj.NFrames]);

end

./MATLAB/+smi_sim/@SimSMLM/simkTets.m
function simkTets(obj, kk, radius_kTet)
%simkTet generates 2D k-tets in the simulation region (units are pixels).
% See kTet for further information.  The number of k-tets generated is based on
% the class property Rho (fluorophore density).
%
% INPUTS:
%    kk           order of the k-tets
%    radius_kTet  radius of the circles (pixel)
%
% OUTPUT:
%    obj.SMD_True    SMD structure containing:
%       X, Y         coordinates of the localizations computed (pixel)

% Created by
%    Michael J. Wester (Lidkelab 2021)

   kTetDensity = obj.Rho / kk;   % obj.Rho is in fluorophores/pixel
   n_kTets = round(kTetDensity * obj.SZ^2);
   if obj.Verbose >= 1
      fprintf('Generating %d %d-tets ...\n', n_kTets, kk);
   end
   center_kTet = rand(1, 2) * obj.SZ;
   obj.SMD_True = obj.kTet(kk, center_kTet, radius_kTet);
   for i = 2 : n_kTets
      center_kTet = rand(1, 2) * obj.SZ;
      SMD_True_tmp = obj.kTet(kk, center_kTet, radius_kTet);
      obj.SMD_True = ...
         smi_core.SingleMoleculeData.catSMD(obj.SMD_True, SMD_True_tmp, false);
   end
   obj.SMD_True.NDims = 2;
   obj.SMD_True.XSize = obj.SZ;
   obj.SMD_True.YSize = obj.SZ;

   % Apply labeling efficiency and generate blinks.
   obj.genModel();

end

./MATLAB/+smi_sim/@SimSMLM/kTet.m
function SMD_True = kTet(k, center, radius, startAngle)
%kTet produces a circle of k equally spaced points starting at a random place
% on the circumference unless the optional argument startAngle is provided.
% Each segment centered around a point will subtend an angle of 2 pi/k.  The
% units of the output will be consistent with those of the inputs.
%
% INPUTS:
%    k            order of the k-tet (= number of points generated)
%    center       (x, y) coordinates of the circle's center [1 x 2] (pixel)
%    radius       radius of the circle (pixel)
%    startAngle   [OPTIONAL] starting angle for the first localization (radian)
%
% OUTPUT:
%    SMD_True     SMD structure containing:
%       X, Y         coordinates of the localizations computed

% Created by
%    Michael J. Wester (Lidkelab 2020)

   if k <= 0
      error('kTet: k must be an integer > 0');
   end

   x = zeros(k, 1);
   y = zeros(k, 1);

   kTetAngle = (2 * pi) / k;
   % Start the k-tet at a random location along the circle's circumference.
   if exist('startAngle', 'var')
      theta = startAngle;
   else
      theta = 2 * pi * rand;
   end
   x(1) = center(1) + radius * cos(theta);
   y(1) = center(2) + radius * sin(theta);

   for i = 2 : k
      theta = theta + kTetAngle;
      x(i) = center(1) + radius * cos(theta);
      y(i) = center(2) + radius * sin(theta);
   end

   SMD_True = smi_core.SingleMoleculeData.createSMD();
   SMD_True.X = x;
   SMD_True.Y = y;
   SMD_True.Z = [];

end

./MATLAB/+smi_sim/@SimSMLM/README.md
### +smi_sim/@SimSMLM
    
SimSMLM is a Single Molecule Localization Microscopy data generating
class. This class can produce Siemen's star shaped data or k-tets
with particles
distributed uniformly throughout the frames. The blinking events are
produced based on the given rate parameters (K_OnToOff, K_OffToOn and
K_OnToBleach). The data has the same uniform background noise for the
whole sequence. The output is corrupted with Poisson noise.
```    
Typical data flows are
   produce noisy coordinates:
      SMD_True -> SMD_Labeled -> SMD_Model -> SMD_Data
   produce noisy image stacks:
      SMD_True -> SMD_Labeled -> SMD_Model -> Model -> Data
where
  SMD_True      true locations of localizations
  SMD_Labeled   obj.LabelingEfficiency applied to SMD_True localizations,
                removing localizations that are not labeled
  SMD_Model     blinks generated for SMD_Labeled localizations
  SMD_Data      SMD_Model with positional and intensity noise added
  Model         Gaussian blob image stack produced from SMD_Model
  Data          Model image stack to which Poisson noise has been applied
```
Model and Data are image stacks (n x n x f), where n is the linear size
of the image in pixels and f is the total number of frames to be
generated (f = obj.NDatasets * obj.NFrames).

EITHER, generate an SMD structure with positional and intensity noise.
(SMD_Data <- genNoisySMD) OR ALTERNATIVELY, generate the blobs without
Poisson noise (Model) and then add it in (Data) [see genImageStack].

---

Examples using this class can be found in MATLAB/examples:
- Example_Clustering.m
- Example_StatisticsClustering.m
- Example_simSMLM.m
For example,
```
   %% Example of generating sythetic SMLM data

   %Create sim object

   S=smi_sim.SimSMLM()
   NWings=20
   S.NDatasets=20
   S.SZ = 64;
   S.simStar(NWings)

   % Generate Images 
   [Model,Data]=S.genImageStack();

   % Generate Noisy Coordinates
   [SMD_Noisy]=S.genNoisySMD()
   figure;scatter(SMD_Noisy.X,SMD_Noisy.Y)
```

---

```
properties
   SZ=256            % Linear size of image (pixels)
   Rho=30            % Fluorophore Density (fluorophore/pixel)
   NDatasets=1       % Number of datasets
   NFrames=1000      % Number of frames per dataset
   ZoomFactor=20     % It can be either smaller or larger than one- CHANGE
   K_OnToOff=1       % Fluorophore turns Off from On state
                     %    (default:1 frames^-1)
   K_OffToOn=0.0005  % Fluorophore return to On state from Off state
                     %    (default:0.0005 frames^-1)
   K_OnToBleach=0.2  % Fluorophore bleached out (default:1/5 frames^-1)
   EmissionRate=1000 % Emission rate (Intensity) of photons (photons/frame)
   Bg=5              % Background Count Rate (counts/pixel)
   PSFSigma=1.3      % Point Spread Function Sigma size (Pixels)
   LabelingEfficiency=1 % Fluorophore labeling efficiency [range: 0 - 1]
   NOnEvents         % Number of on events per localization
   % A string which determine if the particle starts on or starts randomly
   % on or off.  It can be either 'on' or 'Equib'.
   StartState='Equib'
   % SparseFlag, if true, turns on using sparse matrices in genBlinks,
   % allowing it to accomodate larger examples.  However, sparse matrices
   % are also slower to manipulate than regular ones especially for
   % smaller examples, so shouldn't be used unless needed, thus the
   % default is false.
   SparseFlag=false
   Verbose = 1      % Verbosity level

   % Generic note: SMD_* below are SMD structures with various fields
   % filled in as appropriate at that stage.
   SMD_True         % True coordinates produced by sim*
   SMD_Labeled      % True labeled coordinates produced by applyLabelEffic
   SMD_Model        % Coordinates with blinks produced by genBlinks

   % Note SMD_Model.ConnectID: SMD_Labeled -> SMD_Model (see genBlinks)
   % ConnectID produces an indexing array that associates each
   % localization in SMD_Model with the localization that produced it in
   % SMD_Labeled.  That is,
   %
   %    obj.SMD_Labeled.X(obj.SMD_Model.ConnectID) == obj.SMD_Model.X
```

---

methods:
- **[applyLabelEffic](applyLabelEffic.m)**:
  applies labeling efficiency to an existing set of fluorophores
- **[genBlinks](genBlinks.m)**:
  generates the blinking time traces for a single particle over the given
  number of the frames considering the input parameters and returns the
  SMD_Model structure
- **[genImageStack](genImageStack.m)**:
  generates image stacks without and with Poisson noise
- **[genModel](genModel.m)**:
  generates SMD_Labeled and SMD_Model from SMD_True
- **[genNoisyData](genNoisyData.m)**:
  generates a noisy image
- **[genNoisySMD](genNoisySMD.m)**:
  takes the SMD_Model struct as an input, generates the noisy SMD struct and
  return SMD_Data
- **[kTet](kTet.m)**:
  produces a circle of k equally spaced points starting at a random place
- **[simStar](simStar.m)**:
  simulates the Siemen star
- **[simkTets](simkTets.m)**:
  generates 2D k-tets in the simulation region

unit test:
- **[unitTest](unitTest.m)**:
  tests the functionality of this class

./MATLAB/+smi_sim/@SimSMLM/applyLabelEffic.m
function applyLabelEffic(obj)
%applyLabelEffic applies labeling efficiency to an existing set of fluorophores.
%
% INPUTS:
%    obj                object of class SimSMLM defined for:
%       LabelingEfficiency   fractional labeling efficiency in range [0 - 1]
%       Verbose              verbosity level
%       SMD_True             an SMD dataset of true localizations
% OUTPUT:
%    obj.SMD_Labeled    an SMD dataset in which unlabeled localizations have
%                       been removed

   Labeled = ones(size(obj.SMD_True.X));
   Labeled(rand(size(obj.SMD_True.X)) > obj.LabelingEfficiency) = 0;
   obj.SMD_Labeled = obj.SMD_True;
   obj.SMD_Labeled.X(~Labeled) = [];
   obj.SMD_Labeled.Y(~Labeled) = [];

   if obj.Verbose >= 1
      fprintf('%d%% labeling efficiency: %d -> %d localizations\n', ...
              round(100 * obj.LabelingEfficiency), numel(Labeled),  ...
              sum(Labeled));
   end

end

./MATLAB/test_core.m
classdef test_core < matlab.unittest.TestCase

% Run various tests on the core functionality of SMITE.  Much output will be
% saved in tempdir/smite/unitTest/name_of_test.  ExpectedResults are provided
% in the directory in which run_tests.m resides where very large files have
% been deleted so as to not bloat up the the SMITE distribution.

% In the MATLAB unittest context, run in the following manner:
%    testCase = test_core
%    results = testCase.run

% +smi

methods (Test)

   function test_SMLM(testCase)
      fprintf('smi.SMLM.unitTest\n');
      if (gpuDeviceCount > 0)
         results = smi.SMLM.unitTest();
      else
         fprintf('GPU needed!\n');
         results = [1, 1, 1];
      end
      testCase.verifyEqual(results, [1, 1, 1]);
   end

   function test_unitTestFFGC(testCase)
      fprintf( ...
         'smi.SPT.unitTestFFGC (frame-to-frame and gap closing processes)\n');
      if (gpuDeviceCount > 0)
         results = smi.SPT.unitTestFFGC();
      else
         fprintf('GPU needed!\n');
         results = 1;
      end
      testCase.verifyEqual(results, 1);
   end

% +smi_cluster

   function test_Clustering(testCase)
      fprintf('smi_cluster.Clustering.unitTest\n');
      results = smi_cluster.Clustering.unitTest();
      testCase.verifyEqual(results, 1);
   end

   function test_PairCorrelation(testCase)
      fprintf('smi_cluster.PairCorrelation.unitTest\n');
      results = smi_cluster.PairCorrelation.unitTest();
      testCase.verifyEqual(results, 1);
   end

   function test_StatisticsClustering(testCase)
      fprintf('smi_cluster.StatisticsClustering.unitTest\n');
      results = smi_cluster.StatisticsClustering.unitTest();
      testCase.verifyEqual(results, 1);
   end

% +smi_core

   function test_ChannelRegistration(testCase)
      fprintf('smi_core.ChannelRegistration.unitTest\n');
      if (gpuDeviceCount > 0)
         results = smi_core.ChannelRegistration.unitTest();
      testCase.verifyEqual(results, ...
                           [true, true, true, true, true, true, true]);
      else
         fprintf('GPU needed!\n');
         results = [true, true, true, true, true, true, true];
      end
   end

   function test_DataToPhotons(testCase)
      fprintf( ...
      'smi_core.DataToPhotons.unitTest (convert raw data in ADUs to photons)\n');
      if (gpuDeviceCount > 0)
         results = smi_core.DataToPhotons.unitTest();
      else
         fprintf('GPU needed!\n');
         results = [true, true, true, true, true];
      end
      testCase.verifyEqual(results, [true, true, true, true, true]);
   end

   function test_DriftCorrection(testCase)
      fprintf('smi_core.DriftCorrection.unitTest\n');
      results = smi_core.DriftCorrection.unitTest();
      testCase.verifyEqual(results, 1);
   end

   function test_FrameConnection(testCase)
      fprintf('smi_core.FrameConnection.unitTest\n');
      results = smi_core.FrameConnection.unitTest();
      testCase.verifyEqual(results, [true, true, true, true, true]);
   end

   function test_FRC(testCase)
      fprintf( ...
       'smi_core.FRC.unitTest (Fourier Ring Correlation) [DIPimage needed]\n');
      if exist('dipinit')
         results = smi_core.FRC.unitTest();
      else
         fprintf('DIPimage needed!\n');
         results = 1;
      end
      testCase.verifyEqual(results, 1);
   end

   function test_LocalizeData(testCase)
      fprintf( ...
   'smi_core.LocalizeData.unitTest (find localizations in an image stack\n');
      if (gpuDeviceCount > 0)
         results = smi_core.LocalizeData.unitTest();
      else
         fprintf('GPU needed!\n');
         results = true;
      end
      testCase.verifyEqual(results, true);
   end

   function test_Threshold(testCase)
      fprintf('smi_core.Threshold.unitTest\n');
      if (gpuDeviceCount > 0)
         results = smi_core.Threshold.unitTest();
      else
         fprintf('GPU needed!\n');
         results = 1;
      end
      testCase.verifyEqual(results, 1);
   end

% +smi_psf

   function test_crlbPSFPupil(testCase)
      fprintf('smi_psf.PointSpreadFunction.crlbPSFPupil_unitTest\n');
      if (gpuDeviceCount > 0)
         results = smi_psf.PointSpreadFunction.crlbPSFPupil_unitTest();
      else
         fprintf('GPU needed!\n');
         results = 1;
      end
      testCase.verifyEqual(results, 1);
   end

   function test_optimPSFZernike(testCase)
      fprintf('smi_psf.PointSpreadFunction.optimPSFZernike_unitTest\n');
      if (gpuDeviceCount > 0)
         results = smi_psf.PointSpreadFunction.optimPSFZernike_unitTest();
      else
         fprintf('GPU needed!\n');
         results = 1;
      end
      testCase.verifyEqual(results, 1);
   end

   function test_psfROIStack(testCase)
      fprintf('smi_psf.PointSpreadFunction.psfROIStack_unitTest\n');
      if (gpuDeviceCount > 0)
         results = smi_psf.PointSpreadFunction.psfROIStack_unitTest();
      else
         fprintf('GPU needed!\n');
         results = 1;
      end
      testCase.verifyEqual(results, 1);
   end

   function test_scalarPSFPrasadZone(testCase)
      fprintf('smi_psf.PointSpreadFunction.scalarPSFPrasadZone_unitTest\n');
      if (gpuDeviceCount > 0)
         results = smi_psf.PointSpreadFunction.scalarPSFPrasadZone_unitTest();
      else
         fprintf('GPU needed!\n');
         results = 1;
      end
      testCase.verifyEqual(results, 1);
   end

   function test_zernikeImage(testCase)
      fprintf('smi_psf.PointSpreadFunction.zernikeImage_unitTest\n');
      if (gpuDeviceCount > 0)
         results = smi_psf.PointSpreadFunction.scalarPSFPrasadZone_unitTest();
      else
         fprintf('GPU needed!\n');
         results = 1;
      end
      testCase.verifyEqual(results, 1);
   end

   function test_Zernike(testCase)
      fprintf('smi_psf.Zernike.unitTest\n');
      if (gpuDeviceCount > 0)
         results = smi_psf.Zernike.unitTest();
      else
         fprintf('GPU needed!\n');
         results = 1;
      end
      testCase.verifyEqual(results, 1);
   end

% +smi_sim

   function test_GaussBlobs(testCase)
      fprintf('smi_sim.GaussBlobs.unitTest\n');
      if (gpuDeviceCount > 0)
         results = smi_sim.GaussBlobs.unitTest();
      else
         fprintf('GPU needed!\n');
         results = 1;
      end
      testCase.verifyEqual(results, 1);
   end

   function test_SimSMLM(testCase)
      fprintf('smi_sim.SimSMLM.unitTest\n');
      if (gpuDeviceCount > 0)
         results = smi_sim.SimSMLM.unitTest();
      else
         fprintf('GPU needed!\n');
         results = 1;
      end
      testCase.verifyEqual(results, 1);
   end

% +smi_stat

   function test_ChangeDetection(testCase)
      fprintf('smi_stat.ChangeDetection.unitTest\n');
      fprintf('This may sometimes error randomly.\n');
      results = smi_stat.ChangeDetection.unitTest();
      testCase.verifyEqual(results, 1);
   end

   function test_DiffusionEstimator(testCase)
      fprintf('smi_stat.DiffusionEstimator.unitTest\n');
      results = smi_stat.DiffusionEstimator.unitTest();
      testCase.verifyEqual(results, 1);
   end

   function test_HMM(testCase)
      fprintf('smi_stat.HMM.unitTest\n');
      if (gpuDeviceCount > 0)
          results = smi_stat.HMM.unitTest();
      else
         fprintf('GPU needed!\n');
         results = 1;
      end
      testCase.verifyEqual(results, 1);
   end

% +smi_vis

   function test_blobColorOverlay(testCase)
      fprintf('smi_vis.GenerateImages.blobColorOverlay_unitTest\n');
      if (gpuDeviceCount > 0)
         results = smi_vis.GenerateImages.blobColorOverlay_unitTest();
      else
         fprintf('GPU needed!\n');
         results = 1;
      end
      testCase.verifyEqual(results, 1);
   end

   function test_circleImage(testCase)
      fprintf('smi_vis.GenerateImages.circleImage_unitTest\n');
      results = smi_vis.GenerateImages.circleImage_unitTest();
      testCase.verifyEqual(results, 1);
   end

   function test_colorImage(testCase)
      fprintf('smi_vis.GenerateImages.colorImage_unitTest\n');
      if (gpuDeviceCount > 0)
         results = smi_vis.GenerateImages.colorImage_unitTest();
      else
         fprintf('GPU needed!\n');
         results = 1;
      end
      testCase.verifyEqual(results, 1);
   end

   function test_driftImage(testCase)
      fprintf('smi_vis.GenerateImages.driftImage_unitTest\n');
      results = smi_vis.GenerateImages.driftImage_unitTest();
      testCase.verifyEqual(results, 1);
   end

   function test_gaussianImage(testCase)
      fprintf('smi_vis.GenerateImages.gaussianImage_unitTest\n');
      if (gpuDeviceCount > 0)
         results = smi_vis.GenerateImages.gaussianImage_unitTest();
      else
         fprintf('GPU needed!\n');
         results = 1;
      end
      testCase.verifyEqual(results, 1);
   end

   function test_histogramImage(testCase)
      fprintf('smi_vis.GenerateImages.histogramImage_unitTest\n');
      results = smi_vis.GenerateImages.histogramImage_unitTest();
      testCase.verifyEqual(results, 1);
   end

end % Methods

end

./MATLAB/source/cuda/cuda_Make.m
%% This acts as a Makefile for the ptx files.

% This only needs to be run once.  ptx and cu files will be saved to the
% smite/MATLAB/ptx directory.
%
% IMPORTANT:
%    cuda_Make MUST be run while in the smite/MATLAB/source/cuda directory.
%
% REQUIREMENTS:
%    Need to have a CUDA toolkit and VS2013 installed (Windows).

clc

if ispc
   % Adding system path for nvcc to compile with nvcc
   setenv('PATH', [getenv('PATH') ';C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v10.1\bin']);
   % Adding system path for VS2013 to compile with cl
   setenv('PATH', [getenv('PATH') ';C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\bin']);
else % Linux/MacOS
   % Adding system path for nvcc to compile with nvcc
   setenv('PATH', [getenv('PATH') ':/usr/local/cuda-10.1/bin']);
end

%% smi_cuda_gaussMLEv2
clc
cuda_dir = 'smi_cuda_gaussMLEv2';
fprintf('Compiling %s ...\n', cuda_dir);
addpath(cuda_dir);

[s, r] = system(sprintf('nvcc -ptx %s -o %s\n',                ...
                        fullfile(cuda_dir, [cuda_dir, '.cu']), ...
                        fullfile('..', '..', 'ptx', [cuda_dir, '.ptx'])))
copyfile(fullfile(cuda_dir, [cuda_dir, '.cu']), fullfile('..', '..', 'ptx'));

%% smi_cuda_FindROI

cuda_dir = 'smi_cuda_FindROI';
fprintf('Compiling %s ...\n', cuda_dir);
addpath(cuda_dir);

[s, r] = system(sprintf('nvcc -ptx %s -o %s\n',                ...
                        fullfile(cuda_dir, [cuda_dir, '.cu']), ...
                        fullfile('..', '..', 'ptx', [cuda_dir, '.ptx'])))
copyfile(fullfile(cuda_dir, [cuda_dir, '.cu']), fullfile('..', '..', 'ptx'));

%% smi_cuda_gaussBlobROIStack

cuda_dir = 'smi_cuda_gaussBlobROIStack';
fprintf('Compiling %s ...\n', cuda_dir);
addpath(cuda_dir);

[s, r] = system(sprintf('nvcc -ptx %s -o %s\n',                ...
                        fullfile(cuda_dir, [cuda_dir, '.cu']), ...
                        fullfile('..', '..', 'ptx', [cuda_dir, '.ptx'])));
copyfile(fullfile(cuda_dir, [cuda_dir, '.cu']), fullfile('..', '..', 'ptx'));
copyfile(fullfile(cuda_dir, [cuda_dir, '.m']),  fullfile('..', '..', 'ptx'));

%% smi_cuda_PSFSample3DBlob

cuda_dir = 'smi_cuda_PSFSample3DBlob';
fprintf('Compiling %s ...\n', cuda_dir);
addpath(cuda_dir);

[s, r] = system(sprintf('nvcc -ptx %s -o %s\n',                ...
                        fullfile(cuda_dir, [cuda_dir, '.cu']), ...
                        fullfile('..', '..', 'ptx', [cuda_dir, '.ptx'])))
                    
copyfile(fullfile(cuda_dir, [cuda_dir, '.cu']), fullfile('..', '..', 'ptx'));

./MATLAB/source/cuda/smi_cuda_gaussBlobROIStack/smi_cuda_gaussBlobROIStack.m
% smi_cuda_gaussBlobROIStack.ptx contains 2 cuda kernels for creating blob ROI
% stacks
%
% --- kernel_guassiansampleblobs ---
% SYNTAX
% 
% INPUT
%   

./MATLAB/source/c/c_GenColorChannels.m
% c_GenColorChannels C++ function for applying colormap to greyscale image
% 
% SYNTAX
%   [R,G,B] = c_GenColorChannels(Image,ColorMap,MinValue,MaxValue);
% INPUTS
%   Image - 2D array (single floats)
%   ColorMap - N by 3 array (double floats) describing color values, 
%              columns represent Red, Green and Blue values for color 
%              levels (see help colormap)
%   MinValue (optional) - minimum gray scale value for displaying colormap
%                         (default min(Image)) 
%   MaxValue (optional) - maximum grey scale value for displaying colormap
%                         (default max(Image)) 
% OUTPUTS
%   R - 2D array representing Red values
%   G - 2D array representing Green values
%   B - 2D array representing Blue values
%
% Dipimage's joinchannel function can be used to combine R, G and B into an
% RGB image
%

% Marjolein Meddens, Lidke Lab 2017
./MATLAB/source/c/mex_Make.m
%% This acts as a make file for mex functions. 

% This should be run to generate mex files for each architecture.
% mex_Make should be run while in the smite/MATLAB/source/c directory.

%% get path

baseFile = which('smi_core.FrameConnection');
[smite_CorePath] = fileparts(fileparts(baseFile));
[basePath] = fileparts(smite_CorePath);
sourcePath = fullfile(basePath,'source','c');
mexFilePath = fullfile(basePath,'mex');

%% c_FrameConnect

mex(fullfile(sourcePath,'smi_c_FrameConnection.cpp'), '-outdir', mexFilePath);
 
%% c_HistRecon

mex(fullfile(sourcePath,'c_HistRecon.cpp'), '-outdir', mexFilePath);
%copyfile(fullfile(sourcePath,'c_HistRecon.m'),mexFilePath);

%% c_HistImTime

mex(fullfile(sourcePath,'c_HistImTime.cpp'), '-outdir', mexFilePath);
%copyfile(fullfile(sourcePath,'c_HistImTime.m'),mexFilePath);

%% c_GenColorChannels

mex(fullfile(sourcePath,'c_GenColorChannels.cpp'), '-outdir', mexFilePath);
%copyfile(fullfile(sourcePath,'c_GenColorChannels.m'),mexFilePath);

%% c_lap

mex(fullfile(sourcePath,'c_lap.cpp'), '-outdir', mexFilePath);

./MATLAB/run_tests.m
% Run various tests on the core functionality of SMITE.  Much output will be
% saved in tempdir/smite/unitTest/name_of_test.  ExpectedResults are provided
% in the directory in which run_tests.m resides where very large files have
% been deleted so as to not bloat up the the SMITE distribution.

% +smi

fprintf('smi.SMLM.unitTest\n');
try
   smi.SMLM.unitTest()
end

fprintf('smi.SPT.unitTestFFGC (frame-to-frame and gap closing processes)\n');
try
   smi.SPT.unitTestFFGC()
end

% +smi_cluster

fprintf('smi_cluster.Clustering.unitTest\n');
try
   smi_cluster.Clustering.unitTest()
end

fprintf('smi_cluster.PairCorrelation.unitTest\n');
try
   smi_cluster.PairCorrelation.unitTest()
end

fprintf('smi_cluster.StatisticsClustering.unitTest\n');
try
   smi_cluster.StatisticsClustering.unitTest()
end

% +smi_core

fprintf('smi_core.ChannelRegistration.unitTest\n');
try
   smi_core.ChannelRegistration.unitTest()
end

fprintf( ...
   'smi_core.DataToPhotons.unitTest (convert raw data in ADUs to photons)\n');
try
   smi_core.DataToPhotons.unitTest()
end

fprintf('smi_core.DriftCorrection.unitTest\n');
try
   smi_core.DriftCorrection.unitTest()
end

%fprintf( ...
%   'smi_core.FRC.unitTest (Fourier Ring Correlation) [DIPimage needed]\n');
%try
%   smi_core.FRC.unitTest()
%end

fprintf('smi_core.FrameConnection.unitTest\n');
try
   smi_core.FrameConnection.unitTest()
end

fprintf( ...
   'smi_core.LocalizeData.unitTest (find localizations in an image stack\n');
try
   smi_core.LocalizeData.unitTest()
end

fprintf('smi_core.Threshold.unitTest\n');
try
   smi_core.Threshold.unitTest()
end

% +smi_psf

% smi_psf.PointSpreadFunction.crlbPSFPupil_unitTest()
% smi_psf.PointSpreadFunction.optimPSFZernike_unitTest()
% smi_psf.PointSpreadFunction.psfROIStack_unitTest()
% smi_psf.PointSpreadFunction.scalarPSFPrasadZone_unitTest()
% smi_psf.PointSpreadFunction.zernikeImage_unitTest()
fprintf('smi_psf.PointSpreadFunction.unitTest (several individual tests)\n');
try
   smi_psf.PointSpreadFunction.unitTest()
end

fprintf('smi_psf.Zernike.unitTest\n');
try
   smi_psf.Zernike.unitTest()
end

% +smi_sim

fprintf('smi_sim.GaussBlobs.unitTest\n');
try
   smi_sim.GaussBlobs.unitTest()
end

fprintf('smi_sim.SimSMLM.unitTest\n');
try
   smi_sim.SimSMLM.unitTest()
end

% +smi_stat

fprintf('smi_stat.ChangeDetection.unitTest\n');
try
   smi_stat.ChangeDetection.unitTest()
end

fprintf('smi_stat.DiffusionEstimator.unitTest\n');
try
   smi_stat.DiffusionEstimator.unitTest()
end

fprintf('smi_stat.HMM.unitTest\n');
try
   smi_stat.HMM.unitTest()
end

% +smi_vis

fprintf('smi_vis.GenerateImages.blobColorOverlay_unitTest\n');
try
   smi_vis.GenerateImages.blobColorOverlay_unitTest()
end

fprintf('smi_vis.GenerateImages.circleImage_unitTest\n');
try
   smi_vis.GenerateImages.circleImage_unitTest()
end

fprintf('smi_vis.GenerateImages.colorImage_unitTest\n');
try
   smi_vis.GenerateImages.colorImage_unitTest()
end

fprintf('smi_vis.GenerateImages.driftImage_unitTest\n');
try
   smi_vis.GenerateImages.driftImage_unitTest()
end

fprintf('smi_vis.GenerateImages.gaussianImage_unitTest\n');
try
   smi_vis.GenerateImages.gaussianImage_unitTest()
end

fprintf('smi_vis.GenerateImages.histogramImage_unitTest\n');
try
   smi_vis.GenerateImages.histogramImage_unitTest()
end

./MATLAB/+smi_psf/@Zernike/unitTest.m
function success = unitTest()
%unitTest Test functionality of the Zernike polynomial portion of the class.

% Created by
%    Michael Wester, 2017, Lidkelab.

   success = 0;

   Z = smi_psf.Zernike();

   fprintf('\n');
   l = Z.zNM2Wyant(3, 2);
   fprintf('Wyant: l = %d (%s)\n', l, char(Z.zNamesWyant(l)));
   [n, m] = Z.zWyant2NM(11);
   fprintf('Wyant: (n, m) = (%d, %d)\n', n, m);
   l = Z.zNM2Wyant(3, -2);
   fprintf('Wyant: l = %d (%s)\n', l, char(Z.zNamesWyant(l)));
   [n, m] = Z.zWyant2NM(12);
   fprintf('Wyant: (n, m) = (%d, %d)\n', n, m);
   l = Z.zNM2Wyant(3, 0);
   fprintf('Wyant: l = %d (%s)\n', l, char(Z.zNamesWyant(l)));
   [n, m] = Z.zWyant2NM(15);
   fprintf('Wyant: (n, m) = (%d, %d)\n', n, m);

   fprintf('\n');
   l = Z.zNM2Noll(3, 3);
   fprintf('Noll:  l = %d (%s)\n', l, char(Z.zNamesNoll(l)));
   [n, m] = Z.zNoll2NM(10);
   fprintf('Noll:  (n, m) = (%d, %d)\n', n, m);
   l = Z.zNM2Noll(3, -3);
   fprintf('Noll:  l = %d (%s)\n', l, char(Z.zNamesNoll(l)));
   [n, m] = Z.zNoll2NM(9);
   fprintf('Noll:  (n, m) = (%d, %d)\n', n, m);
   l = Z.zNM2Noll(4, 0);
   fprintf('Noll:  l = %d (%s)\n', l, char(Z.zNamesNoll(l)));
   [n, m] = Z.zNoll2NM(11);
   fprintf('Noll:  (n, m) = (%d, %d)\n', n, m);

   nmax = 5;

   nZ_terms = Z.zNZWyant(nmax);
   fprintf('Wyant: %d total terms for nmax = %d\n', nZ_terms, nmax);

   nZ_terms = Z.zNZNoll(nmax);
   fprintf('Noll:  %d total terms for nmax = %d\n', nZ_terms, nmax);

   % Make sure that l_max includes both azimuthal terms (cos and sin) for a
   % particular n and m.
   l_max = 5;
   l_max_new = Z.zProperNollIndex(l_max);
   if l_max_new ~= l_max
      l_max = l_max_new;
      fprintf('\n!!!Resetting l_max to %d!!!\n', l_max);
   end

   success = 1;

   fprintf('Done.\n');

end

./MATLAB/+smi_psf/@Zernike/zNZWyant.m
function nZ = zNZWyant(n)
%nNZWyant Number of Zernike polynomials up through order n (Wyant ordering).

% Created by
%    Michael Wester, 2017, Lidkelab.

   nZ = (n + 1)^2;

end

./MATLAB/+smi_psf/@Zernike/zNamesWyant.m
function names = zNamesWyant(ll)
%zNamesWyant Classical names for Zernike indices ll (Wyant ordering).

% Created by
%    Michael Wester, 2017, Lidkelab.

   names = arrayfun(@zNameWyant, ll, 'UniformOutput', false);

end

function name = zNameWyant(l)
% Classical name for Zernike index l (Noll ordering).

   % Wyant ordering aberration names (0-based).  See
   % http://www.telescope-optics.net/zernike_expansion_schemes.htm
   Wnames = {'Piston',                         ...
             'Tilt Horizontal',                ...
             'Tilt Vertical',                  ...
             'Defocus',                        ...
             'Primary Astigmatism Vertical',   ...
             'Primary Astigmatism Oblique',    ...
             'Primary Coma Horizontal',        ...
             'Primary Coma Vertical',          ...
             'Primary Spherical',              ...
             'Trefoil Oblique',                ...
             'Trefoil Vertical',               ...
             'Secondary Astigmatism Vertical', ...
             'Secondary Astigmatism Oblique',  ...
             'Secondary Coma Horizontal',      ...
             'Secondary Coma Vertical',        ...
             'Secondary Spherical Aberration'};

   if l < 0
      error('zNameWyant: Zernike polynomials not defined for l < 0!');
   else
      if l >= numel(Wnames)
         name = sprintf('Zernike_Wyant %d', l);
      else
         name = Wnames{l + 1};
      end
   end

end

./MATLAB/+smi_psf/@Zernike/zNZNoll.m
function nZ = zNZNoll(n)
%zNZNoll Number of Zernike polynomials up through order n (Noll ordering).

% Created by
%    Michael Wester, 2017, Lidkelab.

   nZ = (n + 1) * (n + 2) / 2;

end

./MATLAB/+smi_psf/@Zernike/zNM2Wyant.m
function l = zNM2Wyant(n, m)
%zNM2Wyant Convert Zernike indices (n, m) into l (Wyant ordering).

% Created by
%    Michael Wester, 2017, Lidkelab.

   if m >= 0
      l = n^2 + 2*(n - m);
   else
      l = n^2 + 2*(n + m) + 1;
   end

end

./MATLAB/+smi_psf/@Zernike/zNamesNoll.m
function names = zNamesNoll(ll)
%zNamesNoll Classical names for Zernike indices ll (Noll ordering).

% Created by
%    Michael Wester, 2017, Lidkelab.

   names = arrayfun(@zNameNoll, ll, 'UniformOutput', false);

end

function name = zNameNoll(l)
% Classical name for Zernike index l (Noll ordering).

   % Noll ordering aberration names (1-based).  See
   % http://www.telescope-optics.net/zernike_expansion_schemes.htm
   Nnames = {'Piston',                         ...
             'Tilt Horizontal',                ...
             'Tilt Vertical',                  ...
             'Defocus',                        ...
             'Primary Astigmatism Oblique',    ...
             'Primary Astigmatism Vertical',   ...
             'Primary Coma Vertical',          ...
             'Primary Coma Horizontal',        ...
             'Trefoil Vertical',               ...
             'Trefoil Oblique',                ...
             'Primary Spherical',              ...
             'Secondary Astigmatism Vertical', ...
             'Secondary Astigmatism Oblique',  ...
             'Quadrafoil Vertical',            ...
             'Quadrafoil Oblique',             ...
             'Secondary Coma Horizontal',      ...
             'Secondary Coma Vertical',        ...
             'Secondary Trefoil Oblique',      ...
             'Secondary Trefoil Vertical',     ...
             'Pentafoil Oblique',              ...
             'Pentafoil Vertical'};

   if l <= 0
      error('zNameNoll: Zernike polynomials not defined for l <= 0!');
   else
      if l > numel(Nnames)
         name = sprintf('Zernike_Noll %d', l);
      else
         name = Nnames{l};
      end
   end

end

./MATLAB/+smi_psf/@Zernike/README.md
### +smi_psf/@Zernike

Zernike includes low-level Zernike polynomial static functions.

SEE ALSO:
- smi_psf.PointSpreadFunction

---

static methods:
- NollIndex = **[zNM2Noll](zNM2Noll.m)**(N, M):
  Convert Zernike indices (n, m) into l (Noll ordering)
- l = **[zNM2Wyant](zNM2Wyant.m)**(n, m):
  Convert Zernike indices (n, m) into l (Wyant ordering)
- nZ = **[zNZNoll](zNZNoll.m)**(n):
  Number of Zernike polynomials up through order n (Noll ordering)
- nZ = **[zNZWyant](zNZWyant.m)**(n):
  Number of Zernike polynomials up through order n (Wyant ordering)
- names = **[zNamesNoll](zNamesNoll.m)**(ll):
  Classical names for Zernike indices ll (Noll ordering)
- names = **[zNamesWyant](zNamesWyant.m)**(ll):
  Classical names for Zernike indices ll (Wyant ordering)
- [N, M] = **[zNoll2NM](zNoll2NM.m)**(NollIndex):
  Convert Zernike index l into (n, m) (Noll ordering)
- l_max = **[zProperNollIndex](zProperNollIndex.m)**(l_max):
  Make sure that l_max includes both azimuthal terms (cos + sin) for a
  particular n and m.
- [n, m] = **[zWyant2NM](zWyant2NM.m)**(l):
  Convert Zernike index l into (n, m) (Wyant ordering)

unit test:
- success = **[unitTest](unitTest.m)**():
  Test functionality of the Zernike polynomial portion of the class

./MATLAB/+smi_psf/@Zernike/zNM2Noll.m
function NollIndex = zNM2Noll(N, M)
%zNM2Noll Convert Zernike indices (n, m) into l (Noll ordering).

% Created by
%    Michael Wester, 2017, Lidkelab.

   mm = abs(M);
   % l = n * (n + 1) / 2 + 1; if mm >= 2; l = l + mm - 1; end
   NollIndex = N * (N + 1) / 2 + 1 + max(0, mm - 1);
   if (M > 0 & mod(N, 4) >= 2) | (M < 0 & mod(N, 4) <= 1)
      NollIndex = NollIndex + 1;
   end

end

./MATLAB/+smi_psf/@Zernike/Zernike.m
classdef Zernike < handle

%Zernike includes low-level Zernike polynomial static functions.
%
% SEE ALSO:
%   smi_psf.PointSpreadFunction

% Created by
%    Michael Wester, 2020, Lidkelab.

% =============================================================================
methods(Static)

   NollIndex = zNM2Noll(N, M)
   l = zNM2Wyant(n, m)
   nZ = zNZNoll(n)
   nZ = zNZWyant(n)
   names = zNamesNoll(ll)
   names = zNamesWyant(ll)
   [N, M] = zNoll2NM(NollIndex)
   l_max = zProperNollIndex(l_max)
   [n, m] = zWyant2NM(l)
   success = unitTest()

end % methods(Static)
% =============================================================================

end % classdef Zernike

./MATLAB/+smi_psf/@Zernike/zWyant2NM.m
function [n, m] = zWyant2NM(l)
%zWyant2NM Convert Zernike index l into (n, m) (Wyant ordering).

% Created by
%    Michael Wester, 2017, Lidkelab.

   n = floor(sqrt(l));
   mm = ceil((2*n - (l - n^2)) / 2);
   if mod(l - n^2, 2) == 0
      m =  mm;
   else
      m = -mm;
   end

end

./MATLAB/+smi_psf/@Zernike/zProperNollIndex.m
function l_max = zProperNollIndex(l_max)
%zProperNollIndex Make sure that l_max includes both azimuthal terms (cos + sin)
% for a particular n and m.  For m ~= 0, the m corresponding to l_max and
% l_max - 1 (or l_max + 1) should agree in absolute value if both azimuthal
% terms are included (m == 0 corresponds to the case of no azimuthal terms).

% Created by
%    Michael Wester, 2017, Lidkelab.

   [n, m] = smi_psf.Zernike.zNoll2NM(l_max);
   if m ~= 0
      [nn, mm] = smi_psf.Zernike.zNoll2NM(l_max - 1);
      if abs(m) ~= abs(mm)
         l_max = l_max + 1;
      end
   end

end

./MATLAB/+smi_psf/@Zernike/zNoll2NM.m
function [N, M] = zNoll2NM(NollIndex)
%zNoll2NM Convert Zernike index l into (n, m) (Noll ordering).

% Created by
%    Michael Wester, 2017, Lidkelab.

   N = ceil((-3 + sqrt(1 + 8*NollIndex)) / 2);
   M = NollIndex - N * (N + 1) / 2 - 1;
   if mod(N, 2) ~= mod(M, 2)
      M = M + 1;
   end
   if mod(NollIndex, 2) == 1
      M = -M;
   end

end

./MATLAB/+smi_psf/@PointSpreadFunction/gui.m
function gui(obj) %#ok<*INUSD>
%gui The beginnings of a GUI for dealing with PSF data.

xsz=400;
ysz=500;
xst=100;
yst=100;
pw=.95;
psep=.01;
staticst=5;
editst=110;
global fullFileName;
global textTwo;
global textTwelve;


h.fig = figure('Units','pixels','position', [xst yst xsz ysz],...
    'MenuBar','none','ToolBar','none','Visible','on',...
 'NumberTitle','off',...
    'name','Data Analysis.gui');

defaultBackground = get(0,'defaultUicontrolBackgroundColor');
set(h.fig,'Color',defaultBackground);
handles.output = h.fig;
guidata(h.fig,handles);

refh=1;

ph=0.09;
php = ph*ysz;

%Position syntax: [left bottom width height]


%File and data panel
hp = uipanel('Title','Data','FontSize',12,...
             'Position',[.05 .6 .4 .3]);
%Microscope panel
mp = uipanel('Title','Microscope','FontSize',12,...
             'Position',[.05 .25 .35 .3]);
%Phase retrieval panel
rp = uipanel('Title','Phase Retrieval','FontSize',12,...
             'Position',[.05 .25 .35 .3]);
%Display panel
dp = uipanel('Title','Display','FontSize',12,...
             'Position',[.6 .6 .35 .4]);
%Save panel
sp = uipanel('Title','Save','FontSize',12,...
             'Position',[.6 .25 .35 .3]);
        
         
         
 buttonZero = uicontrol('Parent', hp, 'Style','pushbutton',...
        'Position',[staticst 100 20 20],...
        'String','File');
    set(buttonZero, 'callback', @fileGet)
     textTwo = uicontrol('Parent', hp, 'Style','edit',... 
     'Position',[staticst+30 100 60 20],...
     'String','');
 
  h.buttonOne = uicontrol('Parent',hp, 'style', 'pushbutton' ,...
    'position', [staticst+100 100 40 20] ,... 
    'string' , 'Load');
 
    
    function fileGet(~,~)
        delete(textTwo)
        [baseName, folder] = uigetfile();
        fullFileName = fullfile(folder, baseName);
         textTwo = uicontrol('Parent', hp, 'Style','edit',... 
     'Position',[staticst+20 100 60 20],...
     'String','');
        set(textTwo,'String',fullFileName);
    end

    function loadData(~,~) %#ok<*DEFNU>
        %Reserved for loading data via "Load" pushbutton
    end

  dataName = uicontrol('Parent', hp, 'Style','text',...
        'Position',[staticst 60 60 20],...
        'String','Data Name');
    
    textThree = uicontrol('Parent', hp, 'Style','edit',... 
     'Position',[staticst+60 60 60 20],...
     'String','');
 
   zVector = uicontrol('Parent', hp, 'Style','text',...
        'Position',[staticst 40 60 20],...
        'String','Z-Vector');
  
  textFour = uicontrol('Parent',hp, 'Style','edit',... 
     'Position',[staticst+60 40 60 20],...
     'String','');
 
   center = uicontrol('Parent', hp, 'Style','text',...
        'Position',[staticst 40 60 20],...
        'String','Center');
 
    textFive = uicontrol('Parent',hp, 'Style','edit',... 
     'Position',[staticst+60 40 60 20],...
     'String','');
 
    na = uicontrol('Parent',mp, 'Style','text',...
        'Position',[staticst-25 110 60 20],...
        'String','NA');

    textSix = uicontrol('Parent',mp, 'Style','edit',... 
     'Position',[staticst+70 110 60 20],...
     'String','');
 
  waveLength = uicontrol('Parent',mp, 'Style','text',...
        'Position',[staticst-5 90 60 20],...
        'String','Wavelength');
    
       textSeven = uicontrol('Parent',mp, 'Style','edit',... 
     'Position',[staticst+70 90 60 20],...
     'String','');
 
   indexOfRefraction = uicontrol('Parent',mp, 'Style','text',...
        'Position',[staticst-20 70 60 20],...
        'String','Index');
    
           textEight = uicontrol('Parent',mp, 'Style','edit',... 
     'Position',[staticst+70 70 60 20],...
     'String','');
    
       pixelSize = uicontrol('Parent',mp, 'Style','text',...
        'Position',[staticst-10 50 60 20],...
        'String','Pixel Size');
    
           textNine = uicontrol('Parent',mp, 'Style','edit',... 
     'Position',[staticst+70 50 60 20],...
     'String','');
 
   maxZernike = uicontrol('Parent', rp, 'Style','text',...
        'Position',[staticst-10 100 100 20],...
        'String','Mag. Max Zernike');
    
           textTen = uicontrol('Parent',rp, 'Style','edit',... 
     'Position',[staticst+90 100 40 20],...
     'String','');
 
   phaseZernike = uicontrol('Parent', rp, 'Style','text',...
        'Position',[staticst-8 80 100 20],...
        'String','Phase Max Zernike');
      textEleven = uicontrol('Parent',rp, 'Style','edit',... 
     'Position',[staticst+90 80 40 20],...
     'String','');
 
   h.buttonTwo = uicontrol('Parent',rp, 'style', 'pushbutton' ,...
    'position', [staticst+23 40 80 20] ,... 
    'string' , 'Phase Retrieve');


checkbox = uicontrol('Parent', dp, 'Style','Checkbox','Units','Pixels',...
                'Position',[staticst 140 100 50], 'String', 'Linear Display'); %#ok<*NASGU>
            
    h.buttonThree = uicontrol('Parent',dp, 'style', 'pushbutton' ,...
    'position', [staticst 120 100 20] ,... 
    'string' , 'Show Pupil Mag.');

    h.buttonFour = uicontrol('Parent',dp, 'style', 'pushbutton' ,...
    'position', [staticst 100 110 20] ,... 
    'string' , 'Show Pupil Phase');

    h.buttonFive = uicontrol('Parent',dp, 'style', 'pushbutton' ,...
    'position', [staticst 80 80 20] ,... 
    'string' , 'Show Data');

    h.buttonSix = uicontrol('Parent',dp, 'style', 'pushbutton' ,...
    'position', [staticst 60 100 20] ,... 
    'string' , 'Plot Zernike');

    h.buttonSeven = uicontrol('Parent',dp, 'style', 'pushbutton' ,...
    'position', [staticst 40 100 20] ,... 
    'string' , 'Show Overlay');

    h.buttonEight = uicontrol('Parent',dp, 'style', 'pushbutton' ,...
    'position', [staticst 20 80 20] ,... 
    'string' , 'Show Model');

    buttonNine = uicontrol('Parent',sp, 'style', 'pushbutton' ,...
    'position', [staticst 100 80 20] ,... 
    'string' , 'Select File');
 set(buttonNine, 'callback', @fileGetII)

      textTwelve = uicontrol('Parent',sp, 'Style','edit',... 
     'Position',[staticst 70 80 20],...
     'String','');
 
     h.buttonTen = uicontrol('Parent',sp, 'style', 'pushbutton' ,...
    'position', [staticst 40 80 20] ,... 
    'string' , 'Save File');
 

    function fileGetII(~,~)
                delete(textTwelve)
        [baseName, folder] = uiputfile();
        fullFileName = fullfile(folder, baseName);
      textTwelve = uicontrol('Parent',sp, 'Style','edit',... 
     'Position',[staticst 70 80 20],...
     'String','');
        set(textTwelve,'String',fullFileName);
    end

    function fileSave(~,~)
        %Reserved for saving data via "Save file" pushbutton
    end

            %set(checkbox1, 'callback', {@isChecked})
            
    %function isChecked(checkbox1, value, testTxt)
            %value = get(checkbox1, 'Value');
                        %testTxt = uicontrol('Style','text',...
        %'Position',[200 700 60 50],...
        %'String','Testing');
            %if value
                %Checkbox is checked
                 %set(testTxt, 'Visible', 'on')
            %else
                %Checkbox is unchecked
                 %set(testTxt, 'Visible', 'off')
            %end
          
end
    

./MATLAB/+smi_psf/@PointSpreadFunction/unitTest.m
function unitTest()
%unitTest Tests various functionality.

   fprintf('crlbPSFPupil_unitTest ...\n');
   try
      [Report, CRLB]=smi_psf.PointSpreadFunction.crlbPSFPupil_unitTest();
   end

   fprintf('optimPSFZernike_unitTest ...\n');
   try
      [Report]=smi_psf.PointSpreadFunction.optimPSFZernike_unitTest();
   end

%  fprintf('oversamplePSFPupil_unitTest (DIPimage needed) ...\n');
%  try
%     [Report]=smi_psf.PointSpreadFunction.oversamplePSFPupil_unitTest();
%  end

%  fprintf('phaseRetrieval_unitTest  (DIPimage needed)...\n');
%  try
%     [PSFStruct]=smi_psf.PointSpreadFunction.phaseRetrieval_unitTest();
%  end

   fprintf('scalarPSFPrasadZone_unitTest ...\n');
   try
      [Report]=smi_psf.PointSpreadFunction.scalarPSFPrasadZone_unitTest();
   end

   fprintf('psfROIStack_unitTest ...\n');
   try
      [Report]=smi_psf.PointSpreadFunction.psfROIStack_unitTest();
   end

   fprintf('zernikeImage_unitTest ...\n');
   try
      [Report]=smi_psf.PointSpreadFunction.zernikeImage_unitTest();
   end

   fprintf('Done.\n');

end

./MATLAB/+smi_psf/@PointSpreadFunction/zernikeImage.m
function [Image]=zernikeImage(NollIndex,SZ,Radius,R,Theta,Mask)
%zernikeImage Generate a Zernike Polynomical Image from Noll Coefficient.
%
%
%   Noll ordering is used as a linear index.
%
%   More about formula and conventions.
%
% INPUTS:
%   NollIndex:      Noll Linear Index
%   SZ:             Size of returned image. Image is square.
%   Radius:         Circle Edge Radius (Pixels)
%   R:              Radius Image (Recalculated by Default)
%   Theta:          Theta Image (Recalculated by Default)
%   Mask:           Mask to apply to image (Default: pixels with R <= 1)
%
% OUTPUTS:
%   Image:          Zernike Polynomial Image
%
% REQUIRES:
%   Parallel Procesing Toolbox
%   NVidia GPU
%

OSZ=SZ;

if nargin <5
    [XGrid,YGrid]=meshgrid((-OSZ/2:OSZ/2-1),(-OSZ/2:OSZ/2-1));
    R=sqrt(gpuArray(XGrid.^2+YGrid.^2));
    R=R/Radius;
    Mask=R<=1;
    R=R.*Mask;
    Theta=(gpuArray(atan2(YGrid,XGrid))); %CHECK!
end

%convert to NM
[N, M] = smi_psf.Zernike.zNoll2NM(NollIndex);

if M<0
    Image=Mask.*sin(M*Theta);
else
    Image=Mask.*cos(M*Theta);
end


N=abs(N);
M=abs(M);

%calculate the radial polynomial
RP=0;
for kk=0:(N-M)/2
    Poly=R.^(N-2*kk);
    %Coef = (-1).^kk*factorial(N-kk)/...
    %    (factorial(kk)*factorial((N+M)/2-kk)*factorial((N-M)/2-kk));
    Coef = (-1)^kk * prod((N - M)/2 - kk + 1 : N - kk) / ...
                     (factorial(kk) * factorial((N + M)/2 - kk));
    RP=RP+Coef*Poly;
end

Image=Mask.*Image.*RP;

./MATLAB/+smi_psf/@PointSpreadFunction/scalarPSFPrasadZone_unitTest.m
function [Report]=scalarPSFPrasadZone_unitTest()
%scalarPSFPrasadZone_unitTest Test scalarPSFPrasadZone functionality.

Report = 0;

SaveDir = smi_helpers.mkSMITETmpDir('unitTest', 'scalarPSFPrasadZone');

L=5;
Photons=500;
Bg=5;

%close all;clc;
P=smi_psf.PointSpreadFunction.createPSFStruct();
P.Z=(-10:.5:10);
P.SZ=256;
P.OSZ=512;
[PSF,P]=smi_psf.PointSpreadFunction.scalarPSFPrasadZone(P,L);

figure; sliceViewer(gather(PSF));
saveas(gcf, fullfile(SaveDir, 'sPPZ1.png'));
figure; imshow(gather(P.Pupil(:,:,2)));
saveas(gcf, fullfile(SaveDir, 'sPPZ2.png'));
smi_psf.PointSpreadFunction.crlbPSFPupil(P,Photons,Bg);
saveas(gcf, fullfile(SaveDir, 'sPPZ3.png'));
smi_psf.PointSpreadFunction.crlbPSFPupil(smi_psf.PointSpreadFunction.createPSFStruct(),Photons,Bg)
saveas(gcf, fullfile(SaveDir, 'sPPZ4.png'));

Report = 1;

end

./MATLAB/+smi_psf/@PointSpreadFunction/psfROIStack.m
function [Model,Data]=psfROIStack(PSF,XYSamPerPix,ZSamPerUnit,SZ,SMD,NoiseIm) 
%psfROIStack Generates boxes of the data containing single particles (blobs).
%
%psfROIStack() gets the size of the boxes, the structure SMD, which
%contains the X, Y, Z positions, photons and the background of the boxes,
%PSF, which is the sampled PSF,XYSamPerPix and ZSamPerUnit, which are the 
%number of the samples in PSF along X,Y ans Z axes, and finally NoiseIm is
%the read-out noise and generates boxes of the data containing single
%particles (blobs).
%
% INPUTS
%   PSF:        The sampled PSF (Point Spread Function).
%   XYSamPerPix:The number of the PSF samples along the X and Y axes per
%               pixel (No default).       
%   ZSamPerUnit:The number of the samples along the Z-axis. (No default)
%   SZ:         size of the box (Default=15) (Pixels).
%   SMD:        This is a structure containing some fileds. We use the fields 
%               X Y, Z, Photons and Background.
%   NoiseIm:    The read-out noise. (Defualt = 0), (Photons).
%
% OUTPUTS:
%   Model:      The box with the blob, which is not croppted with the
%               shot-noise.
%   Data:       The model corrupted with the shot-noise (Poisson noise).
%
% REQUIRES:
%   Parallel processing toolbox
%   NVidia GPU
%   psfSample3DBlob.cu
%   psfSample3DBlob.ptx

% Created by:
%   Mohamadreza Fazel (Lidke Lab, 2017)
%

if nargin < 3
   error('The Sampled PSF and the number of samples along the different axes must be given.'); 
end
if nargin < 4
   SZ = 15;
end
if nargin < 5
   SMD.X = rand([1,10000])*SZ/3+SZ/3;
   SMD.Y = rand([1,10000])*SZ/3+SZ/3;
   SMD.Z = (rand([1,10000])*size(PSF,3)/ZSamPerPix)-size(PSF,3)/(ZSamPerPix*2);
   SMD.Photons = 1000*ones([1,10000]);
   SMD.Bg = 15;
end
if nargin < 6
   NoiseIm = zeros(SZ); 
end
[a,b,c]=size(PSF);
Filter = ones(XYSamPerPix);
PSFIntegral = zeros(a+XYSamPerPix-1,b+XYSamPerPix-1,c);
for ii=1:c
    PSFIntegral(:,:,ii) = (1/XYSamPerPix)^2*conv2(PSF(:,:,ii),Filter);
end
%After the convolution, some of the resulted componenets at the begining and 
%at the end of the array do not represent a whole pixel so we delete them.
PSFIntegral = PSFIntegral(XYSamPerPix:end-(XYSamPerPix-1),XYSamPerPix:end-(XYSamPerPix-1),:);

X = SMD.X;
Y = SMD.Y;
Z = SMD.Z;
Photons = SMD.Photons;
if isscalar(SMD.Bg)
    Bg = SMD.Bg*ones(size(SMD.X));
else
    Bg = SMD.Bg;
end
FrameNum = length(X);
Model = zeros(SZ,SZ,FrameNum,'single');
Nelem =SZ*SZ*FrameNum;
kc = parallel.gpu.CUDAKernel('smi_cuda_PSFSample3DBlob.ptx','smi_cuda_PSFSample3DBlob.cu','cuda_PSFSample3DBlob');
%gpuDevice gives the info of your hardware, like the available
%memory (TotalMemory).
g = gpuDevice;
%The whole set of data cannot be sent into the gpu at the same
%time because of the limitation of the gpu memory. Here we are
%finding the number of chuncks of data based on the available
%memory (g.Totalmemory) to send them to the gpu.
Nloops = ceil(4*4*Nelem/(g.TotalMemory));
%number of frames in each chunk.
NFrameChunk = floor(FrameNum/Nloops);
Cent = round(size(PSFIntegral,1)/2);

for ii = 1:Nloops
       
       if ii == Nloops
          NFrameThisChunk = FrameNum - (NFrameChunk*(Nloops-1));
       else
          NFrameThisChunk = NFrameChunk;
       end
       EndFrame = (ii-1)*NFrameChunk+NFrameThisChunk;
       StartFrame = (ii - 1)*NFrameThisChunk + 1;
       %The chunk of data that are sent to the gpu
       ThisData = zeros(SZ,SZ,NFrameThisChunk);
       %computing the number of the blocks.
       %NumBlocks = ceil(NFrameThisChunk / kc.MaxThreadsPerBlock);
       if NFrameThisChunk < g.MultiprocessorCount
           NumBlocks = NFrameThisChunk;
       elseif NFrameThisChunk > (g.MultiprocessorCount * kc.MaxThreadsPerBlock)
           NumBlocks = ceil(NFrameThisChunk / kc.MaxThreadsPerBlock);
       else
           NumBlocks = g.MultiprocessorCount;
       end
       %calculating the number of the threads in each block. It is more
       %efficient when it is proportional to 32.
       NumThreads = ceil(NFrameThisChunk/(32*NumBlocks))*32;
       %setting the number of the threads in each block
       kc.ThreadBlockSize(1) = NumThreads;
       %setting the number of the blocks
       kc.GridSize(1) = NumBlocks;
       Bg_in = zeros(1,NFrameThisChunk,'single');
       %calling cuda-code

       [ThisData] = feval(kc,X,Y,Z,Photons,Bg_in,XYSamPerPix,ZSamPerUnit,int32(SZ),int32(Cent),int32(size(PSFIntegral)),...
           PSFIntegral,NFrameThisChunk,ThisData);
       %retrieve output from gpu memory
       Model(:,:,StartFrame:EndFrame) = gather(ThisData);
end
ModelCoef = sum(sum(Model));
ModelCoef = ModelCoef(:);
for nn = 1:size(Model,3)
    Model(:,:,nn) = Photons(nn)*Model(:,:,nn)/ModelCoef(nn) + Bg(nn);
end
if nargout > 1
    % add poisson noise
     Data = poissrnd(Model); 
    % add readnoise
    Data = Data + randn(size(Data)).*repmat(NoiseIm,[1 1 FrameNum]);
end
end

./MATLAB/+smi_psf/@PointSpreadFunction/optimPSFZernike_unitTest.m
function [Report]=optimPSFZernike_unitTest()  
%optimPSFZernike_unitTest Tests optimPSFZernike functionality.
%
% OUTPUTS:
%   Report
%
% REQUIRES:
%   Parallel Procesing Toolbox
%   NVidia GPU
%

Report = 0;

SaveDir = smi_helpers.mkSMITETmpDir('unitTest', 'optimPSFZernike');
 
%% Blind start. Search for Astigmatism
P=smi_psf.PointSpreadFunction.createPSFStruct();
PhaseMask=0;
PhaseMask(6)=1; %Vertical Astigmatism 
%clc;
[PFound,PSF,CRLB_Astig]=smi_psf.PointSpreadFunction.optimPSFZernike(P,PhaseMask);
saveas(gcf, fullfile(SaveDir, 'oPZ1.png'));

%%  Directed Start. Search for Tetrapod
P=smi_psf.PointSpreadFunction.createPSFStruct();
PhaseMask=0;
PhaseMask(6)=1; %Vertical Astigmatism 
PhaseMask(12)=1; %Vertical Second Order Astigmatism
PhaseMask(24)=0; %Vertical Second Order Astigmatism
P.ZC_Phase(6)=1;
P.ZC_Phase(12)=-2;
P.ZC_Phase(24)=2;
%clc;
[PFound_Tet,PSF3,CRLB_Tetra]=smi_psf.PointSpreadFunction.optimPSFZernike(P,PhaseMask,P.ZC_Phase);
PFound_Tet.ZC_Phase
saveas(gcf, fullfile(SaveDir, 'oPZ2.png'));

Report = 1;

end

./MATLAB/+smi_psf/@PointSpreadFunction/zernikeImage_unitTest.m
function [Report]=zernikeImage_unitTest()
%zernikeImage_unitTest Tests zernikeImage functionality.

Report = 0;

%% Check orthogonality

% These should all be zero
NMax=9;
Radius=64;
SZ=256;
for nn=1:NMax
    for kk=nn+1:NMax
        Im1=gather(smi_psf.PointSpreadFunction.zernikeImage(nn,SZ,Radius));
        Im2=gather(smi_psf.PointSpreadFunction.zernikeImage(kk,SZ,Radius));
        IP=sum(sum(Im1.*Im2))/(pi*Radius^2);
        if abs(IP)>1e-2
            fprintf('N1=%d, N2=%d. Inner product: %g \n',nn,kk,IP)
        end
    end
end


%% Check Normalization

% These should all be Em*pi(2N-2);
NMax=9;
Radius=64;
SZ=256;
for nn=1:NMax
    Im1=gather(smi_psf.PointSpreadFunction.zernikeImage(nn,SZ,Radius));
    [N,M]=smi_psf.Zernike.zNoll2NM(nn);
    IP=sum(sum(Im1.*Im1))/(pi*Radius^2);
    if (N==0)&&(M==0);
        Norm=1;
    else
        if M==0
            Em=2;
        else
            Em=1;
        end
        Norm=Em/(2*N+2);
    end
    fprintf('N=%d, Inner product: %g Expected: %g\n',nn,IP,Norm)
end

Report = 1;

./MATLAB/+smi_psf/@PointSpreadFunction/zernikeExpansion.m
function [NollCoef,ImageZ]=zernikeExpansion(Image,ZStruct)
%zernikeExpansion Expand Image into Zernike Moments.
%
%
%   Noll ordering is used as a linear index.
%
%   More about formula and conventions.
%
% INPUTS:
%   Image:          Image
%   ZStruct:        Pre-computed images for quick expansion and sum
%
% OUTPUTS:
%   NollCoefs:      Noll Coefficients
%   ImageZ:         Zernike Polynomial Image
%
% REQUIRES:
%   Parallel Procesing Toolbox
%   NVidia GPU
%

Image=Image(:);

NollCoef=(ZStruct.ZImages*Image).*ZStruct.Norms';   

if nargout>1 %Create Image
    [ImageZ]=smi_psf.PointSpreadFunction.zernikeSum(NollCoef,ZStruct);    
end

./MATLAB/+smi_psf/@PointSpreadFunction/psfROIStack_unitTest.m
function [Report] = psfROIStack_unitTest()
%psfROIStack_unitTest Tests psfROIStack functionality.

Report = 0;

SMD.X = rand([1,100000])*5+5;
SMD.Y = rand([1,100000])*5+5;
SMD.Z = rand([1,100000])*10-5;
SMD.Photons = 1000*ones([1,100000]);
SMD.Bg = 15*ones([1,100000]);
SZ = 15;
XYSamPerPix = 6;
ZSamPerUnit = 20;
Z0=1;           
d=1;
PSF0=0.7;

[XGr,YGr,ZGr]=meshgrid(-20+1/(2*XYSamPerPix):1/XYSamPerPix:20-1/(XYSamPerPix*2),...
               -20+1/(XYSamPerPix*2):1/XYSamPerPix:20-1/(2*XYSamPerPix),-15:1/ZSamPerUnit:15);

PSF = (normpdf(XGr,0,PSF0*sqrt(1+((Z0-ZGr)/d).^2)).*...
       normpdf(YGr,0,PSF0*sqrt(1+((Z0+ZGr)/d).^2)));
tic;
[Model,Data]=smi_psf.PointSpreadFunction.psfROIStack(PSF,XYSamPerPix,ZSamPerUnit,SZ,SMD);
T = toc;
fprintf('psfROIStack is successfully tested.\n');
fprintf('%g blobs of 3D super-resolution data were generated in %g seconds.\n',size(SMD.X,2),T);

Report = 1;
end

./MATLAB/+smi_psf/@PointSpreadFunction/crlbPSFPupil.m
function  [CRLB,DET]=crlbPSFPupil(PSFStruct,Photons,Bg,PlotFlag)
%crlbPSFPupil Cramer Rao Lower Bound on (Y,X,Z,Photons,Bg)
%   The PSF is generated using the following model:
%   PSF = |F[OTF]|^2
%   % more...
%
%   PSF is normalized such that the integral over all space = 1
%
% INPUTS:
%   PSFStruct:  PSF Structure.  (Default = createPSFStruct())
%   Photons:    Integrated Emitter Photons. Scalar or Nx1 where N is length(Z)
%   Bg:         Background Photons per Pixel. Scalar or Nx1 where N is length(Z)
%   PlotFlag:   Show plot 0 or 1.  (Default = 1)
%
% OUTPUTS:
%   CRLB        Cramer Rao Lower Bound
%   DET         Determinant of the inverse Fisher Information matrix
%
% REQUIRES:
%   Parallel Procesing Toolbox
%   NVidia GPU
%

%Check for GPU, if not present, overwrite gpuArray
% try
%     gpuDevice
% catch
%     gpuArray=@(x)x;
% end

if nargin <1
    P=smi_psf.PointSpreadFunction.createPSFStruct();
else
    P=PSFStruct;
end

if nargin <2
    Photons=1000;
end

if nargin <3
    Bg=20;
end

if nargin <4
    PlotFlag=1;
end

if length(Photons)==1
   Photons=Photons*ones(length(P.Z),1); 
end

if length(Bg)==1
   Bg=Bg*ones(length(P.Z),1); 
end

%Build Fisher Information Matrix using Numerical Derivatives

%need d model/d Theta


DZ = .05; %micron  step for derivatives

%loop over z

for nn=1:length(P.Z)
    
    PTest=P;
    PTest.Z=P.Z(nn)+[-DZ,0,DZ];
    PTest.SZ=P.SZ+2;
    ModelNorm=smi_psf.PointSpreadFunction.scalarPSFPupil(PTest);
    Model=Photons(nn)*ModelNorm(2:end-1,2:end-1,2)+Bg(nn);
    
    %Derivative in Y. Numerical using whole pixel steps
    D(:,:,1) = Photons(nn)*(ModelNorm(3:end,2:end-1,2)-ModelNorm(1:end-2,2:end-1,2))/(2*P.PixelSize);
    D(:,:,2) = Photons(nn)*(ModelNorm(2:end-1,3:end,2)-ModelNorm(2:end-1,1:end-2,2))/(2*P.PixelSize);
    D(:,:,3) = Photons(nn)*(ModelNorm(2:end-1,2:end-1,3)-ModelNorm(2:end-1,2:end-1,1))/(2*DZ);
    D(:,:,4) = ModelNorm(2:end-1,2:end-1,2);
    D(:,:,5) = Model*0+1;
    %dipshow(gather(D))
    %Build FI
    FI=gpuArray(zeros(5,'single'));
    ModelInv=1./(Model+.1e-5);%dipshow(gather(ModelInv))
    for ii=1:5
        for jj=ii:5
            A=D(:,:,ii).*D(:,:,jj).*ModelInv;
            FI(ii,jj)=sum(A(:));
        end
    end
    
    for ii=1:5
        for jj=ii+1:5
            FI(jj,ii)=FI(ii,jj);
        end
    end
    
    invFI=inv(FI);
    CRLB(nn,:)=diag(invFI);
    DET(nn,:)=det(invFI(1:3,1:3));
end

if PlotFlag
    %figure(1122)
    figure
    plot(P.Z,sqrt(CRLB(:,1))*1000,'R','linewidth',2)
    hold on
    plot(P.Z,sqrt(CRLB(:,2))*1000,'G','linewidth',1.5)
    plot(P.Z,sqrt(CRLB(:,3))*1000,'B','linewidth',1.5)
    xlabel('Z position')
    ylabel('sqrt(crlb) (nm)')
    legend('Y','X','Z')
    axis([min(P.Z) max(P.Z) 0 100])
    hold off
    drawnow;
end

end

./MATLAB/+smi_psf/@PointSpreadFunction/optimPSFZernike.m
function [PSFStruct,PSF,CRLB]=optimPSFZernike(PSFStruct,PhaseMask,StartPhase,Photons,Bg)  
%optimPSFZernike Optimize PSF via Zernike Coef search. 
%   The PSF is generated using the following model:
%   PSF = |F[OTF]|^2
%   % more...
%
%   Noll ordering is used as a linear index.    
%
%   PSF is normalized such that the integral over all space = 1
%
% INPUTS:
%   PSFStruct:  PSF Structure.  (Default = createPSFStruct())
%   PhaseMask:  Nx1 vector of indicating what Zernike Coef will be adjusted
%   StartPhase: Nx1 vector of Coef as starting positions (Default = blind search)    
%   Photons:    Mx1 vector where M is length(P.Z)
%   Bg:         Mx1 vector where M is length(P.Z)
%
% OUTPUTS:
%   PSFStruct:  Updated PSF Structure.  
%   PSF:        Found PSF
%   CRLB:       CRLB at each z position
%
% REQUIRES:
%   Parallel Procesing Toolbox
%   NVidia GPU
%
    
if nargin <1
    P=smi_psf.PointSpreadFunction.createPSFStruct();
else
    P=PSFStruct;
end

if nargin <2
    PhaseMask=[0;0;0;ones(12,1)]
end

NCoef=sum(PhaseMask);
ZC0=ones(NCoef,1);

if nargin<4
   Photons=1000;
   Bg=10;
end

if nargin<3 %Blind search
    FValOld=costCRLB(ZC0,P,Photons,Bg,PhaseMask);
    ZCF_Best=ZC0;
    NAttempts=50;
    
    for nn=1:NAttempts
        ZC0=2*randn(NCoef,1); %first 3 are piston, and tilt, which don't help.
        Fval= costCRLB(ZC0,P,Photons,Bg,PhaseMask);
        if Fval<FValOld
            ZCF_Best=ZC0;
            FValOld=Fval;
        end
    end
else
    if length(StartPhase)<length(PhaseMask)
        StartPhase(length(PhaseMask))=0;
    end
   ZCF_Best=StartPhase(PhaseMask>0); 
end


%optimize
Options=optimset;
Options.MaxIter=5000;
Options.Display='iter';
[ZCF_Best,Fval] = fminsearch(@costCRLB,double(gather(ZCF_Best)),Options,P,Photons,Bg,PhaseMask);

PFound=P;

Phase=PhaseMask;
Phase(PhaseMask>0)=ZCF_Best;
PFound.ZC_Phase=Phase;

[PSF,PFound]=smi_psf.PointSpreadFunction.scalarPSFZernike(PFound); 
[CRLB]=smi_psf.PointSpreadFunction.crlbPSFPupil(PFound,Photons,Bg)
PSF=gather(PSF);
sliceViewer(PSF);

PSFStruct=PFound;
end

function out=costCRLB(ZC,PSFStruct,Photons,Bg,PhaseMask)
%to find Pupil:

PlotFlag=0;

%Fill in phase in correct places. 
if length(PSFStruct.ZC_Phase)>length(PhaseMask) %use these
    Phase=PSFStruct.ZC_Phase;
else
    Phase=PhaseMask;
end

Phase(PhaseMask>0)=ZC;

PSFStruct.ZC_Phase=Phase;

[PSF,PSFStruct]=smi_psf.PointSpreadFunction.scalarPSFZernike(PSFStruct);
[CRLB,DET]=smi_psf.PointSpreadFunction.crlbPSFPupil(PSFStruct,Photons,Bg,PlotFlag);

out=double(gather(sum(DET(:))));


end

./MATLAB/+smi_psf/@PointSpreadFunction/createPSFStruct.m
function  [PSFStruct]=createPSFStruct()
%createPSFStruct Creates a default PSF Structure.
%
%   PSFStruct is a compact representation of a PSF
%
%   It contains the following fields: 
%   
%   Pupil:          Pupil image [Magnitude;Phase]. (SZ x SZ x 2)
%   Z:              Vector of Z positions (microns) (Default = (-2:.1:2))
%   Lambda:         Emission Wavelength (microns) (Default = .69)
%   NA:             Objective Numerical Aperture (Default = 1.35)
%   N:              Index of Refraction (Default = 1.4)
%   PixelSize:      Lateral pixel size (microns) (Default = 0.1)
%   SZ:             PSF lateral size (Pixels) (Default = 64)
%   OTFSigma:       OTF Rescaling factor Sigma [Y X]. (micron) (Default = [0 0])
%   OSZ:            OTF size (Pixels). (Default = 256)
%   ZC_Mag:         Zernike Coef Magnitude (Noll Order) (Default = [1])
%   ZC_Phase:       Zernike Coef Phase (Noll Order) (Default = [0])

% OUTPUTS:
%   PSFStruct:     	PSFStruct will all fields set to default
%
% REQUIRES:
%   Parallel Procesing Toolbox
%   NVidia GPU
%

%Check for GPU, if not present, overwrite gpuArray
% try
%     gpuDevice
% catch
%     gpuArray=@(x)x;
% end

PSFStruct.Z=(-2:.1:2);
PSFStruct.Lambda=.69;
PSFStruct.NA=1.35;
PSFStruct.N=1.4;
PSFStruct.PixelSize=.1;
PSFStruct.SZ=64;
PSFStruct.OTFSigma=[0 0];
PSFStruct.OSZ=256;
PSFStruct.ZC_Mag=[1];
PSFStruct.ZC_Phase=[0];

[XGrid,YGrid]=meshgrid((-PSFStruct.OSZ/2:PSFStruct.OSZ/2-1),(-PSFStruct.OSZ/2:PSFStruct.OSZ/2-1));

R=sqrt(gpuArray(XGrid.^2+YGrid.^2));

KPixelSize=1/(PSFStruct.OSZ*PSFStruct.PixelSize);
PupilRadius=(PSFStruct.NA/PSFStruct.Lambda)/KPixelSize;
Mask=R<PupilRadius;
Pupil_Mag=Mask;
Pupil_Phase=gpuArray(zeros(PSFStruct.OSZ,PSFStruct.OSZ,'single'));
PSFStruct.Pupil=cat(3,Pupil_Mag,Pupil_Phase);




./MATLAB/+smi_psf/@PointSpreadFunction/phaseRetrievalEM.m
function [PSFStruct]=phaseRetrievalEM(PSFStruct,Data)
%phaseRetrievalEM Phase retrieval plus EM to optimize NA, Lambda.
%
%   The PSF is generated using the following model:
%   PSF = |F[OTF]|^2
%   % more...
%
%   PSF is normalized such that the integral over all space = 1
%
%   Input PSFStruct does not require Pupil field.
%
% INPUTS:
%   PSFStruct:  PSF Structure.
%   Data:       PSF Stack
%
% OUTPUTS:
%   PSFStruct:  PSF Image Stack
%
% REQUIRES:
%   Parallel Procesing Toolbox
%   NVidia GPU
%
% CITATION:
%   Hanser, ....

Data=gpuArray(single(Data));
Data=deTilt(Data);

Theta0=[PSFStruct.NA];
Theta_Found=fminsearch(@SSE,Theta0,optimset,Data,PSFStruct);

PSFStruct.NA=Theta_Found(1);
%PSFStruct.Lambda=Theta_Found(2);

end

function [fval,Model]=SSE(Theta,Data,PSFStruct)

NZF=49;

PSFStruct.NA=Theta(1);
%PSFStruct.Lambda=Theta(2);
[P]=smi_psf.PointSpreadFunction.phaseRetrieval(PSFStruct,Data);

KPixelSize=1/(size(P.Pupil,1)*P.PixelSize);
PupilRadius=(P.NA/P.Lambda)/KPixelSize;
ZS=smi_psf.PointSpreadFunction.createZernikeStruct(P.OSZ,PupilRadius,NZF);
P.ZC_Phase=gather(smi_psf.PointSpreadFunction.zernikeExpansion(P.Pupil(:,:,2),ZS));
P.ZC_Mag=gather(smi_psf.PointSpreadFunction.zernikeExpansion(P.Pupil(:,:,1),ZS));
[Model]=smi_psf.PointSpreadFunction.scalarPSFZernike(P);

fval=gather(sum( (Data(:)-Model(:)).^2));
L=size(Data,3);
M=[];
D=[];
for nn=1:L
    M=cat(1,M,stretch(gather(Model(:,:,nn))));
    D=cat(1,D,stretch(gather(Data(:,:,nn))));
end

%dipshow(1234,cat(2,D,M))
pause(.1)

end

function Out=deTilt(In)
%Remove offset from image. Important!

Out=In;
SZ=size(In,1);
PlaneFun=@(Theta,X,Y,Data)double(gather(mean((Theta(1)*X+Theta(2)*Y+Theta(3)-Data).^2)));
[XGrid,YGrid]=meshgrid((1:SZ),(1:SZ));

for ii=1:size(In,3)
    Left = In(:,1,ii);
    Right = In(:,end,ii);
    Top = In(1,:,ii);
    Bottom = In(end,:,ii);
    Data=cat(1,Left(:),Right(:),Top(:),Bottom(:));
    
    V=(1:SZ)';
    V1=ones(SZ,1);
    
    X=cat(1,V1,SZ*V1,V,V);
    Y=cat(1,V,V,V1,V1*SZ);
    
    Theta=fminsearch(PlaneFun,[1 1 1],optimset(),X,Y,Data);
    Out(:,:,ii)=In(:,:,ii)-XGrid*Theta(1)-YGrid*Theta(2)-Theta(3);
    Out(:,:,ii)=Out(:,:,ii)/sum(sum(Out(:,:,ii))); %Normalize
end

end

./MATLAB/+smi_psf/@PointSpreadFunction/rescaleOTF.m
function [OTFVector]=rescaleOTF(PSF,Data)
%rescaleOTF OTF rescaling.
%
% INPUTS:
%    PSF         PSF image stack
%    Data
%
% OUTPUTS:
%    OFTVector   Optical Transfer Function

P.SZ=size(PSF,1);

[XGridS,YGridS]=meshgrid((-P.SZ/2:P.SZ/2-1),(-P.SZ/2:P.SZ/2-1));
    
Theta0=[1 2];
Optim=optimset();
OTFVector=fminsearch(@findCC,Theta0,Optim,PSF,Data,XGridS,YGridS)

end

function NegCC=findCC(Theta,PSF,Data,XGridS,YGridS)

SmoothKer=normpdf(gpuArray(XGridS),0,Theta(2)).*normpdf(gpuArray(YGridS),0,Theta(1));

A=gpuArray(PSF);
for zz=1:size(A,3)
    A(:,:,zz)=conv2(PSF(:,:,zz),SmoothKer,'same');
end

A=A-mean(A(:));
B=Data;
B=B-mean(B(:));
A=A/sqrt(sum(A(:).^2));
B=B/sqrt(sum(B(:).^2));
NegCC=-gather(sum(A(:).*B(:)));


end

./MATLAB/+smi_psf/@PointSpreadFunction/scalarPSF.m
function [PSF,PSFStruct] = scalarPSF(PSFStruct)
%scalarPSF PSF stack based on a scalar model with OTF rescaling.
%   The PSF is generated using the following model:
%   PSF = |F[OTF]|^2
%   % more...
%
%   PSF is normalized such that the integral over all space = 1
%
%   Input PSFStruct does not require Pupil field.
%
% INPUTS:
%   PSFStruct:  PSF Structure.  (Default = createPSFStruct())
%
% OUTPUTS:
%   PSF:        PSF Image Stack
%   OTF:        Optical Transfer Function
%   Pupil:      Pupil Magnitude and Phase (SZ x SZ x 2)
%
% REQUIRES:
%   Parallel Procesing Toolbox
%   NVidia GPU
%

% We are really just setting up a pupil to send to the scalarPSFPupil()
% method

if nargin <1
    P=smi_psf.PointSpreadFunction.createPSFStruct();
end

if nargin <1
    P=smi_psf.PointSpreadFunction.createPSFStruct();
else %recalc Pupil
    P=PSFStruct;
    [XGrid,YGrid]=meshgrid((-P.OSZ/2:P.OSZ/2-1),(-P.OSZ/2:P.OSZ/2-1));
    R=sqrt(gpuArray(XGrid.^2+YGrid.^2));
    KPixelSize=1/(P.OSZ*P.PixelSize);
    PupilRadius=(P.NA/P.Lambda)/KPixelSize;
    Mask=R<PupilRadius;
    Pupil_Phase=gpuArray(zeros(P.OSZ,P.OSZ,'single'));
    Pupil_Mag=Mask;
    P.Pupil=cat(3,Pupil_Mag,Pupil_Phase);
end

[PSF,PSFStruct]=smi_psf.PointSpreadFunction.scalarPSFPupil(P);

end

./MATLAB/+smi_psf/@PointSpreadFunction/scalarPSFPrasadZone.m
function [PSF,PSFStruct]=scalarPSFPrasadZone(PSFStruct,L)
%scalarPSFPrasadZone PSF stack based on a scalar model Prasad Zones. 
%   The PSF is generated using the following model:
%   PSF = |F[OTF]|^2
%   % more...
%
%   PSF is normalized such that the integral over all space = 1
%
%   Input PSFStruct does not require Pupil field.
%
% INPUTS:
%   PSFStruct:  PSF Structure.  (Default = createPSFStruct())
%   L:          expansion order
%
% OUTPUTS:
%   PSF:        PSF Image Stack
%   PSFStruct:  updated PSF Structure
%
% REQUIRES:
%   Parallel Procesing Toolbox
%   NVidia GPU
%

% We are really just setting up a pupil to send to the scalarPSFPupil()
% method

%Check for GPU, if not present, overwrite gpuArray
% try
%     gpuDevice
% catch
%     gpuArray=@(x)x;
% end


if nargin <1
    P=smi_psf.PointSpreadFunction.createPSFStruct();
else %recalc Pupil
    P=PSFStruct;
    [XGrid,YGrid]=meshgrid((-P.OSZ/2:P.OSZ/2-1),(-P.OSZ/2:P.OSZ/2-1));
    R=sqrt(gpuArray(XGrid.^2+YGrid.^2));
    KPixelSize=1/(P.OSZ*P.PixelSize);
    PupilRadius=(P.NA/P.Lambda)/KPixelSize;
    Mask=R<PupilRadius;
    R=R/PupilRadius;
    Pupil_Mag=Mask;
    Pupil_Phase=gpuArray(zeros(P.OSZ,P.OSZ,'single'));
    Theta=(gpuArray(atan2(YGrid,XGrid))); %CHECK!
    
    Alpha=1/2;
    for ll=1:L
        M=(R>=((ll-1)/L).^Alpha)&(R<(ll/L).^Alpha);
        Pupil_Phase(M)=mod((2*(ll-1)+1)*Theta(M),2*pi); %make hole
    end
    %dipshow(gather(Pupil_Phase))
    P.Pupil=cat(3,Pupil_Mag,Pupil_Phase);
        

end



[PSF]=smi_psf.PointSpreadFunction.scalarPSFPupil(P);

PSFStruct=P;


end

./MATLAB/+smi_psf/@PointSpreadFunction/crlbPSFPupil_unitTest.m
function  [Report, CRLB]=crlbPSFPupil_unitTest()
%crlbPSFPupil_unitTest Tests crlbPSFPupil functionality.
%
% REQUIRES:
%   Parallel Procesing Toolbox
%   NVidia GPU
%

Report = 0;

SaveDir = smi_helpers.mkSMITETmpDir('unitTest', 'crlbPSFPupil');

%% Astigmatism PSF
PSFStruct=smi_psf.PointSpreadFunction.createPSFStruct()
PSFStruct.Z=(-1:.05:1);
PSFStruct.ZC_Phase=0;
PSFStruct.ZC_Phase(6)=1;
[PSF,PSFStruct]=smi_psf.PointSpreadFunction.scalarPSFZernike(PSFStruct); 
sliceViewer(gather(PSF))
[CRLB]=smi_psf.PointSpreadFunction.crlbPSFPupil(PSFStruct)
title('Astigmatism')
saveas(gcf, fullfile(SaveDir, 'cPP1.png'));

%% Prasad Spiral
L=2;
PSFStruct=smi_psf.PointSpreadFunction.createPSFStruct()
PSFStruct.Z=(-1:.05:1);
[PSF,PSFStruct]=smi_psf.PointSpreadFunction.scalarPSFPrasadZone(PSFStruct,L);
sliceViewer(gather(PSF))
[CRLB]=smi_psf.PointSpreadFunction.crlbPSFPupil(PSFStruct)
title('Prasad Spiral L=1')
saveas(gcf, fullfile(SaveDir, 'cPP2.png'));

%% Tetrapod
PSFStruct=smi_psf.PointSpreadFunction.createPSFStruct()
PSFStruct.Z=(-1:.05:1);
PSFStruct.ZC_Phase(6)=1;
PSFStruct.ZC_Phase(12)=-2;
PSFStruct.Z=(-1:.05:1);
[PSF,PSFStruct]=smi_psf.PointSpreadFunction.scalarPSFZernike(PSFStruct); 
sliceViewer(gather(PSF))
[CRLB]=smi_psf.PointSpreadFunction.crlbPSFPupil(PSFStruct)
title('Tetrapod')
saveas(gcf, fullfile(SaveDir, 'cPP3.png'));

%% Spherical Aberration
PSFStruct=smi_psf.PointSpreadFunction.createPSFStruct()
PSFStruct.ZC_Phase(11)=1;
PSFStruct.Z=(-1:.05:1);
[PSF,PSFStruct]=smi_psf.PointSpreadFunction.scalarPSFZernike(PSFStruct); 
sliceViewer(gather(PSF))
[CRLB]=smi_psf.PointSpreadFunction.crlbPSFPupil(PSFStruct)
title('Spherical Abberation')
saveas(gcf, fullfile(SaveDir, 'cPP4.png'));

Report = 1;

./MATLAB/+smi_psf/@PointSpreadFunction/createZernikeStruct.m
function  [ZStruct]=createZernikeStruct(SZ,Radius,NMax)
%createZernikeStruct Creates a createZernikeStruct.
%
%   ZStruct contains pre-computed images for quick expansion and sum
%
%   It contains the following fields:
%
%   SZ:             Image size (Default = 256)
%   Radius:         Radius of Pupil (Pixels) (Default = 64)
%   NMax:           Number of Zernike Images (Default = 21)
%   ZImages
%   R
%   Theta
%   NMax 
%   Norms
%
% OUTPUTS:
%   ZStruct:        ZStruct with all fields set to default
%
% REQUIRES:
%   Parallel Procesing Toolbox
%   NVidia GPU
%

%Check for GPU, if not present, overwrite gpuArray
% try
%     gpuDevice
% catch
%     gpuArray=@(x)x;
% end


if nargin <1
    SZ=256;
end

if nargin <2
    Radius=64;
end

if nargin <1
    NMax=21;
end


[XGrid,YGrid]=meshgrid((-SZ/2:SZ/2-1),(-SZ/2:SZ/2-1));
R=sqrt(gpuArray(XGrid.^2+YGrid.^2));
R=R/Radius;
Mask=R<=1;
R=R.*Mask;
Theta=(gpuArray(atan2(YGrid,XGrid)));
ZStruct.ZImages=gpuArray(zeros(NMax,SZ*SZ));

for nn=1:NMax
    Im=smi_psf.PointSpreadFunction.zernikeImage(nn,SZ,Radius,R,Theta,Mask);
    ZStruct.ZImages(nn,:)=Im(:);
end

A=1/sum(Mask(:));

for nn=1:NMax
    [N,M]=smi_psf.Zernike.zNoll2NM(nn);
    if M==0
        Em=2;
    else
        Em=1;
    end
    ZStruct.Norms(nn)=(2+2*N)/(Em)*A;   
end

ZStruct.SZ=SZ;
ZStruct.Radius=Radius;
ZStruct.NMax=NMax;
ZStruct.R=R;
ZStruct.Theta=Theta;
ZStruct.NMax=NMax;

./MATLAB/+smi_psf/@PointSpreadFunction/README.md
### +smi_psf/@PointSpreadFunction

PointSpreadFunction: Create and Quantify Point Spread Functions

Notes on Zernike Coeffiencts:  
We will use the Noll Linear Ordering Scheme.  Conversion from M,N
  to Noll linear index can be done with: 
- smi_psf.Zernike.zNoll2NM
- smi_psf.Zernike.zNM2Noll
- smi_psf.Zernike.zWyant2Noll

REQUIRES:
- Statistics Toolbox
- Parallel Procesing Toolbox
- NVidia GPU

SEE ALSO:
- smi_psf.Zernike

---
    
```
properties
   Lambda          % Emission wavelength (micron)
   NA              % Numerical Aperture
   N               % Index of Refraction
   PSF             % Point Spread Function
   PixelSize       % PixelSize of PSF (micron)
   Z               % Array of Z positions (micron)
   DataSet         % PSF Data (SZxSZxNxM) N repeats of M focal planes
   DataFile        % Data file containing DataSet,Z. Optional: PixelSize,NA,N
   PSFStruct       % PSF Structure for PSF Model
   PSFModel        % PSF Model generated by PFStruct
   RawData         % Raw Data From File
   PSFData         % Cropped PSF Data (not averaged)
   SZ              % Cropped PSF Size
   PSFCenter       % Center of PSF (Pixels) (Y,X)
   MaxZCMag=81     % Max Zenike Expansion in Magnitude Smoothing
   MaxZCPhase=81   % Max Zenike Expansion in Phase Smoothing
```

---

methods:
- **[createPSFStruct](createPSFStruct.m)**:
  Creates a default PSF Structure
- **[createZernikeStruct](createZernikeStruct.m)**:
  Creates a Zernike Structure
- **[crlbPSFPupil](crlbPSFPupil.m)**:
  Cramer Rao Lower Bound on (Y,X,Z,Photons,Bg)
- **[gui](gui.m)**:
  The beginnings of a GUI for dealing with PSF data
- **[optimPSFZernike](optimPSFZernike.m)**:
  Optimize PSF via Zernike Coef search
- **[phaseRetrieval](phaseRetrieval.m)**:
  Phase retrieval using GS Algorithm
- **[phaseRetrievalEM](phaseRetrievalEM.m)**:
  Phase retrieval plus EM to optimize NA, Lambda
- **[phaseRetrieval_Spiral](phaseRetrieval_Spiral.m)**:
  Phase retrieval using GS Algorithm
- **[psfROIStack](psfROIStack.m)**:
  Generates boxes of the data containing single particles (blobs)
- **[rescaleOTF](rescaleOTF.m)**:
  OTF rescaling
- **[scalarPSF](scalarPSF.m)**:
  PSF stack based on a scalar model with OTF rescaling
- **[scalarPSFPrasadZone](scalarPSFPrasadZone.m)**:
  PSF stack based on a scalar model Prasad Zones
- **[scalarPSFPupil](scalarPSFPupil.m)**:
  PSF stack from Pupil based on a scalar model with OTF Rescaling
- **[scalarPSFZernike](scalarPSFZernike.m)**:
  PSF stack from Zernike Coefficients based on a scalar model with OTF Rescaling
- **[zernikeExpansion](zernikeExpansion.m)**:
  xpand Image into Zernike Moments
- **[zernikeImage](zernikeImage.m)**:
  Generate a Zernike Polynomical Image from Noll Coefficient
- **[zernikeSum](zernikeSum.m)**:
  Generate an image from Noll Coefficients

unit tests:
- **[crlbPSFPupil_unitTest](crlbPSFPupil_unitTest.m)**:
  Tests crlbPSFPupil functionality
- **[optimPSFZernike_unitTest](optimPSFZernike_unitTest.m)**:
  Tests optimPSFZernike functionality
- **[psfROIStack_unitTest](psfROIStack_unitTest.m)**:
  Tests psfROIStack functionality
- **[scalarPSFPrasadZone_unitTest](scalarPSFPrasadZone_unitTest.m)**:
  Test scalarPSFPrasadZone functionality
- **[zernikeImage_unitTest](zernikeImage_unitTest.m)**:
  Tests zernikeImage functionality
- **[unitTest](unitTest.m)**:
  runs the individual unitTests

./MATLAB/+smi_psf/@PointSpreadFunction/scalarPSFZernike.m
function [PSF,P] =scalarPSFZernike(PSFStruct)
%scalarPSFZernike PSF stack from Zernike Coefficients based on a scalar model with OTF Rescaling.
%   The PSF is generated using the following model:
%   PSF = |F[OTF]|^2
%   % more...
%
%   Noll ordering is used as a linear index.    
%
%   PSF is normalized such that the integral over all space = 1
%
% INPUTS:
%   PSFStruct:  PSF Structure.  (Default = createPSFStruct())
%
% OUTPUTS:
%   PSF:        PSF Image Stack
%   P:          An updated PSFStruct 
%
% REQUIRES:
%   Parallel Procesing Toolbox
%   NVidia GPU
%
    
if nargin <1
    P=smi_psf.PointSpreadFunction.createPSFStruct();
else
    P=PSFStruct;
end


KPixelSize=1/(P.OSZ*P.PixelSize);
PupilRadius=(P.NA/P.Lambda)/KPixelSize;

NMax=max(length(P.ZC_Phase),length(P.ZC_Mag));
ZStruct=smi_psf.PointSpreadFunction.createZernikeStruct(P.OSZ,PupilRadius,NMax);

%magnitude
[Pupil_Mag]=smi_psf.PointSpreadFunction.zernikeSum(P.ZC_Mag,ZStruct);

%phase
[Pupil_Phase]=smi_psf.PointSpreadFunction.zernikeSum(P.ZC_Phase,ZStruct);

P.Pupil=cat(3,Pupil_Mag,Pupil_Phase);

[PSF,OTF]=smi_psf.PointSpreadFunction.scalarPSFPupil(P);


end

./MATLAB/+smi_psf/@PointSpreadFunction/phaseRetrieval_Spiral.m
function [PSFStruct,PSF]=phaseRetrieval_Spiral(PSFStruct,Data,MaxZCMag,MaxZCPhase,ZInfo,XYsubSample)
%phaseRetrieval_Spiral Phase retrieval using GS Algorithm.
%
%   The PSF is generated using the following model:
%   PSF = |F[OTF]|^2
%   % more....
%
%   PSF is normalized such that the integral over all space = 1
%
%   Input PSFStruct does not require Pupil field.
%
% INPUTS:
%   PSFStruct:  PSF Structure.
%   Data:       PSF Stack
%   MaxZCMag:   Limit for Zernike Expansion smoothing magnitude (Default=22)
%   MaxZCphase: Limit for Zernike Expansion smoothing phase (Default=81)
%               0 for no expansion. 
%   ZInfo:      Used to contruct PSFStruct.Z
%   XYsubSample: Used to normalize PSFStruct.PixelSize
%   
%
% OUTPUTS:
%   PSFStruct:  PSF Image Stack
%   PSF:        Point Spread Function
%
% REQUIRES:
%   Parallel Procesing Toolbox
%   NVidia GPU
%
% CITATION:
%   Hanser, ....

%Check for GPU, if not present, overwrite gpuArray
% try
%     gpuDevice
% catch
%     gpuArray=@(x)x;
% end

NMax_Mag = MaxZCMag;  %Zernike Expansion of Magnitude
NMax_Phase=MaxZCPhase;
NIterations=1000;
P=PSFStruct;
ImageSize=size(Data,1);
P.OSZ=ImageSize*3; %Factor of 3 from tiling

%Setup the arrays needed
KPixelSize=1/(P.OSZ*P.PixelSize);
[XGrid,YGrid]=meshgrid((-P.OSZ/2:P.OSZ/2-1),(-P.OSZ/2:P.OSZ/2-1));
R=sqrt(gpuArray(XGrid.^2+YGrid.^2));
PupilRadius=(P.NA/P.Lambda)/KPixelSize;
Mask=gpuArray(R<PupilRadius);

ZStruct_Mag=smi_psf.PointSpreadFunction.createZernikeStruct(P.OSZ,PupilRadius,NMax_Mag);
ZStruct_Phase=smi_psf.PointSpreadFunction.createZernikeStruct(P.OSZ,PupilRadius,NMax_Phase);

Kr_Image=KPixelSize.*Mask.*R;

Pupil_Mag=Mask;
Pupil_Phase=Mask*0;

OTFA_Stack=gpuArray(zeros(P.OSZ,P.OSZ,length(P.Z),'single'));
DefocusKernel=2*pi*sqrt(complex((P.N/P.Lambda)^2-Kr_Image.^2));

%Prepare the magnitude term from data
Data=gpuArray(single(Data));
Data=deTilt(Data);
PData=pad(Data); %Pad to OTFA Size

for ii=1:size(Data,3) %Inverse FFT Shift
    PSFA_Mag(:,:,ii) =ifftshift(sqrt(abs(PData(:,:,ii))));
end

L=2;
[~,PSFStruct_Spiral]=smi_psf.PointSpreadFunction.scalarPSFPrasadZone(P,L);
PupilSpiral = PSFStruct_Spiral.Pupil(:,:,2);

% Main GS Loop
for ii=1:NIterations
    ii
    %Apply Defocus
    for zz=1:length(P.Z)
        Defocus=P.Z(zz);
        PhaseIm=DefocusKernel.*Defocus+Pupil_Phase+PupilSpiral;
        OTFA_Stack(:,:,zz)=Mask.*Pupil_Mag.*exp(1i*PhaseIm);
        
        %Parseval Normalization
        OTFA_Stack(:,:,zz)=OTFA_Stack(:,:,zz)/sqrt(sum(sum(abs(OTFA_Stack(:,:,zz)).^2)))/ImageSize;
    end
    
    %Transform to real space and replace magnitude
    PSFA_Stack=fft2(OTFA_Stack);
    PSFA_Phase = angle(PSFA_Stack);
    
    for zz=1:length(P.Z)
        PSFA_Stack(:,:,zz)=PSFA_Mag(:,:,zz).*exp(1i*PSFA_Phase(:,:,zz));
    end
    
    %Transform back
    OTFA_Stack=ifft2(PSFA_Stack);
    
    %Remove defocus
    for zz=1:length(P.Z)
        Defocus=P.Z(zz);
        PhaseIm=DefocusKernel.*Defocus+PupilSpiral;
        OTFA_Stack(:,:,zz)=OTFA_Stack(:,:,zz).*exp(-1i*PhaseIm);
    end
    
    %Average stack
    Pupil=Mask.*mean(OTFA_Stack,3);
    
    %Constrain magnitude with zernike expansion
     [PSFStruct.ZC_Mag,Pupil_Mag]=smi_psf.PointSpreadFunction.zernikeExpansion(abs(Pupil),ZStruct_Mag);
    
    %Constrain phase with zernike expansion
    Pupil_Phase=angle(Pupil);
    if NMax_Phase>0
        [PSFStruct.ZC_Phase,Pupil_Phase]=smi_psf.PointSpreadFunction.zernikeExpansion(Pupil_Phase,ZStruct_Phase);
    end
    
    %Apply OTF Retriction
    Pupil_Mag=Mask.*Pupil_Mag;
    Pupil_Phase=Mask.*Pupil_Phase;
    
end

PSFStruct.Pupil=gpuArray(zeros(P.OSZ,P.OSZ,2,'single'));
PSFStruct.Pupil(:,:,1)=Pupil_Mag;
PSFStruct.Pupil(:,:,2)=Pupil_Phase+PupilSpiral;
PSFStruct.OSZ=P.OSZ;

if nargin > 4
    PSFStruct.Z = ZInfo(1):ZInfo(2):ZInfo(3);
end
if nargin > 5
    PSFStruct.PixelSize = PSFStruct.PixelSize / XYsubSample;
end

Model=smi_psf.PointSpreadFunction.scalarPSFPupil(PSFStruct);
PSFStruct.OTFSigma=smi_psf.PointSpreadFunction.rescaleOTF(Model,Data)*PSFStruct.PixelSize;
PSF=smi_psf.PointSpreadFunction.scalarPSFPupil(PSFStruct);

end

function Out=deTilt(In)
%Remove offset from image. Important!

Out=In;
SZ=size(In,1);
PlaneFun=@(Theta,X,Y,Data)double(gather(mean((Theta(1)*X+Theta(2)*Y+Theta(3)-Data).^2)));
[XGrid,YGrid]=meshgrid((1:SZ),(1:SZ));

for ii=1:size(In,3)
    Left = In(:,1,ii);
    Right = In(:,end,ii);
    Top = In(1,:,ii);
    Bottom = In(end,:,ii);
    Data=cat(1,Left(:),Right(:),Top(:),Bottom(:));
    
    V=(1:SZ)';
    V1=ones(SZ,1);
    
    X=cat(1,V1,SZ*V1,V,V);
    Y=cat(1,V,V,V1,V1*SZ);
    
    Theta=fminsearch(PlaneFun,[1 1 1],optimset(),X,Y,Data);
    Out(:,:,ii)=In(:,:,ii)-XGrid*Theta(1)-YGrid*Theta(2)-Theta(3);
    Out(:,:,ii)=Out(:,:,ii)/sum(sum(Out(:,:,ii))); %Normalize
end

end


function Out=pad(In)
% Pad image by flipping and windowing
% 
% try
%     gpuDevice
% catch
%     gpuArray=@(x)x;
% end

L=8; %window length
INSZ=size(In,1); %Assumed square

[XGrid,YGrid]=meshgrid((0:INSZ-1),(0:INSZ-1));
WR=(gpuArray((cos(pi/L*XGrid))+1).*(XGrid<L))/2;
WB=(gpuArray((cos(pi/L*YGrid))+1).*(YGrid<L))/2;
WB(WB<0)=0;

WL=flip(WR,2);
WT=flip(WB,1);

TSZ=INSZ*3;
%Flip image to make 3x3
Out=gpuArray(zeros([TSZ,TSZ,size(In,3)],'single'));

Im1=flip(In,1);
Im2=flip(In,2);
Im12=flip(flip(In,1),2);

% loop over z
for zz = 1 : size(In,3)

%Left Column
Out(1:INSZ,1:INSZ,zz)=Im12(:,:,zz).*WL.*WT;
Out(INSZ+1:INSZ+INSZ,1:INSZ,zz)=Im2(:,:,zz).*WL;
Out(2*INSZ+1:2*INSZ+INSZ,1:INSZ,zz)=Im12(:,:,zz).*WL.*WB;

%Middle Column
Out(1:INSZ,INSZ+1:INSZ+INSZ,zz)=Im1(:,:,zz).*WT;
Out(INSZ+1:INSZ+INSZ,INSZ+1:INSZ+INSZ,zz)=In(:,:,zz);
Out(2*INSZ+1:2*INSZ+INSZ,INSZ+1:INSZ+INSZ,zz)=Im1(:,:,zz).*WB;

%Right Column
Out(1:INSZ,2*INSZ+1:2*INSZ+INSZ,zz)=Im12(:,:,zz).*WT.*WR;
Out(INSZ+1:INSZ+INSZ,2*INSZ+1:2*INSZ+INSZ,zz)=Im2(:,:,zz).*WR;
Out(2*INSZ+1:2*INSZ+INSZ,2*INSZ+1:2*INSZ+INSZ,zz)=Im12(:,:,zz).*WB.*WR;

end

end

./MATLAB/+smi_psf/@PointSpreadFunction/scalarPSFPupil.m
function [PSF,PSFStruct]=scalarPSFPupil(PSFStruct)
%scalerPSFPupil PSF stack from Pupil based on a scalar model with OTF Rescaling.
%   The PSF is generated using the following model:
%   PSF = |F[OTF]|^2
%   % more...
%
%   PSF is normalized such that the integral over all space = 1
%   
% INPUTS:
%   PSFStruct:  PSF Structure.  (Default = createPSFStruct())
%
% OUTPUTS:
%   PSF:        PSF Image Stack
%   PSFStruct:  Updated PSF Structure.
%
% REQUIRES:
%   Parallel Procesing Toolbox
%   NVidia GPU
%


%Check for GPU, if not present, overwrite gpuArray
% try
%     gpuDevice
% catch
%     gpuArray=@(x)x;
% end

% OTF:   Optical Transfer Function
% Pupil: Pupil Magnitude and Phase (SZ x SZ x 2)

%Set Defaults
if nargin <1
    P=smi_psf.PointSpreadFunction.createPSFStruct();
else
    P=PSFStruct;
end

if max(PSFStruct.OTFSigma)>0 %build smoothing kernel
    [XGridS,YGridS]=meshgrid((-P.SZ/2:P.SZ/2-1),(-P.SZ/2:P.SZ/2-1));
    SmoothKer=normpdf(gpuArray(XGridS),0,P.OTFSigma(2)/P.PixelSize).*...
        normpdf(gpuArray(YGridS),0,P.OTFSigma(1)/P.PixelSize);
end


[XGrid,YGrid]=meshgrid((-P.OSZ/2:P.OSZ/2-1),(-P.OSZ/2:P.OSZ/2-1));

R=sqrt(gpuArray(XGrid.^2+YGrid.^2));

KPixelSize=1/(P.OSZ*P.PixelSize);
PupilRadius=(P.NA/P.Lambda)/KPixelSize;
Mask=R<PupilRadius;
Kr_Image=KPixelSize.*Mask.*R;

Pupil_Mag=gpuArray(single(P.Pupil(:,:,1)));
Pupil_Phase=gpuArray(single(P.Pupil(:,:,2)));

%Sometimes this is too big, default to CPU
try
    OTFA_Stack=gpuArray(complex(zeros(P.OSZ,P.OSZ,length(P.Z),'single')));
catch
    OTFA_Stack=complex(zeros(P.OSZ,P.OSZ,length(P.Z),'single')); 
end

DefocusKernel=2*pi*sqrt(complex((P.N/P.Lambda)^2-Kr_Image.^2));

for zz=1:length(P.Z)
    Defocus=P.Z(zz);  %in microns
    PhaseIm=DefocusKernel.*Defocus+Pupil_Phase;
    
    OTFA=Mask.*Pupil_Mag.*exp(1i*PhaseIm);
    
    %Parseval Normalizaton
    Norm=sqrt(sum(sum(abs(OTFA).^2)))*P.OSZ;
    
    if isa(OTFA_Stack,'gpuArray') %Deal with large CPU arrays
        OTFA_Stack(:,:,zz)=OTFA/Norm;
    else
        OTFA_Stack(:,:,zz)=gather(OTFA/Norm);
    end
end

%Transform to real space
try %sometimes this is too big for some reason
    PSFA_Stack=fft2(OTFA_Stack);
catch
    PSFA_Stack=(fft2(gather(OTFA_Stack)));
    if exist('SmoothKer')
        SmoothKer=gather(SmoothKer);
    end
end

try
    SimDataStack=gpuArray(zeros(P.OSZ,P.OSZ,length(P.Z),'single'));
catch
    SimDataStack=(zeros(P.OSZ,P.OSZ,length(P.Z),'single'));
end


for zz=1:length(P.Z)
    PSFA_Stack(:,:,zz)=fftshift(PSFA_Stack(:,:,zz));
    if max(P.OTFSigma)>0 %apply smoothing in real space
        SimDataStack(:,:,zz)=conv2(abs(PSFA_Stack(:,:,zz)).^2,SmoothKer,'same');
    else
        SimDataStack(:,:,zz)=abs(PSFA_Stack(:,:,zz)).^2;
    end
end


% now cut to desired size: (only for even sizes) TODO
CenterPixel=P.OSZ/2+1;
PSF=SimDataStack(CenterPixel-P.SZ/2:CenterPixel+P.SZ/2-1,CenterPixel-P.SZ/2:CenterPixel+P.SZ/2-1,:);


end

./MATLAB/+smi_psf/@PointSpreadFunction/phaseRetrieval.m
function [PSFStruct,PSF]=phaseRetrieval(PSFStruct,Data,MaxZCMag,MaxZCPhase)
%phaseRetrieval Phase retrieval using GS Algorithm.
%
%   The PSF is generated using the following model:
%   PSF = |F[OTF]|^2
%   % more...
%
%   PSF is normalized such that the integral over all space = 1
%
%   Input PSFStruct does not require Pupil field.
%
% INPUTS:
%   PSFStruct:  PSF Structure.
%   Data:       PSF Stack
%   MaxZCMag:   Limit for Zernike Expansion smoothing magnitude (Default=22)
%   MaxZCphase: Limit for Zernike Expansion smoothing phase (Default=81)
%               0 for no expansion. 
%   
%
% OUTPUTS:
%   PSFStruct:  PSF Image Stack
%   PSF:        Point Spread Function
%
% REQUIRES:
%   Parallel Procesing Toolbox
%   NVidia GPU
%
% CITATION:
%   Hanser, ....

%Check for GPU, if not present, overwrite gpuArray
% try
%     gpuDevice
% catch
%     gpuArray=@(x)x;
% end

if ~exist('MaxZCMag', 'var')
   MaxZCMag = 22;
end
if ~exist('MaxZCPhase', 'var')
   MaxZCPhase = 81;
end

NMax_Mag = MaxZCMag;  %Zernike Expansion of Magnitude
NMax_Phase=MaxZCPhase;
NIterations=1000;
P=PSFStruct;
ImageSize=size(Data,1);
P.OSZ=ImageSize*3; %Factor of 3 from tiling

%Setup the arrays needed
KPixelSize=1/(P.OSZ*P.PixelSize);
[XGrid,YGrid]=meshgrid((-P.OSZ/2:P.OSZ/2-1),(-P.OSZ/2:P.OSZ/2-1));
R=sqrt(gpuArray(XGrid.^2+YGrid.^2));
PupilRadius=(P.NA/P.Lambda)/KPixelSize;
Mask=gpuArray(R<PupilRadius);

ZStruct_Mag=smi_psf.PointSpreadFunction.createZernikeStruct(P.OSZ,PupilRadius,NMax_Mag);
ZStruct_Phase=smi_psf.PointSpreadFunction.createZernikeStruct(P.OSZ,PupilRadius,NMax_Phase);


Kr_Image=KPixelSize.*Mask.*R;

Pupil_Mag=Mask;
Pupil_Phase=Mask*0;

OTFA_Stack=gpuArray(zeros(P.OSZ,P.OSZ,length(P.Z),'single'));
DefocusKernel=2*pi*sqrt(complex((P.N/P.Lambda)^2-Kr_Image.^2));

%Prepare the magnitude term from data
Data=gpuArray(single(Data));
Data=deTilt(Data);
PData=pad(Data); %Pad to OTFA Size

for ii=1:size(Data,3) %Inverse FFT Shift
    PSFA_Mag(:,:,ii) =ifftshift(sqrt(abs(PData(:,:,ii))));
end

%Main GS Loop
for ii=1:NIterations
    
    %Apply Defocus
    for zz=1:length(P.Z)
        Defocus=P.Z(zz);
        PhaseIm=DefocusKernel.*Defocus+Pupil_Phase;
        OTFA_Stack(:,:,zz)=Mask.*Pupil_Mag.*exp(1i*PhaseIm);
        
        %Parseval Normalization
        OTFA_Stack(:,:,zz)=OTFA_Stack(:,:,zz)/sqrt(sum(sum(abs(OTFA_Stack(:,:,zz)).^2)))/ImageSize;
    end
    
    %Transform to real space and replace magnitude
    PSFA_Stack=fft2(OTFA_Stack);
    PSFA_Phase = angle(PSFA_Stack);
    
    for zz=1:length(P.Z)
        PSFA_Stack(:,:,zz)=PSFA_Mag(:,:,zz).*exp(1i*PSFA_Phase(:,:,zz));
    end
    
    %Transform back
    OTFA_Stack=ifft2(PSFA_Stack);
    
    %Remove defocus
    for zz=1:length(P.Z)
        Defocus=P.Z(zz);
        PhaseIm=DefocusKernel.*Defocus;
        OTFA_Stack(:,:,zz)=OTFA_Stack(:,:,zz).*exp(-1i*PhaseIm);
    end
    
    %Average stack
    Pupil=Mask.*mean(OTFA_Stack,3);
    
    %Constrain magnitude with zernike expansion
    [PSFStruct.ZC_Mag,Pupil_Mag]=smi_psf.PointSpreadFunction.zernikeExpansion(abs(Pupil),ZStruct_Mag);
    
    %Constrain phase with zernike expansion
    Pupil_Phase=angle(Pupil);
    if NMax_Phase>0
        [PSFStruct.ZC_Phase,Pupil_Phase]=smi_psf.PointSpreadFunction.zernikeExpansion(Pupil_Phase,ZStruct_Phase);
    end
    
    %Apply OTF Retriction
    Pupil_Mag=Mask.*Pupil_Mag;
    Pupil_Phase=Mask.*Pupil_Phase;
    
end

PSFStruct.Pupil=gpuArray(zeros(P.OSZ,P.OSZ,2,'single'));
PSFStruct.Pupil(:,:,1)=Pupil_Mag;
PSFStruct.Pupil(:,:,2)=Pupil_Phase;
PSFStruct.OSZ=P.OSZ;

Model=smi_psf.PointSpreadFunction.scalarPSFPupil(PSFStruct);
PSFStruct.OTFSigma=smi_psf.PointSpreadFunction.rescaleOTF(Model,Data)*PSFStruct.PixelSize;
PSF=smi_psf.PointSpreadFunction.scalarPSFPupil(PSFStruct);

end

function Out=deTilt(In)
%Remove offset from image. Important!

Out=In;
SZ=size(In,1);
PlaneFun=@(Theta,X,Y,Data)double(gather(mean((Theta(1)*X+Theta(2)*Y+Theta(3)-Data).^2)));
[XGrid,YGrid]=meshgrid((1:SZ),(1:SZ));

for ii=1:size(In,3)
    Left = In(:,1,ii);
    Right = In(:,end,ii);
    Top = In(1,:,ii);
    Bottom = In(end,:,ii);
    Data=cat(1,Left(:),Right(:),Top(:),Bottom(:));
    
    V=(1:SZ)';
    V1=ones(SZ,1);
    
    X=cat(1,V1,SZ*V1,V,V);
    Y=cat(1,V,V,V1,V1*SZ);
    
    Theta=fminsearch(PlaneFun,[1 1 1],optimset(),X,Y,Data);
    Out(:,:,ii)=In(:,:,ii)-XGrid*Theta(1)-YGrid*Theta(2)-Theta(3);
    Out(:,:,ii)=Out(:,:,ii)/sum(sum(Out(:,:,ii))); %Normalize
end

end


function Out=pad(In)
% Pad image by flipping and windowing
% 
% try
%     gpuDevice
% catch
%     gpuArray=@(x)x;
% end

L=8; %window length
INSZ=size(In,1); %Assumed square

[XGrid,YGrid]=meshgrid((0:INSZ-1),(0:INSZ-1));
WR=(gpuArray((cos(pi/L*XGrid))+1).*(XGrid<L))/2;
WB=(gpuArray((cos(pi/L*YGrid))+1).*(YGrid<L))/2;
WB(WB<0)=0;

WL=flip(WR,2);
WT=flip(WB,1);

TSZ=INSZ*3;
%Flip image to make 3x3
Out=gpuArray(zeros([TSZ,TSZ,size(In,3)],'single'));

Im1=flip(In,1);
Im2=flip(In,2);
Im12=flip(flip(In,1),2);

% loop over z
for zz = 1 : size(In,3)

%Left Column
Out(1:INSZ,1:INSZ,zz)=Im12(:,:,zz).*WL.*WT;
Out(INSZ+1:INSZ+INSZ,1:INSZ,zz)=Im2(:,:,zz).*WL;
Out(2*INSZ+1:2*INSZ+INSZ,1:INSZ,zz)=Im12(:,:,zz).*WL.*WB;

%Middle Column
Out(1:INSZ,INSZ+1:INSZ+INSZ,zz)=Im1(:,:,zz).*WT;
Out(INSZ+1:INSZ+INSZ,INSZ+1:INSZ+INSZ,zz)=In(:,:,zz);
Out(2*INSZ+1:2*INSZ+INSZ,INSZ+1:INSZ+INSZ,zz)=Im1(:,:,zz).*WB;

%Right Column
Out(1:INSZ,2*INSZ+1:2*INSZ+INSZ,zz)=Im12(:,:,zz).*WT.*WR;
Out(INSZ+1:INSZ+INSZ,2*INSZ+1:2*INSZ+INSZ,zz)=Im2(:,:,zz).*WR;
Out(2*INSZ+1:2*INSZ+INSZ,2*INSZ+1:2*INSZ+INSZ,zz)=Im12(:,:,zz).*WB.*WR;

end

end

./MATLAB/+smi_psf/@PointSpreadFunction/DIP/oversamplePSFPupil.m
function [PSF,PSFStruct_OS] = oversamplePFSPupil(PSFStruct,Sampling)
%oversamplePFSPupil Resamples a PSF to smaller pixels.  
%  
% INPUTS:
%   PSFStruct:      PSF Structure. Must contain 'Pupil' field. 
%   Sampling:       Oversampling. Bust be integer >=1 (Default=4)
%
% OUTPUTS:
%   PSF:            Resampled PSF
%   PSFStruct_OS:   Updated PSF Structure
%
% REQUIRES:
%   Statistics Toolbox
%   Parallel Procesing Toolbox
%   NVidia GPU
%
% CITATION:
%   Full citatation with all authors.         


if nargin<2
    Sampling=4;
end

P_OS=PSFStruct;
P_OS.SZ=PSFStruct.SZ*Sampling;
P_OS.PixelSize=PSFStruct.PixelSize/Sampling;

%Pad pupil
Pupil_1X=gather(P_OS.Pupil);
PMag=extend(Pupil_1X(:,:,1),[Sampling,Sampling]*P_OS.OSZ,'symmetric');
PPhase=extend(Pupil_1X(:,:,2),[Sampling,Sampling]*P_OS.OSZ,'symmetric');
P_OS.Pupil=single(cat(3,PMag,PPhase));

%update OTF size
P_OS.OSZ=Sampling*PSFStruct.OSZ;

PSF=gather(smi_psf.PointSpreadFunction.scalarPSFPupil(P_OS));
PSFStruct_OS=P_OS;

end

./MATLAB/+smi_psf/@PointSpreadFunction/DIP/oversamplePSFPupil_unitTest.m
function [Report] = oversamplePFSPupil_unitTest(PSFStruct,Sampling)
%oversamplePFSPupil_unitTest Test and Demonstrate oversamplePFSPupil.
%
% REQUIRES:
%    DIPimage (https://diplib.org/DIPimage.html)

Report = 0;

SaveDir = smi_helpers.mkSMITETmpDir('unitTest', 'oversamplePSFPupil');

%%
%clc; close all
%Create PSFStruct
P=smi_psf.PointSpreadFunction.createPSFStruct();
P.Z=(-2:.02:2)
P.OTFSigma=[.1,.1];
%Show unsampled PSF
[PSF]=smi_psf.PointSpreadFunction.scalarPSFPupil(P);
figure;
sliceViewer(gather(PSF));
colormap('hot')
saveas(gcf, fullfile(SaveDir, 'osPP1.png'));

[PFS_OS,P_OS]=smi_psf.PointSpreadFunction.oversamplePSFPupil(P,4);
%Show upsampled PSF
figure;
sliceViewer(gather(PFS_OS));
colormap('hot')
saveas(gcf, fullfile(SaveDir, 'osPP2.png'));

Report = 1;

end

./MATLAB/+smi_psf/@PointSpreadFunction/DIP/phaseRetrieval_unitTest.m
function [PSFStruct]=phaseRetrieval_unitTest()
%phaseRetrieval_unitTest Tests phaseRetrieval using GS Algorithm.
%
% REQUIRES:
%    DIPimage (https://diplib.org/DIPimage.html)

%%
%close all

SaveDir = smi_helpers.mkSMITETmpDir('unitTest', 'phaseRetrieval');

%Create a noise defocus stack with offset
P=smi_psf.PointSpreadFunction.createPSFStruct();
P.OSZ=64*3; %Factor 3 to match padding done in PR
P.ZC_Phase(6)=6;
P.ZC_Phase(12)=-2;
P.ZC_Mag(4)=-.2
P.Z=(-1:.2:1);
[PSF,P]=smi_psf.PointSpreadFunction.scalarPSFZernike(P);

Data=poissrnd(gather(PSF)*100000+10)+100;
%Data=Data+shift(Data,[10 0 0])


%Do phase retrieval and compare data stack
P_Out=smi_psf.PointSpreadFunction.phaseRetrieval(P,Data)
%dipshow(gather(P_Out.Pupil))
Model=gather(smi_psf.PointSpreadFunction.scalarPSFPupil(P_Out));

%dipshow(gather(Data))
%dipshow(gather(Model))
joinchannels('RGB',stretch(gather(Data)),stretch(Model))


%Expand into Zernike modes and see if we get correct phase back
KPixelSize=1/(size(P_Out.Pupil,1)*P_Out.PixelSize);
PupilRadius=(P_Out.NA/P_Out.Lambda)/KPixelSize;

ZS=smi_psf.PointSpreadFunction.createZernikeStruct(P_Out.OSZ,PupilRadius,21);
P_Out.ZC_Phase=gather(smi_psf.PointSpreadFunction.zernikeExpansion(P.Pupil(:,:,2),ZS));
P_Out.ZC_Phase
saveas(gcf, fullfile(SaveDir, 'pR1.png'));

return
%% Trying with some real data

close all
load('C:\Data\Data_FastVarLaser2-2016-8-3-12-23-8.mat')
SZ=128;
%%dipshow(1,CleanData);
CNR=[141 107];
Data=cut(CleanData,[SZ SZ size(CleanData,3)],[CNR-SZ/2 0]);

P=smi_psf.PointSpreadFunction.createPSFStruct();
P.SZ=SZ;
P.NA=1.4;
P.N=1.52;
P.Lambda=.69;
P.Z=ZVector;
DataIn=Data;
P_Out=smi_psf.PointSpreadFunction.phaseRetrieval(P,DataIn);

%dipshow(gather(P_Out.Pupil))
Model=gather(smi_psf.PointSpreadFunction.scalarPSFPupil(P_Out));

KPixelSize=1/(size(P_Out.Pupil,1)*P_Out.PixelSize);
PupilRadius=(P_Out.NA/P_Out.Lambda)/KPixelSize;
ZS=smi_psf.PointSpreadFunction.createZernikeStruct(P_Out.OSZ,PupilRadius,49);
P_Out.ZC_Phase=gather(smi_psf.PointSpreadFunction.zernikeExpansion(P_Out.Pupil(:,:,2),ZS));
P_Out.ZC_Mag=gather(smi_psf.PointSpreadFunction.zernikeExpansion(P_Out.Pupil(:,:,1),ZS));
[PSFZ,P_OutZ]=smi_psf.PointSpreadFunction.scalarPSFZernike(P_Out);
%dipshow(gather(P_OutZ.Pupil))
%dipshow(gather(DataIn))
%dipshow(gather(PSFZ))
P_OutZ.ZC_Phase

%%


close all
load('C:\Data\Data_FastVarLaser2-2016-8-3-12-23-8.mat')
SZ=128;
%%dipshow(1,CleanData);
CNR=[141 107];
Data=cut(CleanData,[SZ SZ size(CleanData,3)],[CNR-SZ/2 0]);

P=smi_psf.PointSpreadFunction.createPSFStruct();
P.SZ=SZ;
P.NA=1.48;
P.N=1.52;
P.Lambda=.69;
P.Z=ZVector([1,7]);
DataIn=Data(:,:,[1,6]);
P_Out=smi_psf.PointSpreadFunction.phaseRetrievalEM(P,DataIn);
P_Out=smi_psf.PointSpreadFunction.phaseRetrieval(P_Out,DataIn);

%dipshow(gather(P_Out.Pupil))
Model=gather(smi_psf.PointSpreadFunction.scalarPSFPupil(P_Out));

KPixelSize=1/(size(P_Out.Pupil,1)*P_Out.PixelSize);
PupilRadius=(P_Out.NA/P_Out.Lambda)/KPixelSize;
ZS=smi_psf.PointSpreadFunction.createZernikeStruct(P_Out.OSZ,PupilRadius,49);
P_Out.ZC_Phase=gather(smi_psf.PointSpreadFunction.zernikeExpansion(P_Out.Pupil(:,:,2),ZS));
P_Out.ZC_Mag=gather(smi_psf.PointSpreadFunction.zernikeExpansion(P_Out.Pupil(:,:,1),ZS));
[PSFZ,P_OutZ]=smi_psf.PointSpreadFunction.scalarPSFZernike(P_Out);
%dipshow(gather(P_OutZ.Pupil))
%dipshow(gather(DataIn))
%dipshow(gather(PSFZ))
P_OutZ.ZC_Phase

PSFStruct = P;

./MATLAB/+smi_psf/@PointSpreadFunction/PointSpreadFunction.m
classdef PointSpreadFunction < handle
%PointSpreadFunction Create and Quantify Point Spread Functions
%
%   Notes on Zernike Coeffiencts:  
%       We will use the Noll Linear Ordering Scheme.  Conversion from M,N
%       to Noll linear index can be done with: 
%       smi_psf.Zernike.zNoll2NM
%       smi_psf.Zernike.zNM2Noll
%       smi_psf.Zernike.zWyant2Noll
%
% REQUIRES:
%   Statistics Toolbox
%   Parallel Procesing Toolbox
%   NVidia GPU
%
% SEE ALSO:
%   smi_psf.Zernike
    
    properties
        Lambda              %Emission wavelength (micron)
        NA                  %Numerical Aperture
        N                   %Index of Refraction
        PSF                 %Point Spread Function
        PixelSize           %PixelSize of PSF (micron)
        Z                   %Array of Z positions (micron)
        DataSet             %PSF Data (SZxSZxNxM) N repeats of M focal planes
        DataFile            %Data file containing DataSet,Z. Optional: PixelSize,NA,N
        PSFStruct           %PSF Structure for PSF Model
        PSFModel            %PSF Model generated by PFStruct
        RawData             %Raw Data From File
        PSFData             %Cropped PSF Data (not averaged)
        SZ                  %Cropped PSF Size
        PSFCenter           %Center of PSF (Pixels) (Y,X)
        MaxZCMag=81         %Max Zenike Expansion in Magnitude Smoothing
        MaxZCPhase=81       %Max Zenike Expansion in Phase Smoothing
    end

    methods
        function obj=PointSpreadFunction()
            %Constructor
        end
        
        function loadData(obj,FileName,DataSetName)
            %loadData Load PSF Data and properties from *.mat file
            %
            %   File must contain PSF Data and Z, the vector of defocus
            %   values. 
            %
            %   PixelSize, NA, N will be loaded if avaiable in file. 
            %
            % INPUTS:
            %   FileName:       Name of *.mat file containing PSF Data (optional)
            %   DataSetName:    Name of PSF Data Variable Name (Default='DataSet') 
            %   
            if nargin>1
                obj.DataFile=FileName;
            else
                [FileName,PathName]=uigetfile('Y:\','*.mat');
                obj.DataFile=fullfile(PathName,FileName);
            end
            
            M=matfile(obj.DataFile);
            obj.DataSet=M.DataSet;
            obj.Z=M.Z;
            try
                obj.NA=M.NA;
            end
            try
                obj.N=M.N;
            end
            try
                obj.PixelSize=M.PixelSize;
            end
        end
        
        function savePSF(obj,FileName)
        %savePSF saves PSFStruct and PSF in a user-specified file
            if nargin>1
                SaveFile=FileName;
            else
                [FileName,PathName]=uigetfile('Y:\','*.mat');
                SaveFile=fullfile(PathName,FileName);
            end
            PSF=obj.PSFModel;
            save(SaveFile,'PSFStruct','PSF')
        end
        
        function cropData(obj,Center)
            %cropData Crop data to obj.SZ around Center
            %
            % If Center is not given and obj.PSFCenter is empty,
            % Center finding is interactive
            %
            % INPUTS
            %   Center:     Center of PSF (Pixels) (Y,X) (Default=obj.PSFCenter) 
            
            Data=mean(obj.RawData,3);
            if ((nargin<2) && (isempty(obj.PSFCenter)))
                h=dipshow(Data);
                C=dipgetcoords(h);
                close(h);
                obj.PSFCenter=[C(2),C(1)]+1;
            else
                obj.PSFCenter=Center;
            end
            
            obj.PSFData=obj.RawData(CTR(1)-obj.SZ/2+1:CTR(1)+obj.SZ/2,CTR(2)-obj.SZ/2+1:CTR(2)+obj.SZ/2,:);
    
        end
        
        function phaseRetrieve(obj)
            %phaseRetrieve Retrieval of Pupil Magnitude and Phase
            %
            %   See PointSpreadFunction.phaseRetrieval
            %    
            %
            
            %Crop Data and Average
            if isempty(obj.PSFData)
                obj.cropData();
            end
            
            Data=mean(obj.PSFData,3);
            
            %Make PSF Struct
            P=PointSpreadFunction.createPSFStruct();
            P.Z=obj.Z;
            P.Lambda=obj.Lambda;
            P.NA=obj.NA;
            P.N=obj.N;
            P.PixelSize=obj.PixelSize;
            P.SZ=obj.SZ;
            
            [obj.PSFStruct,obj.PSFModel]=...
                phaseRetrieval(P,Data,obj.MaxZCMag,obj.MaxZCPhase);
        end
    end
    
    methods (Static)
        
        %Data Structures
        [PSFStruct]=createPSFStruct()
        [ZStruct]=createZernikeStruct(SZ,Radius,NMax)
        
        %PSF Generation
        [PSF,PSFStruct]=scalarPSF(PSFStruct)
        [PSF,PSFStruct]=scalarPSFPupil(PSFStruct)
        [PSF,PSFStruct]=scalarPSFZernike(PSFStruct)
        [PSF,PSFStruct]=scalarPSFPrasadZone(PSFStruct,L)
        [PSF,PSFStruct]=oversamplePSFPupil(PSFStruct,Sampling)
        
        %CRLB Calculations
        [CRLB,DET]=crlbPSFPupil(PSFStruct,Photons,Bg,PlotFlag)
       
        %PSF Modeling
        [Pupil,PSF]=phaseRetrieval(PSFStruct,Data,MaxZCMag,MaxZCPhase)
        [PSFStruct]=phaseRetrievalEM(PSFStruct,Data)
        [PSFStruct,PSF]=phaseRetrieval_Spiral(PSFStruct,Data,MaxZCMag,MaxZCPhase)
        %Optimization
        [PSFStruct,PSF,CRLB]=optimPSFZernike(PSFStruct,PhaseMask,StartPhase,Photons,Bg)
        [OTFVector]=rescaleOTF(PSFStruct,Data)
        
        %Zernike Calculations
        [Image]=zernikeImage(NollCoef,SZ,Radius,R,Theta,Mask)  
        [Image]=zernikeSum(NollCoefs,ZStruct)    
        [NollCoef,ImageZ]=zernikeExpansion(Image,ZStruct)
        
        [Model,Data]=psfROIStack(SZ,SMD,PSF,XYSamPerPix,ZSamPerUnit,NoiseIm)

        %Unit Tests
        [Report, CRLB]=crlbPSFPupil_unitTest()
        [Report]=optimPSFZernike_unitTest()
        [Report]=oversamplePSFPupil_unitTest()
        [Report, PSFStruct]=phaseRetrieval_unitTest()
        [Report]=scalarPSFPrasadZone_unitTest()
        [Report] = psfROIStack_unitTest()
        [Report]=zernikeImage_unitTest()
        unitTest()   % overall unitTest

    end

end

./MATLAB/+smi_psf/@PointSpreadFunction/zernikeSum.m
function [Image]=zernikeSum(NollCoefs,ZStruct)
%zernikeSum Generate an image from Noll Coefficients,
%
%
%   Noll ordering is used as a linear index.
%
%   More about formula and conventions.
%
% INPUTS:
%   NollCoefs:      Noll Coefficients (Nx1);
%   ZStruct         Pre-computed images for quick expansion and sum
%
% OUTPUTS:
%   Image:          Zernike Polynomial Image
%
% REQUIRES:
%   Parallel Procesing Toolbox
%   NVidia GPU
%

if length(NollCoefs)>ZStruct.NMax
    error('zernikeSum:: ZStruct too small')
end

if length(NollCoefs)<ZStruct.NMax
    ZImages=ZStruct.ZImages(1:length(NollCoefs),:);
else
    ZImages=ZStruct.ZImages;
end

NollCoefs=diag(NollCoefs);
Image=sum(NollCoefs*ZImages,1);
Image=reshape(Image,[ZStruct.SZ,ZStruct.SZ]);







./MATLAB/+smi_psf/README.md
### +smi_psf

+smi_psf is the namespace for the Point Spread Function classes of ***smite***:
- [@PointSpreadFunction](@PointSpreadFunction/README.md):
  create and quantify point spread functions
- [@Zernike](@Zernike/README.md):
  low-level Zernike polynomial functions

./MATLAB/setupSMITE.m
function setupSMITE()
%Run this function in startup.m to setup required paths for smite.
% If the smite folder is located in userpath, then use the following: 
% 
% MATLAB 2017a and later:
%   run(fullfile(userpath,'smite','setupSMITE'))
% MATLAB 2016b and ealier:
%   run(fullfile(userpath(1:end-1),'smite','setupSMITE'))

SMITEPath=fileparts(which('setupSMITE'));

addpath(SMITEPath)
addpath(fullfile(SMITEPath,'mex'))
addpath(fullfile(SMITEPath,'ptx'))

ExtSoftPath = fileparts(SMITEPath);
run(fullfile(ExtSoftPath, 'ExternalSoftware', 'setupExternalSoftware'));

end


./MATLAB/+smi_core/@DataToPhotons/unitTest.m
function [Success] = unitTest()
%unitTest checks vital functionality of the DataToPhotons class.
% This method will perform various tests to determine if the vital
% methods of the DataToPhotons class are working as intended.
%
% INPUTS:
%
% OUTPUTS:
%   Success: A boolean array whose elements indicate success/failure of
%            various methods of the DataToPhotons class. (Boolean)
%            Success(1): Test of the class constructor.
%            Success(2): method convertToPhotons(), RawData is gain and
%                        offset corrected succesfully for non-scalar gain
%                        and offset.
%            Success(3): method convertToPhotons(), the input read-noise
%                        (given as a variance) is succesfully converted to
%                        units of photons^2 for non-scalar gain and offset.
%            Success(4): Same as Success(1) for scalar gain.
%            Success(5): Same as Success(2) for scalar offset.

% Created by:
%   David J. Schodt (Lidke Lab, 2020)


% Seed the random number generator so that we always get the same results.
rng(1234)

% Generate some simulated raw data (I grabbed some numbers from a random
% sCMOS calibration file and tried to roughly match those numbers for this
% simulation).
% NOTE: Adding structure to the raw data probably doesn't add anything to
%       the unitTest(), but it seems worth it in the case that there is a
%       failure in the unitTest(): it might be easier to track down if
%       there is something meaningful to look at.
FrameSizeFull = 256; % don't change this! other numbers assume = 256
NFrames = 10;
CameraGain = 2 + 0.2*randn(FrameSizeFull, 'single'); % ADU / e-
CameraOffset = 100 + 0.5*randn(FrameSizeFull, 'single'); % ADU
CameraReadNoise = (3 + randn(FrameSizeFull, 'single')).^2; % ADU^2
SMD = smi_core.SingleMoleculeData.createSMD();
SMD.X = repmat(128 + 64*[0; 1; 1; -1; -1], [NFrames, 1]);
SMD.Y = repmat(128 + 64*[0; 1; -1; 1; -1], [NFrames, 1]);
SMD.Photons = 1e3 * ones(5*NFrames, 1);
SMD.PSFSigma = 1.3;
SMD.FrameNum = repelem((1:NFrames).', 5);
SMD.Bg = zeros(5*NFrames, 1);
SMD.YSize = FrameSizeFull;
SMD.XSize = FrameSizeFull;
SMD.NFrames = NFrames;
[~, Data] = smi_sim.GaussBlobs.gaussBlobImage(SMD);

% Add read noise to the simulated data and then convert to ADU.
% NOTE: gaussBlobImage() can also add read noise (in photons) but I wanted
%       to keep ReadNoiseVariance in units of ADU^2 for unit consistency.
ReadNoiseVariancePhotons = CameraReadNoise ./ (CameraGain.^2);
DataWithReadNoise = Data ...
    + sqrt(ReadNoiseVariancePhotons).*randn(FrameSizeFull);
DataWithReadNoise(DataWithReadNoise < 0) = 0;
RawDataFull = CameraGain.*DataWithReadNoise + CameraOffset;

% Divide RawDataFull into 5 quadrants, one centered on each of the blobs
% in the simulation (this is just to test that I'm indexing into arrays
% like CameraGain correctly in convertToPhotons()).
IndicesTopLeft = [1:128; 1:128].'; % [rows, columns]
IndicesTopRight = [1:128; 129:256].';
IndicesBottomRight = [129:256; 129:256].';
IndicesBottomLeft = [129:256; 1:128].';
IndicesCenter = (128-64) + IndicesTopLeft;
RawDataTopLeft = RawDataFull(IndicesTopLeft(:, 1), ...
    IndicesTopLeft(:, 2), :);
RawDataTopRight = RawDataFull(IndicesTopRight(:, 1), ...
    IndicesTopRight(:, 2), :);
RawDataBottomRight = RawDataFull(IndicesBottomRight(:, 1), ...
    IndicesBottomRight(:, 2), :);
RawDataBottomLeft = RawDataFull(IndicesBottomLeft(:, 1), ...
    IndicesBottomLeft(:, 2), :);
RawDataCenter = RawDataFull(IndicesCenter(:, 1), ...
    IndicesCenter(:, 2), :);
ROITopLeft = [min(IndicesTopLeft), max(IndicesTopLeft)];
ROITopRight = [min(IndicesTopRight), max(IndicesTopRight)];
ROIBottomRight = [min(IndicesBottomRight), max(IndicesBottomRight)];
ROIBottomLeft = [min(IndicesBottomLeft), max(IndicesBottomLeft)];
CalibrationROI = [1, 1, FrameSizeFull, FrameSizeFull];

% Create an instance of the DataToPhotons class and test the constructor.
% If this runs without throwing an exception, I'll just assume everything 
% worked.
SMF = smi_core.SingleMoleculeFitting;
SMF.Data.CameraGain = CameraGain;
SMF.Data.CameraOffset = CameraOffset;
SMF.Data.CameraReadNoise = CameraReadNoise;
Success = zeros(1, 5, 'logical');
try
    DTP = smi_core.DataToPhotons(SMF, RawDataBottomRight, ...
        ROIBottomRight, CalibrationROI, true);
    DTP = smi_core.DataToPhotons(SMF, RawDataBottomRight, ...
        ROIBottomRight, CalibrationROI, false);
    Success(1) = true;
catch MException
    warning('error message: %s', ...
        MException.identifier, MException.message)
end

% Test the gain/offset corrections in convertToPhotons() in the corner test
% quadrants.
CorrectedData = zeros(FrameSizeFull, FrameSizeFull, NFrames, 'single');
CorrectedNoise = zeros(FrameSizeFull, 'single');
DTP.RawData = RawDataTopLeft;
DTP.RawDataROI = ROITopLeft;
[CorrectedData(IndicesTopLeft(:, 1), IndicesTopLeft(:, 2), :), ...
    CorrectedNoise(IndicesTopLeft(:, 1), IndicesTopLeft(:, 2))] = ...
    DTP.convertData();
DTP.RawData = RawDataTopRight;
DTP.RawDataROI = ROITopRight;
[CorrectedData(IndicesTopRight(:, 1), IndicesTopRight(:, 2), :), ...
    CorrectedNoise(IndicesTopRight(:, 1), IndicesTopRight(:, 2))] = ...
    DTP.convertData();
DTP.RawData = RawDataBottomRight;
DTP.RawDataROI = ROIBottomRight;
[CorrectedData(IndicesBottomRight(:, 1), IndicesBottomRight(:, 2), :), ...
    CorrectedNoise(IndicesBottomRight(:, 1), IndicesBottomRight(:, 2))] = ...
    DTP.convertData();
DTP.RawData = RawDataBottomLeft;
DTP.RawDataROI = ROIBottomLeft;
[CorrectedData(IndicesBottomLeft(:, 1), IndicesBottomLeft(:, 2), :), ...
    CorrectedNoise(IndicesBottomLeft(:, 1), IndicesBottomLeft(:, 2))] = ...
    DTP.convertData();
Success(2) = all(abs(CorrectedData(:)-DataWithReadNoise(:)) < 0.1);
Success(3) = all(abs(CorrectedNoise(:)-ReadNoiseVariancePhotons(:)) < 0.1);

% Test the gain/offset corrections in the center test quadrant, avoiding
% setting the input ROI to test the default indexing.
DTP.RawData = RawDataCenter;
DTP.RawDataROI = [];
[CorrectedDataCenter, CorrectedNoiseCenter] = DTP.convertData();
TrueDataCenter = DataWithReadNoise(IndicesCenter(:, 1), ...
    IndicesCenter(:, 2), :);
TrueNoiseCenter = ReadNoiseVariancePhotons(IndicesCenter(:, 1), ...
    IndicesCenter(:, 2));
Success(2) = (Success(2) ...
    & all(abs(CorrectedDataCenter(:)-TrueDataCenter(:)) < 0.1));
Success(3) = (Success(3) ...
    & all(abs(CorrectedNoiseCenter(:)-TrueNoiseCenter(:)) < 0.1));

% Repeat the above tests for scalar gain and offset (the quadrants no
% longer matter in this case so we can just test the entire image).
% Add read noise to the simulated data and then convert to ADU.
% NOTE: gaussBlobImage() can also add read noise (in photons) but I wanted
%       to keep ReadNoiseVariance in units of ADU^2 for unit consistency.
CameraGain = mean(CameraGain(:));
CameraOffset = mean(CameraOffset(:));
CameraReadNoise = mean(CameraReadNoise(:));
ScalarReadNoisePhotons = CameraReadNoise / CameraGain.^2;
DataWithScalarReadNoise = Data ...
    + sqrt(ScalarReadNoisePhotons)*randn(FrameSizeFull);
DataWithScalarReadNoise(DataWithScalarReadNoise < 0) = 0;
RawData = CameraGain.*DataWithScalarReadNoise + CameraOffset;
DTP.RawData = RawData;
DTP.CameraGain = CameraGain;
DTP.CameraOffset = CameraOffset;
DTP.CameraReadNoise = CameraReadNoise;
[CorrectedData, CorrectedNoise] = DTP.convertData();
Success(4) = all(abs(CorrectedData(:)-DataWithScalarReadNoise(:)) < 0.1);
Success(5) = (abs(CorrectedNoise-ScalarReadNoisePhotons) < 0.1);


end

./MATLAB/+smi_core/@DataToPhotons/convertToPhotons.m
function [CorrectedData, CorrectedReadNoise] = ...
    convertToPhotons(RawData, ...
    CameraGain, CameraOffset, CameraReadNoise, ...
    RawDataROI, CalibrationROI)
%convertToPhotons converts RawData to units of photons.
%
% This method will convert the image(s) contained in the array RawData to
% units of photons using the detector calibration information contained in
% the input CalibrationStruct.
%
% NOTE: The input RawData is assumed to be of the form 
%       RawData = Gain*RawData_photons + Offset where RawData_photons
%       is the output variable 'RawData' and RawData is given in units of
%       ADU.  It further assumed that one photoelectron correspond to one
%       photon, i.e., RawData_photons is really in units of photoelectrons.
%
% INPUTS:
%   RawData: An array whose entries correspond to pixels of the collection
%            camera. (ADU)(mxnxN numeric array)
%   CameraGain: An array specifying the camera gain. This can be either a 
%               scalar (e.g., for a CCD) or a matrix (e.g., for an sCMOS). 
%               (ADU/e-)(1x1 array, or (m+a)x(n+b) array w/ a,b >= 0)
%   CameraOffset: An array specifying the camera offset.
%                 (ADU)(dimensions must match CameraGain)
%   CameraReadNoise: An array specifying the camera noise.
%                    (ADU^2)(dimensions must match CameraGain)
%   RawDataROI: The region of interest (ROI) of the input RawData on the
%               camera.
%               (Pixels)([YStart, XStart, YEnd, XEnd])
%               (Default = [], meaning RawData is centered w.r.t. 
%               CameraGain/OffsetImage, or that CameraGain/OffsetImage are
%               scalars)
%   CalibrationROI: ROI of the CameraGain, OffsetImage, and CameraNoise (if
%                   they aren't scalars).  If CameraGain/OffsetImage aren't
%                   scalars, CalibrationROI must specify a region that at
%                   least contains the RawDataROI.
%                   (Pixels)([YStart, XStart, YEnd, XEnd])
%                   (Default = [1, 1, size(CameraGain)])
%
% OUTPUTS:
%   Data: The input RawData corrected for gain and offset (i.e., converted
%         to units of photons)(Photons)(mxnxN single array)
%   ReadNoise: The input field CameraReadNoise converted to units of 
%              photons, truncated to the region of the camera defined by
%              RawDataROI when appropriate (i.e., when CameraReadNoise is 
%              non-scalar).
%              (Pixels)(mxn single array, 1x1 single array, or [], 
%              depending on the input CameraReadNoise)

% Created by:
%   David J. Schodt (Lidke Lab, 2020)
%       based on previous version by Hanieh Mazloom-Farsibaf


% Copy parameters from the CalibrationStruct to local variables and set
% defaults where appropriate.
if (~exist('RawDataROI', 'var') || isempty(RawDataROI))
    RawDataROI = [];
end
if (~exist('CalibrationROI', 'var') || isempty(CalibrationROI))
    CalibrationROI = [1, 1, size(CameraGain)];
end

% Typecast arrays where appropriate.
RawData = single(RawData);
CameraGain = single(CameraGain);
CameraOffset = single(CameraOffset);
CameraReadNoise = single(CameraReadNoise);

% Compare array sizes and ROI definitions to ensure consistency.
SizeRawData = size(RawData);
SizeCameraGain = size(CameraGain);
SizeCameraOffset = size(CameraOffset);
SizeCameraNoise = size(CameraReadNoise);
assert(all(SizeCameraGain == SizeCameraOffset), ...
    'DataToPhotons.convertToPhotons(): Input ''%s'' fields ', ...
    '''GainImage'' and ''OffsetImage'' must be the same size', ...
    inputname(2))
assert(...
    (prod(SizeCameraGain)==1) || all(SizeRawData(1:2)<=SizeCameraGain), ...
    ['DataToPhotons.convertToPhotons(): Input ''%s'' fields ', ...
    '''GainImage'' and ''OffsetImage'' must be either scalars or ', ...
    'they must be smaller than images in the image stack ''%s''.'], ...
    inputname(2), inputname(1))
assert(isempty(RawDataROI) ...
    || all((RawDataROI(3:4)-RawDataROI(1:2)+1)==SizeRawData(1:2)), ...
    ['DataToPhotons.convertToPhotons(): RawDataROI is not consistent ', ...
    'with the size of RawData'])
assert(isempty(RawDataROI) ...
    || all((RawDataROI(1:2)>=CalibrationROI(1:2)) ...
    & (RawDataROI(3:4)<=CalibrationROI(3:4))), ...
    ['DataToPhotons.convertToPhotons(): Input CalibrationROI', ...
    ' must contain the RawDataROI.'])
assert(...
    isempty(CameraReadNoise) || all(SizeCameraNoise == SizeCameraGain), ...
    ['DataToPhotons.convertToPhotons(): Input ''%s'' field ', ...
    '''CameraNoise'' must be either empty or the same size as ''%s'' ', ...
    ' field ''CameraGain'''], inputname(2), inputname(2))

% Isolate the portions of GainImage and OffsetImage corresponding to the
% specified RawDataROI of RawData (if needed).
if (prod(SizeCameraGain) > 1)
    % If RawDataROI is empty, we will assume RawData corresponds to the
    % center ROI of GainImage and OffsetImage.
    if isempty(RawDataROI)
        StartPosition = ...
            1 + round((SizeCameraGain(1:2)-SizeRawData(1:2))/2);
        RawDataROI = repmat(StartPosition, [1, 2]) ...
            + [0, 0, SizeRawData(1:2)-1];
    end
    
    % Isolate the desired portions of GainImage and OffsetImage.
    RowIndices = RawDataROI(1):RawDataROI(3);
    ColumnIndices = RawDataROI(2):RawDataROI(4);
    CameraGainSub = CameraGain(RowIndices, ColumnIndices);
    CameraOffsetSub = CameraOffset(RowIndices, ColumnIndices);
    CameraNoiseSub = CameraReadNoise(RowIndices, ColumnIndices);
else
    CameraGainSub = CameraGain;
    CameraOffsetSub = CameraOffset;
    CameraNoiseSub = CameraReadNoise;
end

% Perform the gain and offset correction to convert RawData to units of
% photons.
% NOTE: MATLAB will still do this element-wise calculation correctly even
%       when size(RawData, 3) > 1 .
CorrectedData = (RawData-CameraOffsetSub) ./ CameraGainSub;
CorrectedReadNoise = CameraNoiseSub ./ (CameraGainSub.^2);

% Remove negative values from Data.
% NOTE: The old version of this code used a lower threshold of 0.01 instead
%       of 0.  I'm just using 0 because I don't see the benefit of using
%       0.01 (although one might exist that I'm just not seeing!).
CorrectedData(CorrectedData < 0) = 0; 


end
./MATLAB/+smi_core/@DataToPhotons/convertData.m
function [CorrectedData, CorrectedReadNoise] = convertData(obj)
%convertData performs gain/offset correction on data.
% This method is meant to be a wrapper around convertToPhotons(), providing
% a means to do the gain/offset correction while storing all parameters,
% raw data, and corrected data in the class instance obj.
%
% OUTPUTS:
%   CorrectedData: gain/offset corrected obj.RawData. (float array)
%   CorrectedReadNoise: gain/offset corrected obj.ReadNoise

% Created by:
%   David J. Schodt (Lidke Lab, 2021)


% Call obj.convertToPhotons() and store the outputs in obj.
if (obj.Verbose > 0)
    fprintf(['\tDataToPhotons.convertData(): ', ...
        'Performing gain and offset correction on provided data...\n'])
end
[CorrectedData, CorrectedReadNoise] = ...
    obj.convertToPhotons(obj.RawData, ...
    obj.CameraGain, obj.CameraOffset, obj.CameraReadNoise, ...
    obj.RawDataROI, obj.CalibrationROI);
obj.CorrectedData = CorrectedData;
obj.CorrectedReadNoise = CorrectedReadNoise;
if (obj.Verbose > 0)
    fprintf(['\tDataToPhotons.convertData(): ', ...
        'Gain and offset correction complete.\n'])
end


end
./MATLAB/+smi_core/@DataToPhotons/README.md
### +smi_core/@DataToPhotons

This class contains static methods associated with the gain and
offset correction needed to convert raw data from the camera (arrays
given in Analog to Digital Units (ADU)) to units of photons.  The
main usage of this class is shown in the EXAMPLE USAGE section below.

---

EXAMPLE USAGE:
- Given RawData in units of ADU, and an SMF structure with the fields
  SMF.Data.CameraGain, SMF.Data.CameraOffset, and
  SMF.Data.CameraReadNoise (see SingleMoleculeFitting class for
  details), you can convert RawData and CameraReadNoise to units of
  photons and photons^2, respectively, as follows:
```
      [~, RawDataConverted, CameraReadNoiseConverted] = ...
          smi_core.DataToPhotons(SMF, ...
          RawData, RawDataROI, CalibrationROI, true);
```
  Alternatively, you can prepare the class for usage (and set class
  parameters immediately) as follows:
```
      DTP = smi_core.DataToPhotons(SMF, ...
          RawData, RawDataROI, CalibrationROI);
      [Data, ReadNoise] = DTP.convertData();
```

REQUIRES:
- Image Processing Toolbox
- Statistics and Machine Learning Toolbox

---
    
```
properties:
   % obj.RawData converted to units of photons (float array)
   CorrectedData {mustBeNumeric(CorrectedData)}
   
   % obj.CameraReadNoise converted to units of photons (float array)
   CorrectedReadNoise {mustBeNumeric(CorrectedReadNoise)}
   
   % Data that is to be gain/offset corrected (float array)
   RawData {mustBeNumeric(RawData)}

   % Region of interest of the raw data (float array)
   % (see obj.convertToPhotons() for details/usage)
   RawDataROI {mustBeNumeric(RawDataROI)}
   
   % Gain of the camera used to collect RawData (float array)(ADU/e-)
   CameraGain {mustBeNumeric(CameraGain)}
   
   % Offset of the camera used to collect RawData (float array)(ADU)
   CameraOffset {mustBeNumeric(CameraOffset)}
   
   % Read noise of the camera used to collect Raw Data (float array)(ADU^2)
   CameraReadNoise {mustBeNumeric(CameraReadNoise)}
   
   % Region of interest of the gain/offset arrays (float array)
   % (see obj.convertToPhotons() for details/usage)
   CalibrationROI {mustBeNumeric(CalibrationROI)}
   
   % Verbosity level for standard workflow. (Default = 1)
   %   0: Command Window updates will be supressed where possible and
   %      reasonable.
   %   1: Some updates may appear in Command Window
   %   2: More detailed updates in Command Window
   %   3: Lot's of info. may be passed to Command Window. This mode
   %      may be useful for debugging large workflows encompassing
   %      this class.
   Verbose = 1;
```

---

methods:
- **[convertData](convertData.m)**:
  performs gain/offset correction on data
- **[convertToPhotons](convertToPhotons.m)**:
  converts RawData to units of photons
- **[unitTest](unitTest.m)**:
  checks vital functionality of the DataToPhotons class

./MATLAB/+smi_core/@DataToPhotons/DataToPhotons.m
classdef DataToPhotons < handle
    %DataToPhotons contains static methods to convert raw data to photons.
    %
    % This class contains static methods associated with the gain and
    % offset correction needed to convert raw data from the camera (arrays
    % given in Analog to Digital Units (ADU)) to units of photons.  The
    % main usage of this class is shown in the EXAMPLE USAGE section below.
    %
    % EXAMPLE USAGE:
    %   Given RawData in units of ADU, and an SMF structure with the fields
    %   SMF.Data.CameraGain, SMF.Data.CameraOffset, and
    %   SMF.Data.CameraReadNoise (see SingleMoleculeFitting class for
    %   details), you can convert RawData and CameraReadNoise to units of
    %   photons and photons^2, respectively, as follows:
    %       [~, RawDataConverted, CameraReadNoiseConverted] = ...
    %           smi_core.DataToPhotons(SMF, ...
    %           RawData, RawDataROI, CalibrationROI, true);
    %   Alternatively, you can prepare the class for usage (and set class
    %   parameters immediately) as follows:
    %       DTP = smi_core.DataToPhotons(SMF, ...
    %           RawData, RawDataROI, CalibrationROI);
    %       [Data, ReadNoise] = DTP.convertData();
    %
    % REQUIRES:
    %   Image Processing Toolbox
    %   Statistics and Machine Learning Toolbox
    
    
    properties
        % obj.RawData converted to units of photons (float array)
        CorrectedData {mustBeNumeric(CorrectedData)}
        
        % obj.CameraReadNoise converted to units of photons (float array)
        CorrectedReadNoise {mustBeNumeric(CorrectedReadNoise)}
        
        % Data that is to be gain/offset corrected (float array)
        RawData {mustBeNumeric(RawData)}

        % Region of interest of the raw data (float array)
        % (see obj.convertToPhotons() for details/usage)
        RawDataROI {mustBeNumeric(RawDataROI)}
        
        % Gain of the camera used to collect RawData (float array)(ADU/e-)
        CameraGain {mustBeNumeric(CameraGain)}
        
        % Offset of the camera used to collect RawData (float array)(ADU)
        CameraOffset {mustBeNumeric(CameraOffset)}
        
        % Read noise of the camera used to collect Raw Data (float array)(ADU^2)
        CameraReadNoise {mustBeNumeric(CameraReadNoise)}
        
        % Region of interest of the gain/offset arrays (float array)
        % (see obj.convertToPhotons() for details/usage)
        CalibrationROI {mustBeNumeric(CalibrationROI)}
        
        % Verbosity level for standard workflow. (Default = 1)
        %   0: Command Window updates will be supressed where possible and
        %      reasonable.
        %   1: Some updates may appear in Command Window
        %   2: More detailed updates in Command Window
        %   3: Lot's of info. may be passed to Command Window. This mode
        %      may be useful for debugging large workflows encompassing
        %      this class.
        Verbose = 1;
    end
    
    methods
        function [obj, Data, ReadNoise] = DataToPhotons(SMF, ...
                RawData, RawDataROI, CalibrationROI, Verbose, AutoRun)
            %DataToPhotons is the class constructor.
            % This constructor has several optional inputs which are set to
            % class properties.  If you provide all inputs (e.g., SMF,
            % RawData, ...) and set AutoRun = 1, this class will
            % automatically run obj.convertData() on your data.  The
            % results will be stored in the appropriate class properties,
            % but you can also retrieve them by specifying 2nd and 3rd
            % outputs from this constructor. Note that the input
            % CalibrationROI is unused when SMF.Data.CalibrationFilePath is
            % defined. Instead, we'll attempt to set that field with the
            % value stored in that file.
            
            % Set defaults if needed.
            if (~exist('AutoRun', 'var') || isempty(AutoRun))
                AutoRun = 0;
            end
            
            % Set class properties based on the inputs.
            AllFieldsSet = true;
            if (exist('Verbose', 'var') && ~isempty(Verbose))
                obj.Verbose = Verbose;
            end
            if (exist('CalibrationROI', 'var') && ~isempty(CalibrationROI))
                % NOTE: This may be overwritten below if a calibration file
                %       is present and the camera type is specified as
                %       'SCMOS'. If that happens, it was done on purpose!
                %       It's best to use the value in the calibration file
                %       rather than what the user has entered.
                obj.CalibrationROI = CalibrationROI;
                if (obj.Verbose > 2)
                    fprintf(['\tDataToPhotons constructor: ', ...
                        'Input CalibrationROI structure stored as a ', ...
                        'class property.\n'])
                end
            end
            if (exist('SMF', 'var') && ~isempty(SMF))
                % Reload the SMF to ensure it has all required properties.
                SMF = smi_core.SingleMoleculeFitting.reloadSMF(SMF);
                
                % Set the desired SMF fields to class properties.
                if (isempty(SMF.Data.CalibrationFilePath) ...
                        || strcmpi(SMF.Data.CameraType, 'EMCCD'))
                    % If no filepath is given, or if the camera is
                    % specified as an EMCCD, we don't need to load a
                    % calibration file.
                    obj.CameraGain = SMF.Data.CameraGain;
                    obj.CameraOffset = SMF.Data.CameraOffset;
                    obj.CameraReadNoise = SMF.Data.CameraReadNoise;
                    if (obj.Verbose > 2)
                        fprintf(['\tDataToPhotons constructor: ', ...
                            'Camera gain, offset, and read-noise ', ...
                            'provided in input SMF have been stored ', ...
                            'as class properties.\n'])
                    end
                else
                    % Attempt to load the calibration data.
                    [obj.CameraGain, obj.CameraOffset, ...
                        obj.CameraReadNoise, obj.CalibrationROI] = ...
                        smi_core.LoadData.loadDataCalibration(SMF);
                    if (obj.Verbose > 2)
                        fprintf(['\tDataToPhotons constructor: ', ...
                            'Camera gain, offset, and read-noise ', ...
                            'loaded from file specified by ', ...
                            'SMF.Data.CalibrationFilePath.\n'])
                    end
                end
            else
                AllFieldsSet = false;
            end
            if (exist('RawData', 'var') && ~isempty(RawData))
                obj.RawData = RawData;
                if (obj.Verbose > 2)
                    fprintf(['\tDataToPhotons constructor: ', ...
                        'Input RawData stored as a class property.\n'])
                end
            else
                AllFieldsSet = false;
            end
            if (exist('RawDataROI', 'var') && ~isempty(RawDataROI))
                obj.RawDataROI = RawDataROI;
                if (obj.Verbose > 2)
                    fprintf(['\tDataToPhotons constructor: ', ...
                        'Input RawDataROI stored as a class property.\n'])
                end
            else
                AllFieldsSet = false;
            end
            
            % Run obj.convertToPhotons() if requested.
            Data = [];
            ReadNoise = [];
            if (AutoRun && AllFieldsSet)
                if (obj.Verbose > 2)
                    fprintf(['\tDataToPhotons constructor: ', ...
                        'Auto-running obj.convertData()...\n'])
                end
                obj.convertData();
            end
        end
        
        [CorrectedData, CorrectedReadNoise] = convertData(obj);
        
    end
    
    methods (Static)
        [CorrectedData, CorrectedReadNoise] = convertToPhotons(RawData, ...
            CameraGain, CameraOffset, CameraReadNoise, ...
            RawDataROI, CalibrationROI);
        [Success] = unitTest();
    end
    
    
end
./MATLAB/+smi_core/@DriftCorrection/regViaDC.m
%regViaDC (registration via drift correction) takes two differently labeled
% data collections of the same biological phenomenon and attempts to align them
% using inter-dataset drift correction.
function [delta12, Statistics] = regViaDC(SMD1, SMD2)
%
% INPUTS:
%    SMD1    fixed  data (X and Y fields in pixels)
%    SMD2    moving data (X and Y fields in pixels)
%            Data are from either BaGoL ResultsStruct files (SMR) or smite
%            Results (SMD + SMF) files taken under the same imaging conditions.
%
% OUTPUTS:
%    delta12      computed registration shift in the same units as SMD1/2.X/Y
%    Statistics   statistical information about the algorithm performance
%                 (see driftCorrectKNN)
%
% Note that:
%    drifted coordinates - drift correction = drift corrected coordinates

% Created by
%    Michael J. Wester, 2021

   DC = smi_core.DriftCorrection;

   % Intra-dataset threshold (pixel)
   DC.L_intra        = 1;
   % Inter-dataset threshold (pixel)
   DC.L_inter        = 2;
   % X/Y pixel size in um (only needed for 3D drift correction)
   DC.PixelSizeZUnit = 0.1;
   % Degree of the intra-dataset fitting polynomial for drift rate
   DC.PDegree        = 1;
   % Termination tolerance on the intra-dataset function value
   DC.TolFun_intra   = 1e-2;
   % Termination tolerance on the intra-dataset fitting polynomial
   DC.TolX_intra     = 1e-4;
   % Termination tolerance on the inter-dataset function value
   DC.TolFun_inter   = 1e-2;
   % Termination tolerance on the inter-dataset fitting polynomial
   DC.TolX_inter     = 1e-4;
   % Initialization wrt the previous dataset for inter-dataset drift correction
   % The value should be either 0 (no initial drift), 1 (initial drift of the
   % previous dataset) or SMD.NFrames (final drift); zero or initial drift
   % should work well with brightfield registration, while final drift works
   % well generally (but the optimization process may not converge quite as
   % quickly).
   DC.Init_inter     = 1;
   % If non-empty, override the collected value of number of datasets
   DC.NDatasets      = [];
   % If non-empty, override the collected value of number of frames per dataset
   DC.NFrames        = [];
   % Verbosity level
   DC.Verbose        = 1;

   % Treat the two collections as two datasets in one collection.
   SMDin.X = [SMD1.X; SMD2.X];
   SMDin.Y = [SMD1.Y; SMD2.Y];
   SMDin.NDatasets = 2;
   SMDin.NFrames   = 1;
   SMDin.DatasetNum = [repmat(1, numel(SMD1.X), 1);
                       repmat(2, numel(SMD2.X), 1)];
   SMDin.FrameNum   = repmat(1, numel(SMDin.X), 1);

   [SMDout, Statistics] = DC.driftCorrectKNN(SMDin);
   delta12 = [SMDout.DriftX(1, 2), SMDout.DriftY(1, 2)];

end

./MATLAB/+smi_core/@DriftCorrection/unitTest.m
function [success, SMD2, SMD3, Statistics2, Statistics3] = unitTest()
% unitTest tests smi_core.DriftCorrection.driftCorrectKNN.
% Synthetic data is created by smlmData.m, which then has drift imposed upon
% it.  This data is then drift corrected by driftCorrectKNN, producing a SMD
% structure that has DriftX and DriftY added.
%
% INPUTS:
%   No inputs needed
%
% OUTPUTS:
%   success           0 (failure) or 1 (success)
%   SMD2, SMD3    data structures for 2D or 3D examples with the following
%                 fields:
%       X:            x coordinates (Nx1) where N is total number of points
%       Y:            y coordinates (Nx1)
%       Z:            z coordinates (Nx1)
%       DatasetNum:   dataset number from which localization originates (Nx1)
%       FrameNum:     frame   number from which localization originates (Nx1)
%       NFrames:      number of frames in each dataset
%       NDatasets:    number of datasets
%       DriftX:       found x drift (Nframes x Ndatasets)
%       DriftY:       found y drift (Nframes x Ndatasets)
%       DriftZ:       found z drift (Nframes x Ndatasets)
%   Statistics2:  statistical information about the algorithm performance
%   Statistics3   including various input parameters (2D or 3D)
%
% REQUIRES:
%   Parallel Processing Toolbox
%   Statistics Toolbox
%   NVidia GPU

% Created by:
%   Farzin Farzam (Keith Lidke Lab 2017) [adapted from driftCorrect2D_unitTest]
%   Michael Wester (Lidke Lab 2017/2018)

success = 0;

close all


SaveDir = smi_helpers.mkSMITETmpDir('unitTest', 'DriftCorrection');

SIM = smi_sim.SimSMLM();
SIM.SZ = 256;
SIM.Rho = 10;
SIM.NDatasets = 10;
SIM.NFrames = 100;
SIM.simStar(16);
SMDsim = SIM.SMD_Model;

XYSize = SIM.SZ;
n_frames = SIM.NDatasets * SIM.NFrames;
PpFX = 0.04;      % x drift (pixels per frame)
PpFY = 0.07;      % y drift (pixels per frame)

rho = SIM.Rho;
FpD = SIM.NFrames; % number of frames per dataset

%load('SMDsim2D');

fprintf('2D\n');
n_particles = numel(SMDsim.X);
fprintf('Number of emitters = %d, per pixel = %f, per dataset = %f\n', ...
        n_particles, n_particles / XYSize^2, n_particles / (n_frames / FpD));
[n_emitters, n_blinks, n_local, n_datasets] = ...
   blinks(n_particles, SMDsim.X, SMDsim.Y, SMDsim.Y, ...
          SMDsim.FrameNum, SMDsim.DatasetNum);
fprintf( ...
   '# of emitters = %d, blinks = %d, localizations = %d, datasets = %d\n', ...
   n_emitters, n_blinks, n_local, n_datasets);
PixelSizeZUnit = 0.1; % um
P2nm = PixelSizeZUnit * 1000;

% Re-organize so X and Y are the first inputs.
SMDin = SMDsim;
SMDin.X_SE = ones(n_particles, 1);
SMDin.Y_SE = ones(n_particles, 1);
SMDin.Bg = zeros(n_particles, 1);
SMDin.PixelSizeZUnit = PixelSizeZUnit;

% Histogram image of this data.
SRImageZoom = 4;
TrueIm = smi_vis.GenerateImages.histogramImage(SMDin, SRImageZoom); %new
P = prctile(TrueIm(TrueIm > 0), 99.9);
TrueIm(TrueIm > P) = P;
TrueIm = 255 * TrueIm / P;
figure; imagesc(TrueIm); colormap(gray); % what we should get afterwards
saveas(gcf, fullfile(SaveDir, 'TrueIm.png'));

X_True = single(SMDin.X);
Y_True = single(SMDin.Y);
% Creating drift per frame: fast way!
frame_num = SMDin.NFrames*(SMDin.DatasetNum - 1) + SMDin.FrameNum - 1;
SMDin.X = SMDin.X + frame_num*PpFX;
SMDin.Y = SMDin.Y + frame_num*PpFY;
% Boundary condtions.
for i = 1 : numel(SMDin.X)
   if SMDin.X(i) >= XYSize;
%     SMDin.X(i) = XYSize;
   end
   if SMDin.Y(i) >= XYSize;
%     SMDin.Y(i) = XYSize;
   end
end
SMDsave = SMDin;

DriftIm = smi_vis.GenerateImages.histogramImage(SMDin, SRImageZoom); %new
P = prctile(DriftIm(DriftIm > 0), 99.9);
DriftIm(DriftIm > P) = P;
DriftIm = 255 * DriftIm / P;
figure; imagesc(DriftIm); colormap(gray);  %synthetic drift image
saveas(gcf, fullfile(SaveDir, 'DriftIm.png'));
%GaussIm = smi_vis.GenerateImages.gaussianImage(SMDin, SRImageZoom);
%figure; imagesc(GaussIm); colormap(gray);

SMF = smi_core.SingleMoleculeFitting();
SMF.DriftCorrection.BFRegistration = false;
DC = smi_core.DriftCorrection(SMF, SMDin);

clear SMD
[SMD, Statistics] = DC.driftCorrectKNN(SMDin);
%Statistics

% Remove any NaNs.
nans = find(isnan(SMDin.X) | isnan(SMDin.Y) | isnan(SMD.X) | isnan(SMD.Y));
n_nans = numel(nans);
if n_nans > 0
   fprintf('%d NaNs removed!\n', n_nans);
   SMDin.X(nans) = [];
   SMDin.Y(nans) = [];
   SMD.X(nans) = [];
   SMD.Y(nans) = [];
   X_True(nans) = [];
   X_Yrue(nans) = [];
end

% Consistency check.
N = numel(SMD.X);
X_inDC = zeros(N, 1, 'single');
Y_inDC = zeros(N, 1, 'single');
X_unDC = zeros(N, 1, 'single');
Y_unDC = zeros(N, 1, 'single');
for k = 1:N
   i = SMD.FrameNum(k);
   j = SMD.DatasetNum(k);
   X_inDC(k) = SMDin.X(k) - SMD.DriftX(i, j);
   Y_inDC(k) = SMDin.Y(k) - SMD.DriftY(i, j);
   X_unDC(k) = SMD.X(k) + SMD.DriftX(i, j);
   Y_unDC(k) = SMD.Y(k) + SMD.DriftY(i, j);
end
consistency_un = sum(abs(SMDin.X - X_unDC) + abs(SMDin.Y - Y_unDC));
consistency_in = sum(abs(SMD.X - X_inDC) + abs(SMD.Y - Y_inDC));
fprintf('SMDin.X/Y - (SMD.X/Y + SMD.DriftX/Y) = %f nm\n', ...
        consistency_un * P2nm);
fprintf('SMD.X/Y - (SMDin.X/Y - SMD.DriftX/Y) = %f nm\n', ...
        consistency_in * P2nm);

correctedDriftIm = smi_vis.GenerateImages.histogramImage(SMD, SRImageZoom);
%figure; imagesc(DriftIm); colormap(gray);
% Clean up the sum image by setting the 0.1% top intensity pixels to the
% 99.9% intensity value.
P = prctile(correctedDriftIm(correctedDriftIm > 0), 99.9);
correctedDriftIm(correctedDriftIm > P) = P;
correctedDriftIm = 255 * correctedDriftIm / P;
figure; imagesc(correctedDriftIm); colormap(gray);
saveas(gcf, fullfile(SaveDir, 'correctedDriftIm.png'));

% Plot the drift correction as a function of time.
DC_fig = DC.plotDriftCorrection(SMD);
figure(DC_fig);
saveas(gcf, fullfile(SaveDir, 'DC_fig.png'));

% Compute absolute drift in pixels per frame.
x_drift_true = PpFX .* (1 : n_frames);
y_drift_true = PpFY .* (1 : n_frames);

% Compute the RMSE between the pre-drift data and the drift corrected
% post-drift data.
[dist1, rmse1, dist2, rmse2, ~] = ...
   smi_core.DriftCorrection.calcDCRMSE(SMD, X_True, Y_True, [], ...
                                       x_drift_true, y_drift_true, []);
fprintf('average distance between true and DC locations = %f nm\n', dist1);
fprintf('RMSE1            between true and DC locations = %f nm\n', rmse1);
fprintf('average distance between true and DC curves    = %f nm\n', dist2);
fprintf('RMSE2            between true and DC curves    = %f nm\n', rmse2);

% Compare computed vs. true drift.
base = 0;
framenums = [];
for j = 1:SMDin.NDatasets
   framenums([1:SMDin.NFrames] + base) = ...
      arrayfun(@(i) SMDin.NFrames*(j - 1) + i - 1, 1:SMDin.NFrames);
   base = base + SMDin.NFrames;
end
x_drift = mean(SMD.DriftX(:) ./ (framenums(:) + 1));
y_drift = mean(SMD.DriftY(:) ./ (framenums(:) + 1));
%fprintf('average x-drift per frame = %f px (true = %f px)\n', x_drift, PpFX);
%fprintf('average y-drift per frame = %f px (true = %f px)\n', y_drift, PpFY);
fprintf('average x-drift per frame = %f nm (true = %f nm)\n', ...
        x_drift * P2nm, PpFX * P2nm);
fprintf('average y-drift per frame = %f nm (true = %f nm)\n', ...
        y_drift * P2nm, PpFY * P2nm);

SMD2 = SMD;
Statistics2.Sim_rho = rho;
Statistics2.N_particles = n_particles;
Statistics2.N_particles_per_pixel   = n_particles / XYSize^2;
Statistics2.N_particles_per_dataset = n_particles / (n_frames / FpD);
Statistics2.N_NaNs = n_nans;
Statistics2.Consistency_un = consistency_un;
Statistics2.Consistency_in = consistency_in;
Statistics2.Dist1 = dist1;
Statistics2.RMSE1 = rmse1;
Statistics2.Dist2 = dist2;
Statistics2.RMSE2 = rmse2;
Statistics2.DriftX_mean = x_drift;
Statistics2.DriftY_mean = y_drift;
Statistics2.DriftX_True = PpFX;
Statistics2.DriftY_True = PpFY;

% -----------------------------------------------------------------------------

% Perform the same calculation, but now separate the intra-dataset and
% inter-dataset portions.  Simulate the` situation of calling the two portions
% from separate functions.
fprintf('\n2D: separated intra-dataset and inter-dataset\n');
clear SMD
SMDin = SMDsave;
SMDIntra = [];
SMDtmp   = [];
X_TrueTmp = [];
Y_TrueTmp = [];
SMF = smi_core.SingleMoleculeFitting();
SMF.DriftCorrection.BFRegistration = false;
obj.DC = smi_core.DriftCorrection(SMF);
for i = 1 : SMDin.NDatasets
   SMDin_i = SMDin;
   SMDin_i.NDatasets = 1;
   mask = SMDin.DatasetNum == i;
   SMDin_i.X          = single(SMDin.X(mask));
   SMDin_i.Y          = single(SMDin.Y(mask));
   SMDin_i.X_SE       = SMDin.X_SE(mask);
   SMDin_i.Y_SE       = SMDin.Y_SE(mask);
   SMDin_i.DatasetNum = SMDin.DatasetNum(mask);
   SMDin_i.FrameNum   = SMDin.FrameNum(mask);
   SMDin_i.Photons    = SMDin.Photons(mask);
   SMDin_i.Bg         = SMDin.Bg(mask);
   X_TrueTmp = [X_TrueTmp; X_True(mask)];
   Y_TrueTmp = [Y_TrueTmp; Y_True(mask)];
   [SMDIntra_i, StatisticsIntra] = obj.DC.driftCorrectKNNIntra(SMDin_i, i, i);
   SMDtmp   = smi_core.SingleMoleculeData.catSMD(SMDtmp, SMDin_i, false);
   SMDIntra = smi_core.SingleMoleculeData.catSMD(SMDIntra, SMDIntra_i, false);
end
[SMDInter, StatisticsInter] = obj.DC.driftCorrectKNNInter(SMDIntra);
SMD   = SMDInter;
SMDin = SMDtmp;
X_True = X_TrueTmp;
Y_True = Y_TrueTmp;

% Remove any NaNs.
nans = find(isnan(SMDin.X) | isnan(SMDin.Y) | isnan(SMD.X) | isnan(SMD.Y));
n_nans = numel(nans);
if n_nans > 0
   fprintf('%d NaNs removed!\n', n_nans);
   SMDin.X(nans) = [];
   SMDin.Y(nans) = [];
   SMD.X(nans) = [];
   SMD.Y(nans) = [];
   X_True(nans) = [];
   X_Yrue(nans) = [];
end

% Consistency checks.  These should be 0 to a few hundred if all is correct.
%
% SMDin.X/Y, SMD.X/Y are the drifted/drift corrected coordinates, respectively.
% SMD.DriftX/Y are the drift corrections defined such that
%    drifted coordinates - drift correction = drift corrected coordinates
N = numel(SMD.X);
X_inDC = zeros(N, 1, 'single');
Y_inDC = zeros(N, 1, 'single');
X_unDC = zeros(N, 1, 'single');
Y_unDC = zeros(N, 1, 'single');
for k = 1:N
   i = SMD.FrameNum(k);
   j = SMD.DatasetNum(k);
   X_inDC(k) = SMDin.X(k) - SMD.DriftX(i, j);
   Y_inDC(k) = SMDin.Y(k) - SMD.DriftY(i, j);
   X_unDC(k) = SMD.X(k) + SMD.DriftX(i, j);
   Y_unDC(k) = SMD.Y(k) + SMD.DriftY(i, j);
end
% consistency_un =
%    drifted coordinates - (drift corrected coordinates + drift correction)
% consistency_in =
%    drifted corrected coordinates - (drifted coordinates - drift correction)
consistency_un = sum(abs(SMDin.X - X_unDC) + abs(SMDin.Y - Y_unDC));
consistency_in = sum(abs(SMD.X - X_inDC) + abs(SMD.Y - Y_inDC));
fprintf('SMDin.X/Y - (SMD.X/Y + SMD.DriftX/Y) = %f nm\n', ...
        consistency_un * P2nm);
fprintf('SMD.X/Y - (SMDin.X/Y - SMD.DriftX/Y) = %f nm\n', ...
        consistency_in * P2nm);

correctedDriftIm = smi_vis.GenerateImages.histogramImage(SMD, SRImageZoom);
%figure; imagesc(DriftIm); colormap(gray);
% Clean up the sum image by setting the 0.1% top intensity pixels to the
% 99.9% intensity value.
P = prctile(correctedDriftIm(correctedDriftIm > 0), 99.9);
correctedDriftIm(correctedDriftIm > P) = P;
correctedDriftIm = 255 * correctedDriftIm / P;
figure; imagesc(correctedDriftIm); colormap(gray);
saveas(gcf, fullfile(SaveDir, 'correctedDriftIm2.png'));

% Plot the drift correction as a function of time.
DC_fig = DC.plotDriftCorrection(SMD);
figure(DC_fig);
saveas(gcf, fullfile(SaveDir, 'DC_fig2.png'));

% Compute absolute drift in pixels per frame.
x_drift_true = PpFX .* (1 : n_frames);
y_drift_true = PpFY .* (1 : n_frames);

% Compute the RMSE between the pre-drift data and the drift corrected
% post-drift data.
[dist1, rmse1, dist2, rmse2, ~] = ...
   smi_core.DriftCorrection.calcDCRMSE(SMD, X_True, Y_True, [], ...
                                       x_drift_true, y_drift_true, []);
fprintf('average distance between true and DC locations = %f nm\n', dist1);
fprintf('RMSE1            between true and DC locations = %f nm\n', rmse1);
fprintf('average distance between true and DC curves    = %f nm\n', dist2);
fprintf('RMSE2            between true and DC curves    = %f nm\n', rmse2);

% Compare computed vs. true drift.
base = 0;
framenums = [];
for j = 1:SMDin.NDatasets
   framenums([1:SMDin.NFrames] + base) = ...
      arrayfun(@(i) SMDin.NFrames*(j - 1) + i - 1, 1:SMDin.NFrames);
   base = base + SMDin.NFrames;
end
x_drift = mean(SMD.DriftX(:) ./ (framenums(:) + 1));
y_drift = mean(SMD.DriftY(:) ./ (framenums(:) + 1));
%fprintf('average x-drift per frame = %f px (true = %f px)\n', x_drift, PpFX);
%fprintf('average y-drift per frame = %f px (true = %f px)\n', y_drift, PpFY);
fprintf('average x-drift per frame = %f nm (true = %f nm)\n', ...
        x_drift * P2nm, PpFX * P2nm);
fprintf('average y-drift per frame = %f nm (true = %f nm)\n', ...
        y_drift * P2nm, PpFY * P2nm);

success = 1;

end

% =============================================================================

function [n_emitters, n_blinks, n_local, n_datasets] = ...
   blinks(n_particles, X, Y, Z, F, D)
% Find all the frame number sets (fns) for each emitter (of which there are
% n_emitters).
%
% INPUTS:
%    n_particles   total number of particles (localizations) given
%    X, Y, Z       particle coordinates
%    F             absolute frame numbers
%    D             dataset numbers
%
% OUTPUTS:
%    n_emitters    number of distinct locations, each corresponding to an
%                  emitter
%    n_blinks      number of blinking events
%    n_local       number of entries
%    n_datasets    number of distinct datasets
%
% Data from smlmData with no imposed drift looks like:
%
%     X         Y        F
%     2.9100    1.1548   22.0000
%     2.9100    1.1548   23.0000
%     2.9100    1.1548   24.0000
%     2.9100    1.1548  452.0000
%    17.6154    1.1999  477.0000
%    58.0133    1.5341   40.0000
%    58.0133    1.5341   41.0000
%
% This corresponds to 3 emitters (distinct positions), 4 blinking events (2 for
% the first emitter, 1 each for the other two), and 7 localizations (before
% frame connection).

   fns = {};
   i = 1;
   n_emitters = 0;
   while i <= n_particles
      x = X(i);
      y = Y(i);
      z = Z(i);
      f = F(i);

      i = i + 1;
      while i <= n_particles & X(i) == x & Y(i) == y & Z(i) == z
         f = [f, F(i)];
         i = i + 1;
      end
      n_emitters = n_emitters + 1;
      fns{n_emitters} = f;
   end

   % Count the number of localizations.
   n_local = n_particles;

   % Count the number of blinking events.
   n_blinks = sum(cellfun(@(e) numel(find(diff(e) ~= 1)) + 1, fns));

   % Count the number of datasets.
   n_datasets = numel(unique(D));

end

./MATLAB/+smi_core/@DriftCorrection/changeInterRef.m
function [SMD] = changeInterRef(SMD, RefDatasetNum)
%changeInterRef shifts SMD coordinates to new dataset reference.
% This method will change the "reference" dataset number for inter-dataset
% drift results.  Specifically, this method can be applied AFTER
% inter-dataset drift correction was performed on 'SMD', with the intention
% being to change the asssumed reference dataset of dataset 1 to the
% dataset 'RefDatasetNum'.  This method assumes that 'SMD' arrays are
% sorted w.r.t. DatasetNum and FrameNum.
%
% INPUTS:
%   SMD: Single Molecule Data structure with populated fields DriftX and
%        DriftY and array fields sorted w.r.t. DatasetNum and FrameNum.
%   RefDatasetNum: Dataset number that will be the new reference.
%
% OUTPUTS:
%   SMD: Input SMD with coordinates shifted to the new reference dataset.

% Created by:
%   David J. Schodt (Lidke lab, 2021)


% Check if RefDatasetNum is a valid choice.
if (RefDatasetNum > SMD.NDatasets)
    warning('Input ''RefDatasetNum'' can''t exceed ''SMD.NDatasets''')
    return
end

% Shift coordinates to the new reference and update the drift arrays.
XShift = SMD.DriftX(1, RefDatasetNum);
YShift = SMD.DriftY(1, RefDatasetNum);
SMD.X = SMD.X + XShift;
SMD.Y = SMD.Y + YShift;
SMD.DriftX = SMD.DriftX - XShift;
SMD.DriftY = SMD.DriftY - YShift;


end
./MATLAB/+smi_core/@DriftCorrection/plotXYDriftParametric.m
function [FigHandle] = plotXYDriftParametric(SMD)
%plotXYDriftParametric makes a parametric plot of the x,y drift model.
% This method creates a plot of the inter-dataset linear drift model, 
% plotted as drift vectors for each dataset connected head to tail. 
%
% INPUT:
%    SMD: Single molecule results structure containing that results from
%         a previous single molecule analysis.
%
% OUTPUT:
%    FigHandle: Figure handle for the figure containing the parametric plots.

%Created by:
% David James Schodt (Lidke Lab, 2018)

% Check inputs.
if ~exist('SMD', 'var')
    error('You must enter an SMD structure to plot the drift model.')
end

% Create the plot figure.
FigHandle = figure;
hold('on');

% Extract relevant parameters from the SMD structure.
DriftX = SMD.DriftX; % pixels
DriftY = SMD.DriftY;
NDatasets = SMD.NDatasets;

% Compute the drift vectors for each dataset and plot them head to tail.
TailPosition = [0; 0]; % start the first drift vector at [0; 0]
for ii = 1:NDatasets
    % Compute the drift vector for the ii-th dataset.
    DriftVector = [DriftX(end, ii) - DriftX(1, ii); ...
        DriftY(end, ii) - DriftY(1, ii)];
    
    % Plot the drift vector aligned to the head of the previous dataset.
    quiver(TailPosition(1), TailPosition(2), ...
           DriftVector(1), DriftVector(2), 'b', 'AutoScale', 'off');
    
    % Update the tail position for the next iteration (this is just the
    % head position of the current drift vector).
    TailPosition = TailPosition + DriftVector;
end
title('Drift Model')
xlabel('X Drift Model (pixels)')
ylabel('Y Drift Model (pixels)')

end

./MATLAB/+smi_core/@DriftCorrection/minD.m
%function [sumNND, X]  = minD_intra(Theta, X, T, Ndims, L_intra)
%function [sumNND, X2] = minD_inter(Theta, NS, X2, Ndims, L_inter)
function [sumNND, X] = minD(Theta, X, T, Ndims, L, NS)
% Sum of nearest neighbor distances for intra/inter-dataset drift correction.
%
% INPUTS:
%   Theta   approximating polynomial coefficients
%   X       localization coordinates (NX x Ndims) [pixel]
%   T       localization frame numbers (NX x Ndims)
%   Ndims   coordinate dimension (2 or 3)
%   L       threshold [pixel]
%   Y       localization coordinates for a 2nd dataset (NY x Ndims) [pixel]
%   NS      nearest neighbor searcher object referencing a 2nd static dataset
%           that will compared to X many times (Y); created by createns
%
% OUTPUTS:
%   sumNND  sum of nearest neighbor distances used as a cost estimate for the
%           optimizer
%   X       drift corrected coordinates (NX x Ndims) [pixel]

   if ~exist('NS', 'var') || isempty(NS)
      % --- Intra-dataset ---
      N = numel(Theta);

      m = N/Ndims;
      lo = 1;   hi = m;
      for j = 1:Ndims
         PX = Theta(lo : hi);
         % Assume the constant term of the polynomial is zero for the frames
         % within a dataset.  (This assumption considerably speeds up the
         % intra-dataset minimization.)
         X(:, j) = X(:, j) - polyval([PX', 0], T);

         lo = lo + m;
         hi = hi + m;
      end

      % D(:, 1) will be identically zero since here we are finding the nearest
      % neighbors of X with respect to itself.
      [~, D] = knnsearch(X, X, 'K', 2);
      D = D(:, 2);
   else
      % --- Inter-dataset ---
      % Theta(1) = DriftX, Theta(2) = DriftY, Theta(3) = DriftZ
      for j = 1:Ndims
         X(:, j) = X(:, j) - Theta(j);
      end

      [~, D] = knnsearch(NS, X);
      %[~, D] = knnsearch(X, Y);
   end

   % Make distances > L equal to L in the cost function to
   % de-emphasize widely separated nearest neighbors.  This can be be important
   % in sparse datasets where long distances may separate localizations.  The
   % nearest neighbor of a localization in one frame of a dataset may blink
   % off, resulting in a totally different nearest neighbor for the same
   % localization in the next frame.
   sumNND = sum(min(D, L));

   % In rare cases, D may contain NaNs, so here replace them with an average
   % value.  n is the number of NaNs found and the NaNs are removed from D
   % before recomputing sumNND.
   if isnan(sumNND)
      nans = isnan(D);
      D(nans) = [];
      n = sum(nans);
      % Note that sum(D(D <= L)) + L*sum(D > L) = sum(min(D, L)), then
      % sumNND = sum(min(D, L)) + n*mean(min(D, L))
      %        = sum(min(D, L)) + n * sum(min(D, L))/numel(min(D, L))
      %        = sum(min(D, L)) * (1 + n/numel(D));
      sumNND = sum(min(D, L)) * (1 + n/numel(D));
   end

end

./MATLAB/+smi_core/@DriftCorrection/driftCorrectBFInter.m
function [SMD] = ...
    driftCorrectBFInter(SMD, RefImage, PreSeqImages, ParamStruct)
%driftCorrectBFInter computes inter-DS drift correction from brightfield.
% This method computes inter-dataset drift correction using brightfield 
% images stored in an h5 file.
%
% INPUTS:
%   SMD: Single Molecule Data structure containing the localizations.
%   RefImage: Reference image to which all datasets will be corrected to.
%             (Default = pre dataset 1 focus image).
%   PreSeqImages: Stack of brightfield images collected before each
%                 dataset.
%   ParamStruct: Structure of parameters sent to smi_stat.findOffsetIter().
%                (fields NIterMax, Tolerance, CorrParams, ShiftParams are
%                passed as inputs to smi_stat.findOffsetIter())
%
% OUTPUTS:
%   SMD: Input SMD with applied shifts and updated fields SMD.DriftX and
%        SMD.DriftY.

% Created by:
%   David J. Schodt (Lidke Lab 2021)


% Set a defaults if needed.
if (~exist('ParamStruct', 'var') || isempty(ParamStruct))
    ParamStruct = struct();
end
DefaultParams.NIterMax = 3;
DefaultParams.Tolerance = [];
DefaultParams.CorrParams = struct();
DefaultParams.ShiftParams = struct();
ParamStruct = smi_helpers.padStruct(ParamStruct, DefaultParams);

% Perform inter-dataset drift correction.
if (~isfield(SMD, 'DriftX') || ~isfield(SMD, 'DriftY') ...
        || isempty(SMD.DriftX) || isempty(SMD.DriftY))
    SMD.DriftY = zeros(SMD.NFrames, SMD.NDatasets);
    SMD.DriftX = zeros(SMD.NFrames, SMD.NDatasets);
end
for nn = 1:size(PreSeqImages, 3)
    % Compute the shift between the pre-sequence images and the reference.
    Shift = smi_stat.findOffsetIter(...
        RefImage, PreSeqImages(:, :, nn), ...
        ParamStruct.NIterMax, ParamStruct.Tolerance, ...
        ParamStruct.CorrParams, ParamStruct.ShiftParams);

    % Apply and store the shift in SMD.
    CurrentDS = (SMD.DatasetNum == nn);
    SMD.Y(CurrentDS) = SMD.Y(CurrentDS) - Shift(1);
    SMD.X(CurrentDS) = SMD.X(CurrentDS) - Shift(2);
    SMD.DriftY(:, nn) = SMD.DriftY(:, nn) + Shift(1);
    SMD.DriftX(:, nn) = SMD.DriftX(:, nn) + Shift(2);
end


end
./MATLAB/+smi_core/@DriftCorrection/DriftCorrection.m
classdef DriftCorrection < handle

% driftCorrectKNN performs drift correction on 2D or 3D data
% provided in an SMD structure using K nearest neighbor (KNN) searching,
% returning an updated structure with drift corrected coordinates.  Plots of
% the drift estimates can be produced with plotDriftCorrection and some
% additional measures with calcDCResidual.
%
% EXAMPLE USAGE (see also unitTest):
%    DC = smi_core.DriftCorrection(SMF, SMDin);
%    SMDIntra = [];
%    for i = 1 : NDatasets
%       [SMDIntra_i, StatisticsIntra] = DC.driftCorrectKNNIntra(SMDin_i, i, i);
%       SMDIntra = smi_core.SingleMoleculeData.catSMD(SMDIntra, SMDIntra_i, false);
%    end
%    [SMDInter, StatisticsInter] = DC.driftCorrectKNNInter(SMDIntra);
%    SMDout = SMDInter;

% =============================================================================
properties

   % Intra-dataset threshold (pixel)
   L_intra        = 1;
   % Inter-dataset threshold (pixel)
   L_inter        = 2;
   % X/Y pixel size in um (only needed for 3D drift correction)
   PixelSizeZUnit = 0.1;
   % Degree of the intra-dataset fitting polynomial for drift rate
   PDegree        = 1;
   % Termination tolerance on the intra-dataset function value
   TolFun_intra   = 1e-2;
   % Termination tolerance on the intra-dataset fitting polynomial
   TolX_intra     = 1e-4;
   % Termination tolerance on the inter-dataset function value
   TolFun_inter   = 1e-2;
   % Termination tolerance on the inter-dataset fitting polynomial
   TolX_inter     = 1e-4;
   % Initialization wrt the previous dataset for inter-dataset drift correction
   % The value should be either 0 (no initial drift), 1 (initial drift of the
   % previous dataset) or SMD.NFrames (final drift); zero or initial drift
   % should work well with brightfield registration, while final drift works
   % well generally (but the optimization process may not converge quite as
   % quickly).
   Init_inter     = 0;
   % DriftCorrectKNNInterPair, instead of using Init_inter, uses the actual
   % values of P0_inter to initialize the minimizer search.  The default of []
   % indicates that the initial P0 value will be all zeros, otherwise the
   % values in P0_inter will be used directly.
   P0_inter       = [];
   % Semi-redundant variable, needed because SMD may not exist when the
   % constructor is invoked, so Init_inter has to be set in
   % driftCorrectKNNInter (only needed when breaking intra-dataset and
   % inter-dataset calculations up).
   BFRegistration = true;
   % If non-empty, override the collected value of number of datasets
   NDatasets      = [];
   % If non-empty, override the collected value of number of frames per dataset
   NFrames        = [];
   % Verbosity level
   Verbose        = 1;
   SMF            = [];

end % properties
% =============================================================================

% =============================================================================
properties(SetAccess = protected)

   % Indexing array to record rearrangements of points into datasets
   idx;
   % Values corrected for drift; fields: XY, n
   SMRS = {};

end % properties(SetAccess = protected)
% =============================================================================

% =============================================================================
methods

   [SMD, Statistics] = driftCorrectKNN(obj, SMD)
   [SMD, Statistics] = driftCorrectKNNIntra(obj, SMD, cDataset, iDataset)
   [SMD, Statistics] = driftCorrectKNNInter(obj, SMD)
   [SMDout, Statistics] = driftCorrectKNNInterPair(obj, SMD1, SMD2)
   DC_fig = plotDriftCorrection(obj, SMD, option)

   % Constructor.
   function obj = DriftCorrection(SMF, SMD)
   % SMF values, if provided, can override some of the class properties.
   % SMD is needed for SMD.NFrames when SMF.DriftCorrection.BFRegistration is
   % false.

      if exist('SMF', 'var')
         obj.SMF            = SMF;
         obj.L_intra        = SMF.DriftCorrection.L_intra;
         obj.L_inter        = SMF.DriftCorrection.L_inter;
         obj.PixelSizeZUnit = SMF.DriftCorrection.PixelSizeZUnit;
         obj.PDegree        = SMF.DriftCorrection.PDegree;
         obj.BFRegistration = SMF.DriftCorrection.BFRegistration;
         if SMF.DriftCorrection.BFRegistration
            obj.Init_inter  = 0;
         else
            if exist('SMD', 'var')
               obj.Init_inter  = SMD.NFrames;
            else
               %error('SMD not available when BFRegistration is false.');
            end
         end
      end

   end

end % methods
% =============================================================================

% =============================================================================
methods(Static)

   [dist1, rmse1, dist2, rmse2, nnfig] =      ...
      calcDCRMSE(SMD, X_True, Y_True, Z_True, ...
                 DriftX_True, DriftY_True, DriftZ_True)
   [SMD] = changeInterRef(SMD, RefDatasetNum);
   [SMD, BFStruct] = driftCorrectBF(SMD, SMF, RefImage, BFStruct, ParamStruct);
   [SMD] = driftCorrectBFIntra(SMD, PreSeqImages, PostSeqImages, ParamStruct)  
   [SMD] = driftCorrectBFInter(SMD, RefImage, PreSeqImages, ParamStruct) 
   [RefImage, PreSeqImages, PostSeqImages, ParamStruct] = ...
      driftCorrectBFInit(NDatasets, SMF, RefImage, BFStruct, ParamStruct)
   [sumNND, X] = minD(Theta, X, T, Ndims, L, NS)
   [FigHandle] = plotCumDrift(SMD, FieldName)
   [FigHandle] = plotXYDriftParametric(SMD)
   [varargout] = plotDriftAndReg(PlotAxes, SMD, SMF)
   [delta12, Statistics] = regViaDC(SMD1, SMD2)
   [success, SMD2, SMD3, Statistics2, Statistics3] = unitTest()

end % methods(Static)
% =============================================================================

end % classdef DriftCorrection

./MATLAB/+smi_core/@DriftCorrection/plotDriftAndReg.m
function [varargout] = plotDriftAndReg(PlotAxes, SMD, SMF)
%plotDriftAndReg plots drift correction and brightfield corrections.
% This method plots drift correction results (both inter- and intra-drift
% correction) as well as brightfield registration results in the same plot.
% For now, this method only works for 2D results.
%
% INPUTS:
%   PlotAxes: Axes in which the plot will be made. (Default = gca())
%   SMD: SingleMoleculeData structure containing the fields DriftX and
%        DriftY.
%   SMF: SingleMoleculeFitting structure defining the raw data file
%        containing brightfield registration info., with SMF.Data.FileDir,
%        SMF.Data.FileName, and SMF.Data.PixelSize all being populated.
%
% OUTPUTS:
%   varargout: varargout contains PlotAxes if an output is requested.

% Created by:
%   David J. Schodt (Lidke Lab, 2021)


% Set defaults if needed.
if (~exist('PlotAxes', 'var') || isempty(PlotAxes) || ~isvalid(PlotAxes))
    PlotAxes = gca();
end

% Extract the brightfield registration corrections made during an
% experiment.
PxToNm = 1e3 * SMF.Data.PixelSize;
RegCorrection = -PxToNm * smi.Publish.computeRegCorrection(SMF);

% Separate intra- and inter-drift correction (even if not necessary, this
% might help clarify the code below).
InterX = PxToNm * SMD.DriftX(1, :);
InterY = PxToNm * SMD.DriftY(1, :);
IntraX = PxToNm*SMD.DriftX - InterX;
IntraY = PxToNm*SMD.DriftY - InterY;

% Define the size of points in our drift plot (lower frames -> larger
% points, higher frames -> smaller points, to help indicate time ordering)
% as well as their color (blue -> red corresponds to increasing time).
NFrames = SMD.NFrames;
ColorMap = parula(NFrames * SMD.NDatasets);
Mag = 20;
MarkerSize = (NFrames:-1:1) / Mag;

% Prepare the axes.
hold(PlotAxes, 'on');
axis(PlotAxes, 'equal')
xlabel(PlotAxes, 'X (nm)')
ylabel(PlotAxes, 'Y (nm)')
title(PlotAxes, 'Corrected drift and brightfield registration')

% For each dataset, plot the drift correction results and the brightfield
% registration results (ignoring the first dataset brightfield registration
% results, which are just initial alignments and might not be very useful).
CumulativeInter = cumsum([InterX.', InterY.'], 1);
RegCorrection(1, :) = [0, 0, 0];
CumulativeReg = [0, 0; cumsum(RegCorrection(2:SMD.NDatasets, 1:2), 1)];
BaseCoords = CumulativeReg + CumulativeInter;
for ii = 1:SMD.NDatasets
    % Plot points for each intra-drift correction, starting from 'BaseCoords'.
    scatter(PlotAxes, BaseCoords(ii, 1)+IntraX(:, ii), ...
        BaseCoords(ii, 2)+IntraY(:, ii), ...
        'Marker', '.', 'SizeData', MarkerSize, ...
        'CData', ColorMap((ii-1)*NFrames + (1:NFrames), :))
    
    % Add an arrow to indicate the contribution from inter-dataset DC.
    quiver(PlotAxes, ...
        BaseCoords(ii, 1)-InterX(ii), BaseCoords(ii, 2)-InterY(ii), ...
        InterX(ii), InterY(ii), 'Color', [1, 0, 1], 'LineWidth', 2, ...
        'AutoScale', 'off')
    
    % Add an arrow indicating the brightfield registration correction.
    if (ii > 1)
        quiver(PlotAxes, ...
            BaseCoords(ii, 1)-InterX(ii)-RegCorrection(ii, 1), ...
            BaseCoords(ii, 2)-InterY(ii)-RegCorrection(ii, 2), ...
            RegCorrection(ii, 1), RegCorrection(ii, 2), ...
            'Color', [0, 0, 0], 'LineWidth', 2, ...
            'AutoScale', 'off', 'MaxHeadSize', 0.2)
    end
end

% Add some extra decorations (legend, colorbar, ...).
DummyPoints(1) = line(PlotAxes, NaN, NaN, 'Color', [0, 0, 0]);
DummyPoints(2) = line(PlotAxes, NaN, NaN, 'Color', [1, 0, 1]);
legend(PlotAxes, DummyPoints, {'Brightfield', 'Inter-DS DC'}, ...
    'Location', 'best')
ColorBar = colorbar(PlotAxes);
ColorBar.Label.String = sprintf('fraction of total frames (= %d x %d)', ...
    SMD.NDatasets, SMD.NFrames);

% Return the plot axes if needed.
if (nargout > 0)
    varargout{1} = PlotAxes;
end


end
./MATLAB/+smi_core/@DriftCorrection/driftCorrectBFInit.m
function [RefImage, PreSeqImages, PostSeqImages, ParamStruct] = ...
    driftCorrectBFInit(NDatasets, SMF, RefImage, BFStruct, ParamStruct)
%driftCorrectBF initializes drift correction from brightfield images
% This method performs drift correction using brightfield images stored in
% an h5 file.  This is done by estimating shifts between brightfield images
% taken before and after each dataset in SMD, making the drift model a 1D
% polynomial for inter- and intra-dataset drift correction.
%
% INPUTS:
%   SMD: Single Molecule Data structure containing the localizations.
%   NDatasets: Total number of datasets to be processed.
%   SMF: Single Molecule Fitting structure defining the path to the raw
%        data file.
%   RefImage: Reference image to which all datasets will be corrected to.
%             (Default = pre dataset 1 focus image).
%   BFStruct: Structure of brightfield images (see default setting below).
%   ParamStruct: Structure of parameters sent to smi_stat.findOffsetIter().
%                (fields NIterMax, Tolerance, CorrParams, ShiftParams are
%                passed as inputs to smi_stat.findOffsetIter())
%
% OUTPUTS:
%   RefImage: Reference image to which all datasets will be corrected to.
%   PreSeqImages: 
%   PostSeqImages: 
%   ParamStruct: Structure of parameters sent to smi_stat.findOffsetIter().

% Created by:
%   David J. Schodt (Lidke Lab 2021) and Michael J. Wester (2022)

% Attempt to load the brightfield data (if needed).
if (~exist('BFStruct', 'var') || isempty(BFStruct))
    try
        FilePath = fullfile(SMF.Data.FileDir, SMF.Data.FileName{1});
        H5FileStruct = h5info(FilePath);
        FileGroupList = {H5FileStruct.Groups.Groups.Groups(1).Groups.Name};
        FocusImagesPresent = any(contains(FileGroupList, 'FocusImages'));
        if FocusImagesPresent
           BFStruct = smi_core.LoadData.readH5File(FilePath, 'FocusImages');
        else
           error(sprintf('Cannot extract group ''FocusImages'' from %s', ...
                 FilePath));
        end
    catch ME
        error(sprintf('Cannot extract group ''FocusImages'' from %s', ...
              FilePath));
    end
end

% Set a defaults if needed.
if (~exist('RefImage', 'var') || isempty(RefImage))
    RefImage = median(BFStruct(1).Data.PreSeqImages, 3);
end
if (~exist('ParamStruct', 'var') || isempty(ParamStruct))
    ParamStruct = struct();
end
DefaultParams.NIterMax = 3;
DefaultParams.Tolerance = [];
DefaultParams.CorrParams = struct();
DefaultParams.CorrParams.SuppressWarnings = true;
DefaultParams.ShiftParams = struct();
ParamStruct = smi_helpers.padStruct(ParamStruct, DefaultParams);

% Perform intra-dataset drift correction.
PreSeqImages = zeros([size(RefImage), NDatasets]);
PostSeqImages = zeros([size(RefImage), NDatasets]);
for nn = 1:NDatasets
    PreSeqImages(:, :, nn) = median(BFStruct(nn).Data.PreSeqImages, 3);
    PostSeqImages(:, :, nn) = median(BFStruct(nn).Data.PostSeqImages, 3);
end

% Moved to SMLM.
% Perform intra-dataset drift correction.
%SMD = smi_core.DriftCorrection.driftCorrectBFIntra(...
%    SMD, PreSeqImages, PostSeqImages, ParamStruct);
%
% Perform inter-dataset drift correction.
%SMD = smi_core.DriftCorrection.driftCorrectBFInter(...
%    SMD, RefImage, PreSeqImages, ParamStruct);


end

./MATLAB/+smi_core/@DriftCorrection/driftCorrectBFIntra.m
function [SMD] = ...
    driftCorrectBFIntra(SMD, PreSeqImages, PostSeqImages, ParamStruct)
%driftCorrectBFIntra computes intra-DS drift correction from brightfield.
% This method computes intra-dataset drift correction using brightfield 
% images stored in an h5 file.
%
% INPUTS:
%   SMD: Single Molecule Data structure containing the localizations.
%   PreSeqImages: Stack of brightfield images collected before each
%                 dataset.
%   PostSeqImages: Stack of brightfield images collected after each
%                 dataset.
%   ParamStruct: Structure of parameters sent to smi_stat.findOffsetIter().
%                (fields NIterMax, Tolerance, CorrParams, ShiftParams are
%                passed as inputs to smi_stat.findOffsetIter())
%
% OUTPUTS:
%   SMD: Input SMD with applied shifts and updated fields SMD.DriftX and
%        SMD.DriftY.

% Created by:
%   David J. Schodt (Lidke Lab 2021)


% Set a defaults if needed.
if (~exist('ParamStruct', 'var') || isempty(ParamStruct))
    ParamStruct = struct();
end
DefaultParams.NIterMax = 3;
DefaultParams.Tolerance = [];
DefaultParams.CorrParams = struct();
DefaultParams.ShiftParams = struct();
ParamStruct = smi_helpers.padStruct(ParamStruct, DefaultParams);

% Perform intra-dataset drift correction.
if (~isfield(SMD, 'DriftX') || ~isfield(SMD, 'DriftY') ...
        || isempty(SMD.DriftX) || isempty(SMD.DriftY))
    SMD.DriftY = NaN(SMD.NFrames, SMD.NDatasets);
    SMD.DriftX = NaN(SMD.NFrames, SMD.NDatasets);
end
FrameNum = single(SMD.FrameNum);
NFrames = single(SMD.NFrames);
for nn = 1:size(PreSeqImages, 3)
    % Compute the shift between the pre- and post-sequence images.
    Shift = smi_stat.findOffsetIter(...
        PreSeqImages(:, :, nn), PostSeqImages(:, :, nn), ...
        ParamStruct.NIterMax, ParamStruct.Tolerance, ...
        ParamStruct.CorrParams, ParamStruct.ShiftParams);

    % Apply and store the shift in SMD.
    CurrentDS = (SMD.DatasetNum == nn);
    CurrentFrameNum = FrameNum(CurrentDS);
    SMD.Y(CurrentDS) = SMD.Y(CurrentDS) - (Shift(1)/NFrames)*(CurrentFrameNum-1);
    SMD.X(CurrentDS) = SMD.X(CurrentDS) - (Shift(2)/NFrames)*(CurrentFrameNum-1);
    SMD.DriftY(:, nn) = (Shift(1)/NFrames)*(0:(NFrames-1)).';
    SMD.DriftX(:, nn) = (Shift(2)/NFrames)*(0:(NFrames-1)).';
end


end
./MATLAB/+smi_core/@DriftCorrection/driftCorrectKNNIntra.m
function [SMD, Statistics] = driftCorrectKNNIntra(obj, SMD, cDataset, iDataset)
%driftCorrectKNNIntra calculates intra-dataset drift directly from X,Y{,Z} coordinates
% by fitting a polynomial depending on time (i.e., frame number) to the frames
% with each dataset (intra-dataset), and fitting constant shifts between
% datasets (inter-dataset).  Fitting is done via performing fminsearch on the
% (weighted) sums of nearest neighbor distances.  Intra-dataset portion.
%
% Sign convention:
%
%    N = numel(SMD_drifted.X);
%    for k = 1:N
%       i = SMD_corrected.FrameNum(k);
%       j = SMD_corrected.DatasetNum(k);
%       SMD_corrected.X(k) = SMD_drifted.X(k) - SMD_corrected.DriftX(i, j);
%       SMD_corrected.Y(k) = SMD_drifted.Y(k) - SMD_corrected.DriftY(i, j);
%    end
%
% INPUTS:
%   cDataset:    Dataset count (the dataset number sequential count)
%   iDataset:    Dataset index (actual dataset number being processed)
%                For example, if driftCorrectKNNIntra is called in succession
%                with iDataset = 1 (1st time), 3 (2nd time), 5 (3rd time), then
%                the corresponding dataset count will be 1, 2, 3, respectively,
%                i.e., call 3 to this routine (cDataset = 3) will correspond to
%                iDataset = 5, where iDataset is the dataset to be analyzed.
%                Typically, iDataset and cDataset are equal---this distinction
%                only becomes important if datasets are being skipped
%   SMD:         A structure with fields:
%      X              x coordinates (Nx1) where N is total number of points
%      Y              y coordinates (Nx1)
%      Z              z coordinates (Nx1) [OPTIONAL]
%                  Note: X and Y are typically in pixels, Z in um
%      DatasetNum     dataset number from which localization originates (Nx1)
%      FrameNum       frame   number from which localization originates (Nx1)
%      NDatasets      number of datasets
%      NFrames        number of frames in each dataset
%   obj:           [class properties]
%                     optimization parameters with the following fields:
%      L_intra        intra-dataset threshold (Default = 1 pixel)
%      L_inter        inter-dataset threshold (Default = 2 pixels)
%      PixelSizeZUnit pixel size in um (units of Z; only needed for 3D)
%                     (Default = 0.1)
%      PDegree        degree of the intra-dataset drift correction fitting
%                     polynomial (Default = 1)
%      TolFun_intra   termination tolerance on the intra-dataset function value
%                     (Default = 1e-2)
%      TolX_intra     termination tolerance on the intra-dataset fitting
%                     polynomial (Default = 1e-4)
%      TolFun_inter   termination tolerance on the inter-dataset function value
%                     (Default = 1e-2)
%      TolX_inter     termination tolerance on the inter-dataset fitting
%                     polynomial (Default = 1e-4)
%      Init_inter     inter-dataset initialization with respect to the previous
%                     dataset; the value should be either 0 (no initial drift),
%                     1 (initial drift of the previous dataset) or SMD.NFrames
%                     (final drift); zero or initial drift should work well
%                     with brightfield registration, while final drift works
%                     well generally (but the optimization process may not
%                     converge quite as quickly) (Default = SMD.NFrames)
%      Verbose        verbosity level (Default = 1)
%
% OUTPUTS:
%   SMD:         SMD data structure with updated fields:
%      X              drift corrected x coordinates (Nx1)
%      Y              drift corrected y coordinates (Nx1)
%      Z              drift corrected z coordinates (Nx1) [OPTIONAL]
%      DriftX         found x drift per frame (NFrames x NDatasets)
%      DriftY         found y drift per frame (NFrames x NDatasets)
%      DriftZ         found z drift per frame (NFrames x NDatasets) [OPTIONAL]
%   Statistics:  statistical information about the algorithm performance
%                including various input parameters above and ...:
%      NDatasets          internal number of datasets
%      NFrames            internal number of frames per dataset
%      Intra_iterations   intra-dataset number of fminsearch iterations
%      Intra_funcCount    intra-dataset number of fminsearch function evals
%      Intra_elapsedTime  intra-dataset elapsed time for drift correction
%      Inter_iterations   inter-dataset number of fminsearch iterations
%      Inter_funcCount    inter-dataset number of fminsearch function evals
%      Inter_elapsedTime  inter-dataset elapsed time for drift correction
%
%   NOTE: SMD.DriftX/Y/Z are the drift corrections defined such that
%         drifted coordinates - drift correction = drift corrected coordinates
%
% CITATION:
%    "Robust, Fiducial-Free Drift Correction for Super-resolution Imaging"

% Created by
%    Modelz... Bewerdorf's group
%    Farzin Farzam  (Lidke Lab 2017) [original version of driftCorrect2D]
%    Michael J. Wester and Keith Lidke (Lidke Lab 2017-2019) [knnsearch]
%       (completely rewrote the code)

   if isfield(SMD, 'Z') && numel(SMD.Z) == numel(SMD.X)
      Ndims = 3;
   else
      Ndims = 2;
   end

   DriftParams.L_intra        = obj.L_intra;
   DriftParams.L_inter        = obj.L_inter;
   DriftParams.PixelSizeZUnit = obj.PixelSizeZUnit;
   DriftParams.PDegree        = obj.PDegree;
   DriftParams.TolFun_intra   = obj.TolFun_intra;
   DriftParams.TolX_intra     = obj.TolX_intra;
   DriftParams.TolFun_inter   = obj.TolFun_inter;
   DriftParams.TolX_inter     = obj.TolX_inter;
   DriftParams.Init_inter     = obj.Init_inter;
   DriftParams.Verbose        = obj.Verbose;
   if ~isempty(obj.NDatasets)
      DriftParams.NDatasets   = obj.NDatasets;
   end
   if ~isempty(obj.NFrames)
      DriftParams.NFrames     = obj.NFrames;
   end

   % Initialize various parameters.
   % PixelSizeZUnit is needed for 3D to convert Z into the same units as X
   % and Y.  PixelSizeZUnit is the X/Y pixel size in units of um.
   PixelSizeZUnit = DriftParams.PixelSizeZUnit;
   % L_intra is the intra-dataset threshold used in the cost function
   % computation to limit spurious nearest neighbor distances.  L_intra is
   % in units of pixels.
   L_intra = DriftParams.L_intra;
   % L_inter is the inter-dataset threshold used in the cost function
   % computation to limit spurious nearest neighbor distances.  L_inter is
   % in units of pixels.
   L_inter = DriftParams.L_inter;
   PDegree      = DriftParams.PDegree;
   TolFun_intra = DriftParams.TolFun_intra;
   TolX_intra   = DriftParams.TolX_intra;
   TolFun_inter = DriftParams.TolFun_inter;
   TolX_inter   = DriftParams.TolX_inter;
   Init_inter   = DriftParams.Init_inter;
   Verbose      = DriftParams.Verbose;

   Statistics.Ndims          = Ndims;
   Statistics.PixelSizeZUnit = PixelSizeZUnit;
   Statistics.NDatasets      = SMD.NDatasets;
   Statistics.NFrames        = SMD.NFrames;
   Statistics.L_intra        = L_intra;
   Statistics.L_inter        = L_inter;
   Statistics.PDegree        = PDegree;
   Statistics.Init_inter     = Init_inter;
   Statistics.TolFun_intra   = TolFun_intra;
   Statistics.TolX_intra     = TolX_intra;
   Statistics.TolFun_inter   = TolFun_inter;
   Statistics.TolX_inter     = TolX_inter;

   SMD.DriftX = zeros(SMD.NFrames, SMD.NDatasets, 'single');
   SMD.DriftY = zeros(SMD.NFrames, SMD.NDatasets, 'single');
   if Ndims == 3
      SMD.DriftZ = zeros(SMD.NFrames, SMD.NDatasets, 'single');
   end

   % ---------- Intra-Dataset drift correction --------------------------------

   tic;
   % These options will be used by fminsearch below.
   options = optimset('TolFun', TolFun_intra, 'TolX', TolX_intra);

   % Establish an indexing array to record rearrangements of points into
   % datasets, so that this reordering can be later undone.
   N = numel(SMD.X);
   idx = zeros(N, 1);
   base = 0;

   %SMRS = cell(1, SMD.NDatasets);
   % Count the number of iterations and function calls.
   it = 0;   fc = 0;
   % Note that variables like X, Y, Z are vectors, while variables like XY are
   % n x Ndims matrices.  The basic reason for combining vectors into matrices
   % is to allow easier generalization to 3D.
   for i = 1:SMD.NDatasets
      %mask = SMD.DatasetNum == i;
      mask = SMD.DatasetNum == iDataset;
      n = sum(mask);
      XY = zeros(n, Ndims, 'single');
      XY(:, 1) = SMD.X(mask);
      XY(:, 2) = SMD.Y(mask);
      if Ndims == 3
         % Assume z values are given in um.  Convert these into the same units
         % as the x and y values, which are assumed to be given in pixels.
         % The z values are converted back to um on output.
         XY(:, 3) = SMD.Z(mask) ./ PixelSizeZUnit;
      end
      FrameNum = single(SMD.FrameNum(mask));

      idx(mask) = base + (1 : n);
      base = base + n;

      % Initialize polynomial fitting function, then optimize over the dataset.
      % P0 and P are packed vectors containing coefficients for all Pdegree
      % interpolations over all dimensions as required by fminsearch.  Note
      % that the polynomial is of PDegree for the drift correction.
      P0 = zeros(Ndims*PDegree, 1);
      % Test for really sparse datasets.
      if n <= 1 || SMD.NFrames == 1
         P = P0;
         XYC = XY;
      else
         [P, ~, exitflag, output] = ...
            fminsearch(@minD_intra, P0, options, XY, FrameNum, Ndims, L_intra);
         if exitflag ~= 1 && Verbose >= 1
            fprintf( ...
               'driftCorrectKNN fminsearch on minD_intra exitflag = %d\n', ...
                     exitflag);
         end
         it = it + output.iterations;
         fc = fc + output.funcCount;

         [~, XYC] = minD_intra(P, XY, FrameNum, Ndims, L_intra);
      end

      PX = P(1           : PDegree);
      PY = P(PDegree + 1 : 2*PDegree);

      % Values corrected for drift.
      %SMRS{i}.XY = XYC;
      %SMRS{i}.n  = n;
      SMRS{cDataset}.XY = XYC;
      SMRS{cDataset}.n  = n;

      range = double(1:SMD.NFrames);
      SMD.DriftX(:, i) = polyval([PX', 0], range);
      SMD.DriftY(:, i) = polyval([PY', 0], range);

      if Ndims == 3
         PZ = P(2*PDegree + 1 : end);
         SMD.DriftZ(:, i) = polyval([PZ', 0], range);
      end
   end
   Statistics.Intra_iterations  = it;
   Statistics.Intra_funcCount   = fc;
   Statistics.Intra_elapsedTime = toc;

   obj.idx = [obj.idx; idx + numel(obj.idx)];
   obj.SMRS{cDataset} = SMRS{cDataset};

   % ---------- Inter-Dataset drift correction --------------------------------

   % --------------------------------------------------------------------------

end

% =============================================================================

function [sumNND, X] = minD_intra(Theta, X, T, Ndims, L_intra)
% Sum of nearest neighbor distances for intra-dataset drift correction.

   N = numel(Theta);

   m = N/Ndims;
   lo = 1;   hi = m;
   for j = 1:Ndims
      PX = Theta(lo : hi);
      % Assume the constant term of the polynomial is zero for the frames
      % within a dataset.  (This assumption considerably speeds up the
      % intra-dataset minimization.)
      X(:, j) = X(:, j) + polyval([PX', 0], T);

      lo = lo + m;
      hi = hi + m;
   end

   % D(:, 1) will be identically zero since here we are finding the nearest
   % neighbors of X with respect to itself.
   [~, D] = knnsearch(X, X, 'K', 2);
   D2 = D(:, 2);

   % Make distances > L_intra equal to L_intra in the cost function to
   % de-emphasize widely separated nearest neighbors.  This can be be important
   % in sparse datasets where long distances may separate localizations.  The
   % nearest neighbor of a localization in one frame of a dataset may blink
   % off, resulting in a totally different nearest neighbor for the same
   % localization in the next frame.
   sumNND = sum(min(D2, L_intra));

   % In rare cases, D2 may contain NaNs, so here replace them with an average
   % value (modeled on the code in minD_inter).
   if isnan(sumNND)
      nans = isnan(D2);
      D2(nans) = [];
      n = sum(nans);
      sumNND = sum(min(D2, L_intra)) * (1 + n/numel(D2));
   end

end

./MATLAB/+smi_core/@DriftCorrection/README.md
### smi_core/@DriftCorrection

driftCorrectKNN performs drift correction on 2D or 3D data
provided in an SMD structure using K nearest neighbor (KNN) searching,
returning an updated structure with drift corrected coordinates.  Plots of
the drift estimates can be produced with plotDriftCorrection and some
additional measures with calcDCResidual.

```
EXAMPLE USAGE (see also unitTest):

   DC = smi_core.DriftCorrection(SMF, SMDin);
   SMDIntra = [];
   for i = 1 : NDatasets
      [SMDIntra_i, StatisticsIntra] = DC.driftCorrectKNNIntra(SMDin_i, i, i);
      SMDIntra = smi_core.SingleMoleculeData.catSMD(SMDIntra, SMDIntra_i, false);
   end
   [SMDInter, StatisticsInter] = DC.driftCorrectKNNInter(SMDIntra);
   SMDout = SMDInter;
```

---

CITATION:
Michael J. Wester, David J. Schodt, Hanieh Mazloom-Farsibaf, Mohamadreza
Fazel, Sandeep Pallikkuth and Keith A. Lidke, "Robust, fiducial-free drift
correction for super-resolution imaging", *Scientific Reports*, Volume 11,
Article 23672, December 8, 2021, 1-14,
[https://www.nature.com/articles/s41598-021-02850-7](https://www.nature.com/articles/s41598-021-02850-7)
(DOI: 10.1038/s41598-021-02850-7).

---

```
properties:
   % Intra-dataset threshold (pixel)
   L_intra        = 1;
   % Inter-dataset threshold (pixel)
   L_inter        = 2;
   % X/Y pixel size in um (only needed for 3D drift correction)
   PixelSizeZUnit = 0.1;
   % Degree of the intra-dataset fitting polynomial for drift rate
   PDegree        = 1;
   % Termination tolerance on the intra-dataset function value
   TolFun_intra   = 1e-2;
   % Termination tolerance on the intra-dataset fitting polynomial
   TolX_intra     = 1e-4;
   % Termination tolerance on the inter-dataset function value
   TolFun_inter   = 1e-2;
   % Termination tolerance on the inter-dataset fitting polynomial
   TolX_inter     = 1e-4;
   % Initialization wrt the previous dataset for inter-dataset drift correction
   % The value should be either 0 (no initial drift), 1 (initial drift of the
   % previous dataset) or SMD.NFrames (final drift); zero or initial drift
   % should work well with brightfield registration, while final drift works
   % well generally (but the optimization process may not converge quite as
   % quickly).
   Init_inter     = 0;
   % DriftCorrectKNNInterPair, instead of using Init_inter, uses the actual
   % values of P0_inter to initialize the minimizer search.  The default of []
   % indicates that the initial P0 value will be all zeros, otherwise the
   % values in P0_inter will be used directly.
   P0_inter       = [];
   % Semi-redundant variable, needed because SMD may not exist when the
   % constructor is invoked, so Init_inter has to be set in
   % driftCorrectKNNInter (only needed when breaking intra-dataset and
   % inter-dataset calculations up).
   BFRegistration = true;
   % If non-empty, override the collected value of number of datasets
   NDatasets      = [];
   % If non-empty, override the collected value of number of frames per dataset
   NFrames        = [];
   % Verbosity level
   Verbose        = 1;
   SMF            = [];
```

---

methods:
- **[calcDCRMSE](calcDCRMSE.m)**:
  calculates the RMSE of SMD relative to true coordinates/curves
- **[changeInterRef](changeInterRef.m)**:
  shifts SMD coordinates to new dataset reference
- **[driftCorrectBF](driftCorrectBF.m)**:
  performs drift correction from brightfield images stored in an h5 file
- **[driftCorrectBFInit](driftCorrectBFInit.m)**:
  initializes drift correction from brightfield images
- **[driftCorrectBFInter](driftCorrectBFInter.m)**:
  computes inter-DS drift correction from brightfield images
- **[driftCorrectBFIntra](driftCorrectBFIntra.m)**:
  computes intra-DS drift correction from brightfield images
- **[driftCorrectKNN](driftCorrectKNN.m)**:
  calculates the drift directly from X,Y{,Z} coordinates
  by fitting a polynomial depending on time (i.e., frame number) to the frames
  with each dataset (intra-dataset), and fitting constant shifts between
  datasets (inter-dataset)
- **[driftCorrectKNNInter](driftCorrectKNNInter.m)**:
  Inter-dataset portion of **driftCorrectKNN**
- **[driftCorrectKNNInterPair](driftCorrectKNNInterPair.m)**:
  calculates inter-dataset drift directly from X,Y{,Z}
  coordinates (i.e., constant shifts between datasets)
- **[driftCorrectKNNIntra](driftCorrectKNNIntra.m)**:
  Intra-dataset portion of **driftCorrectKNN**
- **[minD](minD.m)**:
  Sum of nearest neighbor distances for intra/inter-dataset drift correction
- **[plotCumDrift](plotCumDrift.m)**:
  creates cumulative plots for Drift in any direction
- **[plotDriftAndReg](plotDriftAndReg.m)**:
  plots drift correction and brightfield corrections
- **[plotDriftCorrection](plotDriftCorrection.m)**:
  plots the computed drift correction stored in SMD
  structure for 2D or 3D data.  The plot is color coded so as to indicate the
  drift correction as a function of time
- **[plotXYDriftParametric](plotXYDriftParametric.m)**:
  makes a parametric plot of the x,y drift model
- **[regViaDC](regViaDC.m)**:
  (registration via drift correction) takes two differently labeled
  data collections of the same biological phenomenon and attempts to align them
  using inter-dataset drift correction
- **[unitTest](unitTest.m)**:
  tests smi_core.DriftCorrection.driftCorrectKNN

./MATLAB/+smi_core/@DriftCorrection/plotDriftCorrection.m
function DC_fig = plotDriftCorrection(obj, SMD, option)
%plotDriftCorrection plots the computed drift correction stored in SMD
% structure for 2D or 3D data.  The plot is color coded so as to indicate the
% drift correction as a function of time.
%
% The computed drift for each dataset is plotted with a tapering line segment
% indicating increasing frame number (so increasing time), while all the frames
% in the entire image are color coded from blue to red, again indicating the
% direction of increasing time.
%
% INPUTS:
%    SMD:         A structure with fields:
%       X             x-coordinates (Nx1) where N is total number of points
%       Y             y-coordinates (Nx1)
%       Z             z-coordinates (Nx1) [OPTIONAL]
%                  Note: X and Y are typically in pixels, Z in um
%       NFrames       number of frames in each dataset
%       NDatasets     number of datasets
%       DriftX        found x-drift (NFrames x NDatasets)
%       DriftY        found y-drift (NFrames x NDatasets)
%       DriftZ        found z-drift (NFrames x NDatasets) [OPTIONAL]
%    option       [OPTIONAL] type of drift correction plot to make:
%                     'A' - absolute drift predicted per dataset/frame number
%                     'R' - relative (with respect to the previous) drift
%                           predicted per dataset/frame number
%                     '1' - initial values only of the absolute drift predicted
%                           per dataset
%                     (Default = 'A')
%    obj:         [class properties]
%       PixelSizeZUnit pixel size in um (Default = 0.1)
%       PDegree       degree of the intra-dataset drift rate fitting polynomial
%       Init_inter    inter-dataset initialization with respect to the previous
%                     dataset (see driftCorrectKNN)
%
% OUTPUTS:
%    DC_fig       figure handle to the drift correction plot

% Created by
%    Michael J. Wester (Lidke Lab 2020)

   if ~isfield(SMD, 'DriftX') | isempty(SMD.DriftX)
      error('SMD.DriftX either missing or empty, so DriftCorrection plot unavailable!');
   end

   if ~exist('option', 'var')
      option = 'A';
   end

   PixelSizeZUnit = obj.PixelSizeZUnit;
%  DriftParams = obj.DriftParams;
%  if exist('DriftParams', 'var') & isfield('DriftParams', 'PixelSizeZUnit')
%     PixelSizeZUnit = DriftParams.PixelSizeZUnit;
%  else
%     PixelSizeZUnit = 0.1;
%  end
   P2nm = PixelSizeZUnit * 1000;

   SMZ.DriftX = SMD.DriftX * P2nm;
   SMZ.DriftY = SMD.DriftY * P2nm;
   if isfield(SMD, 'Z') && numel(SMD.Z) == numel(SMD.X)
      Ndims = 3;
      SMZ.DriftZ = SMD.DriftZ * 1000;
   else
      Ndims = 2;
   end

   N = SMD.NDatasets * SMD.NFrames;

   % Drift correction plot.
   DC_fig = figure('Visible', 'off');
   hold on
   % Color code the plot from blue to red to indicate the passage of time.
   cm = colormap(jet);
   n_cm = size(cm, 1);

   % Within each dataset, taper the segment width from large to small to
   % indicate the direction of time.
   M = 500;
   sz = arrayfun(@(i) max(1, round(M * i / SMD.NFrames)), ...
                 SMD.NFrames : -1 : 1);
   for i = 1 : SMD.NDatasets
      k = (i - 1)*SMD.NFrames;
      indx = max(1, ceil(n_cm * (k + [1 : SMD.NFrames]) / N));
      if Ndims == 2
         if option == 'R' & i > 1
            SMZ.DriftX(:, i) = SMZ.DriftX(:, i) - ...
               (SMZ.DriftX(1, i) - SMZ.DriftX(SMD.NFrames, i - 1));
            SMZ.DriftY(:, i) = SMZ.DriftY(:, i) - ...
               (SMZ.DriftY(1, i) - SMZ.DriftY(SMD.NFrames, i - 1));
         end
         if option == '1'
            scatter(SMZ.DriftX(1, i), SMZ.DriftY(1, i), sz(1), ...
                    cm(indx(1), :), '.');
         else
            scatter(SMZ.DriftX(:, i), SMZ.DriftY(:, i), sz, cm(indx, :), '.');
         end
      else
         if option == 'R' & i > 1
            SMZ.DriftX(:, i) = SMZ.DriftX(:, i) - ...
               (SMZ.DriftX(1, i) - SMZ.DriftX(SMD.NFrames, i - 1));
            SMZ.DriftY(:, i) = SMZ.DriftY(:, i) - ...
               (SMZ.DriftY(1, i) - SMZ.DriftY(SMD.NFrames, i - 1));
            SMZ.DriftZ(:, i) = SMZ.DriftZ(:, i) - ...
               (SMZ.DriftZ(1, i) - SMZ.DriftZ(SMD.NFrames, i - 1));
         end
         if option == '1'
            scatter3(SMZ.DriftX(1, i), SMZ.DriftY(1, i), SMZ.DriftZ(1, i), ...
                     sz(1), cm(indx(1), :), '.');
         else
            scatter3(SMZ.DriftX(:, i), SMZ.DriftY(:, i), SMZ.DriftZ(:, i), ...
                     sz, cm(indx, :), '.');
         end
      end
   end
   cb = colorbar;
   cb.Label.String = sprintf('fraction of total frames (= %d x %d)', ...
                             SMD.NDatasets, SMD.NFrames);

   % Root mean square error computed from the drift in the first frame of each
   % dataset which should be zero (in theory) for registered data.
   RMSE = sum(SMZ.DriftX(1, :).^2)/SMD.NDatasets + ...
          sum(SMZ.DriftY(1, :).^2)/SMD.NDatasets;
   if Ndims == 3
      RMSE = RMSE + sum(SMZ.DriftZ(1, :).^2)/SMD.NDatasets;
   end
   RMSE = sqrt(RMSE);

   if option == 'R'
      prefix = 'relative ';
   else
      prefix = '';
   end
%  if exist('DriftParams', 'var')
%     title(sprintf([prefix, 'drift correction: RMSE_{reg} = %f nm\n', ...
%                    '(PDegree = %d, Init\\_inter = %d)'],          ...
%                   RMSE, DriftParams.PDegree, DriftParams.Init_inter));
%  else
      title(sprintf([prefix, 'drift correction: RMSE_{reg} = %f nm\n'], RMSE));
%  end
   xlabel('x (nm)');
   ylabel('y (nm)');
   if Ndims == 3
      zlabel('z (nm)');
   end
   axis equal

   hold off

end

./MATLAB/+smi_core/@DriftCorrection/plotCumDrift.m
function [FigHandle] = plotCumDrift(SMD, FieldName)
%plotCumDrift creates cumulative plots for Drift in any direction
% plotCumDrift will create a cumulative drift plot for the specified
% direction given the data in the SMD (single molecule results) structure
% and a CumName specifying the drift field within SMD which will be
% plotted.
%
% INPUT:
%    SMD: Single molecule results structure containing that results from
%         a previous single molecule analysis.
%    FieldName: The field name of the drift within SMD, e.g. 'DriftX'.  
%               FieldName can be either a character array, a string, or a 
%               cell array containing multiple character arrays or strings 
%               (to plot multiple drift lines on the same plot).
%
% OUTPUT:
%    FigHandle:  Figure handle of cumulative Drift plot.

% Hanieh Mazloom-Farsibaf, April 2017 (Keith A. Lidke's lab)
% David James Schodt, December 2018 (Keith A. Lidke's lab)

% Check inputs and set defaults if needed.
if ~exist('SMD', 'var')
    error('You must enter an SMD structure to plot the cumulative drift.')
end
if ~exist('FieldName', 'var')
    error('You must enter the SMD field name for the drift of interest.')
end

% Extract the drift vector(s) from the SMD structure.
if iscell(FieldName)
    % Initialize a cell array for the drift arrays.
    Drift = cell(numel(FieldName), 1);
    
    % Populate the drift cell array, ensuring each element is a vector by
    % stacking the vectors for each dataset.
    for ii = 1:numel(FieldName)
        Drift{ii} = SMD.(FieldName{ii})(:);
    end
else
    % Only one FieldName was given, so we just need one drift array (which
    % we'll place in a cell array for consistency).
    Drift = {SMD.(FieldName)(:)};
end

% Plot the drift array(s) specified by FieldName.
FigHandle = figure;
hold('on')
for ii = 1:numel(Drift)
    % Loop through each of the drift vectors specified in FieldName.
    Frames = (1:numel(Drift{ii})).';
    plot(Frames, Drift{ii}, '.')
end

% Add labels to the figure (titles, axis labels, etc.).
% NOTE: I'm turning off legend warnings in case one of SMD.(FieldName{ii})
%       is empty.  This shouldn't cause errors elsewhere so it's easy to
%       just turn off the warning temporarily.
title('Cumulative Drift')
xlabel('Absolute Frame Number')
ylabel('Shift (Camera Pixels)')
warning('off', 'MATLAB:legend:IgnoringExtraEntries')
legend(FieldName)
warning('on', 'MATLAB:legend:IgnoringExtraEntries')

end

./MATLAB/+smi_core/@DriftCorrection/driftCorrectKNN.m
function [SMD, Statistics] = driftCorrectKNN(obj, SMD)
%driftCorrectKNN calculates the drift directly from X,Y{,Z} coordinates
% by fitting a polynomial depending on time (i.e., frame number) to the frames
% with each dataset (intra-dataset), and fitting constant shifts between
% datasets (inter-dataset).  Fitting is done via performing fminsearch on the
% (weighted) sums of nearest neighbor distances.
%
% Sign convention:
%
%    N = numel(SMD_drifted.X);
%    for k = 1:N
%       i = SMD_corrected.FrameNum(k);
%       j = SMD_corrected.DatasetNum(k);
%       SMD_corrected.X(k) = SMD_drifted.X(k) - SMD_corrected.DriftX(i, j);
%       SMD_corrected.Y(k) = SMD_drifted.Y(k) - SMD_corrected.DriftY(i, j);
%    end
%
% INPUTS:
%   SMD:         A structure with fields:
%      X              x coordinates (Nx1) where N is total number of points
%      Y              y coordinates (Nx1)
%      Z              z coordinates (Nx1) [OPTIONAL]
%                  Note: X and Y are typically in pixels, Z in um
%      DatasetNum     dataset number from which localization originates (Nx1)
%      FrameNum       frame   number from which localization originates (Nx1)
%      NDatasets      number of datasets
%      NFrames        number of frames in each dataset
%   obj:           [class properties]
%                     optimization parameters with the following fields:
%      L_intra        intra-dataset threshold (Default = 1 pixel)
%      L_inter        inter-dataset threshold (Default = 2 pixels)
%      PixelSizeZUnit pixel size in um (units of Z; only needed for 3D)
%                     (Default = 0.1)
%      PDegree        degree of the intra-dataset drift correction fitting
%                     polynomial (Default = 1)
%      TolFun_intra   termination tolerance on the intra-dataset function value
%                     (Default = 1e-2)
%      TolX_intra     termination tolerance on the intra-dataset fitting
%                     polynomial (Default = 1e-4)
%      TolFun_inter   termination tolerance on the inter-dataset function value
%                     (Default = 1e-2)
%      TolX_inter     termination tolerance on the inter-dataset fitting
%                     polynomial (Default = 1e-4)
%      Init_inter     inter-dataset initialization with respect to the previous
%                     dataset; the value should be either 0 (no initial drift),
%                     1 (initial drift of the previous dataset) or SMD.NFrames
%                     (final drift); zero or initial drift should work well
%                     with brightfield registration, while final drift works
%                     well generally (but the optimization process may not
%                     converge quite as quickly) (Default = SMD.NFrames)
%      BFRegistration override value for Init_inter from obj if BFRegistration
%                     is false and the current value for Init_inter is zero, so
%                     the two are in conflict.  BFRegistration will take
%                     precedence
%      Verbose        verbosity level (Default = 1)
%      NDatasets      [OPTIONAL] override the collected value.  This causes the
%                     dataset/frame numbering to be reorganized internally as
%                     specified by the user
%      NFrames        [OPTIONAL] override the collected value.  See above
%      NOTES: Only one of NDatasets or NFrames needs to be specified.  These
%             numbers must evenly divide the total number of frames.  Better
%             results can sometimes occur by increasing the number of datasets
%             or decreasing the number of frames per dataset up to some limit
%             when the datasets become too sparse.  Init_inter will be
%             automatically changed from SMD.NFrames (if so specified) to
%             NFrames.
%
% OUTPUTS:
%   SMD:         SMD data structure with updated fields:
%      X              drift corrected x coordinates (Nx1)
%      Y              drift corrected y coordinates (Nx1)
%      Z              drift corrected z coordinates (Nx1) [OPTIONAL]
%      DriftX         found x drift per frame (NFrames x NDatasets)
%      DriftY         found y drift per frame (NFrames x NDatasets)
%      DriftZ         found z drift per frame (NFrames x NDatasets) [OPTIONAL]
%   Statistics:  statistical information about the algorithm performance
%                including various input parameters above and ...:
%      NDatasets          internal number of datasets
%      NFrames            internal number of frames per dataset
%      NDatasets_C        original (collected) number of datasets
%      NFrames_C          original (collected) number of frames per dataset
%      Intra_cost         intra-dataset cost function values per dataset
%      Intra_iterations   intra-dataset number of fminsearch iterations
%      Intra_funcCount    intra-dataset number of fminsearch function evals
%      Intra_elapsedTime  intra-dataset elapsed time for drift correction
%      Inter_cost         inter-dataset cost function values per dataset
%      Inter_iterations   inter-dataset number of fminsearch iterations
%      Inter_funcCount    inter-dataset number of fminsearch function evals
%      Inter_elapsedTime  inter-dataset elapsed time for drift correction
%
%   NOTE: SMD.DriftX/Y/Z are the drift corrections defined such that
%         drifted coordinates - drift correction = drift corrected coordinates
%
% CITATION:
%    "Robust, fiducial-free drift correction for super-resolution imaging",
%    Michael J. Wester, David J. Schodt, Hanieh Mazloom-Farsibaf, Mohamadreza
%    Fazel, Sandeep Pallikkuth and Keith A. Lidke, Scientific Reports,
%    (DOI: 10.1038/s41598-021-02850-7).

% Created by
%    Modelz... Bewerdorf's group
%    Farzin Farzam  (Lidke Lab 2017) [original version of driftCorrect2D]
%    Michael J. Wester and Keith Lidke (Lidke Lab 2017-2019) [knnsearch]
%       (completely rewrote the code)

   if isfield(SMD, 'Z') && numel(SMD.Z) == numel(SMD.X)
      Ndims = 3;
   else
      Ndims = 2;
   end

   NDatasets_C = SMD.NDatasets;
   NFrames_C   = SMD.NFrames;

   DriftParams.L_intra        = obj.L_intra;
   DriftParams.L_inter        = obj.L_inter;
   DriftParams.PixelSizeZUnit = obj.PixelSizeZUnit;
   DriftParams.PDegree        = obj.PDegree;
   DriftParams.TolFun_intra   = obj.TolFun_intra;
   DriftParams.TolX_intra     = obj.TolX_intra;
   DriftParams.TolFun_inter   = obj.TolFun_inter;
   DriftParams.TolX_inter     = obj.TolX_inter;
   DriftParams.Init_inter     = obj.Init_inter;
   % Override value for Init_inter from obj if BFRegistration is false and the
   % current value for Init_inter is zero, so the two are in conflict.
   % BFRegistration will take precedence.
   if ~obj.BFRegistration && DriftParams.Init_inter == 0
      DriftParams.Init_inter = SMD.NFrames;
   end
   if ~isempty(obj.NDatasets)
      DriftParams.NDatasets   = obj.NDatasets;
   end
   if ~isempty(obj.NFrames)
      DriftParams.NFrames     = obj.NFrames;
   end
   DriftParams.Verbose        = obj.Verbose;

   % Initialize various parameters, either provided by the user or defaults.
%  if exist('DriftParams', 'var')
      % PixelSizeZUnit is needed for 3D to convert Z into the same units as X
      % and Y.  PixelSizeZUnit is the X/Y pixel size in units of um.
      if isfield(DriftParams, 'PixelSizeZUnit')
         PixelSizeZUnit = DriftParams.PixelSizeZUnit;
      else
         PixelSizeZUnit = 0.1;   % default value in um
      end
      % L_intra is the intra-dataset threshold used in the cost function
      % computation to limit spurious nearest neighbor distances.  L_intra is
      % in units of pixels.
      if isfield(DriftParams, 'L_intra')
         L_intra = DriftParams.L_intra;
      else
         L_intra = 1;   % default value in pixels
      end
      % L_inter is the inter-dataset threshold used in the cost function
      % computation to limit spurious nearest neighbor distances.  L_inter is
      % in units of pixels.
      if isfield(DriftParams, 'L_inter')
         L_inter = DriftParams.L_inter;
      else
         L_inter = 2;   % default value in pixels
      end
      PDegree      = DriftParams.PDegree;
      TolFun_intra = DriftParams.TolFun_intra;
      TolX_intra   = DriftParams.TolX_intra;
      TolFun_inter = DriftParams.TolFun_inter;
      TolX_inter   = DriftParams.TolX_inter;
      Init_inter   = DriftParams.Init_inter;
      Verbose      = DriftParams.Verbose;

      if any(isfield(DriftParams, {'NDatasets', 'NFrames'}))
         SMD = ReorganizeDatasets(SMD, DriftParams);
         % SMD.NFrames has changed, so if Init_inter was set to the old value,
         % now reset it to the new value.
         if Init_inter == NFrames_C
            Init_inter = SMD.NFrames;
         end
      end
%  else
%     % Default values.
%     L_intra       = 1;     % intra-dataset threshold
%     L_inter       = 2;     % inter-dataset threshold
%     PixelSizeZUnit = 0.1;  % pixel size in um
%     PDegree       = 1;     % degree of the intra-dataset fitting polynomial
%                            % for drift correction
%     TolFun_intra = 1e-2;   % termination tolerance on the function value
%     TolX_intra   = 1e-4;   % termination tolerance on the fitting polynomial
%     TolFun_inter = 1e-2;   % termination tolerance on the function value
%     TolX_inter   = 1e-4;   % termination tolerance on the fitting polynomial
%     Init_inter   = SMD.NFrames; % initialization with respect to the previous
%                            % dataset for inter-dataset drift correction
%  end

   Statistics.Ndims          = Ndims;
   Statistics.PixelSizeZUnit = PixelSizeZUnit;
   Statistics.NDatasets      = SMD.NDatasets;
   Statistics.NFrames        = SMD.NFrames;
   Statistics.NDatasets_C    = NDatasets_C;
   Statistics.NFrames_C      = NFrames_C;
   Statistics.L_intra        = L_intra;
   Statistics.L_inter        = L_inter;
   Statistics.PDegree        = PDegree;
   Statistics.Init_inter     = Init_inter;
   Statistics.TolFun_intra   = TolFun_intra;
   Statistics.TolX_intra     = TolX_intra;
   Statistics.TolFun_inter   = TolFun_inter;
   Statistics.TolX_inter     = TolX_inter;

   SMD.DriftX = zeros(SMD.NFrames, SMD.NDatasets, 'single');
   SMD.DriftY = zeros(SMD.NFrames, SMD.NDatasets, 'single');
   if Ndims == 3
      SMD.DriftZ = zeros(SMD.NFrames, SMD.NDatasets, 'single');
   end

   % ---------- Intra-Dataset drift correction --------------------------------

   tic;
   % These options will be used by fminsearch below.
   options = optimset('TolFun', TolFun_intra, 'TolX', TolX_intra);

   % Establish an indexing array to record rearrangements of points into
   % datasets, so that this reordering can be later undone.
   N = numel(SMD.X);
   idx = zeros(N, 1);
   base = 0;

   SMRS = cell(1, SMD.NDatasets);
   cost_intra = zeros(1, SMD.NDatasets);
   % Count the number of iterations and function calls.
   it = 0;   fc = 0;
   % Note that variables like X, Y, Z are vectors, while variables like XY are
   % n x Ndims matrices.  The basic reason for combining vectors into matrices
   % is to allow easier generalization to 3D.
   for i = 1:SMD.NDatasets
      mask = SMD.DatasetNum == i;
      n = sum(mask);
      XY = zeros(n, Ndims, 'single');
      XY(:, 1) = SMD.X(mask);
      XY(:, 2) = SMD.Y(mask);
      if Ndims == 3
         % Assume z values are given in um.  Convert these into the same units
         % as the x and y values, which are assumed to be given in pixels.
         % The z values are converted back to um on output.
         XY(:, 3) = SMD.Z(mask) ./ PixelSizeZUnit;
      end
      FrameNum = single(SMD.FrameNum(mask));

      idx(mask) = base + (1 : n);
      base = base + n;

      % Initialize polynomial fitting function, then optimize over the dataset.
      % P0 and P are packed vectors containing coefficients for all Pdegree
      % interpolations over all dimensions as required by fminsearch.  Note
      % that the polynomial is of PDegree for the drift correction.
      P0 = zeros(Ndims*PDegree, 1);
      % Test for really sparse datasets.
      if n <= 1 || SMD.NFrames == 1
         P = P0;
         XYC = XY;
      else
         [P, ~, exitflag, output] = ...
            fminsearch(@minD_intra, P0, options, XY, FrameNum, Ndims, L_intra);
         if exitflag ~= 1 && Verbose >= 1
            fprintf( ...
               'driftCorrectKNN fminsearch on minD_intra exitflag = %d\n', ...
                     exitflag);
         end
         it = it + output.iterations;
         fc = fc + output.funcCount;

         [cost_intra(i), XYC] = minD_intra(P, XY, FrameNum, Ndims, L_intra);
      end

      PX = P(1           : PDegree);
      PY = P(PDegree + 1 : 2*PDegree);

      % Values corrected for drift.
      SMRS{i}.XY = XYC;
      SMRS{i}.n  = n;

      range = double(1:SMD.NFrames);
      SMD.DriftX(:, i) = polyval([PX', 0], range);
      SMD.DriftY(:, i) = polyval([PY', 0], range);

      if Ndims == 3
         PZ = P(2*PDegree + 1 : end);
         SMD.DriftZ(:, i) = polyval([PZ', 0], range);
      end
   end
   Statistics.Intra_cost        = cost_intra;
   Statistics.Intra_iterations  = it;
   Statistics.Intra_funcCount   = fc;
   Statistics.Intra_elapsedTime = toc;

   % ---------- Inter-Dataset drift correction --------------------------------

   tic;
   % These options will be used by fminsearch below.
   options = optimset('TolFun', TolFun_inter, 'TolX', TolX_inter);
   %options = optimset('TolFun', TolFun_inter, 'TolX', TolX_inter, ...
   %                  'PlotFcns', @optimplotfval);

   % Create a NeighborSearcher object for k-nearest neighbors search from the
   % first dataset.
   if SMD.NDatasets > 1 && SMRS{1}.n == 0
      % This whole procedure fails if the first dataset is empty!
      error(['First dataset is empty!  ', ...
             'Cannot perform inter-dataset drift correction.']);
   end
   NS = createns(SMRS{1}.XY);
   cost_inter = zeros(1, SMD.NDatasets);
   % Count the number of iterations and function calls.
   it = 0;   fc = 0;
   for i = 2:SMD.NDatasets
      XY2 = SMRS{i}.XY;

      % Initialize the inter-dataset constant shift from the previous dataset's
      % initial or final drift depending on the value of Init_inter (or 0 for
      % no expected drift).  Note that we assume here that the inter-dataset
      % drift correction is constant.
      if Init_inter == 0
         P0_inter = zeros(1, Ndims);
      else
         if Ndims == 2
            P0_inter = [ SMD.DriftX(Init_inter, i - 1), ...
                         SMD.DriftY(Init_inter, i - 1) ];
         else
            P0_inter = [ SMD.DriftX(Init_inter, i - 1), ...
                         SMD.DriftY(Init_inter, i - 1), ...
                         SMD.DriftZ(Init_inter, i - 1) ];
         end
      end
      P0 = double(P0_inter);
      if SMRS{i}.n <= 1
         XY2C = XY2;
         P = P0;
      else
         [P, ~, exitflag, output] = ...
            fminsearch(@minD_inter, P0, options, NS, XY2, Ndims, L_inter);
         if exitflag ~= 1 && Verbose >= 1
            fprintf( ...
               'driftCorrectKNN fminsearch on minD_inter exitflag = %d\n', ...
                    exitflag);
         end
         it = it + output.iterations;
         fc = fc + output.funcCount;

         [cost_inter(i), XY2C] = minD_inter(P, NS, XY2, Ndims, L_inter);
      end

      % Values corrected for drift.
      SMRS{i}.XY = XY2C;

      % Update the drift correction for dataset i.
      SMD.DriftX(:, i) = SMD.DriftX(:, i) + P(1);
      SMD.DriftY(:, i) = SMD.DriftY(:, i) + P(2);

      if Ndims == 3
         SMD.DriftZ(:, i) = SMD.DriftZ(:, i) + P(3);
      end
   end
   Statistics.Inter_cost        = cost_inter;
   Statistics.Inter_iterations  = it;
   Statistics.Inter_funcCount   = fc;
   Statistics.Inter_elapsedTime = toc;

   % --------------------------------------------------------------------------

   % Make sign of drift consistent with what was done before.
   SMD.DriftX = - SMD.DriftX;
   SMD.DriftY = - SMD.DriftY;
   if Ndims == 3
      SMD.DriftZ = - SMD.DriftZ .* PixelSizeZUnit;
   end

   % Save the drift corrected coordinates in SMD.
   XYout = cell(1, Ndims);
   for i = 1:SMD.NDatasets
      for j = 1:Ndims
         XYout{j} = [XYout{j}; SMRS{i}.XY(:, j)];
      end
   end
   SMD.X = XYout{1}(idx);
   SMD.Y = XYout{2}(idx);
   if Ndims == 3
      SMD.Z = XYout{3}(idx) .* PixelSizeZUnit;
   end

   % If the dataset organization has been modified (because the user chose a
   % reorganization), restore the original scheme back.
   if isfield(SMD, 'Collected')
      SMD.Internal.NDatasets  = SMD.NDatasets;
      SMD.Internal.NFrames    = SMD.NFrames;
      SMD.Internal.DatasetNum = SMD.DatasetNum;
      SMD.Internal.FrameNum   = SMD.FrameNum;
      SMD.Internal.DriftX = SMD.DriftX;
      SMD.Internal.DriftY = SMD.DriftY;
      if Ndims == 3
         SMD.Internal.DriftZ = SMD.DriftZ;
      end

      SMD.NDatasets  = SMD.Collected.NDatasets;
      SMD.NFrames    = SMD.Collected.NFrames;
      SMD.DatasetNum = SMD.Collected.DatasetNum;
      SMD.FrameNum   = SMD.Collected.FrameNum;
      SMD = rmfield(SMD, 'Collected');

      DriftX = SMD.DriftX;
      SMD.DriftX = zeros(SMD.NFrames, SMD.NDatasets, 'single');
      % The notation below reshapes the internal matrix produced for DriftX
      % into the shape expected for the original NDatasets and NFrames.
      SMD.DriftX(:) = DriftX(:);
      DriftY = SMD.DriftY;
      SMD.DriftY = zeros(SMD.NFrames, SMD.NDatasets, 'single');
      SMD.DriftY(:) = DriftY(:);
      if Ndims == 3
         DriftZ = SMD.DriftZ;
         SMD.DriftZ = zeros(SMD.NFrames, SMD.NDatasets, 'single');
         SMD.DriftZ(:) = DriftZ(:);
      end
   end

end

% =============================================================================

function [sumNND, X] = minD_intra(Theta, X, T, Ndims, L_intra)
% Sum of nearest neighbor distances for intra-dataset drift correction.

   N = numel(Theta);

   m = N/Ndims;
   lo = 1;   hi = m;
   for j = 1:Ndims
      PX = Theta(lo : hi);
      % Assume the constant term of the polynomial is zero for the frames
      % within a dataset.  (This assumption considerably speeds up the
      % intra-dataset minimization.)
      X(:, j) = X(:, j) + polyval([PX', 0], T);

      lo = lo + m;
      hi = hi + m;
   end

   % D(:, 1) will be identically zero since here we are finding the nearest
   % neighbors of X with respect to itself.
   [~, D] = knnsearch(X, X, 'K', 2);
   D2 = D(:, 2);

   % Make distances > L_intra equal to L_intra in the cost function to
   % de-emphasize widely separated nearest neighbors.  This can be be important
   % in sparse datasets where long distances may separate localizations.  The
   % nearest neighbor of a localization in one frame of a dataset may blink
   % off, resulting in a totally different nearest neighbor for the same
   % localization in the next frame.
   sumNND = sum(min(D2, L_intra));

   % In rare cases, D2 may contain NaNs, so here replace them with an average
   % value (modeled on the code in minD_inter).
   if isnan(sumNND)
      nans = isnan(D2);
      D2(nans) = [];
      n = sum(nans);
      sumNND = sum(min(D2, L_intra)) * (1 + n/numel(D2));
   end

end

% -----------------------------------------------------------------------------

function [sumNND, X2] = minD_inter(Theta, NS, X2, Ndims, L_inter)
% Sum of nearest neighbor distances for inter-dataset drift correction.

   % Theta(1) = DriftX, Theta(2) = DriftY, Theta(3) = DriftZ
   for j = 1:Ndims
      X2(:, j) = X2(:, j) + Theta(j);
   end

   %[~, D] = knnsearch(NS, X2, 'K', 1);
   [~, D] = knnsearch(NS, X2);
   sumNND = sum(min(D, L_inter));

   % In rare cases, D may contain NaNs, so here replace them with an average
   % value.  n is the number of NaNs found and the NaNs are removed from D
   % before recomputing sumNND.
   if isnan(sumNND)
      nans = isnan(D);
      D(nans) = [];
      n = sum(nans);
      % Note that sum(D(D <= L)) + L*sum(D > L) = sum(min(D, L)), then
      % sumNND = sum(min(D, L)) + n*mean(min(D, L))
      %        = sum(min(D, L)) + n * sum(min(D, L))/numel(min(D, L))
      %        = sum(min(D, L)) * (1 + n/numel(D));
      sumNND = sum(min(D, L_inter)) * (1 + n/numel(D));
   end
   
end

% =============================================================================

function SMD = ReorganizeDatasets(SMD, DriftParams)
% Reorganize the collected frames into user specified dataset divisions.

   % NDatasets is the number of datasets.
   % NFrames   is the number of frames per dataset.
   % NFrames_total is the total number of frames over all datasets.
   NFrames_total = SMD.NDatasets * SMD.NFrames;
   if isfield(DriftParams, 'NDatasets') && ~isempty(DriftParams.NDatasets)
      NDatasets = DriftParams.NDatasets;
      NFrames   = NFrames_total / NDatasets;
      if mod(NFrames, 1) ~= 0
         error(['DriftParams.NDatasets (%d) does not divide evenly into\n', ...
                'the total number of frames (%d)!'], NDatasets, NFrames_total);
      end
      if isfield(DriftParams, 'NFrames') && ~isempty(DriftParams.NFrames)
         if DriftParams.NFrames ~= NFrames
         error(['DriftParams.NDatasets * DriftParams.NFrames (%d * %d) !=\n',...
                'the total number of frames (%d)!'], ...
               DriftParams.NDatasets, DriftParams.NFrames, NFrames_total);
         end
      end
   elseif isfield(DriftParams, 'NFrames') && ~isempty(DriftParams.NFrames)
      NFrames   = DriftParams.NFrames;
      NDatasets = NFrames_total / NFrames;
      if mod(NDatasets, 1) ~= 0
         error(['DriftParams.NFrames (%d) does not divide evenly into\n', ...
                'the total number of frames (%d)!'], NFrames, NFrames_total);
      end
   end

   % Compute absolute frame number as if there was only one dataset.
   FrameNumAbs = ...
      (SMD.DatasetNum - 1)*double(SMD.NFrames) + double(SMD.FrameNum);
   % Reorganize the absolute frame numbers into new dataset divisions.
   DatasetNum = ones(size(FrameNumAbs));
   FrameNum   = zeros(size(FrameNumAbs));
   for i = 1 : numel(DatasetNum)
      DatasetNum(i) = ...
         (FrameNumAbs(i) - 1 - mod(FrameNumAbs(i) - 1, NFrames)) / NFrames + 1;
      FrameNum(i)   = mod(FrameNumAbs(i) - 1, NFrames) + 1;
   end

   % Save collected dataset/frame numbering.
   SMD.Collected.NDatasets  = SMD.NDatasets;
   SMD.Collected.NFrames    = SMD.NFrames;
   SMD.Collected.DatasetNum = SMD.DatasetNum;
   SMD.Collected.FrameNum   = SMD.FrameNum;
   % Replace the old numbering scheme with the new one.
   SMD.NDatasets  = NDatasets;
   SMD.NFrames    = NFrames;
   SMD.DatasetNum = DatasetNum;
   SMD.FrameNum   = FrameNum;

end

./MATLAB/+smi_core/@DriftCorrection/driftCorrectKNNInter.m
function [SMD, Statistics] = driftCorrectKNNInter(obj, SMD)
%driftCorrectKNNInter calculates inter-dataset drift directly from X,Y{,Z} coordinates
% by fitting a polynomial depending on time (i.e., frame number) to the frames
% with each dataset (intra-dataset), and fitting constant shifts between
% datasets (inter-dataset).  Fitting is done via performing fminsearch on the
% (weighted) sums of nearest neighbor distances.  Inter-dataset portion.
%
% Sign convention:
%
%    N = numel(SMD_drifted.X);
%    for k = 1:N
%       i = SMD_corrected.FrameNum(k);
%       j = SMD_corrected.DatasetNum(k);
%       SMD_corrected.X(k) = SMD_drifted.X(k) - SMD_corrected.DriftX(i, j);
%       SMD_corrected.Y(k) = SMD_drifted.Y(k) - SMD_corrected.DriftY(i, j);
%    end
%
% INPUTS:
%   SMD:         A structure with fields:
%      X              x coordinates (Nx1) where N is total number of points
%      Y              y coordinates (Nx1)
%      Z              z coordinates (Nx1) [OPTIONAL]
%                  Note: X and Y are typically in pixels, Z in um
%      DatasetNum     dataset number from which localization originates (Nx1)
%      FrameNum       frame   number from which localization originates (Nx1)
%      NDatasets      number of datasets
%      NFrames        number of frames in each dataset
%      DriftX         intra-dataset x drift (NFrames x NDatasets)
%      DriftY         intra-dataset y drift (NFrames x NDatasets)
%      DriftZ         intra-dataset z drift (NFrames x NDatasets) [OPTIONAL]
%                  Note: DriftX/Y/Z should be computed by driftCorrectKNNIntra
%   obj:           [class properties]
%                     optimization parameters with the following fields:
%      L_intra        intra-dataset threshold (Default = 1 pixel)
%      L_inter        inter-dataset threshold (Default = 2 pixels)
%      PixelSizeZUnit pixel size in um (units of Z; only needed for 3D)
%                     (Default = 0.1)
%      PDegree        degree of the intra-dataset drift correction fitting
%                     polynomial (Default = 1)
%      TolFun_intra   termination tolerance on the intra-dataset function value
%                     (Default = 1e-2)
%      TolX_intra     termination tolerance on the intra-dataset fitting
%                     polynomial (Default = 1e-4)
%      TolFun_inter   termination tolerance on the inter-dataset function value
%                     (Default = 1e-2)
%      TolX_inter     termination tolerance on the inter-dataset fitting
%                     polynomial (Default = 1e-4)
%      Init_inter     inter-dataset initialization with respect to the previous
%                     dataset; the value should be either 0 (no initial drift),
%                     1 (initial drift of the previous dataset) or SMD.NFrames
%                     (final drift); zero or initial drift should work well
%                     with brightfield registration, while final drift works
%                     well generally (but the optimization process may not
%                     converge quite as quickly) (Default = SMD.NFrames)
%      BFRegistration override value for Init_inter from obj if BFRegistration
%                     is false and the current value for Init_inter is zero, so
%                     the two are in conflict.  BFRegistration will take
%                     precedence
%      Verbose        verbosity level (Default = 1)
%
% OUTPUTS:
%   SMD:         SMD data structure with updated fields:
%      X              drift corrected x coordinates (Nx1)
%      Y              drift corrected y coordinates (Nx1)
%      Z              drift corrected z coordinates (Nx1) [OPTIONAL]
%      DriftX         found x drift per frame (NFrames x NDatasets)
%      DriftY         found y drift per frame (NFrames x NDatasets)
%      DriftZ         found z drift per frame (NFrames x NDatasets) [OPTIONAL]
%   Statistics:  statistical information about the algorithm performance
%                including various input parameters above and ...:
%      NDatasets          internal number of datasets
%      NFrames            internal number of frames per dataset
%      Intra_iterations   intra-dataset number of fminsearch iterations
%      Intra_funcCount    intra-dataset number of fminsearch function evals
%      Intra_elapsedTime  intra-dataset elapsed time for drift correction
%      Inter_iterations   inter-dataset number of fminsearch iterations
%      Inter_funcCount    inter-dataset number of fminsearch function evals
%      Inter_elapsedTime  inter-dataset elapsed time for drift correction
%
%   NOTE: SMD.DriftX/Y/Z are the drift corrections defined such that
%         drifted coordinates - drift correction = drift corrected coordinates
%
% CITATION:
%    "Robust, Fiducial-Free Drift Correction for Super-resolution Imaging"

% Created by
%    Modelz... Bewerdorf's group
%    Farzin Farzam  (Lidke Lab 2017) [original version of driftCorrect2D]
%    Michael J. Wester and Keith Lidke (Lidke Lab 2017-2019) [knnsearch]
%       (completely rewrote the code)

   if isfield(SMD, 'Z') && numel(SMD.Z) == numel(SMD.X)
      Ndims = 3;
   else
      Ndims = 2;
   end

   DriftParams.L_intra        = obj.L_intra;
   DriftParams.L_inter        = obj.L_inter;
   DriftParams.PixelSizeZUnit = obj.PixelSizeZUnit;
   DriftParams.PDegree        = obj.PDegree;
   DriftParams.TolFun_intra   = obj.TolFun_intra;
   DriftParams.TolX_intra     = obj.TolX_intra;
   DriftParams.TolFun_inter   = obj.TolFun_inter;
   DriftParams.TolX_inter     = obj.TolX_inter;
   DriftParams.Init_inter     = obj.Init_inter;
   DriftParams.Verbose        = obj.Verbose;
   % Override value for Init_inter from obj if BFRegistration is false and the
   % current value for Init_inter is zero, so the two are in conflict.
   % BFRegistration will take precedence.
   if ~obj.BFRegistration && DriftParams.Init_inter == 0
      DriftParams.Init_inter = SMD.NFrames; 
   end
   if ~isempty(obj.NDatasets)
      DriftParams.NDatasets   = obj.NDatasets;
      obj.Init_inter          = obj.NDatasets;
   end
   if ~isempty(obj.NFrames)
      DriftParams.NFrames     = obj.NFrames;
   end

   % Initialize various parameters.
   % PixelSizeZUnit is needed for 3D to convert Z into the same units as X
   % and Y.  PixelSizeZUnit is the X/Y pixel size in units of um.
   PixelSizeZUnit = DriftParams.PixelSizeZUnit;
   % L_intra is the intra-dataset threshold used in the cost function
   % computation to limit spurious nearest neighbor distances.  L_intra is
   % in units of pixels.
   L_intra = DriftParams.L_intra;
   % L_inter is the inter-dataset threshold used in the cost function
   % computation to limit spurious nearest neighbor distances.  L_inter is
   % in units of pixels.
   L_inter = DriftParams.L_inter;
   PDegree      = DriftParams.PDegree;
   TolFun_intra = DriftParams.TolFun_intra;
   TolX_intra   = DriftParams.TolX_intra;
   TolFun_inter = DriftParams.TolFun_inter;
   TolX_inter   = DriftParams.TolX_inter;
   Init_inter   = DriftParams.Init_inter;
   Verbose      = DriftParams.Verbose;

   Statistics.Ndims          = Ndims;
   Statistics.PixelSizeZUnit = PixelSizeZUnit;
   Statistics.NDatasets      = SMD.NDatasets;
   Statistics.NFrames        = SMD.NFrames;
   Statistics.L_intra        = L_intra;
   Statistics.L_inter        = L_inter;
   Statistics.PDegree        = PDegree;
   Statistics.Init_inter     = Init_inter;
   Statistics.TolFun_intra   = TolFun_intra;
   Statistics.TolX_intra     = TolX_intra;
   Statistics.TolFun_inter   = TolFun_inter;
   Statistics.TolX_inter     = TolX_inter;

   % ---------- Intra-Dataset drift correction --------------------------------

   % ---------- Inter-Dataset drift correction --------------------------------

   idx  = obj.idx;
   SMRS = obj.SMRS;

   tic;
   % These options will be used by fminsearch below.
   options = optimset('TolFun', TolFun_inter, 'TolX', TolX_inter);
   %options = optimset('TolFun', TolFun_inter, 'TolX', TolX_inter, ...
   %                  'PlotFcns', @optimplotfval);

   % Create a NeighborSearcher object for k-nearest neighbors search from the
   % first dataset.
   if SMD.NDatasets > 1 && SMRS{1}.n == 0
      % This whole procedure fails if the first dataset is empty!
      error(['First dataset is empty!  ', ...
             'Cannot perform inter-dataset drift correction.']);
   end
   NS = createns(SMRS{1}.XY);
   % Count the number of iterations and function calls.
   it = 0;   fc = 0;
   for i = 2:SMD.NDatasets
      XY2 = SMRS{i}.XY;

      % Initialize the inter-dataset constant shift from the previous dataset's
      % initial or final drift depending on the value of Init_inter (or 0 for
      % no expected drift).  Note that we assume here that the inter-dataset
      % drift correction is constant.
      if Init_inter == 0
         P0_inter = zeros(1, Ndims);
      else
         if Ndims == 2
            P0_inter = [ SMD.DriftX(Init_inter, i - 1), ...
                         SMD.DriftY(Init_inter, i - 1) ];
         else
            P0_inter = [ SMD.DriftX(Init_inter, i - 1), ...
                         SMD.DriftY(Init_inter, i - 1), ...
                         SMD.DriftZ(Init_inter, i - 1) ];
         end
      end
      P0 = double(P0_inter);
      if SMRS{i}.n <= 1
         XY2C = XY2;
         P = P0;
      else
         [P, ~, exitflag, output] = ...
            fminsearch(@minD_inter, P0, options, NS, XY2, Ndims, L_inter);
         if exitflag ~= 1 && Verbose >= 1
            fprintf( ...
               'driftCorrectKNN fminsearch on minD_inter exitflag = %d\n', ...
                    exitflag);
         end
         it = it + output.iterations;
         fc = fc + output.funcCount;

         [~, XY2C] = minD_inter(P, NS, XY2, Ndims, L_inter);
      end

      % Values corrected for drift.
      SMRS{i}.XY = XY2C;

      % Update the drift correction for dataset i.
      SMD.DriftX(:, i) = SMD.DriftX(:, i) + P(1);
      SMD.DriftY(:, i) = SMD.DriftY(:, i) + P(2);

      if Ndims == 3
         SMD.DriftZ(:, i) = SMD.DriftZ(:, i) + P(3);
      end
   end
   Statistics.Inter_iterations  = it;
   Statistics.Inter_funcCount   = fc;
   Statistics.Inter_elapsedTime = toc;

   % --------------------------------------------------------------------------

   % Make sign of drift consistent with what was done before.
   SMD.DriftX = - SMD.DriftX;
   SMD.DriftY = - SMD.DriftY;
   if Ndims == 3
      SMD.DriftZ = - SMD.DriftZ .* PixelSizeZUnit;
   end

   % Save the drift corrected coordinates in SMD.
   XYout = cell(1, Ndims);
   for i = 1:SMD.NDatasets
      for j = 1:Ndims
         XYout{j} = [XYout{j}; SMRS{i}.XY(:, j)];
      end
   end
   SMD.X = XYout{1}(idx);
   SMD.Y = XYout{2}(idx);
   if Ndims == 3
      SMD.Z = XYout{3}(idx) .* PixelSizeZUnit;
   end

   % If the dataset organization has been modified (because the user chose a
   % reorganization), restore the original scheme back.
   if isfield(SMD, 'Collected')
      SMD.Internal.NDatasets  = SMD.NDatasets;
      SMD.Internal.NFrames    = SMD.NFrames;
      SMD.Internal.DatasetNum = SMD.DatasetNum;
      SMD.Internal.FrameNum   = SMD.FrameNum;
      SMD.Internal.DriftX = SMD.DriftX;
      SMD.Internal.DriftY = SMD.DriftY;
      if Ndims == 3
         SMD.Internal.DriftZ = SMD.DriftZ;
      end

      SMD.NDatasets  = SMD.Collected.NDatasets;
      SMD.NFrames    = SMD.Collected.NFrames;
      SMD.DatasetNum = SMD.Collected.DatasetNum;
      SMD.FrameNum   = SMD.Collected.FrameNum;
      SMD = rmfield(SMD, 'Collected');

      DriftX = SMD.DriftX;
      SMD.DriftX = zeros(SMD.NFrames, SMD.NDatasets, 'single');
      % The notation below reshapes the internal matrix produced for DriftX
      % into the shape expected for the original NDatasets and NFrames.
      SMD.DriftX(:) = DriftX(:);
      DriftY = SMD.DriftY;
      SMD.DriftY = zeros(SMD.NFrames, SMD.NDatasets, 'single');
      SMD.DriftY(:) = DriftY(:);
      if Ndims == 3
         DriftZ = SMD.DriftZ;
         SMD.DriftZ = zeros(SMD.NFrames, SMD.NDatasets, 'single');
         SMD.DriftZ(:) = DriftZ(:);
      end
   end

end

% =============================================================================

function [sumNND, X2] = minD_inter(Theta, NS, X2, Ndims, L_inter)
% Sum of nearest neighbor distances for inter-dataset drift correction.

   % Theta(1) = DriftX, Theta(2) = DriftY, Theta(3) = DriftZ
   for j = 1:Ndims
      X2(:, j) = X2(:, j) + Theta(j);
   end

   %[~, D] = knnsearch(NS, X2, 'K', 1);
   [~, D] = knnsearch(NS, X2);
   sumNND = sum(min(D, L_inter));

   % In rare cases, D may contain NaNs, so here replace them with an average
   % value.  n is the number of NaNs found and the NaNs are removed from D
   % before recomputing sumNND.
   if isnan(sumNND)
      nans = isnan(D);
      D(nans) = [];
      n = sum(nans);
      % Note that sum(D(D <= L)) + L*sum(D > L) = sum(min(D, L)), then
      % sumNND = sum(min(D, L)) + n*mean(min(D, L))
      %        = sum(min(D, L)) + n * sum(min(D, L))/numel(min(D, L))
      %        = sum(min(D, L)) * (1 + n/numel(D));
      sumNND = sum(min(D, L_inter)) * (1 + n/numel(D));
   end
   
end

./MATLAB/+smi_core/@DriftCorrection/calcDCRMSE.m
function [dist1, rmse1, dist2, rmse2, nnfig] = ...
   calcDCRMSE(SMD, X_True, Y_True, Z_True,     ...
              DriftX_True, DriftY_True, DriftZ_True)
% calcDCRMSE calculates the RMSE of SMD relative to true coordinates/curves.
% (1) considers differences in localization coordinates wrt the true values.
% (2) considers differences in drift curves wrt to the true values.
% (1) and (2) are typically close in value.
%
% INPUTS:
%   SMD              A structure with fields:
%      X                  x-coordinates (Nx1) where N is total number of points
%      Y                  y-coordinates (Nx1) [pixels, also for X]
%      Z                  z-coordinates (Nx1) [um]
%      DriftX             x-drifts found (Nframes x Ndatasets) [pixels]
%      DriftY             y-drifts found (Nframes x Ndatasets) [pixels]
%      DriftZ             z-drifts found (Nframes x Ndatasets) [um]
%      PixelSizeZUnit     um per pixel
%   X_True           true x-coordinates (Nx1) [pixels]
%   Y_True           true y-coordinates (Nx1) [pixels]
%   Z_True           true z-coordinates (Nx1) [um]
%   DriftX_True      true x-drift curve (Nframes x Ndatasets) [pixels]
%   DriftY_True      true y-drift curve (Nframes x Ndatasets) [pixels]
%   DriftZ_True      true z-drift curve (Nframes x Ndatasets) [um]
% OUTPUTS:
%   dist1   average distance between true and drift corrected coordinates (nm)
%   dist2   average distance between true and drift corrected curves (nm)
%   rmse1   root-mean-square-error between true and drift corrected coords (nm)
%   rmse2   root-mean-square-error between true and drift corrected curves (nm)
%   nnfig   histogram of nearest neighbor distances between drift corrected and
%           true coordinates
%
% Created by:
%   Michael J. Wester (Lidke Lab 2020)

   SRImageZoom = 10;

   % Remove any NaNs.
   nans = find(isnan(SMD.X) | isnan(SMD.Y) | isnan(X_True) | isnan(Y_True));
   n_nans = numel(nans);
   if n_nans > 0
      fprintf('calcDCRMSE: %d NaNs removed!\n', n_nans);
      SMD.X(nans) = [];
      SMD.Y(nans) = [];
      X_True(nans) = [];
      Y_True(nans) = [];
   end
   N = numel(SMD.X);
   Nframes = SMD.NFrames;

   % --------------------------------------------------------------------------

%  % Drift corrected image.
%  DCimage = smi_vis.GenerateImages.histogramImage(SMD, SRImageZoom);

%  % True image.
%  SMD_True = SMD;
%  SMD_True.X = X_True;
%  SMD_True.Y = Y_True;
%  TrueImage = smi_vis.GenerateImages.histogramImage(SMD_True, SRImageZoom);

%  % Reconstructed original image.
%  X_unDC = zeros(N, 1, 'single');
%  Y_unDC = zeros(N, 1, 'single');
%  for k = 1:N
%     i = SMD.FrameNum(k);
%     j = SMD.DatasetNum(k);
%     X_unDC(k) = SMD.X(k) + SMD.DriftX(i, j);
%     Y_unDC(k) = SMD.Y(k) + SMD.DriftY(i, j);
%  end
%  SMD_unDC = SMD;
%  SMD_unDC.X = X_unDC;
%  SMD_unDC.Y = Y_unDC;
%  unDCimage = smi_vis.GenerateImages.histogramImage(SMD_unDC, SRImageZoom);

%  % Residual image.
%  residual = abs(DCimage - TrueImage);

   % --------------------------------------------------------------------------

   P2nm = SMD.PixelSizeZUnit * 1000;   % nm per pixel

   % Drift corrected and true coordinates (nm).
   XX = SMD.X * P2nm;
   YY = SMD.Y * P2nm;
   XX_True = X_True * P2nm;
   YY_True = Y_True * P2nm;
   if ~isempty(Z_True)
      ZZ      = SMD.Z  * 1000;
      ZZ_True = Z_True * 1000;
   end

   % Average distance between the true and drift corrected coordinates.
   if ~isempty(Z_True)
      dists1 = sqrt((XX_True - XX).^2 + (YY_True - YY).^2 + (ZZ_True - ZZ).^2);
   else
      dists1 = sqrt((XX_True - XX).^2 + (YY_True - YY).^2);
   end
   dist1 = sum(dists1) / N;
   % RMSE1 between the true and drift corrected coordinates (nm).
   rmse1 = sqrt(sum(dists1.^2) / N);

   % Histogram of nearest neighbor distances between the true and the drift
   % corrected coordinates.
   if ~isempty(Z_True)
      [~, D] = knnsearch([XX_True, YY_True, ZZ_True], [XX, YY, ZZ]);
   else
      [~, D] = knnsearch([XX_True, YY_True], [XX, YY]);
   end
   nnfig = figure('Visible', 'off');
   hold on
   histogram(D, 100);
   title('true vs. drift corrected image');
   xlabel('nearest neighbor distances (nm)');
   ylabel('frequency');
   hold off

   % --------------------------------------------------------------------------

   % Compare found versus true drift.
   % Convert drift from pixels per frame to nm per frame.
   x_drift_true_nm = DriftX_True(:) * P2nm;
   y_drift_true_nm = DriftY_True(:) * P2nm;
   x_drift_found_nm = SMD.DriftX(:) * P2nm;
   y_drift_found_nm = SMD.DriftY(:) * P2nm;
   if ~isempty(DriftZ_True)
      % Convert drift from um per frame to nm per frame for z.
      z_drift_true_nm = DriftZ_True(:) * 1000; 
      z_drift_found_nm = SMD.DriftZ(:) * 1000;
   end

   % Average distance between the true and the found drift corrected curves.
   if ~isempty(DriftZ_True)
      dists2 = ...
         sqrt((x_drift_true_nm - x_drift_found_nm).^2 + ...
              (y_drift_true_nm - y_drift_found_nm).^2 + ...
              (z_drift_true_nm - z_drift_found_nm).^2);
   else
      dists2 = ...
         sqrt((x_drift_true_nm - x_drift_found_nm).^2 + ...
              (y_drift_true_nm - y_drift_found_nm).^2);
   end
   dist2 = sum(dists2) / numel(x_drift_found_nm);
   % RMSE for true versus found drift curves.
   rmse2 = sqrt(sum(dists2.^2) / numel(x_drift_found_nm));

end

./MATLAB/+smi_core/@DriftCorrection/driftCorrectBF.m
function [SMD, BFStruct] = ...
    driftCorrectBF(SMD, SMF, RefImage, BFStruct, ParamStruct)
%driftCorrectBF performs drift correction from brightfield images.
% This method performs drift correction using brightfield images stored in
% an h5 file.  This is done by estimating shifts between brightfield images
% taken before and after each dataset in SMD, making the drift model a 1D
% polynomial for inter- and intra-dataset drift correction.
%
% INPUTS:
%   SMD: Single Molecule Data structure containing the localizations.
%   SMF: Single Molecule Fitting structure defining the path to the raw
%        data file.
%   RefImage: Reference image to which all datasets will be corrected to.
%             (Default = pre dataset 1 focus image).
%   BFStruct: Structure of brightfield images (see default setting below).
%   ParamStruct: Structure of parameters sent to smi_stat.findOffsetIter().
%                (fields NIterMax, Tolerance, CorrParams, ShiftParams are
%                passed as inputs to smi_stat.findOffsetIter())
%
% OUTPUTS:
%   SMD: Input SMD with applied shifts and updated fields SMD.DriftX and
%        SMD.DriftY.
%   BFStruct: Structure of brightfield images loaded from the data file.

% Created by:
%   David J. Schodt (Lidke Lab 2021)


% Attempt to load the brightfield data (if needed).
if (~exist('BFStruct', 'var') || isempty(BFStruct))
    try
        BFStruct = smi_core.LoadData.readH5File(...
            fullfile(SMF.Data.FileDir, SMF.Data.FileName{1}), 'FocusImages');
    catch ME
        error(sprintf('Cannot extract group ''FocusImages'' from %s', ...
            fullfile(SMF.Data.FileDir, SMF.Data.FileName{1})));
    end
end

% Set a defaults if needed.
if (~exist('RefImage', 'var') || isempty(RefImage))
    RefImage = median(BFStruct(1).Data.PreSeqImages, 3);
end
if (~exist('ParamStruct', 'var') || isempty(ParamStruct))
    ParamStruct = struct();
end
DefaultParams.NIterMax = 3;
DefaultParams.Tolerance = [];
DefaultParams.CorrParams = struct();
DefaultParams.CorrParams.SuppressWarnings = true;
DefaultParams.ShiftParams = struct();
ParamStruct = smi_helpers.padStruct(ParamStruct, DefaultParams);

% Perform intra-dataset drift correction.
PreSeqImages = zeros([size(RefImage), SMD.NDatasets]);
PostSeqImages = zeros([size(RefImage), SMD.NDatasets]);
for nn = 1:SMD.NDatasets
    PreSeqImages(:, :, nn) = median(BFStruct(nn).Data.PreSeqImages, 3);
    PostSeqImages(:, :, nn) = median(BFStruct(nn).Data.PostSeqImages, 3);
end
SMD = smi_core.DriftCorrection.driftCorrectBFIntra(...
    SMD, PreSeqImages, PostSeqImages, ParamStruct);

% Perform inter-dataset drift correction.
SMD = smi_core.DriftCorrection.driftCorrectBFInter(...
    SMD, RefImage, PreSeqImages, ParamStruct);


end

./MATLAB/+smi_core/@DriftCorrection/driftCorrectKNNInterPair.m
function [SMDout, Statistics] = driftCorrectKNNInterPair(obj, SMD1, SMD2)
%driftCorrectKNNInterPair calculates inter-dataset drift directly from X,Y{,Z}
% coordinates (i.e., constant shifts between datasets).  Fitting is done via
% performing fminsearch on the (weighted) sums of nearest neighbor distances.
% NOTE: SMD1 is considered fixed in space, while SMD2 is moving.  SMD1 and SMD2
% should have the same number of datasets and frames per dataset.
%
% Sign convention:
%
%    N = numel(SMD_drifted.X);
%    for k = 1:N
%       i = SMD_corrected.FrameNum(k);
%       j = SMD_corrected.DatasetNum(k);
%       SMD_corrected.X(k) = SMD_drifted.X(k) - SMD_corrected.DriftX(i, j);
%       SMD_corrected.Y(k) = SMD_drifted.Y(k) - SMD_corrected.DriftY(i, j);
%    end
%
% INPUTS:
%   SMD1, SMD2:    A structure with fields:
%      X              x coordinates (Nx1) where N is total number of points
%      Y              y coordinates (Nx1)
%      Z              z coordinates (Nx1) [OPTIONAL]
%                  Note: X and Y are typically in pixels, Z in um
%      DatasetNum     dataset number from which localization originates (Nx1)
%      FrameNum       frame   number from which localization originates (Nx1)
%      NDatasets      number of datasets
%      NFrames        number of frames in each dataset
%      DriftX         previously computed x drift (NFrames x NDatasets)
%      DriftY         previously computed y drift (NFrames x NDatasets)
%      DriftZ         previously computed z drift (NFrames x NDatasets)
%                     [OPTIONAL]
%   obj:           [class properties]
%                     optimization parameters with the following fields:
%      L_inter        inter-dataset threshold (Default = 2 pixels)
%      PixelSizeZUnit pixel size in um (units of Z; only needed for 3D)
%                     (Default = 0.1)
%      TolFun_inter   termination tolerance on the inter-dataset function value
%                     (Default = 1e-2)
%      TolX_inter     termination tolerance on the inter-dataset fitting
%                     polynomial (Default = 1e-4)
%      P0_inter       inter-dataset initialization
%                     (Default = [] for all zeros)
%      Verbose        verbosity level (Default = 1)
%
% OUTPUTS:
%   SMDout:      SMD data structure with updated fields:
%      X              drift corrected x coordinates (Nx1)
%      Y              drift corrected y coordinates (Nx1)
%      Z              drift corrected z coordinates (Nx1) [OPTIONAL]
%      DriftX         found x drift per frame (NFrames x NDatasets)
%      DriftY         found y drift per frame (NFrames x NDatasets)
%      DriftZ         found z drift per frame (NFrames x NDatasets) [OPTIONAL]
%   Statistics:  statistical information about the algorithm performance
%                including various input parameters above and ...:
%      NDatasets          internal number of datasets
%      NFrames            internal number of frames per dataset
%      Inter_iterations   inter-dataset number of fminsearch iterations
%      Inter_funcCount    inter-dataset number of fminsearch function evals
%      Inter_cost         inter-dataset cost at the found minimum (sumNND)
%      Inter_elapsedTime  inter-dataset elapsed time for drift correction
%
%   NOTE: SMD.DriftX/Y/Z are the drift corrections defined such that
%         drifted coordinates - drift correction = drift corrected coordinates
%
% CITATION:
%    "Robust, Fiducial-Free Drift Correction for Super-resolution Imaging"

% Created by
%    Modelz... Bewerdorf's group
%    Farzin Farzam  (Lidke Lab 2017) [original version of driftCorrect2D]
%    Michael J. Wester and Keith Lidke (Lidke Lab 2017-2019) [knnsearch]
%       (completely rewrote the code)

   if isfield(SMD1, 'Z') && numel(SMD1.Z) == numel(SMD1.X)
      Ndims = 3;
   else
      Ndims = 2;
   end

   DriftParams.L_inter        = obj.L_inter;
   DriftParams.PixelSizeZUnit = obj.PixelSizeZUnit;
   DriftParams.TolFun_inter   = obj.TolFun_inter;
   DriftParams.TolX_inter     = obj.TolX_inter;
   DriftParams.P0_inter       = obj.P0_inter;
   DriftParams.Verbose        = obj.Verbose;

   % Initialize various parameters.
   % PixelSizeZUnit is needed for 3D to convert Z into the same units as X
   % and Y.  PixelSizeZUnit is the X/Y pixel size in units of um.
   PixelSizeZUnit = DriftParams.PixelSizeZUnit;
   % L_inter is the inter-dataset threshold used in the cost function
   % computation to limit spurious nearest neighbor distances.  L_inter is
   % in units of pixels.
   L_inter = DriftParams.L_inter;
   TolFun_inter = DriftParams.TolFun_inter;
   TolX_inter   = DriftParams.TolX_inter;
   P0_inter     = DriftParams.P0_inter;
   Verbose      = DriftParams.Verbose;

   Statistics.Ndims          = Ndims;
   Statistics.PixelSizeZUnit = PixelSizeZUnit;
   Statistics.NDatasets      = SMD1.NDatasets;
   Statistics.NFrames        = SMD1.NFrames;
   Statistics.L_inter        = L_inter;
   Statistics.TolFun_inter   = TolFun_inter;
   Statistics.TolX_inter     = TolX_inter;

   % ---------- Intra-Dataset drift correction --------------------------------

   % ---------- Inter-Dataset drift correction --------------------------------

   %SMRS = obj.SMRS;
   % Sum image of SMD over all datasets in SMD.
   if Ndims == 2
      SMRS{1}.XY = [SMD1.X, SMD1.Y];
   else
      SMRS{1}.XY = [SMD1.X, SMD1.Y, SMD1.Z ./ PixelSizeZunit];
   end
   SMRS{1}.n  = size(SMRS{1}.XY, 1);
   % sum image of SMD2 over all datasets in SMD2.
   if Ndims == 2
      SMRS{2}.XY = [SMD2.X, SMD2.Y];
   else
      SMRS{2}.XY = [SMD2.X, SMD2.Y, SMD2.Z ./ PixelSizeZunit];
   end
   SMRS{2}.n  = size(SMRS{2}.XY, 1);
   DriftX = zeros(SMD1.NFrames, 1, 'single');
   DriftY = zeros(SMD1.NFrames, 1, 'single');
   if Ndims == 3
      DriftZ = zeros(SMD1.NFrames, 1);
   end

   tic;
   % These options will be used by fminsearch below.
   options = optimset('TolFun', TolFun_inter, 'TolX', TolX_inter);
   %options = optimset('TolFun', TolFun_inter, 'TolX', TolX_inter, ...
   %                  'PlotFcns', @optimplotfval);

   % Create a NeighborSearcher object for k-nearest neighbors search from the
   % first dataset.
   if SMRS{1}.n == 0
      % This whole procedure fails if the first dataset is empty!
      error(['First dataset is empty!  ', ...
             'Cannot perform inter-dataset drift correction.']);
   end
   NS = createns(SMRS{1}.XY);
   cost_inter = 0;
   % Count the number of iterations and function calls.
   it = 0;   fc = 0;
%  for i = 2:SMD1.NDatasets
      XY2 = SMRS{2}.XY;

      % Initialize the inter-dataset constant shift.  Note that we assume here
      % that the inter-dataset drift correction is constant.
      if isempty(P0_inter)
         P0_inter = zeros(1, Ndims);
      end
      P0 = double(P0_inter);
      if SMRS{2}.n <= 1
         XY2C = XY2;
         P = P0;
      else
         [P, ~, exitflag, output] = ...
            fminsearch(@smi_core.DriftCorrection.minD, ...
                       P0, options, XY2, [], Ndims, L_inter, NS);
         if exitflag ~= 1 && Verbose >= 1
            fprintf( ...
               'driftCorrectKNN fminsearch on minD_inter exitflag = %d\n', ...
                    exitflag);
         end
         it = it + output.iterations;
         fc = fc + output.funcCount;

         [cost_inter, XY2C] = ...
            smi_core.DriftCorrection.minD(P, XY2, [], Ndims, L_inter, NS);
      end

      % Values corrected for drift.
      SMRS{2}.XY = XY2C;

      % Update the drift correction.
      DriftX(:, 1) = DriftX(:, 1) + P(1);
      DriftY(:, 1) = DriftY(:, 1) + P(2);

      if Ndims == 3
%        SMD1.DriftZ(:, i) = SMD1.DriftZ(:, i) + P(3);
         DriftZ(:, 1) = DriftZ(:, 1) + P(3);
      end
%  end
   Statistics.Inter_iterations  = it;
   Statistics.Inter_funcCount   = fc;
   Statistics.Inter_cost        = cost_inter;
   Statistics.Inter_elapsedTime = toc;

   % --------------------------------------------------------------------------

   SMDout = SMD1;
   SMDout.DriftX = DriftX;
   SMDout.DriftY = DriftY;
   if Ndims == 3
      SMDout.DriftZ = DriftZ .* PixelSizeZUnit;
   end

   % No longer needed when sign in minD for X updates is reversed.
%  % Make sign of drift consistent with what was done before.
%  SMDout.DriftX = - SMDout.DriftX;
%  SMDout.DriftY = - SMDout.DriftY;
%  if Ndims == 3
%     SMDout.DriftZ = - SMDout.DriftZ .* PixelSizeZUnit;
%  end

   % Save the drift corrected coordinates in SMDout.
   XYout = cell(1, Ndims);
%  for i = 1:SMD1.NDatasets
      for j = 1:Ndims
         XYout{j} = [XYout{j}; SMRS{2}.XY(:, j)];
      end
%  end
   SMDout.X = XYout{1};
   SMDout.Y = XYout{2};
   if Ndims == 3
      SMDout.Z = XYout{3} .* PixelSizeZUnit;
   end

end

./MATLAB/+smi_core/@Threshold/unitTest.m
function success = unitTest()
    %  unitTest for setThreshFlag() in smi_core.Threshold class.
    %  A test image stack is generated using functions gaussBlobImage,
    %  data2Photons, findROI and gaussMLE from SMA_Sim class.
    %  The image stack is used to generate SMD structure, which forms the input
    %  for this unitTest. Additional fields are generated for SMD  and
    %  filled up with random numbers. MinMax structure is also provided as
    %  input to the unitTest. The SMD.ThreshFlag is generated by running
    %  setThreshFlag.
    %  The routine then runs through each field of SMD dataset to check
    %  if the flag value for the field at each localization is set correct.
    %
    %  OUTPUT: success (1 if passed; 0 if failed)

    %Created by
    %  Sandeep Pallikkuth, Lidkelab 2017
    % Revised Michael Wester 2020.
    %  ---------------------------------------------------------------------

    success=1;

    %SMD.NFiles=1; %Create a SMD structure
    PSFSigma=1;

    % Create default SMF structure.
    SMF = smi_core.SingleMoleculeFitting();

    %Data=SMA_Sim.gaussBlobImage();
    Data=smi_sim.GaussBlobs.genRandomBlobImage();

    %Data2Photons
    CameraType='EMCCD';
%   if strcmp(CameraType,'EMCCD')
%       CCDCalibration=struct('ROI',[],'OffsetImage',0,'GainImage',1,'ReadnoiseImage',[]);
%   elseif strcmp(CameraType,'SCMOS')
%       Y_start=897;
%       X_start=897;
%       Y_end=1152;
%       X_end=1152;
%       %CCDCalibration.ROI=[Y_start X_start Y_end X_end];
%       %CCDCalibration.OffsetImage=abs(single(normrnd(100,2,[Y_end-Y_start+1 X_end-X_start+1])));
%       %CCDCalibration.GainImage=abs(single(normrnd(2,0.05,[Y_end-Y_start+1 X_end-X_start+1])));
%       %CCDCalibration.ReadnoiseImage=abs(single(normrnd(50,40,[Y_end-Y_start+1 X_end-X_start+1])));
%   end
    if strcmp(CameraType,'EMCCD')
        RawDataROI=[];
        CameraOffset=0;
        CameraGain=1;
        CameraReadNoise=[];
    elseif strcmp(CameraType,'SCMOS')
        Y_start=897;
        X_start=897;
        Y_end=1152;
        X_end=1152;
        RawDataROI=[Y_start X_start Y_end X_end];
        CameraOffset=abs(single(normrnd(100,2,[Y_end-Y_start+1 X_end-X_start+1])));
        CameraGain=abs(single(normrnd(2,0.05,[Y_end-Y_start+1 X_end-X_start+1])));
        CameraReadNoise=abs(single(normrnd(50,40,[Y_end-Y_start+1 X_end-X_start+1])));
    end
    %[Data,CCDReadnoise]=SMA_Core.data2Photons(Data,CCDCalibration);
    [Data, CCDReadnoise] = smi_core.DataToPhotons.convertToPhotons(Data, ...
       CameraGain, CameraOffset, CameraReadNoise, RawDataROI);

    MinInt=1000/(4*pi*PSFSigma^2)/4;
    %[SMD,ROIStack]=SMA_Core.findROI(SMD,Data,PSFSigma,2*PSFSigma,PSFSigma*6,MinInt);
    SMF.BoxFinding.BoxSize    = 6*PSFSigma;
    SMF.BoxFinding.MinPhotons = MinInt;
    SMF.Fitting.PSFSigma      = PSFSigma;
    FindROI = smi_core.FindROI(SMF, Data);
    [ROIStack, SMD] = FindROI.findROI();

    %[SMD,Statistics]=SMA_Core.gaussMLE(ROIStack,'Basic','CCD',PSFSigma);
    SMF.Fitting.FitType  = 'XYNB';
    SMF.Fitting.PSFSigma = PSFSigma;
    GaussMLE = smi_core.GaussMLE(SMF, ROIStack);
    GaussMLE.CameraType = CameraType;
    [SMD, Statistics] = GaussMLE.gaussMLE(SMD);

    Threshold = smi_core.Threshold;
    FNames = Threshold.Fields;
    %FNames={'X';'Y';'Z';'Photons';'Bg';'PSFSigma';'PSFSigmaX';'PSFSigmaY';'X_SE';'Y_SE';'Z_SE';'Photons_SE';'Bg_SE';'PSFSigma_SE';'PSFSigmaX_SE';'PSFSigmaY_SE';'ZOffset';'DatasetNum';'FrameNum';'PValue';'LogLikelihood';'ConnectID'};
    SMDFN=fieldnames(SMD);
    for i=1:length(FNames)
        Check1=ismember(FNames(i),SMDFN);
        if Check1==0
            fn1=char(FNames(i));
            data=abs(randn(length(SMD.X),1));
            value1=data./max(data);
            SMD=setfield(SMD,fn1,value1);
        end
    end
    SMDFNames=fieldnames(SMD);
    MinMax.X=[];
    for i=1:length(SMDFNames)
        fn1=char(SMDFNames(i));
        MinMax=setfield(MinMax,fn1,[0.23 0.85]);
    end
    MinMax.X=[];
    MMFN=fieldnames(MinMax);
    for i=1:length(MMFN)
        Check2=ismember(MMFN(i),FNames);
        if Check2==0
            MinMax=rmfield(MinMax,MMFN(i));
        end
    end

    % ------ generating data done ---------

    fprintf('Running setThreshFlag with empty MinMax\n');
    MinMax1.X=MinMax.X;
    [SMD,TFlag]=Threshold.setThreshFlag(SMD, MinMax1);
    fprintf('Running setThreshFlag with nonempty MinMax\n');
    MinMax2=rmfield(MinMax,'X');
    MinMax2=rmfield(MinMax2,'Y');
    MinMax2=rmfield(MinMax2,'Z');
    [SMD,TFlag]=Threshold.setThreshFlag(SMD, MinMax2);
    MM2FN=fieldnames(MinMax2);
    NFields=length(MM2FN);
    FNThresh=getfield(SMD,'ThreshFlag');
    for nn=1:NFields
        FN1=getfield(MinMax2,MM2FN{nn});
        FN2=getfield(SMD,MM2FN{nn});
        for i=1:length(FN2)
            if (FN2(i)<FN1(1)||FN2(i)>FN1(2))>0
                binvar=fliplr(dec2bin(FNThresh(i),32));
                j=strmatch(MM2FN{nn},FNames,'exact');
                if binvar(j)==0
                    success=0;
                end
            end
        end
    end
end % unitTest

./MATLAB/+smi_core/@Threshold/applyThresh.m
function [SMR] = applyThresh(SMD, Verbose)
%   applyThresh applies ThreshFlag to perform thresholding on SMD,
%   where SMD can be any appropriate smite coordinate containing structure.
%
% INPUT:
%   SMD       smite coordinate containing structure
%   Verbose   [OPTIONAL, Default = 1] verbosity level
%
% OUTPUT:
%   SMR       updated object with ThreshFlag applied

%Created by
%   Michael J. Wester (2020) and Sandeep Pallikkuth, Lidke Lab, 2017.

   if ~exist('Verbose', 'var')
      Verbose = 1;
   end

   SMR = SMD;

   SMD_FNames = fieldnames(SMD);
   sizeX = size(SMD.X, 1);
   for nn = 1:length(SMD_FNames)
      fn = SMD.(SMD_FNames{nn});
      % Apply threshold to compatibly sized arrays ...
      if ~isempty(fn) && size(fn, 1) == sizeX
         SMR.(SMD_FNames{nn}) = ...
            SMD.(SMD_FNames{nn})([SMD.ThreshFlag] == 0);
      end
   end

   if Verbose >= 1
      fprintf('   Thresholding: %d -> %d localizations\n', ...
              sizeX, numel(SMR.X));
   end
   if Verbose >= 3
     THR = smi_core.Threshold;
     THR.rejectedLocalizations(SMD, '');
   end

end % applyThresh

./MATLAB/+smi_core/@Threshold/setThreshFlag.m
function [SMD, TFlag] = setThreshFlag(obj, SMD, MinMax)
% Creates ThreshFlag field for SMD, the same size as SMD.X .
% Values in the ThreshFlag are decimal equivalent of a 32 bit binary number.
% Each bit indicates whether the value for a field falls within the range
% provided by MinMax (success=0) or not (failure=1). A localization which
% succeeds to pass through all the threshold conditions will have a
% ThreshFlag value of '0'.  Note that if a field is not present in the MinMax
% structure, the corresponding bit in ThreshFlag will be set to '0'.
%
% Format for the bits (flags) in the binary number (starting from left) is:
%     bit 11   'LogL'
%     bit 10   'PValue'
%     bit  9   'Z_SE'
%     bit  8   'Y_SE'
%     bit  7   'X_SE'
%     bit  6   'PSFSigma'
%     bit  5   'Bg'
%     bit  4   'Photons'
%     bit  3   'Z'
%     bit  2   'Y'
%     bit  1   'X'
% x marks fields that do not seem to be used elsewhere.  Corresponding tests
% for these fields below has been removed in order to simplify the code.
%
% Example: Value of SMD.Threshflag '536' indicates a binary value of
% '00000000000000000000001000011000' (from dec2bin(536,32)) - showing the
% particular localisation failed the threshold conditions for fields
% 'Photons' (bit 4), 'Bg' (bit 5) and 'PValue' (bit 10).
%
% INPUTS:
%    SMD      with fields as defined (or a subset)
%    MinMax   structure with each field that reqires thresholding
%             (same or subset of fields in SMD)
%             format:[Minvalue Maxvalue] for each field
%             { E.g.: MinMax.Bg = [BgMin BgMax] }
%    NOTE: Only those fields provided and non-empty will be used in
%          thresholding.  The default is no thresholding.  See Fields for
%          possible thresholding fields.  Typical fields used are:
%             X, Y, Z, X_SE, Y_SE, Z_SE, Photons, Bg, PSFSigma, PValue
%
% OUTPUTS:
%    SMD      the same as input, but with the field 'ThreshFlag' added/appended
%    TFlag    a copy of the SMD.ThreshFlag
%
% REQUIRES:
%    Statistics Toolbox

%Created by
%   Sandeep Pallikkuth, Lidke Lab 2017
%Revised by Hanieh Mazloom-Farsibaf (Lidke Lab, 2018)
%Revised by Michael Wester, 2020

    if nargin<1
        error('Please input structure SMD\n')
    end

    % Checking MinMax has fields that are subset of those of SMD
    SMDFN=fieldnames(SMD);
    MMFN=fieldnames(MinMax);
    if isempty(SMDFN)>0
        error('SMD structure empty. Please add fields.\n');
    end
    if isempty(MMFN)>0
        error('MinMax structure empty. Please add fields to threshold.\n')
    end
    Check1=ismember(MMFN,obj.Fields);
    if any(Check1(:,:)==0)
        error('Fields in MinMax should be a subset of those in SMD');
    end

    % Case of no data!
    if length(SMD.X) == 0
       warning('No localizations!');
       TFlag = [];
       SMD.ThreshFlag=TFlag;
       return;
    end
     
    % checking if SMD.ThreshFlag exists
    if sum(strcmp(fieldnames(SMD), 'ThreshFlag')) == 1
        if isempty(SMD.ThreshFlag)
            TFlag(length(SMD.X),1)=uint32(0);
        else
            TFlag=SMD.ThreshFlag;
            % if ThreshFlag exists, then initialize the bits corresponding to
            % fields in MinMax to 0
            for i=1:length(MMFN)
                fn1=MMFN(i);
                xx=strmatch(fn1,obj.Fields,'exact');
                TFlag(:,:)=bitset(TFlag(:,:),xx,0);
            end
        end
    else
        TFlag(length(SMD.X),1)=uint32(0);
    end

    % checking for MinMax field values and assigning failure flags (value 1)
    % for corresponding SMD fields
    if sum(strcmp(fieldnames(MinMax), 'X')) == 1
        if ~isempty(MinMax.X)==1 && ~isempty(SMD.X)
            tflagX=SMD.X<MinMax.X(1)|SMD.X>MinMax.X(2)|~isreal(SMD.X)| isnan(SMD.X);
            k=find(tflagX); % find the position of failures in the array
            xx=strmatch('X',obj.Fields,'exact');
            TFlag(k)=bitset(TFlag(k),xx);
        end
    end
    if sum(strcmp(fieldnames(MinMax), 'Y')) == 1
        if ~isempty(MinMax.Y)==1 && ~isempty(SMD.Y)
            tflagY=SMD.Y<MinMax.Y(1)|SMD.Y>MinMax.Y(2)|~isreal(SMD.Y)|isnan(SMD.Y);
            k=find(tflagY); % find the position of failures in the array
            xx=strmatch('Y',obj.Fields,'exact');
            TFlag(k)=bitset(TFlag(k),xx);
        end
    end
    if sum(strcmp(fieldnames(MinMax), 'Z')) == 1
        if ~isempty(MinMax.Z)==1 && ~isempty(SMD.Z)
            tflagZ=SMD.Z<MinMax.Z(1)|SMD.Z>MinMax.Z(2)|~isreal(SMD.Z)|isnan(SMD.Z);
            k=find(tflagZ); % find the position of failures in the array
            xx=strmatch('Z',obj.Fields,'exact');
            TFlag(k)=bitset(TFlag(k),xx);
        end
    end
    if sum(strcmp(fieldnames(MinMax), 'Photons')) == 1
        if ~isempty(MinMax.Photons)==1 && ~isempty(SMD.Photons)
            tflagI=SMD.Photons<MinMax.Photons(1)|SMD.Photons>MinMax.Photons(2)...
                |~isreal(SMD.Photons)|isnan(SMD.Photons);
            k=find(tflagI); % find the position of failures in the array
            xx=strmatch('Photons',obj.Fields,'exact');
            TFlag(k)=bitset(TFlag(k),xx);
        end
    end
    if sum(strcmp(fieldnames(MinMax), 'Bg')) == 1
        if ~isempty(MinMax.Bg)==1 && ~isempty(SMD.Bg)
            tflagBg=SMD.Bg<MinMax.Bg(1)|SMD.Bg>MinMax.Bg(2)|~isreal(SMD.Bg)...
                |isnan(SMD.Bg);
            k=find(tflagBg); % find the position of failures in the array
            xx=strmatch('Bg',obj.Fields,'exact');
            TFlag(k)=bitset(TFlag(k),xx);
        end
    end
    if sum(strcmp(fieldnames(MinMax), 'PSFSigma')) == 1
        if ~isempty(MinMax.PSFSigma)==1 && ~isempty(SMD.PSFSigma)
            tflagPSFSigma=SMD.PSFSigma<MinMax.PSFSigma(1)|...
                SMD.PSFSigma>MinMax.PSFSigma(2)|~isreal(SMD.PSFSigma)...
                |isnan(SMD.PSFSigma);
            k=find(tflagPSFSigma); % find the position of failures in the array
            xx=strmatch('PSFSigma',obj.Fields,'exact');
            TFlag(k)=bitset(TFlag(k),xx);
        end
    end
    if sum(strcmp(fieldnames(MinMax), 'X_SE')) == 1
        if ~isempty(MinMax.X_SE)==1 && ~isempty(SMD.X_SE)
            tflagXSE=SMD.X_SE<MinMax.X_SE(1)|SMD.X_SE>MinMax.X_SE(2)|...
                SMD.X_SE~=real(SMD.X_SE)|isnan(SMD.X_SE);

            k=find(tflagXSE); % find the position of failures in the array
            xx=strmatch('X_SE',obj.Fields,'exact');
            TFlag(k)=bitset(TFlag(k),xx);
        end
    end
    if sum(strcmp(fieldnames(MinMax), 'Y_SE')) == 1
        if ~isempty(MinMax.Y_SE)==1 && ~isempty(SMD.Y_SE)
            tflagYSE=SMD.Y_SE<MinMax.Y_SE(1)|SMD.Y_SE>MinMax.Y_SE(2)|...
                SMD.Y_SE~=real(SMD.Y_SE)|isnan(SMD.Y_SE);
            k=find(tflagYSE); % find the position of failures in the array
            xx=strmatch('Y_SE',obj.Fields,'exact');
            TFlag(k)=bitset(TFlag(k),xx);
        end
    end
    if sum(strcmp(fieldnames(MinMax), 'Z_SE')) == 1
        if ~isempty(MinMax.Z_SE)==1 && ~isempty(SMD.Z_SE)
            tflagZSE=SMD.Z_SE<MinMax.Z_SE(1)|SMD.Z_SE>MinMax.Z_SE(2)|...
                SMD.Z_SE~=real(SMD.Z_SE)|isnan(SMD.Z_SE);
            k=find(tflagZSE); % find the position of failures in the array
            xx=strmatch('Z_SE',obj.Fields,'exact');
            TFlag(k)=bitset(TFlag(k),xx);
        end
    end
    if sum(strcmp(fieldnames(MinMax), 'PValue')) == 1
        if ~isempty(MinMax.PValue)==1 && ~isempty(SMD.PValue)
            tflagPValue=SMD.PValue<MinMax.PValue(1)|...
                SMD.PValue>MinMax.PValue(2)|~isreal(SMD.PValue)...
                |isnan(SMD.PValue);
            k=find(tflagPValue); % find the position of failures in the array
            xx=strmatch('PValue',obj.Fields,'exact');
            TFlag(k)=bitset(TFlag(k),xx);
        end
    end
    if sum(strcmp(fieldnames(MinMax), 'LogLikelihood')) == 1
        if ~isempty(MinMax.LogLikelihood)==1 && ~isempty(SMD.LogLikelihood)
            tflagLogL=SMD.LogLikelihood<MinMax.LogLikelihood(1)|...
                SMD.LogLikelihood>MinMax.LogLikelihood(2)|~isreal(SMD.LogLikelihood)...
                |isnan(SMD.LogLikelihood);
            k=find(tflagLogL); % find the position of failures in the array
            xx=strmatch('LogLikelihood',obj.Fields,'exact');
            TFlag(k)=bitset(TFlag(k),xx);
        end
    end

    % adding/appending ThresholdFlag field of SMD
    SMD.ThreshFlag=TFlag;

end % setThreshFlag

./MATLAB/+smi_core/@Threshold/translateThreshFlagNS.m
function [ThreshFlagReadable, HotBits] = ...
    translateThreshFlagNS(obj, ThreshFlag)
%translateThreshFlagNS translates ThreshFlag to a human readable string.
% This method will take the numeric array ThreshFlag (decimal integers) and
% output the human-readable threshold identifier given by the mapping in
% setThreshFlag().  The 'NS' suffix stands for non-static, as this is the
% non-static version of this method (there is a static version
% translateThreshFlag() which itself calls this method).
%
% NOTE: This method assumes that ThreshFlag is 32 bits, i.e.,
%       max possible ThreshFlag = 2^32 - 1, but it does not directly
%       attempt to typecast/validate the input type of ThreshFlag.
%
% EXAMPLE:
%   Given an SMD structure with SMD.ThreshFlag populated, this method can
%   be used as
%   ThreshFlagReadable = ...
%      smi_core.Threshold.translateThreshFlag(SMD.ThreshFlag);
%
% INPUTS:
%   ThreshFlag: Array containing the decimal integer threshold flags as
%               described in setThreshFlag().
%               (unsigned integer, up to uint32 array)
%
% OUTPUTS:
%   ThreshFlagReadable: Cell array containing the translated
%                       (human-readable) identifier corresponding to
%                       ThreshFlag.  There is a direct mapping between the
%                       index of ThreshFlag and ThreshFlagReadable, i.e.
%                       ThreshFlagReadable{ii} <-> ThreshFlag(ii)
%                       (numel(ThreshFlag) x 1 cell array of strings)
%   HotBits: Cell array containing the "hot" bits corresponding to each
%            ThreshFlag (e.g., instead of the string "PValue", HotBits
%            would have the integer 20, corresponding to bit 20 being hot).
%            (numel(ThreshFlag) x 1 cell array of uint64)
%
% REQUIRES:
%   MATLAB R2016b to use the datatype 'string'

% Created by:
%   David James Schodt (Lidkelab, 2020)

% Define some parameters and initialize/pre-allocate arrays as needed.
NFlags = numel(ThreshFlag);
ThreshFlagReadable = cell(NFlags, 1);
HotBits = ThreshFlagReadable; % initialize
NBits = 32; % defined to emphasize this assumption

% Define our bit-to-string map such that ThreshFlagMap(bb) <-> threshold
% flag string for bit bb (note that this method will use the uncommon
% convention that bits start at 1, as is used in setThreshFlag()).
ThreshFlagMap = repelem("Unknown flag", NBits);
ThreshFlagFields = convertCharsToStrings(obj.Fields).';
ThreshFlagMap(1:numel(ThreshFlagFields)) = ThreshFlagFields;

% Loop through the input elements of ThreshFlag and translate.
for ii = 1:NFlags
    % Determine which bits of ThreshFlag(ii) are "hot", i.e., set to 1.
    HotBitBool = logical(bitget(ThreshFlag(ii), 1:NBits));
    HotBits{ii} = uint32(find(HotBitBool));

    % Populate the ii-th element of the ThreshFlagReadable array.
    ThreshFlagReadable{ii} = ThreshFlagMap(HotBitBool);
end

end % translateThreshFlagNS

./MATLAB/+smi_core/@Threshold/README.md
### +smi_core/@Threshold

Threshold localizations based on various properties of the localizations.
This is done by creating a *ThreshFlag* field for the SMD structure using the
method **setThreshFlag** and the bounds in the SMF.MinMax (only those bounds
defined will be applied).  **applyThresh** then applies the *ThreshFlag* to the
localizations.  **rejectedLocalizations** will visually display what
localizations were eliminated and for what reasons.  **translateThreshFlag**
can also be used to produce human readable interpretations of the
**ThreshFlag**.

---

methods:
- **[applyThresh](applyThresh.m)**:
  applies ThreshFlag to perform thresholding on SMD,
  where SMD can be any appropriate smite coordinate containing structure.
- **[rejectedLocalizations](rejectedLocalizations.m)**:
  Produce plots of accepted and rejected localization fits,
  individually by reason rejected and combined by number of reasons rejected
  or by major reason rejected
- **[setMinMax](setMinMax.m)**:
  creates the MinMax structure used throughout the Threshold class
  from a provided SMF structure.  The MinMax fields contain a minimum and a
  maximum value on which to threshold
- **[setThreshFlag](setThreshFlag.m)**:
  Creates ThreshFlag field for SMD, the same size as SMD.X
- **[translateThreshFlag](translateThreshFlag.m)**:
  is a static "wrapper" for translateThreshFlagNS
- **[translateThreshFlagNS](translateThreshFlagNS.m)**:
  translates ThreshFlag to a human readable string
- **[unitTest](unitTest.m)**:
  unitTest for setThreshFlag() in smi_core.Threshold class

./MATLAB/+smi_core/@Threshold/setMinMax.m
function MinMax = setMinMax(SMF)
%setMinMax creates the MinMax structure used throughout the Threshold class
% from a provided SMF structure.  The MinMax fields contain a minimum and a
% maximum value on which to threshold.
%
% INPUT:
%    SMF      Single Molecule Fitting structure
%
% OUTPUT:
%    MinMax   structure containing fields on which to threshold

% Created by
%    Michael J. Wester (2021, Lidke lab)

   MinMax = [];
   MinMax.Photons  = [SMF.Thresholding.MinPhotons, inf];
   MinMax.Bg       = [0, SMF.Thresholding.MaxBg];
   MinMax.PSFSigma = [SMF.Thresholding.MinPSFSigma, ...
       SMF.Thresholding.MaxPSFSigma];
   MinMax.X_SE     = [0, SMF.Thresholding.MaxXY_SE];
   MinMax.Y_SE     = [0, SMF.Thresholding.MaxXY_SE];
   MinMax.Z_SE     = [0, SMF.Thresholding.MaxZ_SE];
   MinMax.PValue   = [SMF.Thresholding.MinPValue, 1];
   MinMax.LogLikelihood = [-inf, inf];

end

./MATLAB/+smi_core/@Threshold/Threshold.m
classdef Threshold < handle

% Threshold localizations based on various properties of the localizations.
% This is done by creating a ThreshFlag field for the SMD structure using the
% method setThreshFlag and the bounds in the SMF.MinMax (only those bounds
% defined will be applied).  applyThresh then applies the ThreshFlag to the
% localizations.  rejectedLocalizations will visually display what
% localizations were eliminated and for what reasons.  translateThreshFlag can
% also be used to produce human readable interpretations of the ThreshFlag.

% =============================================================================
properties

%   % MinMax - structure with each field that reqires thresholding
%   %          (same or subset of fields in SMD)
%   %          format:[Minvalue Maxvalue] for each field
%   %          { E.g.: MinMax.Bg = [BgMin BgMax] }
%   % NOTE: Only those fields provided will be used in thresholding.  The
%   %       default is no thresholding.  See Fields for possible thresholding
%   %       fields.  Typical fields used are:
%   %          X, Y, Z, X_SE, Y_SE, Z_SE, Photons, Bg, PSFSigma, PValue
%   MinMax=[]
    Verbose = 1;   % verbosity level

end % properties
% =============================================================================

% =============================================================================
properties(Constant = true)

   % Defining the possible fields for SMD thresholding.
   Fields={'X';'Y';'Z';'Photons';'Bg';'PSFSigma';'X_SE';'Y_SE';'Z_SE';'PValue';'LogLikelihood'};
   %Fields={'X';'Y';'Z';'Photons';'Bg';'PSFSigma';'PSFSigmaX';'PSFSigmaY';   ...
   %        'X_SE';'Y_SE';'Z_SE';'Photons_SE';'Bg_SE';'PSFSigma_SE';         ...
   %        'PSFSigmaX_SE';'PSFSigmaY_SE';'ZOffset';'DatasetNum';'FrameNum'; ...
   %        'PValue';'LogLikelihood';'ConnectID'};

end % properties(Constant = true)
% =============================================================================

% =============================================================================
methods

   rejectedLocalizations(obj, SMD, options, SaveDir)
   [SMD, TFlag] = setThreshFlag(obj, SMD, MinMax)
   [ThreshFlagReadable, HotBits] = translateThreshFlagNS(obj, ThreshFlag)

end % methods
% =============================================================================

% =============================================================================
methods(Static)

   [SMR] = applyThresh(SMD, Verbose)
   MinMax = setMinMax(SMF)
   [ThreshFlagReadable, HotBits] = translateThreshFlag(ThreshFlag);
   success = unitTest()

end % methods(Static)
% =============================================================================

end % classdef Threshold

./MATLAB/+smi_core/@Threshold/rejectedLocalizations.m
function rejectedLocalizations(obj, SMD, options, SaveDir)
% Produce plots of accepted and rejected localization fits,
% individually by reason rejected and combined by number of reasons rejected
% or by major reason rejected.
%
% INPUT:
%    SMD       SMD (Single Molecule Data) structure.  Fields required:
%          X, Y         x and y coordinates of fitted localizations
%          ThreshFlag   thresholding flag.  Accepted fits have flag = 0, while
%                       rejected fits have a nonzero flag, the value indicating
%                       the reason for rejection.  See setThreshFlag for
%                       further details.
%    options   [OPTIONAL] string indicating which plots to produce or all if
%                         omitted:
%              'R'  rejected due to individual reasons (X,Y,Z; Photons; ...
%              'N'  rejected for the indicated number of reasons
%              'M'  rejected for the indicated major reasons
%    SaveDir   [OPTIONAL] directory in which to save plots produced

%Created by
%    Michael Wester (Lidkelab 2020)

   if ~exist('options', 'var')
      options = 'RNM';
   end
   Rplot = contains(options, 'R');

   if ~exist('SaveDir', 'var')
       SaveDir = [];
   end

   fprintf('Fits = %d\n', numel(SMD.X));
   fprintf('Accepted = %d\n', sum(SMD.ThreshFlag == 0));

   % Threshold Flag for the fields or groups of fields named below.
   TF = false(numel(SMD.X), numel(obj.Fields) - 2 - 2);

   % field_bits are the bit numbers corresponding to Fields (above) for the
   % given named fields.

   % Rejection due to X, Y, Z
   field_bits = [strmatch('X', obj.Fields, 'exact'), ...
                 strmatch('Y', obj.Fields, 'exact'), ...
                 strmatch('Z', obj.Fields, 'exact')];
   TF(:, 1) = rejected2DPlot(SMD, field_bits, Rplot, SaveDir, 'X,Y,Z');

   % Rejection due to Photons
   field_bits = strmatch('Photons', obj.Fields, 'exact');
   TF(:, 2) = rejected2DPlot(SMD, field_bits, Rplot, SaveDir, 'Photons');

   % Rejection due to Bg
   field_bits = strmatch('Bg', obj.Fields, 'exact');
   TF(:, 3) = rejected2DPlot(SMD, field_bits, Rplot, SaveDir, 'Bg');

   % Rejection due to PSFSigma
   field_bits = strmatch('PSFSigma',  obj.Fields, 'exact');
   TF(:, 4) = rejected2DPlot(SMD, field_bits, Rplot, SaveDir, ...
                                                     'PSFSigma{,X,Y}');

   % Rejection due to {X,Y,Z}_SE
   field_bits = [strmatch('X_SE', obj.Fields, 'exact'), ...
                 strmatch('Y_SE', obj.Fields, 'exact'), ...
                 strmatch('Z_SE', obj.Fields, 'exact')];
   TF(:, 5) = rejected2DPlot(SMD, field_bits, Rplot, SaveDir, '{X,Y,Z}_SE');

   % Rejection due to PValue
   field_bits = strmatch('PValue', obj.Fields, 'exact');
   TF(:, 6) = rejected2DPlot(SMD, field_bits, Rplot, SaveDir, 'PValue');

   % Combined plot for number of reasons a fit was rejected.
   color = ['b', 'c', 'g', 'y', 'm', 'r'];
   n_colors = numel(color);

   n_reasons = 6;

   fprintf('\n');
   STF = sum(TF, 2);
   if contains(options, 'N')
      figure;
      hold on
      k = 0;
      indx = ~STF;
      % Only include legend entries if the indexing array (indx) has some
      % nonzero entries [tested with sum(indx)].
      if sum(indx) > 0
         fprintf('Accepted = %d\n', sum(indx));
         plot(SMD.X(indx), SMD.Y(indx), 'k.');
         k = k + 1;
         lgd{k} = 'accepted';
      end
      fprintf('Rejected = %d\n', sum(~indx));
      for i = 1 : n_colors - 1
         indx = STF == i;
         if sum(indx) > 0
            fprintf('Rejected for %d reason(s) = %d\n', i, sum(indx));
            plot(SMD.X(indx), SMD.Y(indx), [color(i), '.']);
            k = k + 1;
            lgd{k} = sprintf('%d', i);
         end
      end
      indx = STF >= n_colors;
      if sum(indx) > 0
         fprintf('Rejected for %d+ reasons = %d\n', n_colors, sum(indx));
         plot(SMD.X(indx), SMD.Y(indx), [color(n_colors), '.']);
         k = k + 1;
         lgd{k} = sprintf('%d+', n_colors);
      end
      xlabel('x (pixels)');
      ylabel('y (pixels)');
      reason = 'NumberReasons';
      title(sprintf('Rejected: %s', reason));
      legend(lgd, 'Location', 'Best');
      hold off
      clear lgd
      if ~isempty(SaveDir)
         saveas(gcf, fullfile(SaveDir, reason), 'png');
      end
   end

   if contains(options, 'M')
      % Combined plot for major reasons a fit was rejected.
      figure;
      hold on
      color = [color(n_colors), color(1 : n_colors - 1)];
      k = 0;
      indx = ~STF;
      if sum(indx) > 0
         plot(SMD.X(indx), SMD.Y(indx), 'k.');
         k = k + 1;
         lgd{k} = 'accepted';
      end
      for i = 1 : n_colors
         switch i
         case 1
            indices = [];
            lgd_text = 'multiple';
         case 2
            indices = [1, 5];
            lgd_text = 'X,Y,Z/\_SE';
         case 3
            indices = 2;
            lgd_text = 'Photons';
         case 4
            indices = 3;
            lgd_text = 'Bg';
         case 5
            indices = 4;
            lgd_text = 'PSFSigma';
         case 6
            indices = 6;
            lgd_text = 'PValue';
         %case 7
         %   indices = [3, 7, 9, 10, 12, 13];
         %   lgd_text = 'otherwise';
         end
         % Rejected if any of the specified bits is nonzero for a single
         % (combined) reason or for multiple reasons (STF > 1).  This is not
         % quite consistent as a combined reason may be taken as a multiple
         % reason in some situations, so plot multiple reasons first and let
         % combined reasons overwrite.  Of course, this may completely wipe out
         % multiple reasons while still leaving an entry in the legend.
         if i == 1
            indx = STF > 1;
         else
            indx =  any(TF(:, indices), 2) & ...
                   ~any(TF(:, setdiff(1:n_reasons, indices)), 2);
         end
         if sum(indx > 0)
            plot(SMD.X(indx), SMD.Y(indx), [color(i), '.']);
            k = k + 1;
            lgd{k} = lgd_text;
         end
      end
      xlabel('x (pixels)');
      ylabel('y (pixels)');
      reason = 'MajorReasons';
      title(sprintf('Rejected: %s', reason));
      legend(lgd, 'Location', 'Best');
      hold off
      if ~isempty(SaveDir)
         saveas(gcf, fullfile(SaveDir, reason), 'png');
      end
   end

end % rejectedLocalizations

% -----------------------------------------------------------------------------

function TF = rejected2DPlot(SMD, field_bits, Rplot, SaveDir, reason)
% Make an accept/reject plot for a particular specified reason,
% but only if the number of rejections is nonzero.
%
% INPUT:
%    SMD          SMD (Single Molecule Data) structure.  Fields required:
%          X, Y         x and y coordinates of fitted localizations
%          ThreshFlag   thresholding flag.  Accepted fits have flag = 0, while
%                       rejected fits have a nonzero flag, the value indicating
%                       the reason for rejection.  See setThreshFlag for
%                       further details.
%    field_bits   bit numbers corresponding to combined fields
%    Rplot        if true, produce a plot
%    SaveDir      directory in which to save the plot produced
%    reason       string describing the reason that the fits were rejected for
%                 the given set of field_bits
%
% OUTPUT:
%    TF           combined threshold flag for the set of field_bits.  For
%                 example, if field_bits = [1, 2, 3], corresponding, in turn,
%                 to rejection by X, Y and Z , then TF will be fits
%                 rejected due to the combination of X, Y _or_ Z.

   TFs = arrayfun(@(i) bitget(SMD.ThreshFlag, i), field_bits, ...
                  'UniformOutput', false);
   TF = logical(TFs{1});
   for i = 2 : numel(field_bits)
      TF = TF | TFs{i};
   end

   STF = sum(TF);
   if STF > 0
      fprintf('Rejected due to %s = %d\n', reason, STF);

      if Rplot
         figure;
         hold on
         k = 0;
         if sum(~TF) > 0
            plot(SMD.X(~TF), SMD.Y(~TF), 'k.');
            k = k + 1;
            lgd{k} = 'accepted';
         end
         plot(SMD.X(TF), SMD.Y(TF), 'r.');
         k = k + 1;
         lgd{k} = 'rejected';
         legend(lgd, 'Location', 'Best');
         xlabel('x (pixels)');
         ylabel('y (pixels)');
         treason = regexprep(reason, '([{}_])', '\\$1');
         title(sprintf('Rejected: %s', treason));
         hold off

         if ~isempty(SaveDir)
            saveas(gcf, fullfile(SaveDir, reason), 'png');
         end
      end
   end

end % rejected2DPlot

./MATLAB/+smi_core/@Threshold/translateThreshFlag.m
function [ThreshFlagReadable, HotBits] = translateThreshFlag(ThreshFlag)
%translateThreshFlag is a static "wrapper" for translateThreshFlagNS
% This method is a "wrapper" for the method
% smi_core.Threshold.translateThreshFlagNS(). The purpose of this static
% method is to be a more user-friendly version of the non-static method
% translateThreshFlagNS(). This method will create an instance of the
% Threshold class solely for the purpose of calling
% translateThreshFlagNS().
%
% NOTE: This method assumes that ThreshFlag is 32 bits, i.e.,
%       max possible ThreshFlag = 2^32 - 1, but it does not directly
%       attempt to typecast/validate the input type of ThreshFlag.
%
% EXAMPLE:
%   Given an SMD structure with SMD.ThreshFlag populated, this method can
%   be used as
%   ThreshFlagReadable = smi_core.Threshold.translateThreshFlag(...
%       SMD.ThreshFlag);
%
% INPUTS:
%   ThreshFlag: Array containing the decimal integer threshold flags as
%               described in setThreshFlag().
%               (unsigned integer, up to uint32 array)
%
% OUTPUTS:
%   ThreshFlagReadable: Cell array containing the translated
%                       (human-readable) identifier corresponding to
%                       ThreshFlag.  There is a direct mapping between the
%                       index of ThreshFlag and ThreshFlagReadable, i.e.
%                       ThreshFlagReadable{ii} <-> ThreshFlag(ii)
%                       (numel(ThreshFlag) x 1 cell array of strings)
%   HotBits: Cell array containing the "hot" bits corresponding to each
%            ThreshFlag (e.g., instead of the string "PValue", HotBits
%            would have the integer 20, corresponding to bit 20 being hot).
%            (numel(ThreshFlag) x 1 cell array of uint64)
%
% REQUIRES:
%   MATLAB R2016b to use the datatype 'string'

% Created by:
%   David James Schodt (Lidkelab, 2020)


% Create an instance of the smi_core.Threshold class.
Threshold = smi_core.Threshold();

% Call the non-static class method translateThreshFlagNS().
[ThreshFlagReadable, HotBits] = ...
    Threshold.translateThreshFlagNS(ThreshFlag);


end % translateThreshFlag
./MATLAB/+smi_core/README_GaussMLE.md
### [+smi_core/GaussMLE.m](GaussMLE.m)

GaussMLE: Maximum Likelihood Estimate of 2D Gaussian blob parameters

GaussMLE fits a 2D Gaussian blob model to the each image in a stack of 2D
images.  Several fit types are available. The MLE is maximized with an
iterative Newton-Raphson method and implemented on GPU using NVIDIA
CUDA as described by Smith et al.

The input is assumed to be gain and offset corrected so that
pixel values indicate effective photon counts. Noise model is 'Poisson',
which is suitable for EMCCD cameras used at high gain, or 'SCMOS' which
includes a pixel-wise readnoise as described by Huang et al.

REQUIRES:
- MATLAB 2014a or later versions
- Parallel Procesing Toolbox
- NVidia GPU
- smi_cuda_FindROI.ptx
- smi_cuda_FindROI.cu

CITATION:
- Smith, C., Joseph, N., Rieger, B. et al.
  Fast, single-molecule localization that achieves theoretically minimum
  uncertainty. Nat Methods 7, 373375 (2010).
  https://doi.org/10.1038/nmeth.1449

- Huang, F., Hartwich, T., Rivera-Molina, F. et al. Video-rate nanoscopy
  using sCMOS cameraspecific single-molecule localization algorithms.
  Nat Methods 10, 653658 (2013).
  https://doi.org/10.1038/nmeth.2488

./MATLAB/+smi_core/@FRC/unitTest.m
function success = unitTest()
% Test Fourier Ring Correlation (FRC) interface functions and provide examples
% of usage.
%
% REQUIRES:
%    DIPlib Image Resolution add-on
%    Curve Fitting Toolbox (needed by qCorrectLocs)
%    Parallel Processing Toolbox
%    NVidia GPU
%
% CITATION:
%    http://www.diplib.org/add-ons
%    Image Resolution, Reference: R.P.J. Nieuwenhuizen, K.A. Lidke, M. Bates,
%    D. Leyton Puig, D. Grnwald, S. Stallinga, B. Rieger, Measuring Image
%    Resolution in Optical Nanoscopy, Nature Methods, 10(6):557-562, 2013.
% NOTE:
%    Install the Image Resolution software at the same level as sma-core-alpha.
%    This software is located at the URL above (see CITATION).  In startup.m,
%    add a path to
%       .../FRCresolution_software/matlabdistribution/FRCresolutionfunctions
%    where often ... = /Documents/MATLAB.  In the FRCresolutionfunctions, copy
%    smooth.m from the MATLAB Curve Fitting Toolbox into cfsmooth.m .  For
%    example, look in
%       MATLAB_DISTRIBUTION/toolbox/curvefit/curvefit/smooth.m
%    This is needed because DIPimage also has a smooth function which will
%    typically shadow MATLAB's smooth.

   success = 0;

   SaveDir = smi_helpers.mkSMITETmpDir('unitTest', 'FRC');

   PixelSize = 100;   % nm
   SRZoom = 10;

   % Generate localizations and put them into an SMD structure.
   SIM = smi_sim.SimSMLM();
   SIM.SZ = 64;
   SIM.Rho = 50;
   SIM.NDatasets = 1;
   SIM.NFrames = 1000;
   SIM.simStar(16);
   SMD = SIM.SMD_Model;

   n_particles = numel(SMD.X);
   SMD.X_SE = (PixelSize/1000)*ones(n_particles, 1);
   SMD.Y_SE = (PixelSize/1000)*ones(n_particles, 1);

   %% ---------- uncorrected resolution calculation

   FRCc = smi_core.FRC();   % FRC class
   FRCc.PixelSize = PixelSize;
   FRCc.SRImageZoom = SRZoom;

   [res, ~, resH, resL] = FRCc.posToResolution(SMD);

   fprintf('resolution = %2.1f +- %2.2f [px]\n', ...
           res / SRZoom, (resL / SRZoom - resH / SRZoom)/2);
   fprintf('resolution = %2.1f +- %2.2f [nm]\n', ...
           res * PixelSize/SRZoom, (resL - resH)/2 * PixelSize/SRZoom);

   %% ---------- compute uncorrected FRC curve

   frc_curve = FRCc.posToFRC(SMD);
   [~, frc_curveA] = FRCc.posToResolution(SMD);

   figure();
   hold on
   qmax = 0.5 / (PixelSize/SRZoom);
   plot(linspace(0, qmax*sqrt(2), numel(frc_curve)), frc_curve,  'b-');
   plot(linspace(0, qmax*sqrt(2), numel(frc_curve)), frc_curveA, 'g-');
   xlim([0, qmax]);
   plot([0, qmax], [1/7, 1/7], 'r-');
   plot([0, qmax], [0, 0], 'k--');
   xlabel('spatial frequency (nm^{-1})');
   ylabel('FRC');
   title('Fourier Ring Correlation curve');
   legend({'posToFRC', 'posToResolution'}, 'Location', 'NorthEast');
   hold off
   saveas(gcf, fullfile(SaveDir, 'FRCcurve.png'));

   %% ---------- compute uncorrected and corrected FRC curves and resolutions
   % Correction removes spurious correlations and is the recommended method to
   % use for typical applications.

   try
   [res_corr, res_uncorr, Q, frc_curve_corr, frc_curve_uncorr] = ...
      FRCc.qCorrectionLocs(SMD);

   res1 = frctoresolution(frc_curve_uncorr, SMD.YSize*SRZoom);
   res2 = frctoresolution(frc_curve_corr,   SMD.YSize*SRZoom);
   fprintf('resolution = %2.1f, corrected = %2.1f [px], Q = %f\n', ...
           res_uncorr / SRZoom, res_corr / SRZoom, Q);
   fprintf('resolution = %2.1f, corrected = %2.1f [nm], Q = %f\n', ...
           res_uncorr * PixelSize/SRZoom, res_corr * PixelSize/SRZoom, Q);
   fprintf('frctoresolution = %2.1f, corrected = %2.1f [px]\n', res1, res2);

   figure();
   hold on
   qmax = 0.5 / (PixelSize/SRZoom);
   plot(linspace(0, qmax*sqrt(2), numel(frc_curve_corr)),   ...
        frc_curve_corr, 'b-');
   plot(linspace(0, qmax*sqrt(2), numel(frc_curve_uncorr)), ...
        frc_curve_uncorr, 'g-');
   xlim([0, qmax]);
   plot([0, qmax], [1/7, 1/7], 'r-');
   plot([0, qmax], [0, 0], 'k--');
   xlabel('spatial frequency (nm^{-1})');
   ylabel('FRC');
   title('Corrected Fourier Ring Correlation curve');
   legend({'corrected', 'uncorrected'}, 'Location', 'NorthEast');
   hold off
   saveas(gcf, fullfile(SaveDir, 'correctedFRCcurve.png'));
   end

   success = 1;

end

./MATLAB/+smi_core/@FRC/FRC.m
classdef FRC < handle

% Fourier Ring Correlation (FRC) class for computing average image resolution.
% FRC is a measure of the average resolution over a super-resolution image.  It
% works by dividing the set of single-emitter localizations in the
% super-resolution image into two statistically independent subsets.  The
% Fourier transforms of subimages generated from each of these subsets are then
% statistically correlated over pixels on the perimeters of circles of constant
% spatial frequency.  The image resolution is defined as the inverse of the
% spatial frequency when the FRC curve drops below a threshold, taken to be
% 1/7 in the citation below.  Spurious correlations (for example, due to
% repeated photoactivation of the same emitter) are removed by estimating the
% number of times an emitter is localized on average (Q) assuming Poisson
% statistics.
%
% REQUIRES:
%    DIPlib Image Resolution add-on
%    Curve Fitting Toolbox (needed by qCorrectLocs)
%    Parallel Processing Toolbox
%    NVidia GPU
%
% CITATION:
%    http://www.diplib.org/add-ons
%    Image Resolution, Reference: R.P.J. Nieuwenhuizen, K.A. Lidke, M. Bates,
%    D. Leyton Puig, D. Grnwald, S. Stallinga, B. Rieger, Measuring Image
%    Resolution in Optical Nanoscopy, Nature Methods, 10(6):557-562, 2013.
% NOTE:
%    Install the Image Resolution software at the same level as smite.
%    This software is located at the URL above (see CITATION).  In startup.m,
%    add a path to
%       .../FRCresolution_software/matlabdistribution/FRCresolutionfunctions
%    where often ... = /Documents/MATLAB.  In the FRCresolutionfunctions, copy
%    smooth.m from the MATLAB Curve Fitting Toolbox into cfsmooth.m .  For
%    example, look in
%       MATLAB_DISTRIBUTION/toolbox/curvefit/curvefit/smooth.m
%    This is needed because DIPimage also has a smooth function which will
%    typically shadow MATLAB's smooth. 

% =============================================================================
properties

   PixelSize   = 100;   % nm per pixel
   SRImageZoom = 10;    % image magnification factor
   Repeats     = 1;     % number of times FRC curve is computed for averaging

end % properties
% =============================================================================

% =============================================================================
methods

   frc_curve = posToFRC(obj, SMR)
   [resolution, frc_curve, resolution_hi, resolution_lo, resolution_t] = ...
      posToResolution(obj, SMR)
   [res_corr, res_uncorr, Q, frc_curve_corr, frc_curve_uncorr] = ...
      qCorrectionLocs(obj, SMR)

   % Constructor.
   function obj = FRC(SMF)
   % SMF values, if provided, can override class properties.

      if exist('SMF', 'var')
         if ~isempty(FRC.Data.PixelSize)
            obj.PixelSize = 1000 * FRC.Data.PixelSize;   % convert um to nm
         end
      end

   end

end % methods
% =============================================================================

% =============================================================================
methods(Static)

   success = unitTest()

end % methods(Static)
% =============================================================================

end % classdef FRC

./MATLAB/+smi_core/@FRC/posToFRC.m
function frc_curve = posToFRC(obj, SMR)
% posToFRC calculates the Fourier Ring Correlation curve.
% The FRC curve is computed by taking blocks of localizations and assigning 
% them randomly to half data sets. The localizations in these sets are binned
% into 2 images from which the FRC curve is computed.
%   
% INPUTS:
%    SMR:            SMR structure with the following fields:
%       YSize        size (pixels) of the image
%       X,Y          (x, y) coordinates (pixels) of each localization [Nx1]
%       DatasetNum   dataset number of each localization              [Nx1]
%       FrameNum     frame number of each localization                [Nx1]
%       NFrames      number of frames in each dataset
%    obj:
%       SRImageZoom  image magnification factor
%
% OUTPUTS:
%    frc_curve       FRC curve vs. spatial frequency (1/nm)
%
% REQUIRES:
%    DIPlib Image Resolution add-on
%    Parallel Processing Toolbox
%    NVidia GPU
%
% CITATION:
%    http://www.diplib.org/add-ons
%    Image Resolution, Reference: R.P.J. Nieuwenhuizen, K.A. Lidke, M. Bates,
%    D. Leyton Puig, D. Grnwald, S. Stallinga, B. Rieger, Measuring Image
%    Resolution in Optical Nanoscopy, Nature Methods, 10(6):557-562, 2013.
%    Also, see FRC_unitTest.m .

   % Compute absolute frame numbers as if there is just one dataset.
   FrameAbs = double(SMR.NFrames)*(SMR.DatasetNum - 1) + double(SMR.FrameNum);
   SRImageZoom = obj.SRImageZoom;
   % Number of time blocks into which the dataset is split.  2 blocks is the
   % minimum accepted amount.
   blocks = 50;

   frc_curve = postofrc([SMR.X, SMR.Y, FrameAbs], SMR.YSize*SRImageZoom, ...
                        SRImageZoom, blocks);

end

./MATLAB/+smi_core/@FRC/README.md
### +smi_core/@FRC

Fourier Ring Correlation (FRC) class for computing average image resolution.
FRC is a measure of the average resolution over a super-resolution image.  It
works by dividing the set of single-emitter localizations in the
super-resolution image into two statistically independent subsets.  The
Fourier transforms of subimages generated from each of these subsets are then
statistically correlated over pixels on the perimeters of circles of constant
spatial frequency.  The image resolution is defined as the inverse of the
spatial frequency when the FRC curve drops below a threshold, taken to be
1/7 in the citation below.  Spurious correlations (for example, due to
repeated photoactivation of the same emitter) are removed by estimating the
number of times an emitter is localized on average (Q) assuming Poisson
statistics.

REQUIRES:
- DIPlib Image Resolution add-on
- Curve Fitting Toolbox (needed by qCorrectLocs)
- Parallel Processing Toolbox
- NVidia GPU

CITATION:

   ```http://www.diplib.org/add-ons```
   Image Resolution, Reference: R.P.J. Nieuwenhuizen, K.A. Lidke, M. Bates,
   D. Leyton Puig, D. Grnwald, S. Stallinga, B. Rieger, Measuring Image
   Resolution in Optical Nanoscopy, Nature Methods, 10(6):557-562, 2013.

NOTE:
   Install the Image Resolution software at the same level as smite.
   This software is located at the URL above (see CITATION).  In startup.m,
   add a path to
```
      .../FRCresolution_software/matlabdistribution/FRCresolutionfunctions
```
   where often ... = /Documents/MATLAB.  In the FRCresolutionfunctions, copy
   smooth.m from the MATLAB Curve Fitting Toolbox into cfsmooth.m.  For
   example, look in
```
      MATLAB_DISTRIBUTION/toolbox/curvefit/curvefit/smooth.m
```
   This is needed because DIPimage also has a smooth function which will
   typically shadow MATLAB's smooth. 

---

```
properties:
   PixelSize   = 100;   % nm per pixel
   SRImageZoom = 10;    % image magnification factor
   Repeats     = 1;     % number of times FRC curve is computed for averaging
```

---

methods:
- **[posToFRC](posToFRC.m)**:
  calculates the Fourier Ring Correlation curve
- **[posToResolution](posToResolution.m)**:
  computes the image resolution from a list of localizations
- **[qCorrectionLocs](qCorrectionLocs.m)**:
  calculates Q-corrected FRC curves and resolutions
- **[unitTest](unitTest.m)**:
  Test Fourier Ring Correlation (FRC) interface functions and provide examples
  of usage

./MATLAB/+smi_core/@FRC/posToResolution.m
function [resolution, frc_curve, resolution_hi, resolution_lo, ...
          resolution_t] = posToResolution(obj, SMR)
% posToResolution computes the image resolution from a list of localizations.
% The resolution is computed by taking blocks of localizations and assigning
% them randomly to half data sets.  The localizations in these sets are binned
% into 2 images from which the FRC curve and subsequently the resolution are
% computed.
%   
% INPUTS:
%    SMR             SMR structure with the following fields:
%       YSize        size (pixels) of the image
%       X,Y          (x, y) coordinates (pixels) of each localization [Nx1]
%       DatasetNum   dataset number of each localization              [Nx1]
%       FrameNum     frame number of each localization                [Nx1]
%       NFrames      number of frames in each dataset
%    obj:
%       SRImageZoom  image magnification factor
%       Repeats      number of times the FRC curve is computed for averaging
%
% OUTPUTS:
%    resolution      mean image resolution (pixels)
%    frc_curve       FRC curve vs. spatial frequency (1/nm)
%    resolution_hi   resolution + 1 standard deviation (pixels)
%    resolution_lo   resolution - 1 standard deviation (pixels)
%    resolution_t    mean of resolution over time
%
% REQUIRES:
%    DIPlib Image Resolution add-on
%    Parallel Processing Toolbox
%    NVidia GPU
%
% CITATION:
%    http://www.diplib.org/add-ons
%    Image Resolution, Reference: R.P.J. Nieuwenhuizen, K.A. Lidke, M. Bates,
%    D. Leyton Puig, D. Grnwald, S. Stallinga, B. Rieger, Measuring Image
%    Resolution in Optical Nanoscopy, Nature Methods, 10(6):557-562, 2013.
%    Also, see FRC_unitTest.m .

   % Compute absolute frame numbers as if there is just one dataset.
   FrameAbs = double(SMR.NFrames)*(SMR.DatasetNum - 1) + double(SMR.FrameNum);
   SRImageZoom = obj.SRImageZoom;;
   % Number of time blocks into which the dataset is split.  2 blocks is the
   % minimum accepted amount.
   blocks = 50;
   timefractions = 1;
   reps = obj.Repeats;

   [resolution, frc_curve, resolution_hi, resolution_lo, resolution_t] = ...
      postoresolution([SMR.X, SMR.Y, FrameAbs], SMR.YSize*SRImageZoom,   ...
                      SRImageZoom, timefractions, reps);

end

./MATLAB/+smi_core/@FRC/qCorrectionLocs.m
function [res_corr, res_uncorr, Q, frc_curve_corr, frc_curve_uncorr] = ...
         qCorrectionLocs(obj, SMR)
% qCorrectionLocs calculates Q-corrected FRC curves and resolutions.
%   
% INPUTS:
%    SMR             SMR structure with the following fields:
%       YSize        size (pixels) of the image
%       X,Y          (x, y) coordinates (pixels) of each localization [Nx1]
%       X_SE,Y_SE    standard errors of the estimation of the above   [NX1]
%       DatasetNum   dataset number of each localization              [Nx1]
%       FrameNum     frame number of each localization                [Nx1]
%       NFrames      number of frames in each dataset
%    obj:
%       PixelSize       nm per pixel
%       SRImageZoom     image magnification factor
%       Repeats         number of times the FRC curve is computed for averaging
%
% OUTPUTS:
%    res_corr         resolution after correction for spurious correlations
%    res_uncorr       resolution value without correction
%    Q                estimate for the number of times an emitter is localized
%                        on average assuming Poisson statistics for the
%                        localizations per emitter
%    frc_curve_corr   FRC curve corrected for spurious correlations
%    frc_curve_uncorr FRC curve without correction
% Note: frc_curve is the FRC curve vs. spatial frequency (1/nm)
%
% REQUIRES:
%    DIPlib Image Resolution add-on
%    Curve Fitting Toolbox
%    Parallel Processing Toolbox
%    NVidia GPU
%  
% CITATION:
%    http://www.diplib.org/add-ons
%    Image Resolution, Reference: R.P.J. Nieuwenhuizen, K.A. Lidke, M. Bates,
%    D. Leyton Puig, D. Grnwald, S. Stallinga, B. Rieger, Measuring Image
%    Resolution in Optical Nanoscopy, Nature Methods, 10(6):557-562, 2013.
%    Also, see FRC_unitTest.m .

   % Compute absolute frame numbers as if there is just one dataset.
   FrameAbs = double(SMR.NFrames)*(SMR.DatasetNum - 1) + double(SMR.FrameNum);
   SRImageZoom = obj.SRImageZoom;
   % Number of time blocks into which the dataset is split.  2 blocks is the
   % minimum accepted amount.
   blocks = 50;
   reps = obj.Repeats;
   sig = sqrt(SMR.X_SE.^2 + SMR.Y_SE.^2);
   meansig = mean(sig);
   stdsig  = std(sig);
   SR_pixelsize = obj.PixelSize; % nm
   floorcor = true;
   show_frc = false;

   [res_corr, res_uncorr, Q, frc_curve_corr, frc_curve_uncorr] = ...
      qcorrection_locs([SMR.X, SMR.Y, FrameAbs], SMR.YSize*SRImageZoom, ...
                        SRImageZoom, blocks, reps, meansig, stdsig,     ...
                        SR_pixelsize, floorcor, show_frc);

end

./MATLAB/+smi_core/@ChannelRegistration/gui.m
function gui(obj, GUIParent)
%gui is the GUI method for the ChannelRegistration class.
% This method generates a GUI for the ChannelRegistration class which
% allows the user to interactively load fiducials and generate transforms.
%
% INPUTS:
%   GUIParent: The 'Parent' of this GUI, e.g., a figure handle.
%              (Default = figure(...))

% Created by:
%   David J. Schodt (Lidke lab, 2020)


% Create a figure handle for the GUI if needed.
if ~(exist('GUIParent', 'var') && ~isempty(GUIParent) ...
        && isgraphics(GUIParent))
    DefaultFigurePosition = get(0, 'defaultFigurePosition');
    GUIParent = figure('MenuBar', 'none', ...
        'Name', 'Channel Registration', 'NumberTitle', 'off', ...
        'Units', 'pixels', ...
        'Position', DefaultFigurePosition);
end

% Generate some panels to help organize the GUI.
FilePanel = uipanel(GUIParent, 'Title', 'Fiducial files', ...
    'Units', 'normalized', 'Position', [0, 0.5, 0.5, 0.5]);
FittingPanel = uipanel(GUIParent, 'Title', 'Fiducial fitting', ...
    'Units', 'normalized', 'Position', [0, 0, 0.5, 0.5]);
TransformParametersPanel = uipanel(GUIParent, ...
    'Title', 'Transform parameters', ...
    'Units', 'normalized', 'Position', [0.5, 0.5, 0.5, 0.5]);
TransformControlsPanel = uipanel(GUIParent, ...
    'Title', 'Transform controls', ...
    'Units', 'normalized', 'Position', [0.5, 0, 0.5, 0.5]);

% Add some controls to the fiducial file panel.
ButtonSize = [0, 0, 1, 0.12];
TextSize = [0, 0, 0.5, 0.12];
PopupSize = [0, 0, 1, 0.5];
EditSize = [0, 0, 0.5, 0.12];
ControlHandles.AddFileButton = uicontrol(FilePanel, ...
    'Style', 'pushbutton', ...
    'FontUnits', 'normalized', 'FontSize', 0.5, ...
    'String', 'Add fiducial(s)', ...
    'Units', 'normalized', ...
    'Tooltip', 'Select fiducial image files', ...
    'Position', ButtonSize+[0, 1-ButtonSize(4), 0, 0], ...
    'Callback', @addFile);
ControlHandles.RemoveFileButton = uicontrol(FilePanel, ...
    'Style', 'pushbutton', ...
    'FontUnits', 'normalized', 'FontSize', 0.5, ...
    'String', 'Remove selected fiducial', ...
    'Units', 'normalized', ...
    'Tooltip', 'Remove fiducial image file', ...
    'Position', ButtonSize+[0, 1-2*ButtonSize(4), 0, 0], ...
    'Callback', @removeFile);
FiducialFileTooltip = ...
    sprintf(['Fiducial filenames. The currently selected file in\n', ...
    'in the list will be used as the reference.']);
ControlHandles.FileList = uicontrol(FilePanel, ...
    'Style', 'listbox', ...
    'Units', 'normalized', ...
    'Position', PopupSize+[0, 1-2*ButtonSize(4)-PopupSize(4), 0, 0], ...
    'Tooltip', FiducialFileTooltip, ...
    'Callback', @selectReference);
ControlHandles.ReferenceFileText = uicontrol(FilePanel, ...
    'Style', 'text', ...
    'FontUnits', 'normalized', 'FontSize', 0.5, 'FontWeight', 'bold', ...
    'String', 'Reference fiducial: ', ...
    'Visible', 'off', ...
    'HorizontalAlignment', 'right', ...
    'Tooltip', FiducialFileTooltip, ...
    'Units', 'normalized', ...
    'Position', ...
    TextSize + [0, 1-2*ButtonSize(4)-PopupSize(4)-TextSize(4), 0, 0]);
ControlHandles.ReferenceFileName = uicontrol(FilePanel, ...
    'Style', 'text', ...
    'FontUnits', 'normalized', 'FontSize', 0.5, 'FontWeight', 'bold', ...
    'Visible', 'off', ...
    'HorizontalAlignment', 'left', ...
    'Tooltip', FiducialFileTooltip, ...
    'Units', 'normalized', 'Position', TextSize ...
    + [TextSize(3), 1-2*ButtonSize(4)-PopupSize(4)-TextSize(4), 0, 0]);
ROISplittingTooltip = sprintf(...
    ['If your fiducial file contains multiple fiducials in the\n', ...
    'same image (i.e., different ROIs of the image), you can define\n', ...
    'the way the image is split in this field.  This field becomes\n', ...
    'the class property ''SplitFormat'' (see \n', ...
    'convertSplitFormatToROIs() for more details)']);
ControlHandles.ROISplittingText = uicontrol(FilePanel, ...
    'Style', 'text', ...
    'FontUnits', 'normalized', 'FontSize', 0.5, 'FontWeight', 'bold', ...
    'String', 'ROI splitting format: ', ...
    'Visible', 'off', ...
    'HorizontalAlignment', 'right', ...
    'Tooltip', ROISplittingTooltip, ...
    'Units', 'normalized', ...
    'Position', ...
    TextSize + [0, 1-2*ButtonSize(4)-PopupSize(4)-TextSize(4), 0, 0]);
ControlHandles.ROISplittingPopup = uicontrol(FilePanel, ...
    'Style', 'popup', ...
    'String', obj.SplitFormatOptionsChar, ...
    'FontUnits', 'normalized', 'FontSize', 0.5, ...
    'Visible', 'off', ...
    'HorizontalAlignment', 'center', ...
    'Tooltip', ROISplittingTooltip, ...
    'Units', 'normalized', 'Position', TextSize ...
    + [TextSize(3), 1-2*ButtonSize(4)-PopupSize(4)-TextSize(4), 0, 0], ...
    'Callback', @refresh);

% Add some controls to the fitting panel.
ButtonSize = [0, 0, 1, 0.12];
TextSize = [0, 0, 0.5, 0.12];
CheckSize = [0, 0, 0.5, 0.12];
ControlHandles.SMFButton = uicontrol(FittingPanel, ...
    'Style', 'pushbutton', ...
    'FontUnits', 'normalized', 'FontSize', 0.5, 'FontWeight', 'bold', ...
    'String', 'Modify fitting parameters', ...
    'Units', 'normalized', ...
    'Position', ButtonSize+[0, 1-ButtonSize(4), 0, 0], ...
    'Tooltip', sprintf(...
    ['Open SMF GUI to adjust the fiducial fitting parameters.\n', ...
    'Note that this is only relevant for coordinate transforms\n', ...
    '(i.e., when ChannelRegistration.TransformBasis = ''coords'').']), ...
    'Callback', @openSMFGUI);
CullTooltipString = sprintf(...
    ['Selecting manual cull will allow you to cull\n', ...
    'fiducial localizations that you don''t want to include when\n', ...
    'computing the transform.']);
uicontrol(FittingPanel, 'Style', 'text', ...
    'FontUnits', 'normalized', 'FontSize', 0.5, 'FontWeight', 'bold', ...
    'String', 'Manual cull: ', ...
    'HorizontalAlignment', 'right', ...
    'Tooltip', CullTooltipString, ...
    'Units', 'normalized', ...
    'Position', TextSize+[0, 1-ButtonSize(4)-TextSize(4), 0, 0]);
ControlHandles.CullCheckbox = uicontrol(FittingPanel, ...
    'Style', 'checkbox', 'Value', obj.ManualCull, ...
    'Units', 'normalized', ...
    'Position', CheckSize ...
    + [TextSize(3), 1-ButtonSize(4)-TextSize(4), 0, 0], ...
    'Tooltip', CullTooltipString, ...
    'Callback', @refresh);
AutoscaleTooltip = ...
    sprintf(['Autoscale fiducial images before fitting.\n', ...
    'Selecting this will use an empirical autoscaling on the\n', ...
    'fiducial images, which generally seems to help the fitting.\n', ...
    'This parameter only matters for coordinate type transforms']);
uicontrol(FittingPanel, 'Style', 'text', ...
    'FontUnits', 'normalized', 'FontSize', 0.5, 'FontWeight', 'bold', ...
    'String', 'Autoscale fiducials: ', ...
    'HorizontalAlignment', 'right', ...
    'Tooltip', AutoscaleTooltip, ...
    'Units', 'normalized', ...
    'Position', TextSize+[0, 1-ButtonSize(4)-2*TextSize(4), 0, 0]);
ControlHandles.AutoscaleFiducialCheckbox = uicontrol(FittingPanel, ...
    'Style', 'checkbox', 'Value', obj.AutoscaleFiducials, ...
    'Units', 'normalized', ...
    'Position', CheckSize ...
    + [TextSize(3), 1-ButtonSize(4)-2*TextSize(4), 0, 0], ...
    'Tooltip', AutoscaleTooltip, ...
    'Callback', @refresh);

% Add some controls to the transform parameters panel.
EditSize = [0, 0, 0.5, 0.12];
TextSize = [0, 0, 0.5, 0.12];
PopupSize = [0, 0, 0.5, 0.12];
BasisTooltipString = ...
    sprintf(['Basis of the transformation.  Coordinate transforms\n', ...
    'compute the transform from localizations made from your\n', ...
    'fiducial images.  Image transforms compute a transform\n', ...
    'directly from your fiducial images (easier, but not as good)']);
uicontrol(TransformParametersPanel, 'Style', 'text', ...
    'FontUnits', 'normalized', 'FontSize', 0.5, 'FontWeight', 'bold', ...
    'String', 'Transformation basis: ', ...
    'HorizontalAlignment', 'right', ...
    'Tooltip', BasisTooltipString, ...
    'Units', 'normalized', ...
    'Position', TextSize+[0, 1-TextSize(4), 0, 0]);
ControlHandles.BasisPopup = uicontrol(TransformParametersPanel, ...
    'Style', 'popupmenu', 'String', {'coordinates', 'images'}, ...
    'Tooltip', BasisTooltipString, ...
    'Units', 'normalized', ...
    'Position', PopupSize+[TextSize(3), 1-PopupSize(4), 0, 0], ...
    'Callback', @refresh);
TransformOptionsTooltip = ...
    sprintf(['Type of transform to be used.  The options listed\n', ...
    'will depend on the transformation basis.  See\n', ...
    '''doc fitgeotrans'' for descriptions of the coordinate\n', ...
    'transforms and ''doc imregtform'' for descriptions of the\n', ...
    'image transforms.']);
uicontrol(TransformParametersPanel, 'Style', 'text', ...
    'FontUnits', 'normalized', 'FontSize', 0.5, 'FontWeight', 'bold', ...
    'String', 'Transformation type: ', ...
    'HorizontalAlignment', 'right', ...
    'Tooltip', TransformOptionsTooltip, ...
    'Units', 'normalized', ...
    'Position', TextSize+[0, 1-2*TextSize(4), 0, 0]);
ControlHandles.TransformTypePopup = uicontrol(TransformParametersPanel, ...
    'Style', 'popupmenu', 'String', obj.CoordTransformOptions, ...
    'Value', ...
    find(strcmp(obj.TransformationType, obj.CoordTransformOptions)), ...
    'Tooltip', TransformOptionsTooltip, ...
    'Units', 'normalized', ...
    'Position', PopupSize+[TextSize(3), 1-2*PopupSize(4), 0, 0], ...
    'Callback', @selectTransform);
TransformInputTooltip = ...
    sprintf(['See ''doc fitgeotrans''\n', ...
    '(or obj.NNeighborPoints/obj.PolynomialDegree)']);
ControlHandles.TransformInputText = uicontrol(TransformParametersPanel, ...
    'Style', 'text', ...
    'FontUnits', 'normalized', 'FontSize', 0.5, 'FontWeight', 'bold', ...
    'String', 'N neighbor points: ', ...
    'HorizontalAlignment', 'right', ...
    'Tooltip', TransformInputTooltip, ...
    'Units', 'normalized', ...
    'Position', TextSize+[0, 1-3*TextSize(4), 0, 0], ...
    'Visible', 'off');
ControlHandles.TransformInputEdit = uicontrol(TransformParametersPanel, ...
    'Style', 'edit', ...
    'FontUnits', 'normalized', 'FontSize', 0.5, ...
    'String', num2str(obj.NNeighborPoints), ...
    'HorizontalAlignment', 'center', ...
    'Tooltip', TransformInputTooltip, ...
    'Units', 'normalized', ...
    'Position', EditSize+[EditSize(3), 1-3*PopupSize(4), 0, 0], ...
    'Visible', 'off', 'Callback', @refresh);

% Add controls to the transform control panel.
ButtonSize = [0, 0, 1, 0.12];
ControlHandles.ComputeTransformButton = uicontrol(...
    TransformControlsPanel, ...
    'Style', 'pushbutton', 'BackgroundColor', [0, 1, 0], ...
    'FontUnits', 'normalized', 'FontSize', 0.5, 'FontWeight', 'bold', ...
    'String', 'Compute transform', ...
    'Units', 'normalized', ...
    'Position', ButtonSize+[0, 1-ButtonSize(4), 0, 0], ...
    'Tooltip', sprintf(...
    ['Compute a transform based on the defined parameters.\n', ...
    'The transform will be stored in obj.RegistrationTransform.']), ...
    'Callback', @computeTransform);
ControlHandles.VisualizeTransformButton = uicontrol(...
    TransformControlsPanel, ...
    'Style', 'pushbutton', ...
    'FontUnits', 'normalized', 'FontSize', 0.5, 'FontWeight', 'bold', ...
    'String', 'Visualize transform magnitude', ...
    'Units', 'normalized', ...
    'Position', ButtonSize+[0, 1-3*ButtonSize(4), 0, 0], ...
    'Tooltip', ...
    'Visualize the magnitude of the transform (opens a new figure).', ...
    'Callback', @visualizeTransformMagnitude);
ControlHandles.VisualizeResultsButton = uicontrol(...
    TransformControlsPanel, ...
    'Style', 'pushbutton', ...
    'FontUnits', 'normalized', 'FontSize', 0.5, 'FontWeight', 'bold', ...
    'String', 'Visualize registration performance', ...
    'Units', 'normalized', ...
    'Position', ButtonSize+[0, 1-4*ButtonSize(4), 0, 0], ...
    'Tooltip', ...
    sprintf(['Visualize the registration performance on the\n', ...
    'fiducial localizations (only relevant for coordinate type\n', ...
    'transforms).']), ...
    'Callback', @visualizeRegistrationPerformance);
ControlHandles.VisualizeErrorButton = uicontrol(...
    TransformControlsPanel, ...
    'Style', 'pushbutton', ...
    'FontUnits', 'normalized', 'FontSize', 0.5, 'FontWeight', 'bold', ...
    'String', 'Visualize registration error', ...
    'Units', 'normalized', ...
    'Position', ButtonSize+[0, 1-5*ButtonSize(4), 0, 0], ...
    'Tooltip', ...
    'Visualize the registration error (opens a new figure).', ...
    'Callback', @visualizeError);
ControlHandles.ExportTransformButton = uicontrol(...
    TransformControlsPanel, ...
    'Style', 'pushbutton', ...
    'FontUnits', 'normalized', 'FontSize', 0.5, 'FontWeight', 'bold', ...
    'String', 'Export transform', ...
    'Units', 'normalized', ...
    'Position', ButtonSize, ...
    'Tooltip', ...
    'Save the transform (and related information) in a .mat file.', ...
    'Callback', @exportTransformCallback);

% Ensure the GUI items reflect class properties and vice versa.
refresh()


%{
This section contains various nested and callback functions for use in this
method.
%}

    function guiToProperties(~, ~)
        % This function takes relevant inputs in the GUI and sets them as
        % class properties.
        
        % Update obj.SplitFormat based on the popup menu selection (if
        % needed).
        if (numel(obj.SMF.Data.FileName) == 1)
            obj.SplitFormat = obj.SplitFormatOptions{...
                ControlHandles.ROISplittingPopup.Value};
        end
        
        % Update obj.ManualCull and obj.AutoscaleFiducials based on the
        % appropriate checkboxes.
        obj.ManualCull = ControlHandles.CullCheckbox.Value;
        obj.AutoscaleFiducials = ...
            ControlHandles.AutoscaleFiducialCheckbox.Value;
        
        % Set the transformation basis and type.
        obj.TransformationBasis = ControlHandles.BasisPopup.String{...
            ControlHandles.BasisPopup.Value};
        obj.TransformationType = ...
            ControlHandles.TransformTypePopup.String{...
            ControlHandles.TransformTypePopup.Value};
        
        % Set the additional transform inputs if needed (e.g.,
        % obj.NNeighborPoints).
        if strcmp(ControlHandles.TransformTypePopup.String{...
                ControlHandles.TransformTypePopup.Value}, 'lwm')
            obj.NNeighborPoints = str2double(...
                ControlHandles.TransformInputEdit.String);
        elseif strcmp(ControlHandles.TransformTypePopup.String{...
                ControlHandles.TransformTypePopup.Value}, 'polynomial')
            obj.PolynomialDegree = str2double(...
                ControlHandles.TransformInputEdit.String);
        end
    end

    function propertiesToGUI(~, ~)
        % This function updates the GUI based on the current class
        % properties.
        
        % Populate the fiducial file list if it is empty (re-populating
        % everytime we call this method is annoying, as it will change the
        % order of the files each time a new reference is selected).
        if isempty(ControlHandles.FileList.String)
            ControlHandles.FileList.String = obj.SMF.Data.FileName;
        end
        
        % Update the reference file/ROI selection GUI elements.
        if (numel(obj.SMF.Data.FileName) > 1)
            % Display the reference fiducial elements.
            ControlHandles.ReferenceFileText.Visible = 'on';
            ControlHandles.ReferenceFileName.Visible = 'on';
            ControlHandles.ROISplittingText.Visible = 'off';
            ControlHandles.ROISplittingPopup.Visible = 'off';
        else
            % Display the ROI selection elements.
            ControlHandles.ROISplittingText.Visible = 'on';
            ControlHandles.ROISplittingPopup.Visible = 'on';
            ControlHandles.ReferenceFileText.Visible = 'off';
            ControlHandles.ReferenceFileName.Visible = 'off';
        end
        if ~(isempty(obj.SMF.Data.FileName) ...
                || isempty(obj.SMF.Data.FileName{1}))
            ControlHandles.ReferenceFileName.String = ...
                obj.SMF.Data.FileName{1};
        else
            ControlHandles.ReferenceFileName.String = '';
        end
        
        % Update the checkbox for the manual cull and autoscale fiducial
        % options.
        ControlHandles.CullCheckbox.Value = obj.ManualCull;
        ControlHandles.AutoscaleFiducialCheckbox.Value = ...
                obj.AutoscaleFiducials;
        
        % Update the transformation basis and type.
        % NOTE: I have to reset the 'Value' of the popup to 1 (even if it
        %       changes a few lines later) to prevent conflicts (i.e.,
        %       Value>numel(String))
        ControlHandles.BasisPopup.String = obj.TransformationBasisOptions;
        ControlHandles.BasisPopup.Value = ...
            find(strcmp(obj.TransformationBasis, ...
            ControlHandles.BasisPopup.String));
        ControlHandles.TransformTypePopup.Value = 1;
        if strcmp(obj.TransformationBasis, 'coordinates')
            ControlHandles.TransformTypePopup.String = ...
                obj.CoordTransformOptions;
        else
            ControlHandles.TransformTypePopup.String = ...
                obj.ImageTransformOptions;
        end
        TransformIndex = find(strcmp(obj.TransformationType, ...
            ControlHandles.TransformTypePopup.String));
        if isempty(TransformIndex)
            TransformIndex = 1;
        end
        ControlHandles.TransformTypePopup.Value = TransformIndex;
        
        % Modify the text and edit box for the additional transform inputs
        % (e.g., NNeighborPoints).
        if strcmp(ControlHandles.TransformTypePopup.String{...
                ControlHandles.TransformTypePopup.Value}, 'lwm')
            ControlHandles.TransformInputText.Visible = 'on';
            ControlHandles.TransformInputText.String = ...
                'N neighbor points: ';
            ControlHandles.TransformInputEdit.Visible = 'on';
            ControlHandles.TransformInputEdit.String = ...
                num2str(obj.NNeighborPoints);
        elseif strcmp(ControlHandles.TransformTypePopup.String{...
                ControlHandles.TransformTypePopup.Value}, 'polynomial')
            ControlHandles.TransformInputText.Visible = 'on';
            ControlHandles.TransformInputText.String = ...
                'Polynomial degree: ';
            ControlHandles.TransformInputEdit.Visible = 'on';
            ControlHandles.TransformInputEdit.String = ...
                num2str(obj.PolynomialDegree);
        else
            ControlHandles.TransformInputText.Visible = 'off';
            ControlHandles.TransformInputEdit.Visible = 'off';
        end
    end

    function refresh(~, ~)
        % This function calls guiToProperties() and propertiesToGUI()
        guiToProperties()
        propertiesToGUI()
    end

    function addFile(~, ~)
        % This function allows the user to interactively select the
        % fiducial file(s).
        
        % Ensure obj is updated.
        guiToProperties()
        
        % Request the user to select the fiducial(s).
        [FileName, FileDir] = uigetfile({'*.mat'; '*.h5'}, ...
            'Select fiducial file(s)', 'Multiselect', 'on');
        
        % Store the filename(s) and filepath in obj.SMF.
        if isequal(FileName, 0)
            return
        else
            % Update filename and filepath.
            obj.SMF.Data.FileDir = FileDir;
            if ~iscell(FileName)
                FileName = {FileName};
            end
            if (isempty(obj.SMF.Data.FileName) ...
                    || isempty(obj.SMF.Data.FileName{1}))
                obj.SMF.Data.FileName = FileName;
            else
                obj.SMF.Data.FileName = [obj.SMF.Data.FileName; FileName];
            end

            % Reset a class property to reflect that the GUI loaded a
            % fiducial.
            obj.ManualSetFiducials = false;
        end
        
        % Update the file list.
        ControlHandles.FileList.String = obj.SMF.Data.FileName;
        
        % Update the GUI.
        propertiesToGUI()
    end

    function removeFile(~, ~)
        % This function removes the file selected in the filename list.
        
        % Ensure obj is updated.
        guiToProperties()
        
        % Remove the selected file from the file list.
        FileIndex = ControlHandles.FileList.Value;
        IndexArray = 1:numel(obj.SMF.Data.FileName);
        KeepBool = (IndexArray ~= FileIndex);
        obj.SMF.Data.FileName = obj.SMF.Data.FileName(KeepBool);
        ControlHandles.FileList.Value = 1;
        ControlHandles.FileList.String = ...
            ControlHandles.FileList.String(KeepBool);
        
        % Update the GUI.
        propertiesToGUI()
    end

    function selectReference(Source, ~)
        % This function re-orders the files so that the selected file will
        % be used as the reference (internally, ChannelRegistration always
        % uses the first file as the reference).
        
        % Ensure obj is updated.
        guiToProperties()
        
        % Reorder the files so that the currently selected file is the
        % first element of obj.SMF.Data.FileName).
        FileIndex = Source.Value;
        IndexArray = 1:numel(Source.String);
        obj.SMF.Data.FileName = Source.String([FileIndex, ...
            setdiff(IndexArray, FileIndex)]);
        if ~isempty(obj.SMF.Data.FileName)
            ControlHandles.ReferenceFileName.String = ...
                obj.SMF.Data.FileName{1};
        else
            ControlHandles.ReferenceFileName.String = '';
        end
        
        % Update the GUI.
        propertiesToGUI()
    end

    function openSMFGUI(~, ~)
        % This function opens the SMF class GUI.
        guiToProperties()
        obj.SMF.gui();
        propertiesToGUI()
    end

    function selectTransform(~, ~)
        % This function modifies some GUI properties when the transform
        % type is selected.
        % NOTE: Even though refresh() would be ideal, I can't use that
        %       because it calls guiToProperties() first (the block below
        %       is found in propertiesToGUI()) which can cause an error
        %       when switching between 'lwm' and 'polynomial'.  We also
        %       don't want to just flip the order here, as that could cause
        %       other bugs.
        
        % Update the GUI.
        if strcmp(ControlHandles.TransformTypePopup.String{...
                ControlHandles.TransformTypePopup.Value}, 'lwm')
            ControlHandles.TransformInputText.Visible = 'on';
            ControlHandles.TransformInputText.String = ...
                'N neighbor points: ';
            ControlHandles.TransformInputEdit.Visible = 'on';
            ControlHandles.TransformInputEdit.String = ...
                num2str(obj.NNeighborPoints);
        elseif strcmp(ControlHandles.TransformTypePopup.String{...
                ControlHandles.TransformTypePopup.Value}, 'polynomial')
            ControlHandles.TransformInputText.Visible = 'on';
            ControlHandles.TransformInputText.String = ...
                'Polynomial degree: ';
            ControlHandles.TransformInputEdit.Visible = 'on';
            ControlHandles.TransformInputEdit.String = ...
                num2str(obj.PolynomialDegree);
        else
            ControlHandles.TransformInputText.Visible = 'off';
            ControlHandles.TransformInputEdit.Visible = 'off';
        end
        
        % Update the properties.
        if strcmp(ControlHandles.TransformTypePopup.String{...
                ControlHandles.TransformTypePopup.Value}, 'lwm')
            obj.NNeighborPoints = str2double(...
                ControlHandles.TransformInputEdit.String);
        elseif strcmp(ControlHandles.TransformTypePopup.String{...
                ControlHandles.TransformTypePopup.Value}, 'polynomial')
            obj.PolynomialDegree = str2double(...
                ControlHandles.TransformInputEdit.String);
        end
        
        % Refresh both the GUI and obj.
        refresh()
    end

    function computeTransform(Source, ~)
        % This function will compute a registration transform.
        
        % Ensure obj is updated.
        guiToProperties()
        
        % Modify the compute transform button and then proceed to find the
        % transform.
        OriginalString = Source.String;
        Source.BackgroundColor = [1, 0, 0];
        Source.Enable = 'off';
        Source.String = 'Computing transform...';
        try 
            obj.findTransform();
        catch Exception
            Source.BackgroundColor = [0, 1, 0];
            Source.Enable = 'on';
            Source.String = OriginalString;
            rethrow(Exception)
        end
        disp(['Transform(s) computed and stored in ', ...
            'obj.RegistrationTransform'])
        Source.BackgroundColor = [0, 1, 0];
        Source.Enable = 'on';
        Source.String = OriginalString;
        
        % Update the GUI.
        propertiesToGUI()
    end

    function visualizeTransformMagnitude(~, ~)
        % This function creates a visualization of the computed 
        % transform(s).
        
        % Make sure a transform has already been computed.
        if (isempty(obj.RegistrationTransform) ...
                || isempty(obj.RegistrationTransform{2}))
            error(['You have to compute the transform using the ', ...
                'compute transform button before visualizing the ', ...
                'results (i.e., obj.RegistrationTransform must be ', ...
                'populated first).'])
        end
        
        % Determine how to proceed based on the transformation basis.
        % NOTE: If the user computes a transform and then changes the
        %       basis, this might not work correctly.
        for ii = 2:numel(obj.RegistrationTransform)
            % Note that obj.RegistrationTransform{1} isn't useful, it's
            % just there as sort of a placeholder.
            FigureName = sprintf('Transform %i', ii);
            if strcmp(obj.TransformationBasis, 'coordinates')
                obj.visualizeCoordTransform(figure('Name', FigureName), ...
                    obj.RegistrationTransform{ii}, ...
                    size(obj.FiducialImages, [1, 2]));
            else
                TempFigureHandle = figure('Name', FigureName);
                obj.visualizeImageTransform(...
                    axes(TempFigureHandle), ...
                    obj.RegistrationTransform{ii}, ...
                    size(obj.FiducialImages, [1, 2]));
            end
        end
        
    end

    function visualizeRegistrationPerformance(~, ~)
        % This function creates a visualization of the computed 
        % transform(s) on the fiducial localizations.
        
        % Make sure a transform has already been computed.
        if (isempty(obj.RegistrationTransform) ...
                || isempty(obj.RegistrationTransform{2}))
            error(['You have to compute the transform using the ', ...
                'compute transform button before visualizing the ', ...
                'results (i.e., obj.RegistrationTransform must be ', ...
                'populated first).'])
        end
        
        % Determine how to proceed based on the transformation basis.
        % NOTE: If the user computes a transform and then changes the
        %       basis, this might not work correctly.
        for ii = 2:numel(obj.RegistrationTransform)
            % Note that obj.RegistrationTransform{1} isn't useful, it's
            % just there as sort of a placeholder.
            if strcmp(obj.TransformationBasis, 'coordinates')
                FigureName = sprintf('Transform %i', ii);
                TempFigureHandle = figure('Name', FigureName);
                obj.visualizeRegistrationResults(...
                    TempFigureHandle, ...
                    obj.RegistrationTransform{ii}, ...
                    obj.Coordinates{ii}(:, :, 2), ...
                    obj.Coordinates{ii}(:, :, 1), ...
                    obj.FiducialImages(:, :, ii), ...
                    obj.FiducialImages(:, :, 1));
            else
                warning(['You can only visualize the registration', ...
                    'performance for coordinate transforms.'])
                return
            end
        end
        
    end

    function visualizeError(~, ~)
        % This function calls obj.visualizeRegistrationError().
        
        % Make sure a transform has already been computed.
        if (isempty(obj.RegistrationTransform) ...
                || isempty(obj.RegistrationTransform{2}))
            error(['You have to compute the transform using the ', ...
                'compute transform button before visualizing the ', ...
                'results (i.e., obj.RegistrationTransform must be ', ...
                'populated first).'])
        end
        
        % Determine how to proceed based on the transformation basis.
        % NOTE: If the user computes a transform and then changes the
        %       basis, this might not work correctly.
        for ii = 2:numel(obj.RegistrationTransform)
            % Note that obj.RegistrationTransform{1} isn't useful, it's
            % just there as sort of a placeholder.
            if strcmp(obj.TransformationBasis, 'coordinates')
                FigureName = sprintf('Transform %i', ii);
                TempFigureHandle = figure('Name', FigureName);
                obj.visualizeRegistrationError(axes(TempFigureHandle), ...
                    obj.RegistrationTransform{ii}, ...
                    obj.Coordinates{ii}(:, :, 2), ...
                    obj.Coordinates{ii}(:, :, 1));
            else
                warning(['You can only visualize the registration', ...
                    'error for coordinate transforms.'])
                return
            end
        end
    end

    function exportTransformCallback(~, ~)
        % This callback calls obj.exportTransform().
        
        % Allow the user to select the export location and then export the
        % transform(s).
        FileDir = uigetdir('Specify save location for the transform(s)');
        if isequal(FileDir, 0)
            return
        else
            obj.exportTransform(FileDir);
        end
        
    end

end
./MATLAB/+smi_core/@ChannelRegistration/unitTest.m
function [Success] = unitTest()
%unitTest tests vital functionality of smi_core.ChannelRegistration
%
% This method tests various methods in the class
% smi_core.ChannelRegistration class to ensure that the vital functionality
% is working as intended.  This is done by simulating some data, applying
% an artificial "warping" of the field of view, and then trying to undo
% this effect.
%
% OUTPUTS:
%   Success: An array of flags specifying the success of various methods in
%            smi_core.ChannelRegistration, where 1 means success and 0
%            means failure (of a specific method/functionality). 
%            (Boolean array)
%               Success(1): ChannelRegistration() (constructor)
%               Success(2): findTransform()
%               Success(3): estimateRegistrationError()
%               Success(4): visualizeCoordTransform()
%               Success(5): visualizeImageTransform()
%               Success(6): visualizeRegistrationError()
%               Success(7): visualizeRegistrationResults()

% Created by:
%   David J. Schodt (Lidke Lab, 2021)


% Initialize the Success output.
Success = zeros(1, 7, 'logical');

% Seed the random number generator so that the simulated SMD is predictable
% NOTE: If this is changed, there will almost certainly be entries of
%       Success that are 0.
rng(1234)

% Simulate several emitter positions.
% NOTE: Most of these parameters were chosen arbitrarily, HOWEVER, there
%       may be some checks below that might be affected by changing these
%       parameters (i.e., causing some elements of Success to be 0 even if
%       things worked correctly).
FrameSize = 128;
NEmittersPerRow = 10;
NEmitters = NEmittersPerRow ^ 2;
PhotonSum = 1e4;
Background = 5;
PSFSigma = 1.3;
SigmaNoise = PSFSigma / sqrt(PhotonSum);
GridSpacing = FrameSize / (NEmittersPerRow+1);
[XMesh, YMesh] = meshgrid(GridSpacing:GridSpacing:(FrameSize-GridSpacing));
Coordinates = [XMesh(:), YMesh(:)] + SigmaNoise*randn(NEmitters, 2);

% Construct a "fixed" (reference) SMD structure.
OnesArray =  ones(NEmitters, 1);
SMDFixed = smi_core.SingleMoleculeData.createSMD();
SMDFixed.X = reshape(Coordinates(:, 1), NEmitters, 1);
SMDFixed.Y = reshape(Coordinates(:, 2), NEmitters, 1);
SMDFixed.Z = [];
SMDFixed.X_SE = SigmaNoise * OnesArray;
SMDFixed.Y_SE = SMDFixed.X_SE;
SMDFixed.Z_SE = [];
SMDFixed.Photons = PhotonSum * OnesArray;
SMDFixed.Bg = Background * OnesArray;
SMDFixed.PSFSigma = PSFSigma;
SMDFixed.FrameNum = ones(NEmitters, 1);
SMDFixed.NFrames = 1;
SMDFixed.DatasetNum = OnesArray;
SMDFixed.ThreshFlag = 0 * OnesArray;

% Construct the artificially shifted "moving" SMD structure by applying an
% affine transform to it.
% NOTE: These numbers were just made up at the time of writing, and I
%       didn't really check through the math carefully!
RotationAngle = 0.0123 * (pi/180);
Shift = [1; 2];
Shear = [0.01; 0.005];
Scale = [1.005; 1.001];
RotationMatrix = [cos(RotationAngle), -sin(RotationAngle); ...
    sin(RotationAngle), cos(RotationAngle)];
ShearMatrix = [1, Shear(1); ...
    Shear(2), 1];
ScaleMatrix = [Scale(1), 0; ...
    0, Scale(2)];
WarpingMatrix = RotationMatrix * ShearMatrix * ScaleMatrix;
Coords = [SMDFixed.X, SMDFixed.Y].';
WarpedCoords = Coords.';
for ii = 1:size(Coords, 2)
    WarpedCoords3D = WarpingMatrix*Coords(:, ii) + Shift;
    WarpedCoords(ii, :) = WarpedCoords3D(1:2).';
end
SMDMoving = SMDFixed;
SMDMoving.X = WarpedCoords(:, 1);
SMDMoving.Y = WarpedCoords(:, 2);

% Simulate some raw data.
% NOTE: Warping the first image to make the moving image would be faster,
%       but I'm not doing that because this is slightly easier to code...
SMF = smi_core.SingleMoleculeFitting;
SMF.Data.DataROI = [1, 1, FrameSize, FrameSize];
[~, RawDataFixed] = smi_sim.GaussBlobs.gaussBlobImage(...
    SMDFixed, SMF, Background);
[~, RawDataMoving] = smi_sim.GaussBlobs.gaussBlobImage(...
    SMDMoving, SMF, Background);

% Find a transform to align these channels (testing various components
% along the way).
SMF = smi_core.SingleMoleculeFitting;
SMF.BoxFinding.MinPhotons = 100;
SMF.Fitting.FitType = 'XYNBS';
SMF.Fitting.PSFSigma = PSFSigma;
try
    ChannelReg = smi_core.ChannelRegistration([], [], SMF);
    Success(1) = true;
catch MException
    warning('ChannelRegistration constructor failed with error: %s-%s',...
        MException.identifier, MException.message)
end
ChannelReg.NNeighborPoints = 12;
ChannelReg.TransformationType = 'lwm';
ChannelReg.ManualCull = false;
ChannelReg.SeparationThreshold = GridSpacing / 2;
ChannelReg.ManualSetFiducials = true;
ChannelReg.FiducialROI = [1, 1, FrameSize, FrameSize, 1, 1; ...
    1, 129, FrameSize, 2*FrameSize, 1, 1];
ChannelReg.FiducialImages = cat(3, RawDataFixed, RawDataMoving);
try
    ChannelReg.findTransform();
    Success(2) = true;
catch MException
    warning(['ChannelRegistration.findTransform() ', ...
        'failed with error: %s-%s'], ...
        MException.identifier, MException.message)
end

% Test estimateRegistrationError() and make sure the error is "reasonable"
% (BASED ON THE HARD-CODED THRESHOLD BELOW).
ErrorThreshold = 0.1;
try
    SquaredDifference = ChannelReg.estimateRegistrationError(...
        ChannelReg.RegistrationTransform{2}, ...
        ChannelReg.Coordinates{2}(:, :, 2), ...
        ChannelReg.Coordinates{2}(:, :, 1));
    Success(3) = (sqrt(mean(SquaredDifference)) <= ErrorThreshold);
catch MException
    warning(['ChannelRegistration.findTransform() ', ...
        'failed with error: %s-%s'], ...
        MException.identifier, MException.message)
end

% Test several visualization tools.
PlotFigure = figure('Visible', 'off');
try
    ChannelReg.visualizeCoordTransform(PlotFigure, ...
        ChannelReg.RegistrationTransform{2}, FrameSize * [1, 1]);
    Success(4) = true;
catch MException
    warning(['ChannelReg.visualizeCoordTransform() ', ...
        'failed with error: %s-%s'], ...
        MException.identifier, MException.message)
end
clf(PlotFigure);
PlotAxes = axes(PlotFigure);
try
    ChannelReg.visualizeImageTransform(PlotAxes, ...
        ChannelReg.RegistrationTransform{2}, FrameSize * [1, 1]);
    Success(5) = true;
catch MException
    warning(['ChannelReg.visualizeImageTransform() ', ...
        'failed with error: %s-%s'], ...
        MException.identifier, MException.message)
end
cla(PlotAxes);
try
ChannelReg.visualizeRegistrationError(PlotAxes, ...
    ChannelReg.RegistrationTransform{2}, ...
    ChannelReg.Coordinates{2}(:, :, 2), ...
    ChannelReg.Coordinates{2}(:, :, 1));
    Success(6) = true;
catch MException
    warning(['ChannelReg.visualizeRegistrationError() ', ...
        'failed with error: %s-%s'], ...
        MException.identifier, MException.message)
end
cla(PlotAxes);
try
    ChannelReg.visualizeRegistrationResults(PlotFigure, ...
        ChannelReg.RegistrationTransform{2}, ...
        ChannelReg.Coordinates{2}(:, :, 2), ...
        ChannelReg.Coordinates{2}(:, :, 1), ...
        ChannelReg.FiducialImages(:, :, 2), ...
        ChannelReg.FiducialImages(:, :, 1));
    Success(7) = true;
catch MException
    warning(['ChannelReg.visualizeRegistrationResults() ', ...
        'failed with error: %s-%s'], ...
        MException.identifier, MException.message)
end
close(PlotFigure);


end

./MATLAB/+smi_core/@ChannelRegistration/visualizeRegistrationResults.m
function [PlotFigure] = visualizeRegistrationResults(PlotFigure, ...
    RegistrationTransform, ...
    MovingCoordinates, FixedCoordinates, ...
    MovingImage, FixedImage)
%visualizeRegistrationResults shows registration results on the fiducials.
% This method will demonstrate the registration performance on the
% fiducials by plotting appropriately transformed overlays of the raw data
% and the resulting coordinates.
%
% NOTE: For some transforms, we have to treat FixedCoordinates as the
%       moving pair (forward transforms don't exist for some transforms).  
%
% NOTE: Default values can be used (when available) by setting the
%       corresponding input to [].  For example, 
%       visualizeRegistrationResults([], TForm, Coords1, Coords2, ...
%           Fiducial1, Fiducial2) will use a default value for PlotFigure.
%
% INPUTS:
%   PlotFigure: Figure in which we will make the plots. (Default = gcf())
%   RegistrationTransform: RegistrationTransform is a MATLAB tform object
%                          describing the transform to be visualized.
%                          (tform object)
%   MovingCoordinates: Coordinates of points in the second fiducial.
%                      (Nx2 numeric array)
%   FixedCoordinates: Coordinates of points in the first fiducial.
%                     (Nx2 numeric array)
%   MovingImage: Image of the second fiducial. (MxP numeric array)
%   FixedImage: Image of the first fiducial. (MxP numeric array)
%
% OUTPUTS:
%   PlotFigure: A MATLAB figure handle for the figure in which the 
%               visualizations are contained. 

% Created by:
%   David J. Schodt (Lidke Lab, 2020)


% Set default parameters if needed.
if (~exist('PlotFigure', 'var') || isempty(PlotFigure) ...
        || ~isvalid(PlotFigure))
    PlotFigure = gcf();
end

% Transform the moving fiducial..
MovingImageTransformed = smi_core.ChannelRegistration.transformImages(...
    RegistrationTransform, MovingImage);

% Perform a full scale histogram stretch on the fiducials.
FixedImage = (FixedImage-min(FixedImage(:))) ...
    ./ max(max(FixedImage-min(FixedImage(:))));
MovingImage = (MovingImage-min(MovingImage(:))) ...
    ./ max(max(MovingImage-min(MovingImage(:))));
MovingImageTransformed = ...
    (MovingImageTransformed-min(MovingImageTransformed(:))) ...
    ./ max(max(MovingImageTransformed-min(MovingImageTransformed(:))));

% Create an RGB image of the fixed and moving fiducials (both before and 
% after the transform).
FiducialOverlay = zeros([size(FixedImage), 3]);
FiducialOverlay(:, :, 2) = FixedImage;
FiducialOverlay(:, :, 1) = MovingImage;
FiducialOverlay(:, :, 3) = MovingImage;
FiducialOverlayTrans = zeros([size(FixedImage), 3]);
FiducialOverlayTrans(:, :, 2) = FixedImage;
FiducialOverlayTrans(:, :, 1) = MovingImageTransformed;
FiducialOverlayTrans(:, :, 3) = MovingImageTransformed;

% Transform the coordinates.
[MovingCoordsTransformed] = ...
    smi_core.ChannelRegistration.transformCoords(...
    RegistrationTransform, MovingCoordinates);

% Compute the RMSE.
RMSEBefore = sqrt(mean(sum((MovingCoordinates - FixedCoordinates).^2, 2)));
RMSEAfter = sqrt(mean(...
    smi_core.ChannelRegistration.estimateRegistrationError(...
    RegistrationTransform, MovingCoordinates, FixedCoordinates)));

% Plot the fiducial images and the coordinates.
ImshowCorrection = [0.5, 0.5];
PlotAxesLeft = subplot(1, 2, 1, 'Parent', PlotFigure);
imshow(FiducialOverlay, [], 'Parent', PlotAxesLeft, ...
    'XData', [1, size(FiducialOverlayTrans, 2)]+ImshowCorrection, ...
    'YData', [1, size(FiducialOverlayTrans, 1)]+ImshowCorrection)
line(PlotAxesLeft, ...
    FixedCoordinates(:, 1), FixedCoordinates(:, 2), ...
    'Marker', 'x', 'MarkerSize', 8, 'Color', [0, 1, 0], ...
    'LineStyle', 'none', 'LineWidth', 1.5)
line(PlotAxesLeft, ...
    MovingCoordinates(:, 1), MovingCoordinates(:, 2), ...
    'Marker', '+', 'MarkerSize', 8, 'Color', [1, 0, 1], ...
    'LineStyle', 'none', 'LineWidth', 1.5)
title(PlotAxesLeft, ...
    {sprintf('BEFORE: RMSE = %.3f pixels', RMSEBefore), ...
    'Fixed fiducial - green', 'Moving fiducial - magenta'})
xlabel(PlotAxesLeft, 'X (pixels)')
ylabel(PlotAxesLeft, 'Y (pixels)')
PlotAxesRight = subplot(1, 2, 2, 'Parent', PlotFigure);
imshow(FiducialOverlayTrans, [], 'Parent', PlotAxesRight, ...
    'XData', [1, size(FiducialOverlayTrans, 2)]+ImshowCorrection, ...
    'YData', [1, size(FiducialOverlayTrans, 1)]+ImshowCorrection)
line(PlotAxesRight, ...
    FixedCoordinates(:, 1), FixedCoordinates(:, 2), ...
    'Marker', 'x', 'MarkerSize', 8, 'Color', [0, 1, 0], ...
    'LineStyle', 'none', 'LineWidth', 1.5)
line(PlotAxesRight, ...
    MovingCoordsTransformed(:, 1), MovingCoordsTransformed(:, 2), ...
    'Marker', '+', 'MarkerSize', 8, 'Color', [1, 0, 1], ...
    'LineStyle', 'none', 'LineWidth', 1.5)
title(PlotAxesRight, ...
    {sprintf('AFTER: RMSE = %.3f pixels', RMSEAfter), ...
    'Fixed fiducial - green', 'Moving fiducial - magenta'})
xlabel(PlotAxesRight, 'X (pixels)')
ylabel(PlotAxesRight, 'Y (pixels)')


end
./MATLAB/+smi_core/@ChannelRegistration/estimateRegistrationError.m
function [SquaredError] = estimateRegistrationError(...
    RegistrationTransform, MovingCoordinates, FixedCoordinates)
%estimateRegistrationError estimates the registration error.
% This method will estimate the registration error as the squared
% difference between the fiducial coordinates being compared after 
% transforming (e.g., fiducial 1 localizations and transformed fiducial 2
% localizations).
%
% NOTE: If you need a single number to quantify your registration error,
%       a good estimate would be RMSE = sqrt(mean(SquaredError))
%
% INPUTS:
%   RegistrationTransform: RegistrationTransform is a MATLAB tform object
%                          describing the transform to be visualized.
%                          (tform object)
%   MovingCoordinates: Coordinates of points in the second fiducial.
%                      (Nx2 numeric array)
%   FixedCoordinates: Coordinates of points in the first fiducial.
%                     (Nx2 numeric array)
%
% OUTPUTS:
%   SquaredError: Squared error computed between FixedCoordinates and
%                 transformed MovingCoordinates. This is returned for 
%                 convenience in other codes (i.e., instead of the RMSE)
%                 (Pixels)(Nx1 numeric array)

% Created by:
%   David J. Schodt (Lidke Lab, 2020)


% Transform the input Coords2 and compute the error.
if isempty(RegistrationTransform)
    SquaredError = NaN(size(MovingCoordinates, 1), 1);
    return
end
MovingCoordinates = ...
    smi_core.ChannelRegistration.transformCoords(...
    RegistrationTransform, MovingCoordinates);
SquaredError = sum((FixedCoordinates - MovingCoordinates).^2, 2);


end
./MATLAB/+smi_core/@ChannelRegistration/estimateRegErrorLOO.m
function [SquaredError] = estimateRegErrorLOO(...
    TransformationType, TransformationParams, ...
    MovingCoordinates, FixedCoordinates)
%estimateRegErrorLOO estimates registration error by leave-one-out analysis
% This method will estimate the registration error as the squared
% difference between the fiducial coordinates and the transformed
% coordinates, with the transform used being computed for all other
% fiducial coordinates but the current point.  That is, this method
% estimates the registration error at each fiducial (control) point by a
% leave-one-out (LOO) analysis.
%
% INPUTS:
%   TransformationType: See smi_core.ChannelRegistration property of the
%                       same name.
%   TransformationParams: Cell array of additional parameters needed based
%                         on the TransformationType. For example, for
%                         TransformationType = 'lwm', this is a cell array
%                         with one element: NNeighborPoints. For
%                         TransformationType = 'polynomial', the one
%                         parameter is the polynomial degree (see usage
%                         below).
%   MovingCoordinates: Coordinates of points in the second fiducial.
%                      (Nx2 numeric array)
%   FixedCoordinates: Coordinates of points in the first fiducial.
%                     (Nx2 numeric array)
%
% OUTPUTS:
%   SquaredError: Squared error computed between FixedCoordinates and
%                 transformed MovingCoordinates, where the transform is
%                 found using all other points but the current point.
%                 (Pixels)(Nx1 numeric array)

% Created by:
%   David J. Schodt (Lidke Lab, 2021)


% Loop through each fiducial coordinate, compute a transform that excludes
% that point, and then determine the squared error after applying that
% transform to the fiducial coordinate.
NCoordinates = size(MovingCoordinates, 1);
IndexArray = 1:NCoordinates;
SquaredError = zeros(NCoordinates, 1);
for nn = IndexArray
    % Recompute the transform from all points but the current point.
    IndexArrayCurrent = IndexArray(IndexArray ~= nn);
    MovingCoordsCurrent = MovingCoordinates(IndexArrayCurrent, :);
    FixedCoordinatesCurrent = FixedCoordinates(IndexArrayCurrent, :);
    switch TransformationType
        case 'lwm'
            RegistrationTransform = fitgeotrans(...
                MovingCoordsCurrent, ...
                FixedCoordinatesCurrent, ...
                TransformationType, TransformationParams{1});
        case 'polynomial'
            RegistrationTransform = fitgeotrans(...
                MovingCoordsCurrent, ...
                FixedCoordinatesCurrent, ...
                TransformationType, TransformationParams{1});
        otherwise
            RegistrationTransform = fitgeotrans(...
                MovingCoordsCurrent, ...
                FixedCoordinatesCurrent, ...
                TransformationType);
    end
    
    % Apply the transform to the excluded coordinate and save the
    % squared error.
    SquaredError(nn) = ...
        smi_core.ChannelRegistration.estimateRegistrationError(...
        RegistrationTransform, ...
        MovingCoordinates(nn, :), FixedCoordinates(nn, :));
end


end
./MATLAB/+smi_core/@ChannelRegistration/pairCoordinates.m
function [PairMap12, PairMap21] = pairCoordinates(Coords1, Coords2, ...
    SeparationThreshold)
%pairCoordinates pairs sets of coordinates with each other.
% This method will pair the coordinates in Coords1 with the coordinates in
% Coords2 based on their distance (i.e., this finds the nearest neighbor of
% each of Coords1 in Coords2), ensuring the Threshold is note exceeded and
% that no duplicate pairings are made (each of Coords1 is only paired to
% one of Coords2, and vice versa).
%
% INPUTS:
%   Coords1: A set of x,y coordinates (numeric array, Mx2)
%   Coords2: A set of x,y coordinates to be paired with Coords1
%            (numeric array, Nx2)
%   SeparationThreshold: Maximum distance between paired coordinates.
%                        (Pixels)(positive scalar)(Default = inf)
% 
% OUTPUTS:
%   PairMap12: Array specifying how Coords1 and Coords2 were paired.  For
%              example, if PairMap12(7) = 5, Coords1(7, :) and 
%              Coords2(5, :) were paired together.  A NaN marker indicates 
%              a pairing was not made for that index.
%              (Px1 array, P<=min(M, N))
%   PairMap21: Array specifying how Coords1 and Coords2 were paired.  For
%              example, if PairMap21(3) = 12, Coords2(3, :) and 
%              Coords1(12, :) were paired together.  A NaN marker indicates 
%              a pairing was not made for that index.
%              (Px1 array, P<=min(M, N))

% Created by:
%   David J. Schodt (Lidke Lab, 2020)


% Set defaults if needed.
if (~exist('SeparationThreshold', 'var') || isempty(SeparationThreshold))
    SeparationThreshold = inf;
end

% Loop through Coords1 and search for the nearest neighbor.
NCoords1 = size(Coords1, 1);
PairMap12 = NaN(NCoords1, 1);
PairMap21 = PairMap12;
for ii = 1:NCoords1
    % Find the nearest coordinate in Coords2 to Coords1(ii, :).
    Separation = sqrt((Coords1(ii, 1)-Coords2(:, 1)).^2 ...
        + (Coords1(ii, 2)-Coords2(:, 2)).^2);
    [MinSeparation, NearestNeighborIndex] = min(Separation);
    if ((MinSeparation<=SeparationThreshold) ...
            && ~ismember(NearestNeighborIndex, PairMap12))
        PairMap12(ii) = NearestNeighborIndex;
        PairMap21(NearestNeighborIndex) = ii;
    end
end


end
./MATLAB/+smi_core/@ChannelRegistration/visualizeCoordTransform.m
function [PlotFigure] = visualizeCoordTransform(PlotFigure, ...
    RegistrationTransform, FrameSize, GridSpacing)
%visualizeCoordTransform creates visuals for a coordinate transform.
% This method will plot the magnitude and gradient of RegistrationTransform
% at points within a FrameSize(1)xFrameSize(2) grid.
%
% NOTE: Default values can be used (when available) by setting the
%       corresponding input to [].  For example, 
%       visualizeCoordTransform([], TForm, FrameSize) will use a default
%       value for PlotFigure.
%
% INPUTS:
%   PlotFigure: Figure in which we will make the plots. (Default = gcf())
%   RegistrationTransform: RegistrationTransform is a MATLAB tform object
%                          describing the transform to be visualized.
%                          (tform object)
%   FrameSize: Size of the frame (ROI) within which RegistrationTransform 
%              can be applied. (Pixels)(2x1, [YSize, XSize])
%   GridSpacing: Spacing of a grid made across FrameSize.  The grid will
%                consist of points
%                [0:GridSpacing:FrameSize(1), 0:GridSpacing:FrameSize(2)] 
%                at which we will apply RegistrationTransform.
%                (Pixels)(Default = 1)
%
% OUTPUTS:
%   PlotFigure: A MATLAB figure handle for the figure in which the 
%               visualizations are contained. 

% Created by:
%   David J. Schodt (Lidke Lab, 2020)


% Set default parameters if needed.
if (~exist('PlotFigure', 'var') || isempty(PlotFigure) ...
        || ~isvalid(PlotFigure))
    PlotFigure = gcf();
end
if (~exist('GridSpacing', 'var') || isempty(GridSpacing))
    GridSpacing = 1;
end

% Compute a "heatmap" of the transform magnitude across the ROI, as well as
% the gradient of this heatmap.
[XGrid, YGrid] = meshgrid(0:GridSpacing:FrameSize(2), ...
    0:GridSpacing:FrameSize(1));
TransformedCoords = smi_core.ChannelRegistration.transformCoords(...
    RegistrationTransform, [XGrid(:), YGrid(:)]);
XGridTransformed = reshape(TransformedCoords(:, 1), size(XGrid));
YGridTransformed = reshape(TransformedCoords(:, 2), size(YGrid));
TransformMagnitude = sqrt((XGrid-XGridTransformed).^2 ...
    + (YGrid-YGridTransformed).^2);
[XDerivative, YDerivative] = gradient(TransformMagnitude);
GradientMagnitude = sqrt(XDerivative.^2 + YDerivative.^2);
TransformMean = mean(TransformMagnitude(:));
TransformStD = std(TransformMagnitude(:));
OutlierBool = ((TransformMagnitude-TransformMean) > 2*TransformStD);
TransformMagnitude(OutlierBool) = max(TransformMagnitude(~OutlierBool));

% Plot the heatmap.
PlotAxesTop = subplot(1, 2, 1, 'Parent', PlotFigure);
PlotAxesTop.YDir = 'reverse';
axis(PlotAxesTop, 'tight');
axis(PlotAxesTop, 'equal');
hold(PlotAxesTop, 'on');
surface(PlotAxesTop, XGrid, YGrid, TransformMagnitude, ...
    'EdgeColor', 'none')
title(PlotAxesTop, 'sqrt(XCorrection^2 + YCorrection^2)')
xlabel(PlotAxesTop, 'X (pixels)')
ylabel(PlotAxesTop, 'Y (pixels)')
RegColorBar = colorbar(PlotAxesTop);
RegColorBar.Label.String = 'Magnitude of correction (pixels)';
PlotAxesBottom = subplot(1, 2, 2, 'Parent', PlotFigure);
PlotAxesBottom.YDir = 'reverse';
axis(PlotAxesBottom, 'tight');
axis(PlotAxesBottom, 'equal');
hold(PlotAxesBottom, 'on');
surface(PlotAxesBottom, XGrid, YGrid, GradientMagnitude, ...
    'EdgeColor', 'none')
title(PlotAxesBottom, 'sqrt(XDerivative^2 + YDerivative^2)')
xlabel(PlotAxesBottom, 'X (pixels)')
ylabel(PlotAxesBottom, 'Y (pixels)')
RegColorBar = colorbar(PlotAxesBottom);
RegColorBar.Label.String = 'Magnitude of gradient';


end
./MATLAB/+smi_core/@ChannelRegistration/simFiducials.m
function [RawData, Files] = simFiducials(ROISize, NRows, SaveDir)
%simFiducials simulates two channel fiducials to test channel registration.
% This method simulates a grid of test points with an affine transform
% shifting points from the reference channel.
%
% INPUTS:
%   ROISize: Size of the simulated fiducials. (Scalar)(Default=128)
%   NRows: Number of rows and columns of fiducial points.
%          (Scalar)(Default=8)
%   SaveDir: Optional save directory.  If provided, fiducials will be saved
%            in two separate files in the directory as 
%            "fiducial1<time>.mat" and "fiducial2<time>.mat", where
%            "<time>" is a timestamp generated upon saving.
%
% OUTPUTS:
%   RawData: Simulated two-channel noise-free fiducial data. Channel 1 is
%            the reference channel and channel 2 is the moving channel.
%            (ROISize x ROISize x 2)
%   Files: If "SaveDir" was given, this will be a cell array of the
%          filenames where the fiducials were saved.  Files{1} points to
%          the reference, Files{2} to the moving channel, and Files{3} to a
%          file containing a single image with both channels stored
%          side-by-side.

% Created by:
%   David J. Schodt (Lidke Lab, 2023)


% Set defaults.
if (~exist('ROISize', 'var') || isempty(ROISize))
    ROISize = 128;
end
if (~exist('NRows', 'var') || isempty(NRows))
    NRows = 8;
end

% Simulate several emitter positions.
% NOTE: Most of these parameters were chosen arbitrarily.
rng(1234)
GridSpacing = ROISize / (NRows+1);
[XMesh, YMesh] = meshgrid(GridSpacing:GridSpacing:(ROISize-GridSpacing));
Coordinates = [XMesh(:), YMesh(:)];

% Construct a "fixed" (reference) SMD structure.
NEmitters = NRows ^ 2;
PhotonSum = 1e4;
Background = 5;
PSFSigma = 1.3;
OnesArray =  ones(NEmitters, 1);
SMDFixed = smi_core.SingleMoleculeData.createSMD();
SMDFixed.X = reshape(Coordinates(:, 1), NEmitters, 1);
SMDFixed.Y = reshape(Coordinates(:, 2), NEmitters, 1);
SMDFixed.Photons = PhotonSum * OnesArray;
SMDFixed.Bg = Background * OnesArray;
SMDFixed.PSFSigma = PSFSigma;
SMDFixed.FrameNum = ones(NEmitters, 1);
SMDFixed.NFrames = 1;
SMDFixed.DatasetNum = OnesArray;
SMDFixed.ThreshFlag = 0 * OnesArray;

% Construct the artificially shifted "moving" SMD structure by applying an
% affine transform to it.
% NOTE: These numbers were just made up at the time of writing to give
%       something that looked reasonable.
RotationAngle = 0.0123 * (pi/180);
Shift = [1; 2];
Shear = [0.01; 0.005];
Scale = [1.005; 1.001];
RotationMatrix = [cos(RotationAngle), -sin(RotationAngle); ...
    sin(RotationAngle), cos(RotationAngle)];
ShearMatrix = [1, Shear(1); ...
    Shear(2), 1];
ScaleMatrix = [Scale(1), 0; ...
    0, Scale(2)];
WarpingMatrix = RotationMatrix * ShearMatrix * ScaleMatrix;
Coords = [SMDFixed.X, SMDFixed.Y].';
WarpedCoords = Coords.';
for ii = 1:size(Coords, 2)
    WarpedCoords3D = WarpingMatrix*Coords(:, ii) + Shift;
    WarpedCoords(ii, :) = WarpedCoords3D(1:2).';
end
SMDMoving = SMDFixed;
SMDMoving.X = WarpedCoords(:, 1);
SMDMoving.Y = WarpedCoords(:, 2);

% Simulate some raw data.
% NOTE: Warping the first image to make the moving image would be faster,
%       but I'm not doing that because this is slightly easier to code...
SMF = smi_core.SingleMoleculeFitting;
SMF.Data.DataROI = [1, 1, ROISize, ROISize];
[~, RawData] = smi_sim.GaussBlobs.gaussBlobImage(...
    SMDFixed, SMF, Background);
[~, RawData(:, :, 2)] = smi_sim.GaussBlobs.gaussBlobImage(...
    SMDMoving, SMF, Background);

% If needed, save the fiducials as .mat files.
if exist('SaveDir', 'var')
    if ~isfolder(SaveDir)
        mkdir(SaveDir)
    end

    % Save fiducials in separate files.
    TimeString = smi_helpers.genTimeString();
    sequence = RawData(:, :, 1);
    Files{1, 1} = fullfile(SaveDir, ...
        sprintf('fiducial1_%s.mat', TimeString));
    save(Files{1}, 'sequence')
    sequence = RawData(:, :, 2);
    Files{2, 1} = fullfile(SaveDir, ...
        sprintf('fiducial2_%s.mat', TimeString));
    save(Files{2}, 'sequence')

    % Save fiducials in a single file, side-by-side.
    sequence =  [RawData(:, :, 1), RawData(:, :,  2)];
    Files{3, 1} = fullfile(SaveDir, ...
        sprintf('fiducial12_%s.mat', TimeString));
    save(Files{3}, 'sequence')
end


end

./MATLAB/+smi_core/@ChannelRegistration/visualizeImageTransform.m
function [PlotAxes] = visualizeImageTransform(PlotAxes, ...
    RegistrationTransform, FrameSize, GridSpacing)
%visualizeImageTransform creates visuals for an image transform.
% This method will create a grid image and apply RegistrationTransform to
% it so as to help us visualize what the transform is doing.
%
% NOTE: Default values can be used (when available) by setting the
%       corresponding input to [].  For example, 
%       visualizeImageTransform([], TForm, FrameSize) will use a default
%       value for PlotAxes.
%
% INPUTS:
%   PlotAxes: Axes in which we will make the plots. (Default = gca())
%   RegistrationTransform: RegistrationTransform is a MATLAB tform object
%                          describing the transform to be visualized.
%                          (tform object)
%   FrameSize: Size of the frame (ROI) within which RegistrationTransform 
%              can be applied. (Pixels)(1x2, [YSize, XSize])
%   GridSpacing: Spacing between grid lines in the grid image that we will
%                transform.  For example, in 1D, GridSpacing = 2 would give
%                us a grid image that looks like [1, 0, 1, 0, ...]
%                (Pixels)(Default = 10)
%
% OUTPUTS:
%   PlotAxes: A MATLAB axes handle for the axes in which the 
%             visualizations are contained. 

% Created by:
%   David J. Schodt (Lidke Lab, 2020)


% Set default parameters and modify inputs if needed.
if (~exist('PlotAxes', 'var') || isempty(PlotAxes) ...
        || ~isvalid(PlotAxes))
    PlotAxes = gca();
end
if (~exist('GridSpacing', 'var') || isempty(GridSpacing))
    GridSpacing = 10;
end
if (size(FrameSize,  1) > size(FrameSize, 2))
    FrameSize = FrameSize.';
end

% Create a grid image that we can transform.
GridImage = zeros(FrameSize);
GridImage(1:GridSpacing:FrameSize(1), :) = 1;
GridImage(:, 1:GridSpacing:FrameSize(2)) = 1;

% Transform the grid image.
TransformedGrid = smi_core.ChannelRegistration.transformImages(...
    RegistrationTransform, GridImage);

% Create an RGB image containing the original and transformed grid (to help
% show the changes).
ComparisonImage  = zeros([FrameSize, 3]);
ComparisonImage(:, :, 2) = GridImage;
ComparisonImage(:, :, 1) = TransformedGrid;
ComparisonImage(:, :, 3) = TransformedGrid;

% Display the grid image in the desired PlotAxes.
imshow(ComparisonImage, 'Parent', PlotAxes)


end
./MATLAB/+smi_core/@ChannelRegistration/findTransform.m
function [RegistrationTransform] = findTransform(obj)
%findTransform finds a channel registration transform.
% This method will find a channel registration transform object that is
% intended to register coordinates from/features in the fiducial files
% specified by obj.SMF.Data.FileNames.
%
% OUTPUTS:
%   RegistrationTransform: A cell array of MATLAB tform objects (this
%                          will be the same cell array stored in
%                          obj.RegistrationTransform). (cell array)
%
% REQUIRES:
%   MATLAB 2013b or later
%   Image Processing Toolbox (to use fitgeotrans())

% Created by:
%   David J. Schodt (Lidke Lab, 2020)


% Load the fiducial images/ensure the manually set fiducials are consistent
% with some other class properties.
if (obj.Verbose > 0)
    fprintf(['\tChannelRegistration.findTransform(): ', ...
        'Computing channel registration transform...\n'])
end
if (obj.Verbose > 1)
    fprintf(['\tChannelRegistration.findTransform(): ', ...
        'Loading fiducials...\n'])
end
if obj.ManualSetFiducials
    obj.SplitFormat = 1;
    assert(~isempty(obj.FiducialImages), ...
        'You must set obj.FiducialImages if obj.ManualSetFiducials is true')
    ImageSize = size(obj.FiducialImages);
    if (size(obj.FiducialROI, 1) ~= ImageSize(3))
        obj.FiducialROI = ...
            repmat([1, 1, ImageSize(1:2), 1, 1], ImageSize(3), 1);
        if (obj.Verbose > 0)
            warning(['ChannelRegistration.findTransform(): FiducialROI ', ...
                'reset to a default based on the size of FiducialImages.'])
        end
    end
else
    obj.loadFiducials()
end
NFiducials = size(obj.FiducialImages, 3);

% Perform the gain and offset correction on each of the fiducial images
% (this probably doesn't matter for image transforms, but I'm going to do
% this up here anyways because it looks cleaner).  If
% obj.AutoscaleFiducials is set, we'll attempt to autoscale the fiducials
% instead of doing a proper gain/offset correction.
if (obj.Verbose > 1)
    fprintf(['\tChannelRegistration.findTransform(): ', ...
        'Rescaling fiducial images...\n'])
end
ScaledData = obj.rescaleFiducials(obj.FiducialImages, ...
    obj.SMF, obj.AutoscaleFiducials);

% If autoscaling, multiply by an extra factor so that the counts are
% somewhat realistic for a camera (having the range [0, 1] messes up the
% fitting, presumably because it seems like 0 photons but I'm not sure).
if obj.AutoscaleFiducials
    ScaledData = 100 * ScaledData;
end

% Proceed based on the setting of obj.TransformationBasis (which defines
% whether or not we need to find localizations from the fiducial data).
RegistrationTransform = cell(NFiducials, 1);
switch obj.TransformationBasis
    case 'coordinates'
        % Use smi_core.LocalizeData to find localizations in the fiducial
        % images.
        if (obj.Verbose > 1)
            fprintf(['\tChannelRegistration.findTransform(): ', ...
                'Fitting localizations in fiducial images...\n'])
        end
        LocalizeData = smi_core.LocalizeData([], obj.SMF);
        FiducialSMD = cell(NFiducials, 1);
        FiducialSMDPreThresh = FiducialSMD;
        for ii = 1:NFiducials
            LocalizeData.ScaledData = ScaledData(:, :, ii);
            [FiducialSMD{ii}, FiducialSMDPreThresh{ii}] = ...
                LocalizeData.genLocalizations();
        end
        
        % Attempt to pair the sets of coordinates, treating the first set
        % as the reference.
        if (obj.Verbose > 1)
            fprintf(['\tChannelRegistration.findTransform(): ', ...
                'Pairing localizations in fiducial images...\n'])
        end
        Coords1 = [FiducialSMD{1}.X, FiducialSMD{1}.Y];
        FinalCoordinates = cell(NFiducials, 1);
        FinalCoordinates{1} = repmat(Coords1, [1, 1, 2]);
        for ii = 2:NFiducials
            % Pair the coordinates.
            Coords2 = [FiducialSMD{ii}.X, FiducialSMD{ii}.Y];
            PairMap12 = obj.pairCoordinates(Coords1, Coords2, ...
                obj.SeparationThreshold);
            
            % Define PairedCoordinates{ii} as a 3D array, with the
            % third dimension corresponding to the fiducial number.
            IsPairedCoords1 = ~isnan(PairMap12);
            PairedCoordinates = cat(3, ...
                Coords1(IsPairedCoords1, :), ...
                Coords2(PairMap12(IsPairedCoords1), :));
            
            % If needed, let the user manually cull pairs of points (there
            % might be some non-sensical pairings/localizations).
            if obj.ManualCull
                if (obj.Verbose > 1)
                    fprintf(['\tChannelRegistration.findTransform(): ', ...
                        'Culling localization pairs...\n'])
                end
                [FinalCoordinates{ii}] = obj.performManualCull(...
                    obj.FiducialImages, PairedCoordinates);
            else
                FinalCoordinates{ii} = PairedCoordinates;
            end
            
            % Compute the transform.
            if (obj.Verbose > 2)
                fprintf(['\tChannelRegistration.findTransform(): ', ...
                    'Computing ''%s'' transform from ', ...
                    'localizations\n\t\tusing fitgeotrans()...\n'], ...
                    obj.TransformationType)
            elseif (obj.Verbose > 1)
                fprintf(['\tChannelRegistration.findTransform(): ', ...
                    'Computing transform from localizations...\n'])
            end
            switch obj.TransformationType
                case 'lwm'
                    RegistrationTransform{ii} = fitgeotrans(...
                        FinalCoordinates{ii}(:, :, 2), ...
                        FinalCoordinates{ii}(:, :, 1), ...
                        obj.TransformationType, obj.NNeighborPoints);
                case 'polynomial'
                    RegistrationTransform{ii} = fitgeotrans(...
                        FinalCoordinates{ii}(:, :, 2), ...
                        FinalCoordinates{ii}(:, :, 1), ...
                        obj.TransformationType, obj.PolynomialDegree);
                otherwise
                    RegistrationTransform{ii} = fitgeotrans(...
                        FinalCoordinates{ii}(:, :, 2), ...
                        FinalCoordinates{ii}(:, :, 1), ...
                        obj.TransformationType);
            end
            obj.Coordinates = FinalCoordinates;
        end
    case 'images'
        % Find the transform directly from the images.
        if (obj.Verbose > 1)
            fprintf(['\tChannelRegistration.findTransform(): ', ...
                'Computing transform directly from images...\n'])
        end
        [Optimizer, Metric] = imregconfig('multimodal');
        for ii = 2:NFiducials
            RegistrationTransform{ii} = imregtform(...
                ScaledData(:, :, ii), ScaledData(:, :, 1), ...
                obj.TransformationType, Optimizer, Metric);
        end
    otherwise
        fprintf(['Unrecognized transformation basis:\n', ...
            'obj.TransformationBasis = %s\n'], obj.TransformationBasis)
end
obj.RegistrationTransform = RegistrationTransform;
if (obj.Verbose > 0)
    fprintf(['\tChannelRegistration.findTransform(): ', ...
        'Call to findTransform() complete.\n'])
end


end
./MATLAB/+smi_core/@ChannelRegistration/visualizeRegistrationError.m
function [PlotAxes] = visualizeRegistrationError(PlotAxes, ...
    RegistrationTransform, MovingCoordinates, FixedCoordinates, ...
    FOV, GridSpacing)
%visualizeRegistrationError visualizes the error in RegistrationTransform
% This method will plot the error of RegistrationTransform.  This is done
% by finding the registration error as the root mean square difference
% between the fiducial coordinates being compared after transforming (e.g.,
% fiducial 1 localizations and transformed fiducial 2 localizations) and
% interpolating between the points to produce a smooth heat map type image
% estimate of the error. 
%
% NOTE: For some transforms, we have to treat FixedCoordinates as the
%       moving pair (forward transforms don't exist for some transforms).  
%
% NOTE: Default values can be used (when available) by setting the
%       corresponding input to [].  For example, 
%       visualizeRegistrationError([], TForm, Coords1, Coords2) will use a
%       default value for PlotAxes.
%
% INPUTS:
%   PlotAxes: Axes in which we will make the plots. (Default = gca())
%   RegistrationTransform: RegistrationTransform is a MATLAB tform object
%                          describing the transform to be visualized.
%                          (tform object)
%   MovingCoordinates: Coordinates of points in the second fiducial.
%                      (Nx2 numeric array)
%   FixedCoordinates: Coordinates of points in the first fiducial.
%                     (Nx2 numeric array)
%   FOV: Field of view in which we will estimate the error.
%        (Pixels)(1x4, [XStart, YStart, XEnd, YEnd])
%        (Default is set to encompass all points in FixedCoordinates)
%   GridSpacing: Spacing of a grid made across FrameSize.  The grid will
%                consist of points
%                [0:GridSpacing:FrameSize(1), 0:GridSpacing:FrameSize(2)] 
%                at which we will apply RegistrationTransform.
%                (Pixels)(Default = 1)
% OUTPUTS:
%   PlotAxes: A MATLAB axes handle for the axes in which the 
%             visualizations are contained. 

% Created by:
%   David J. Schodt (Lidke Lab, 2020)


% Set default parameters and modify inputs.
FixedCoordinates = double(FixedCoordinates);
MovingCoordinates = double(MovingCoordinates);
if (~exist('PlotAxes', 'var') || isempty(PlotAxes) ...
        || ~isvalid(PlotAxes))
    PlotAxes = gca();
end
if (~exist('GridSpacing', 'var') || isempty(GridSpacing))
    GridSpacing = 1;
end
if (~exist('FOV', 'var') || isempty(FOV))
    FOV = [floor(min(FixedCoordinates(:, 1))-GridSpacing), ...
        floor(min(FixedCoordinates(:, 2))-GridSpacing), ...
        ceil(max(FixedCoordinates(:, 1))+GridSpacing), ...
        ceil(max(FixedCoordinates(:, 2))+GridSpacing)];
end

% Compute the squared difference between FixedCoordinates and transformed 
% MovingCoordinates.
SquaredError = smi_core.ChannelRegistration.estimateRegistrationError(...
    RegistrationTransform, MovingCoordinates, FixedCoordinates);

% Create an interpolant function handle for our registration error.
InterpolantFunction = scatteredInterpolant(...
    FixedCoordinates(:, 1), FixedCoordinates(:, 2), ...
    double(SquaredError), ...
    'natural', 'linear');

% Estimate the squared error on a grid.
[XGrid, YGrid] = ...
    meshgrid(FOV(1):GridSpacing:FOV(3), FOV(2):GridSpacing:FOV(4));
SquaredErrorGrid = InterpolantFunction(XGrid(:), YGrid(:));

% Display the grid of estimated squared errors.
SquaredErrorGrid = reshape(SquaredErrorGrid, size(XGrid));
ImshowCorrection = [0.5, -0.5];
imshow(SquaredErrorGrid, [], 'Parent', PlotAxes, ...
    'XData', FOV([1, 3])+ImshowCorrection, ...
    'YData', FOV([2, 4])+ImshowCorrection)
colormap(PlotAxes, 'parula')
title(PlotAxes, ...
    'Squared registration error (interpolated) in full field of view')
xlabel(PlotAxes, 'X (pixels)')
ylabel(PlotAxes, 'Y (pixels)')
axis(PlotAxes, 'tight')
ColorBar = colorbar(PlotAxes);
ColorBar.Label.String = 'Squared error (pixels^2)';

% Plot the true points as a visual reference.
hold(PlotAxes, 'on');
line(PlotAxes, FixedCoordinates(:, 1), FixedCoordinates(:, 2), ...
    'Color', 'k', 'Marker', '.', 'LineStyle', 'none')


end
./MATLAB/+smi_core/@ChannelRegistration/loadFiducials.m
function [] = loadFiducials(obj)
%loadFiducials loads fiducial files and sets associated class properties.
% This method will load the fiducial files specified by the fields in
% obj.SMF.Data.  Once the files are loaded, this method will set various
% other class properties based on the fiducial images.

% Created by:
%   David J. Schodt (Lidke Lab, 2021)


% Load the first fiducial file and set obj.FiducialROI to a default if
% needed.
% NOTE: I'll be averaging over the "time" dimension of all fiducials used.
NFiles = numel(obj.SMF.Data.FileName);
if (obj.Verbose > 1)
    fprintf(['\tChannelRegistration.loadFiducials(): ', ...
        'Loading %i fiducial files from %s...\n'], ...
        NFiles, obj.SMF.Data.FileDir)
end
LoadData = smi_core.LoadData;
[~, TempImage] = ...
    LoadData.loadRawData(obj.SMF, 1, obj.SMF.Data.DataVariable);
ImageSize = size(TempImage);
FullROI = [1, 1, ImageSize(1:2)];
if isempty(obj.SplitFormat)
    % When obj.SplitFormat is empty, the user must manually define
    % obj.FiducialROI!
    if isempty(obj.FiducialROI)
        error(['loadFiducials(): If you set obj.SplitFormat = [], ', ...
            'you must also manually define obj.FiducialROI'])
    end
else
    % We must define (or re-define) obj.FiducialROI based on
    % obj.SplitFormat and the number of files present.
    if (NFiles == 1)
        % Split the file into the specified ROIs.
        if (obj.SplitFormat == 1)
            % In this case, the user hasn't selected an appropriate
            % SplitFormat for the single file case, so we'll define a
            % (hopefully) useful default.
            if (ImageSize(1) > ImageSize(2))
                obj.SplitFormat = [1; 2];
            else
                obj.SplitFormat = [1, 2];
            end
            if (obj.Verbose > 0)
                warning(['loadFiducials(): obj.SplitFormat ', ...
                    'reset to [%i, %i]'], ...
                    obj.SplitFormat(1), obj.SplitFormat(2))
            end
        end
        obj.FiducialROI = obj.convertSplitFormatToROIs(...
            FullROI, obj.SplitFormat);
    elseif (NFiles > 1)
        % For multiple files, we'll set FiducialROI s.t. each image is used
        % in it's entirety.  If one of the images is too small, everything
        % will crash, but I'll assume that's the users fault!
        obj.SplitFormat = 1;
        obj.FiducialROI = [FullROI, 1, 1];
    else
        error('loadFiducials(): no files defined in obj.SMF.Data.FileName')
    end
end

% Load the remaining fiducial images/split the fiducial into the specified
% ROIs for later use.
NROIs = size(obj.FiducialROI, 1);
if (NROIs == 1)
    % All fiducial images are stored in separate files, so we'll have to
    % load them one at a time.
    NFiducials = NFiles;
    FiducialImages = zeros([obj.FiducialROI(1, 3:4), NFiducials]);
    FiducialImages(:, :, 1) = mean(TempImage(...
        obj.FiducialROI(1):obj.FiducialROI(3), ...
        obj.FiducialROI(2):obj.FiducialROI(4)), ...
        3);
    for ii = 2:NFiducials
        [~, TempImage] = ...
            LoadData.loadRawData(obj.SMF, ii, obj.SMF.Data.DataVariable);
        FiducialImages(:, :, ii) = mean(TempImage(...
            obj.FiducialROI(1):obj.FiducialROI(3), ...
            obj.FiducialROI(2):obj.FiducialROI(4), :), ...
            3);
    end
else
    % There is only one fiducial image, which we'll need to split by ROI.
    if (obj.Verbose > 1)
        fprintf(['\tChannelRegistration.loadFiducials(): ', ...
            'Splitting fiducial image into channels.\n'])
    end
    NFiducials = NROIs;
    FiducialImages = zeros(...
        [obj.FiducialROI(1, 3:4)-obj.FiducialROI(1, 1:2)+1, NFiducials]);
    for ii = 1:NFiducials
        FiducialImages(:, :, ii) = mean(TempImage(...
            obj.FiducialROI(ii, 1):obj.FiducialROI(ii, 3), ...
            obj.FiducialROI(ii, 2):obj.FiducialROI(ii, 4), ...
            obj.FiducialROI(ii, 5):obj.FiducialROI(ii, 6):end), ...
            3);
    end
end
obj.FiducialImages = FiducialImages;


end
./MATLAB/+smi_core/@ChannelRegistration/transformCoords.m
function [MovingCoordsTransformed] = ...
    transformCoords(RegistrationTransform, MovingCoords)
%transformCoords transforms a set of coordinates with the given transform.
% This method transforms the input coordinates, with the set being
% transformed depending on the type of transform.  The purpose of this
% method is to overcome the annoyances/issues that may arise when applying 
% the transform directly (e.g., 'lwm' doesn't have a forward transform, so
% we have to do "reverse" the effect of that transform). 
%
% INPUTS:
%   RegistrationTransform: RegistrationTransform is a MATLAB tform object
%                          describing the transform to be visualized.
%                          (tform object)
%   MovingCoords: Coordinates of points in the "moving" fiducial.
%                 (Nx2 numeric array)
%
% OUTPUTS:
%   MovingCoordsTransformed: Input 'MovingCoords' transformed by 
%                            'RegistrationTransform'. 
%                            (Nx2 numeric array)

% Created by:
%   David J. Schodt (Lidke Lab, 2020)


% Determine the transformation type and proceed as appropriate.
if ismember(class(RegistrationTransform), ...
        {'images.geotrans.LocalWeightedMeanTransformation2D', ...
        'images.geotrans.PolynomialTransformation2D', ...
        'images.geotrans.PiecewiseLinearTransformation2D'})
    % Since these transforms only have the transformPointsInverse() method,
    % we'll need to "reverse" the transform at each point (i.e., use the
    % inverse transform, see how far points moved, and then move the
    % initial points the same amount in the opposite direction).
    MovingCoordsTransformed = ...
        smi_core.ChannelRegistration.transformCoordsDirect(...
        RegistrationTransform, MovingCoords);
    MovingCoordsTransformed = 2*MovingCoords - MovingCoordsTransformed;
else
    MovingCoordsTransformed = ...
        smi_core.ChannelRegistration.transformCoordsDirect(...
        RegistrationTransform, MovingCoords);
end


end
./MATLAB/+smi_core/@ChannelRegistration/README.md
### +smi_core/@ChannelRegistration

This class contains methods for performing channel registration and
methods used to interpret/visualize the results.

REQUIRES:
- MATLAB 2019b or later (some newer method inputs are used, e.g.,
      size(Image, [1, 2]) wasn't allowed pre-2019b).
- Image Processing Toolbox
- Statistics and Machine Learning Toolbox

---
    
```
properties:
   % Single molecule fitting structure (see SingleMoleculeFitting)
   % This SMF structure is used to find localizations in the fiducial
   % files specified by FiducialFilePath.  If
   % TransformationBasis = 'images' this is not needed.
   SMF
   
   % Coords used to compute transforms (cell array of numeric array)
   % These coordinates are ordered as follows: the coordinates used to
   % find a transform from fiducial m to fiducial n will be stored in
   % Coordinates{m}.  The coordinates from fiducial m will be in
   % Coordinates{m}(:, :, m), and those from fiducial n will be in
   % Coordinates{m}(:, :, n), with each of these being organized as
   % two-column arrays [X, Y].
   Coordinates cell
   
   % Indicates fiducial images set manually by user. (Default = false)
   % This can be useful if the user already has the set of fiducial
   % images loaded into their workspace (e.g., if they were simulated
   % and not saved to a file).
   % NOTE: If using this setting, the fiducials must be
   %       "pre-processed" before setting to obj.FiducialImages (e.g.,
   %       truncated to proper ROI, averaged over time, ...).
   %       Furthermore, obj.FiducialROI should be set to the
   %       appropriate value so that the correct ROI is saved along
   %       with the transform. obj.SplitFormat cannot be used with
   %       this setting.
   ManualSetFiducials(1, 1) logical = false;
   
   % Fiducial images (numeric array, MxP(xNFiducials))
   FiducialImages {mustBeNumeric(FiducialImages)}
   
   % Format guiding the fiducial ROIs to be used (Default = [1])
   % (see obj.convertSplitFormatToROIs() for a more complete
   % description).
   % NOTE: If you wish to manually set obj.FiducialROI, you must set
   %       obj.SplitFormat = [].
   SplitFormat {mustBeInteger(SplitFormat)} = 1;
   
   % Fiducial ROIs ([YStart, XStart, YEnd, XEnd, ZStart, ZPeriod])
   % NOTE: In its current usuage, FiducialROI is set automatically in
   %       findTransform(), or manually by the user.
   % NOTE: If you wish to manually define this array, you must set
   %       obj.SplitFormat = [].  Otherwise, the ROI splitting scheme
   %       defined by obj.SplitFormat takes precedence.
   % OPTIONS:
   %   If size(FiducialROI, 1) == 1, each image in FiducialImages will
   %       be truncated to the ROI specified by FiducialROI before
   %       computing the transform.
   %   If size(FiducialROI, 1) > 1, the image found in in
   %       SMF.Data.FileName{1} will be split up into
   %       the ROIs defined by each row of FiducialROI.  Each row of
   %       FiducialROI must specify an equal size ROI.
   %       FiducialROI(1, :) will be treated as the "reference" (or
   %       "fixed") fiducial, meaning all other ROIs will be
   %       transformed w.r.t. FiducialROI(1, :).  Furthermore, the
   %       properties 'Coordinates' and 'RegistrationTransform' will
   %       follow the same ordering as FiducialROI.
   %   If FiducialROI is not set by the user, it will be given a
   %       default depending on how many files are specified by
   %       obj.SMF.Data.FileName.  If there is only one file,
   %       FiducialROI will be set by default s.t. the image in the
   %       one file will be split in two along its columns.  If there
   %       are multiple files,
   %       FiducialROI = [1, 1, size(FiducialImages(:, :, 1))]
   %       where FiducialImages will contain the image stored in the
   %       file obj.SMF.Data.FileName.
   FiducialROI(:, 6) {mustBeInteger(FiducialROI)}
   
   % Data used to compute transform (char)(Default = 'coordinates')
   % OPTIONS:
   %   'coordinates': localizations (defined by (x, y) coordinates)
   %                  are used to find the transform.
   %   'images': images are used directly to find the transform.
   TransformationBasis char {mustBeMember(TransformationBasis, ...
       {'coordinates', 'images'})} = 'coordinates';
   
   % Type of transform to be computed (char array)(Default = 'lwm')
   % OPTIONS:
   %   If TransformationBasis = 'coords', this can be set to any of
   %       the transformationType options defined in doc fitgeotrans
   %   If TransformationBasis = 'images', this can be set to any of
   %       the transformType options defined in doc imregtform.
   TransformationType char = 'lwm';
   
   % Threshold for pairing localizations (Pixels)(Default = inf)
   % This only matters when TransformationBasis = 'coords'.
   SeparationThreshold(1, 1) = inf;
   
   % # of neighbor points used to compute transform (Default = 12)
   % This is only used when TransformationType = 'lwm'
   NNeighborPoints(1, 1) {mustBeInteger, ...
       mustBeGreaterThan(NNeighborPoints, 5)} = 12;
   
   % Degree of polynomial for 'polynomial' tform (Default = 2)
   % This is only used when TransformationType = 'polynomial'.
   PolynomialDegree(1, 1) ...
       {mustBeMember(PolynomialDegree, [2, 3, 4])} = 2;
   
   % Auto-scale fiducial images (boolean)(Default = true)
   % This flag lets this class do a somewhat arbitrary scaling of the
   % fiducial images in an attempt to simplify the code usage.  This
   % allows us to avoid gain/offset correcting the data, which might
   % be annoying in some cases (as in, it's nice to just use the
   % default SMF instead of having to tweak parameters just for this
   % code).
   AutoscaleFiducials(1, 1) logical = true;
   
   % Manually cull localization pairs (boolean)(Default = true)
   % This flag lets the user manually cull the paired localizations
   % used to produce the transform (this is only applicable for
   % TransformationBasis = 'coords').
   ManualCull(1, 1) logical = true;
   
   % Verbosity level for standard workflow. (Default = 1)
   %   0: Command Window updates will be supressed where possible and
   %      reasonable.
   %   1: Some updates may appear in Command Window
   %   2: More detailed updates in Command Window
   %   3: Lot's of info. may be passed to Command Window. This mode
   %      may be useful for debugging large workflows encompassing
   %      this class.
   Verbose = 1;
```

---

methods:
- **[convertSplitFormatToROIs](convertSplitFormatToROIs.m)**:
  converts a split format to an array of ROIs
- **[estimateRegErrorLOO](estimateRegErrorLOO.m)**:
  estimates registration error by leave-one-out analysis
- **[estimateRegistrationError](estimateRegistrationError.m)**:
  estimates the registration error
- **[exportTransform](exportTransform.m)**:
  exports transform information into a .mat file
- **[findTransform](findTransform.m)**:
  finds a channel registration transform
- **[gui](gui.m)**:
  is the GUI method for the ChannelRegistration class
- **[loadFiducials](loadFiducials.m)**:
  loads fiducial files and sets associated class properties
- **[pairCoordinates](pairCoordinates.m)**:
  pairs sets of coordinates with each other
- **[performManualCull](performManualCull.m)**:
  performs the interactive (graphical) culling process
- **[plotCoordsOnData](plotCoordsOnData.m)**:
  plots coordinates in Coordinates on top of ScaledData
- **[rescaleFiducials](rescaleFiducials.m)**:
  rescales the images in Fiducials as needed
- **[simFiducials](simFiducials.m)**:
  simulates two channel fiducials to test channel registration
- **[transformCoords](transformCoords.m)**:
  transforms a set of coordinates with the given transform
- **[transformCoordsDirect](transformCoordsDirect.m)**:
  transforms a set of coordinates directly
- **[transformImages](transformImages.m)**:
  transforms a set of images with the given transform
- **[transformSMD](transformSMD.m)**:
  transforms SMD structures using the specified transform
- **[transformTR](transformTR.m)**:
  transforms a TR structure using the specified transform
- **[unitTest](unitTest.m)**:
  tests vital functionality of smi_core.ChannelRegistration
- **[visualizeCoordTransform](visualizeCoordTransform.m)**:
  creates visuals for a coordinate transform
- **[visualizeImageTransform](visualizeImageTransform.m)**:
  creates visuals for an image transform
- **[visualizeRegistrationError](visualizeRegistrationError.m)**:
  visualizes the error in RegistrationTransform
- **[visualizeRegistrationResults](visualizeRegistrationResults.m)**:
  shows registration results on the fiducials

./MATLAB/+smi_core/@ChannelRegistration/transformSMD.m
function [SMDMoving] = transformSMD(RegistrationTransform, SMDMoving)
%transformSMD transforms SMD structures using the specified transform.
% This method is just a wrapper around
% smi_core.ChannelRegistration.transformCoords(...) which was added for
% convenience.
%
% INPUTS:
%   RegistrationTransform: RegistrationTransform is a MATLAB tform object
%                          describing the transform to be visualized.
%                          (tform object)
%   SMDMoving: SMD structure (see SingleMoleculeData class) for the
%              "moving" fiducial (see
%              ChannelRegistration.transformCoords()).
%
% OUTPUTS:
%   SMDMoving: SMD structure (see SingleMoleculeData class) for the
%              "moving" fiducial (see 
%              ChannelRegistration.transformCoords()) which can be
%              considered transformed after passing through this method
%              (the actual transformed SMD will be either SMDMoving or
%              SMDFixed, depending on the transform used).

% Created by:
%   David J. Schodt (Lidke Lab, 2020)


% Check if the provided SMD has already been transformed.  If it has, don't
% proceed.
if (isfield(SMDMoving, 'IsTransformed') ...
        && ~isempty(SMDMoving.IsTransformed) ...
        && SMDMoving.IsTransformed)
    error(['The input ''SMD'' has already been transformed! If you intend ', ...
        'to apply another transform to this SMD, set SMD.IsTransformed ', ...
        'to false before proceeding.']);
end

% If the provided transform is empty, we don't need to proceed.
if isempty(RegistrationTransform)
    SMDMoving.IsTransformed = false;
    return
end

% Call transformCoords on the input SMDs.
MovingCoords = [SMDMoving.X, SMDMoving.Y];
MovingCoordsTransformed = ...
    smi_core.ChannelRegistration.transformCoords(...
    RegistrationTransform, MovingCoords);
SMDMoving.X = MovingCoordsTransformed(:, 1);
SMDMoving.Y = MovingCoordsTransformed(:, 2);

% Populate the fields 'XRegCorrection' and 'YRegCorrection'.
SMDMoving.XRegCorrection = ...
    MovingCoordsTransformed(:, 1) - MovingCoords(:, 1);
SMDMoving.YRegCorrection = ...
    MovingCoordsTransformed(:, 2) - MovingCoords(:, 2);

% Update the IsTransformed field.
SMDMoving.IsTransformed = true;


end
./MATLAB/+smi_core/@ChannelRegistration/performManualCull.m
function [CulledCoordinates] = performManualCull(RawData, Coordinates)
%performManualCull performs the interactive (graphical) culling process
% This method will plot RawData and points in Coordinates on the same
% axes.  The user can click points of interest to remove them (the 
% intention is that this method can be used to remove "bad" points so they
% don't contribute the the final transform computed from a set of SMDs).
%
% INPUTS:
%   RawData: Stack of images that will be plotted and have coordinates 
%            overlain. (numeric array, MxNx2)
%   Coordinates: Stack of paired coordinates. (numeric array, Px2x2)
%
% OUTPUTS:
%   CulledCoordinates: Subset of the input Coordinates containing only
%                      those points which weren't culled.
%                      (numeric array, Qx2x2, Q<=P)

% Created by:
%   David J. Schodt (Lidke Lab, 2020)


% Prepare a figure and axes for the plotting.
PlotFigure = figure();
PlotAxes = axes(PlotFigure);
axis(PlotAxes, 'tight')
axis(PlotAxes, 'equal')
PlotAxes.YDir = 'reverse';
title(PlotAxes, {'Click localizations to cull points', ...
    ['Right click in figure window (outside of axes) to undo ', ...
    'most recent cull'], 'Close the figure when finished'});
hold(PlotAxes, 'on');

% Plot the RawData and the localizations in Coordinates.  If there are more
% than 2 fiducials included, we'll do the culling process in a loop,
% treating the first image in RawData (and first element of Coordinates) as 
% the reference.
NPoints = size(Coordinates, 1);
[~, LineHandles] = smi_core.ChannelRegistration.plotCoordsOnData(...
    PlotAxes, RawData, {Coordinates(:, :, 1), Coordinates(:, :, 2)});

% Add the 'ButtonDownFcn' to each of LineHandles and the PlotFigure.
PlotFigure.ButtonDownFcn = @rightClickUndoCull;
MostRecentCull = [];
KeepPointsBool = ones(NPoints, 1, 'logical');
for ii = 1:NPoints
    LineHandles{1}(ii).ButtonDownFcn = {@localizationClicked, ii};
    LineHandles{2}(ii).ButtonDownFcn = {@localizationClicked, ii};
end

% Wait for the figure to be closed and then remove the points
% marked for removal.
waitfor(PlotFigure);
CulledCoordinates = Coordinates(KeepPointsBool, :, :);
clear('LineHandles')

    function localizationClicked(~, ~, ii)
        % This is the callback function called when a user clicks a
        % localization which they wish to remove from the FixedPoints and
        % MovingPoints arrays.        
        
        % Hide the culled points in the plot.
        LineHandles{1}(ii).Visible = 'off';
        LineHandles{2}(ii).Visible = 'off';
        
        % Mark the culled points in the point arrays that are used to
        % find the transform.
        KeepPointsBool(ii) = 0;
        MostRecentCull = ii;
    end

    function rightClickUndoCull(Source, ~)
        % This is the callback function called when a user right clicks the
        % figure, which will bring back the most recently culled pair of
        % localizations.
        
        % Check if this was a right click event, exiting this function if
        % it wasn't.
        if (~strcmpi(Source.SelectionType, 'alt') ...
                || isempty(MostRecentCull))
            return
        end
        
        % Undo the most recent cull.
        LineHandles{1}(MostRecentCull).Visible = 'on';
        LineHandles{2}(MostRecentCull).Visible = 'on';
        KeepPointsBool(MostRecentCull) = 1;
    end


end
./MATLAB/+smi_core/@ChannelRegistration/ChannelRegistration.m
classdef ChannelRegistration < handle
    %ChannelRegistration contains methods for channel registration.
    % This class contains methods for performing channel registration and
    % methods used to interpret/visualize the results.
    %
    % REQUIRES:
    %   MATLAB 2019b or later (some newer method inputs are used, e.g.,
    %       size(Image, [1, 2]) wasn't allowed pre-2019b).
    %   Image Processing Toolbox
    %   Statistics and Machine Learning Toolbox
    
    % Created by:
    %   David J. Schodt (Lidke Lab, 2020)
    
    
    properties
        % Single molecule fitting structure (see SingleMoleculeFitting)
        % This SMF structure is used to find localizations in the fiducial
        % files specified by FiducialFilePath.  If
        % TransformationBasis = 'images' this is not needed.
        SMF
        
        % Coords used to compute transforms (cell array of numeric array)
        % These coordinates are ordered as follows: the coordinates used to
        % find a transform from fiducial m to fiducial n will be stored in
        % Coordinates{m}.  The coordinates from fiducial m will be in
        % Coordinates{m}(:, :, m), and those from fiducial n will be in
        % Coordinates{m}(:, :, n), with each of these being organized as
        % two-column arrays [X, Y].
        Coordinates cell
        
        % Indicates fiducial images set manually by user. (Default = false)
        % This can be useful if the user already has the set of fiducial
        % images loaded into their workspace (e.g., if they were simulated
        % and not saved to a file).
        % NOTE: If using this setting, the fiducials must be
        %       "pre-processed" before setting to obj.FiducialImages (e.g.,
        %       truncated to proper ROI, averaged over time, ...).
        %       Furthermore, obj.FiducialROI should be set to the
        %       appropriate value so that the correct ROI is saved along
        %       with the transform. obj.SplitFormat cannot be used with
        %       this setting.
        ManualSetFiducials(1, 1) logical = false;
        
        % Fiducial images (numeric array, MxP(xNFiducials))
        FiducialImages {mustBeNumeric(FiducialImages)}
        
        % Format guiding the fiducial ROIs to be used (Default = [1])
        % (see obj.convertSplitFormatToROIs() for a more complete
        % description).
        % NOTE: If you wish to manually set obj.FiducialROI, you must set
        %       obj.SplitFormat = [].
        SplitFormat {mustBeInteger(SplitFormat)} = 1;
        
        % Fiducial ROIs ([YStart, XStart, YEnd, XEnd, ZStart, ZPeriod])
        % NOTE: In its current usuage, FiducialROI is set automatically in
        %       findTransform(), or manually by the user.
        % NOTE: If you wish to manually define this array, you must set
        %       obj.SplitFormat = [].  Otherwise, the ROI splitting scheme
        %       defined by obj.SplitFormat takes precedence.
        % OPTIONS:
        %   If size(FiducialROI, 1) == 1, each image in FiducialImages will
        %       be truncated to the ROI specified by FiducialROI before
        %       computing the transform.
        %   If size(FiducialROI, 1) > 1, the image found in in
        %       SMF.Data.FileName{1} will be split up into
        %       the ROIs defined by each row of FiducialROI.  Each row of
        %       FiducialROI must specify an equal size ROI.
        %       FiducialROI(1, :) will be treated as the "reference" (or
        %       "fixed") fiducial, meaning all other ROIs will be
        %       transformed w.r.t. FiducialROI(1, :).  Furthermore, the
        %       properties 'Coordinates' and 'RegistrationTransform' will
        %       follow the same ordering as FiducialROI.
        %   If FiducialROI is not set by the user, it will be given a
        %       default depending on how many files are specified by
        %       obj.SMF.Data.FileName.  If there is only one file,
        %       FiducialROI will be set by default s.t. the image in the
        %       one file will be split in two along its columns.  If there
        %       are multiple files,
        %       FiducialROI = [1, 1, size(FiducialImages(:, :, 1))]
        %       where FiducialImages will contain the image stored in the
        %       file obj.SMF.Data.FileName.
        FiducialROI(:, 6) {mustBeInteger(FiducialROI)}
        
        % Data used to compute transform (char)(Default = 'coordinates')
        % OPTIONS:
        %   'coordinates': localizations (defined by (x, y) coordinates)
        %                  are used to find the transform.
        %   'images': images are used directly to find the transform.
        TransformationBasis char {mustBeMember(TransformationBasis, ...
            {'coordinates', 'images'})} = 'coordinates';
        
        % Type of transform to be computed (char array)(Default = 'lwm')
        % OPTIONS:
        %   If TransformationBasis = 'coords', this can be set to any of
        %       the transformationType options defined in doc fitgeotrans
        %   If TransformationBasis = 'images', this can be set to any of
        %       the transformType options defined in doc imregtform.
        TransformationType char = 'lwm';
        
        % Threshold for pairing localizations (Pixels)(Default = inf)
        % This only matters when TransformationBasis = 'coords'.
        SeparationThreshold(1, 1) = inf;
        
        % # of neighbor points used to compute transform (Default = 12)
        % This is only used when TransformationType = 'lwm'
        NNeighborPoints(1, 1) {mustBeInteger, ...
            mustBeGreaterThan(NNeighborPoints, 5)} = 12;
        
        % Degree of polynomial for 'polynomial' tform (Default = 2)
        % This is only used when TransformationType = 'polynomial'.
        PolynomialDegree(1, 1) ...
            {mustBeMember(PolynomialDegree, [2, 3, 4])} = 2;
        
        % Auto-scale fiducial images (boolean)(Default = true)
        % This flag lets this class do a somewhat arbitrary scaling of the
        % fiducial images in an attempt to simplify the code usage.  This
        % allows us to avoid gain/offset correcting the data, which might
        % be annoying in some cases (as in, it's nice to just use the
        % default SMF instead of having to tweak parameters just for this
        % code).
        AutoscaleFiducials(1, 1) logical = true;
        
        % Manually cull localization pairs (boolean)(Default = true)
        % This flag lets the user manually cull the paired localizations
        % used to produce the transform (this is only applicable for
        % TransformationBasis = 'coords').
        ManualCull(1, 1) logical = true;
        
        % Verbosity level for standard workflow. (Default = 1)
        %   0: Command Window updates will be supressed where possible and
        %      reasonable.
        %   1: Some updates may appear in Command Window
        %   2: More detailed updates in Command Window
        %   3: Lot's of info. may be passed to Command Window. This mode
        %      may be useful for debugging large workflows encompassing
        %      this class.
        Verbose = 1;
    end
    
    properties (SetAccess = protected)
        % Computed transformation(s) (cell array of tform objects)
        % RegistrationTransform will be organized differently depending on
        % the usage of FiducialROI:
        % If size(FiducialROI, 1) == 1, then each fiducial was provided as
        %   a separate image, in which case each element corresponds to a
        %   transform w.r.t. the fiducial in obj.SMF.Data.FileName{1}. For
        %   example, RegistrationTransform{3} is a registration between
        %   obj.SMF.Data.FileName{3} and obj.SMF.Data.FileName{1}.
        % If size(FiducialROI, 1) > 1, only one fiducial image was
        %   provided, but it will be split into different ROIs.  In this
        %   case, RegistrationTransform{n} will be the transform between
        %   the ROI defined by FiducialROI(n, :) and FiducialROI(1, :).
        RegistrationTransform cell
    end
    
    properties (Hidden, SetAccess = protected)
        % These properties are used for convenience internally (e.g., for
        % use in the GUI) and shouldn't be modified by the user.
        
        TransformationBasisOptions cell = {'coordinates', 'images'};
        CoordTransformOptions cell = {'nonreflectivesimilarity', ...
            'similarity', 'affine', 'projective', 'polynomial', 'pwl', ...
            'lwm'};
        ImageTransformOptions cell = {'translation', 'rigid', ...
            'similarity', 'affine'};
        SplitFormatOptions cell = {[1, 2], [1; 2], [1, 3; 2, 4]};
        SplitFormatOptionsChar cell = ...
            {'[1, 2]', '[1; 2]', '[1, 3; 2, 4]'};
        
    end
    
    methods
        function [obj] = ChannelRegistration(...
                FiducialFileDir, FiducialFileNames, SMF, Verbose)
            %ChannelRegistration class constructor.
            % The inputs can be used to set class properties if desired.
            
            % Set inputs to class properties if needed.
            if (exist('Verbose', 'var') && ~isempty(Verbose))
                obj.Verbose = Verbose;
            end
            if (exist('SMF', 'var') && ~isempty(SMF))
                obj.SMF = SMF;
                if (obj.Verbose > 2)
                    fprintf(['\tChannelRegistration constructor: ', ...
                        'Input SMF structure stored as a class ', ...
                        'property\n'])
                end
            else
                % Set a (mostly) default SMF, with a few tweaks that tend
                % to help out for several types of fiducial images.
                if (obj.Verbose > 2)
                    fprintf(['\tChannelRegistration constructor: ', ...
                        'Using default SMF structure.\n'])
                end
                obj.SMF = smi_core.SingleMoleculeFitting;
                obj.SMF.BoxFinding.MinPhotons = 100;
                obj.SMF.Fitting.FitType = 'XYNBS';
            end
            if (exist('FiducialFileDir', 'var') ...
                    && ~isempty(FiducialFileDir))
                obj.SMF.Data.FileDir = FiducialFileDir;
                if (obj.Verbose > 2)
                    fprintf(['\tChannelRegistration constructor: ', ...
                        'Input \n\tFiducialFileDir = ''%s'' stored ', ...
                        'as a class property.\n'], FiducialFileDir)
                end
            end
            if (exist('FiducialFileNames', 'var') ...
                    && ~isempty(FiducialFileNames))
                obj.SMF.Data.FileName = FiducialFileNames;
                if (obj.Verbose > 2)
                    fprintf(['\tChannelRegistration constructor: ', ...
                        'Input FiducialFileNames stored as a ', ...
                        'class property.\n'])
                end
            end
            if (obj.Verbose > 1)
                fprintf(['\tChannelRegistration: constructor ran ', ...
                    'succesfully.\n'])
            end
            
        end
        
        function set.SMF(obj, SMFInput)
            % This is a set method for the SMF to ensure a valid SMF is
            % provided.
            obj.SMF = smi_core.SingleMoleculeFitting.reloadSMF(SMFInput);
        end
        
        [RegistrationTransform] = findTransform(obj);
        loadFiducials(obj)
        [FilePath] = exportTransform(obj, FileDir);
        gui(obj, GUIParent)
        
    end
    
    methods (Static)
        [PlotAxes, LineHandles] = ...
            plotCoordsOnData(PlotAxes, RawData, Coordinates);
        [SMDMoving] = transformSMD(RegistrationTransform, SMDMoving);
        [TRMoving] = transformTR(RegistrationTransform, TRMoving);
        [MovingCoordsTransformed] = ...
            transformCoords(RegistrationTransform, MovingCoords);
        [TransformedImages] = transformImages(...
            RegistrationTransform, Images)
        [PlotFigure] = visualizeCoordTransform(PlotFigure, ...
            RegistrationTransform, FrameSize, GridSpacing);
        [PlotAxes] = visualizeImageTransform(PlotAxes, ...
            RegistrationTransform, FrameSize, GridSpacing);
        [SquaredError] = estimateRegistrationError(...
            RegistrationTransform, MovingCoordinates, FixedCoordinates);
        [SquaredError] = estimateRegErrorLOO(...
            TransformationType, TransformationParams, ...
            MovingCoordinates, FixedCoordinates);
        [PlotAxes] = visualizeRegistrationError(PlotAxes, ...
            RegistrationTransform, MovingCoordinates, FixedCoordinates, ...
            FOV, GridSpacing)
        [PlotFigure] = visualizeRegistrationResults(PlotFigure, ...
            RegistrationTransform, MovingCoordinates, FixedCoordinates, ...
            MovingImage, FixedImage);
        [RawData, Files] = simFiducials(ROISize, NRows, SaveDir);
        [Success] = unitTest()
    end
    
    methods (Static, Hidden)
        % These methods aren't expected to be used directly by the user, so
        % it's nice to hide them from view (so they don't distract the
        % user).
        [PairMap12, PairMap21] = pairCoordinates(Coords1, Coords2, ...
            SeparationThreshold);
        [CulledCoordinates] = performManualCull(RawData, Coordinates);
        [TransformedCoordinates] = transformCoordsDirect(...
            RegistrationTransform, Coordinates);
        [SplitROIs] = convertSplitFormatToROIs(FullROI, SplitFormat)
        [ScaledFiducials] = rescaleFiducials(Fiducials, SMF, AutoScale);
    end
    
    
end

./MATLAB/+smi_core/@ChannelRegistration/plotCoordsOnData.m
function [PlotAxes, LineHandles] = plotCoordsOnData(PlotAxes, ...
    RawData, Coordinates)
%plotCoordsOnData plots coordinates in Coordinates on top of ScaledData.
% This method will take coordinates in Coordinates and plot them on top of
% ScaledData.  The intention is that RawData will contain a stack of
% fiducial images, which will be displayed in some projection so they are
% both visible at once.  Coordinates will be a cell array of numeric arrays
% corresponding to localizations in each image of ScaledData.
%
% NOTE: Input PlotAxes can be set to an empty array to use the default.
% NOTE: This method is best used to compare only two images/localization
%       sets.  If numel(Coordinates) > 2, the results probably won't look
%       very nice.
%
% INPUTS:
%   PlotAxes: Axes in which we will make the plots. (Default = gca())
%   RawData: Stack of images that will be plotted and have coordinates 
%            overlain. (numeric array, MxNxP with P>1)
%   Coordinates: Cell array of coordinate arrays, where numel(Coordinates)
%                must match the third dimension of RawData. 
%                (Px1 cell array of numeric arrays)
%
% OUTPUTS:
%   PlotAxes: Axes containing the plots.
%   LineHandles: Handles to the points in Coordinates added to the plot.
%                This is a cell array such that LineHandles{2} contains an
%                array of line handles for the points in Coordinates{2}.
%                (This is useful if you intend to modify the plot outside
%                of this method.) (cell array of line handles)

% Created by:
%   David J. Schodt (Lidke Lab, 2020)


% Set defaults/modify inputs if needed.
if (~exist('PlotAxes', 'var') || isempty(PlotAxes) || ~isvalid(PlotAxes))
    PlotAxes = gca();
end
if ~iscell(Coordinates)
    Coordinates = {Coordinates};
end

% Plot the images in ScaledData.
SumImage = sum(RawData, 3);
SumImage = (SumImage-min(SumImage(:))) ...
    ./ max(max(SumImage-min(SumImage(:))));
surface(PlotAxes, ...
    [1, size(SumImage, 2)], [1, size(SumImage, 1)], ...
    [0, 0; 0, 0], repmat(SumImage, [1, 1, 3]), ...
    'facecolor', 'texturemap');

% Plot the localizations in FiducialSMD.
NPoints = cellfun(@(X) size(X, 1), Coordinates);
NDatasets = numel(Coordinates);
LineHandles = cell(NDatasets, 1);
MarkerOptions = repelem('h', NDatasets);
MarkerOptions(1:14) = ['o', '+', '*', '.', 'x', '_', '|', 's', 'd', ...
    '^', 'v', '>', '<', 'p'];
LineColors = colormap(PlotAxes, lines(max(NPoints)));
for ii = 1:NDatasets
    % Plot each of the localizations for each datset in a different color
    % and with different markers if possible. 
    LineHandles{ii} = gobjects(NPoints(ii), 1);
    for jj = 1:NPoints(ii)
        LineHandles{ii}(jj) = line(PlotAxes, ...
            Coordinates{ii}(jj, 1)-0.5, Coordinates{ii}(jj, 2)-0.5, ...
            'Marker', MarkerOptions(ii), 'Color', LineColors(jj, :), ...
            'LineWidth', 1.5);
    end
end


end
./MATLAB/+smi_core/@ChannelRegistration/rescaleFiducials.m
function [ScaledFiducials] = ...
    rescaleFiducials(Fiducials, SMF, AutoScale)
%rescaleFiducials rescales the images in Fiducials as needed.
% This method "rescales" the fiducial images in Fiducials.  When
% AutoScale = false, this just means a gain/offset correction is performed.
% When AutoScale = true, the images are scaled to the range [0, 1].
%
% INPUTS:
%   Fiducials: Stack of images to be rescaled. (MxPxNImages numeric array)
%   SMF: Single Molecule Fitting structure (see
%        smi_core.SingleMoleculeFitting)
%   AutoScale: Flag to indicate whether to do gain/offset correction with
%              the gain and offset in the SMF (false), or to rescale each
%              of the NImages to the range [0, 1] (true).
%              (Boolean)(Default = false)
%
% OUTPUTS:
%   ScaledFiducials: Input images Fiducials rescaled as appropriate.
%                    (MxPxNImages numeric array)

% Created by:
%   David J. Schodt (Lidke Lab, 2021)


% Set defaults if needed.
if (~exist('SMF', 'var') || isempty(SMF))
    SMF = smi_core.SingleMoleculeFitting;
end
if (~exist('AutoScale', 'var') || isempty(AutoScale))
    AutoScale = false;
end

% Rescale the fiducials as appropriate.
if AutoScale
    % Rescale the images to the range [0, 1].
    ScaledFiducials = Fiducials;
    for nn = 1:size(Fiducials, 3)
        CurrentImage = Fiducials(:, :, nn);
        ScaledFiducials(:, :, nn) = ...
            (CurrentImage-min(CurrentImage(:))) ...
            ./ max(max(CurrentImage-min(CurrentImage(:))));
    end
else
    % Perform gain/offset correction.
    [ScaledFiducials] = smi_core.DataToPhotons.convertToPhotons(...
        Fiducials, SMF.Data.CameraGain, SMF.Data.CameraOffset, []);
end


end
./MATLAB/+smi_core/@ChannelRegistration/exportTransform.m
function [FilePath] = exportTransform(obj, FileDir)
%exportTransform exports transform information into a .mat file.
% This method will save a bunch of relevant class fields into a .mat file
% in the specified location.
%
% INPUTS:
%   FileDir: Directory in which transforms will be saved.
%            (Default = obj.SMF.Data.FileDir)
%
% OUTPUTS:
%   FilePath: Cell array of path(s) to the exported transforms.

% Created by:
%   David J. Schodt (Lidke Lab, 2020)


% Set defaults if needed.
if (~exist('FileDir', 'var') || isempty(FileDir))
    FileDir = obj.SMF.Data.FileDir;
end
if (exist('TransformIndex', 'var') && ~isempty(TransformIndex))
    TransformIndices = TransformIndex;
else
    TransformIndices = 1:numel(obj.RegistrationTransform);
end

% Compute the registration errors (useful to export here, even if it slows
% things down).
RegistrationError = zeros(numel(TransformIndices), 1);
RegistrationErrorLOO = zeros(numel(TransformIndices), 1);
RegParams = {smi_helpers.arrayMUX({obj.PolynomialDegree, obj.NNeighborPoints}, ...
    strcmpi(obj.TransformationType, 'lwm'))};
for ii = TransformIndices
    RegistrationError(ii) = sqrt(mean(obj.estimateRegistrationError(...
        obj.RegistrationTransform{ii}, ...
        obj.Coordinates{ii}(:, :, 2), obj.Coordinates{ii}(:, :, 1))));
    RegistrationErrorLOO(ii) = sqrt(mean(obj.estimateRegErrorLOO(...
        obj.TransformationType, RegParams, ...
        obj.Coordinates{ii}(:, :, 2), obj.Coordinates{ii}(:, :, 1))));
end

% Save the requested transform(s).
if (obj.Verbose > 1)
    fprintf(['\tChannelRegistration.exportTransform(): ', ...
        'Exporting transform(s)...\n'])
end
SplitFormat = obj.SplitFormat;
TransformationBasis = obj.TransformationBasis;
TransformationType = obj.TransformationType;
SeparationThreshold = obj.SeparationThreshold;
NNeighborPoints = obj.NNeighborPoints;
PolynomialDegree = obj.PolynomialDegree;
SMF = obj.SMF;
AutoscaleFiducials = obj.AutoscaleFiducials;
FiducialROI = obj.FiducialROI;
[~, FiducialFileName] = fileparts(obj.SMF.Data.FileName{1});
ExportFileName = ...
    sprintf('RegistrationTransform_%s.mat', FiducialFileName);
FilePath = fullfile(FileDir, ExportFileName);
RegistrationTransform = obj.RegistrationTransform(TransformIndices);
Coordinates = obj.Coordinates{TransformIndices};
save(FilePath, 'RegistrationTransform', ...
    'Coordinates',  'FiducialROI', 'SplitFormat', ...
    'TransformationBasis', 'TransformationType', ...
    'SeparationThreshold', 'NNeighborPoints', 'PolynomialDegree', ...
    'SMF', 'AutoscaleFiducials', 'TransformIndices', ...
    'RegistrationError', 'RegistrationErrorLOO')


end
./MATLAB/+smi_core/@ChannelRegistration/convertSplitFormatToROIs.m
function [SplitROIs] = convertSplitFormatToROIs(FullROI, SplitFormat)
%convertSplitFormatToROIs converst a split format to an array of ROIs.
% This method will take a split format (e.g., obj.SplitFormat) and convert
% it to the sub-ROIs of FullROI (e.g., what we need in obj.FiducialROI).
%
% INPUTS:
%   FullROI: Full ROI of that is being split.  FullROI(3:4) must both be
%            even numbers UNLESS SplitFormat = [] or 1.
%            ([YStart, XStart, YEnd, XEnd, ZStart, ZPeriod])
%   SplitFormat: The format guideline defining how FullROI will be split
%                into sub-ROIs (integer array)(must consist of the set of
%                integers 1:numel(SplitFormat))(Default = [])
%                OPTIONS:
%                   []: This option simply returns SplitROIs = FullROI.
%                   [1]: Same action as [], but both are included for
%                        consistent usage elsewhere in the class.
%                   [1, 2]: For use when only a single fiducial image is
%                           provided.  The image will be split along
%                           columns into two equal ROIs.
%                   [1; 2]: Similar to above, but the image is split along
%                           rows.
%                   [1, 3; 2, 4]: Image is split into four equal ROIs.
%                NOTE: Entries correspond to the row indices of the output
%                      SplitROIs according to column-major indexing, e.g.,
%                      SplitROIs(3, :) corresponds to (SplitFormat==3).  
%                      As a more explicit example: 
%                      SplitFormat = [4, 3; 1, 2] means that 
%                      SplitROIs(1, :) defines the bottom left ROI
%                      SplitROIs(2, :) defines the bottom right ROI
%                      SplitROIs(3, :) defines the top right ROI
%                      SplitROIs(4, :) defines the top left ROI
%
% OUTPUTS:
%   SplitROIs: Array of ROIs corresponding to the input FullROI split as
%              guided by SplitFormat.  Each row will have the format
%              [YStart, XStart, YEnd, XEnd, ZStart, ZPeriod].  Row indices
%              correspond to the integers specifying ROIs in SplitFormat.

% Created by:
%   David J. Schodt (Lidke lab, 2021)

% Set defaults if needed.
if ~exist('SplitFormat', 'var')
    SplitFormat = [];
end

% Return the FullROI if appropriate.
NROIs = numel(SplitFormat);
if (isempty(SplitFormat) || (NROIs==1))
    SplitROIs = [FullROI, 1, 1];
    return
end

% Revise the SplitFormat to make sure it contains all integers
% 1:numel(SplitFormat).
[~, SortIndices] = sort(SplitFormat(:));
SplitFormat(SortIndices) = 1:NROIs;

% Split the ROIs as defined by SplitFormat.
SplitROIs = NaN(NROIs, 4);
FormatSize = size(SplitFormat);
if ((FormatSize(1)==2) && (FormatSize(2)==1))
    % Split FullROI into two equal ROIs along the rows.
    SplitROIs(1, :) = [FullROI(1), FullROI(2), ...
        FullROI(3)/2, FullROI(4)];
    SplitROIs(2, :) = [FullROI(3)/2 + 1, FullROI(2), ...
        FullROI(3), FullROI(4)];
elseif ((FormatSize(1)==1) && (FormatSize(2)==2))
    % Split FullROI into two equal ROIs along the columns.
    SplitROIs(1, :) = [FullROI(1), FullROI(2), ...
        FullROI(3), FullROI(4)/2];
    SplitROIs(2, :) = [FullROI(1), FullROI(4)/2 + 1, ...
        FullROI(3), FullROI(4)];
elseif (FormatSize(1) == FormatSize(2))
    % Split FullROI into four equal ROIs.
    SplitROIs(1, :) = [FullROI(1), FullROI(2), ...
        FullROI(3)/2, FullROI(4)/2];
    SplitROIs(2, :) = [FullROI(3)/2 + 1, FullROI(2), ...
        FullROI(3), FullROI(4)/2];
    SplitROIs(3, :) = [FullROI(1), FullROI(4)/2 + 1, ...
        FullROI(3)/2, FullROI(4)];
    SplitROIs(4, :) = [FullROI(3)/2 + 1, FullROI(4)/2 + 1, ...
        FullROI(3), FullROI(4)];
else
    error(['convertSplitFormatToROIs(): size of input ', ...
        'SplitFormat does not match defined options'])
end
SplitROIs = [SplitROIs(SortIndices, :), ones(NROIs, 2)];


end
./MATLAB/+smi_core/@ChannelRegistration/transformTR.m
function [TRMoving] = transformTR(RegistrationTransform, TRMoving)
%transformTR transforms TR a structure using the specified transform.
% This method is just a wrapper around
% smi_core.ChannelRegistration.transformSMD().
%
% INPUTS:
%   RegistrationTransform: RegistrationTransform is a MATLAB tform object
%                          describing the transform to be visualized.
%                          (tform object)
%   TRMoving: TR structure (see smi_core.TrackingResults) that will be
%             transformed by 'RegistrationTransform'.
%
% OUTPUTS:
%   TRMoving: TR structure transformed by 'RegistrationTransform'.

% Created by:
%   David J. Schodt (Lidke Lab, 2021)


% Make sure none of the trajectories have been transformed.  If any have,
% throw an error.
if isfield(TRMoving, 'IsTransformed')
    assert(~any([TRMoving.IsTransformed]), ...
        ['Some trajectories in ''TR'' has already been transformed! ', ...
        'If you intend to apply another transform to this TR, set ', ...
        'TR.IsTransformed to false for each trajectory before proceeding.']);
else
    % Initialize this field to false for now.  transformSMD() will change
    % this below if all goes well.
    [TRMoving.IsTransformed] = deal(false);
    
    % Initialize the fields 'XRegCorrection' and 'YRegCorrection'.
    [TRMoving.XRegCorrection] = deal([]);
    [TRMoving.YRegCorrection] = deal([]);
end

% Loop through trajectories in 'TRMoving' and apply the transform.
for nn = 1:numel(TRMoving)
    TRMoving(nn) = smi_core.ChannelRegistration.transformSMD(...
        RegistrationTransform, TRMoving(nn));
end


end
./MATLAB/+smi_core/@ChannelRegistration/transformCoordsDirect.m
function [TransformedCoordinates] = transformCoordsDirect(...
    RegistrationTransform, Coordinates)
%transformCoordsDirect transforms a set of coordinates.
% This method transforms the input coordinates directly.  For some
% transforms, the inverse transform is applied (nothing in the output will
% distinguish this).  For this reason, it is recommended that you use
% transformCoords() instead of this method.
%
% INPUTS:
%   RegistrationTransform: RegistrationTransform is a MATLAB tform object
%                          describing the transform to be visualized.
%                          (tform object)
%   Coordinates: Coordinates to be transformed. (Nx2 numeric array)
%
% OUTPUTS:
%   TransformedCoordinates: Input Coordinates transformed by
%                           RegistrationTransform. (Nx2 numeric array)

% Created by:
%   David J. Schodt (Lidke Lab, 2020)


% Determine the transformation type and proceed as appropriate.
if ismember(class(RegistrationTransform), ...
        {'images.geotrans.LocalWeightedMeanTransformation2D', ...
        'images.geotrans.PolynomialTransformation2D', ...
        'images.geotrans.PiecewiseLinearTransformation2D'})
    % None of these transforms have a transformPointsForward()
    % implementation, so we must use the inverse on our reference points
    % (We could just compute the transform treating the reference as
    % moving, but then the transform can't be applied to our raw data since
    % MATLAB doesn't have an inverse of imwarp().  For SPT, it's nice to
    % have transformed raw data for use in movies.)
    [TransformedCoordinates(:, 1), TransformedCoordinates(:, 2)] = ...
        transformPointsInverse(RegistrationTransform, ...
        Coordinates(:, 1), Coordinates(:, 2));
else
    [TransformedCoordinates(:, 1), TransformedCoordinates(:, 2)] = ...
        transformPointsForward(RegistrationTransform, ...
        Coordinates(:, 1), Coordinates(:, 2));
end


end
./MATLAB/+smi_core/@ChannelRegistration/transformImages.m
function [TransformedImages] = transformImages(...
    RegistrationTransform, Images)
%transformImages transforms a set of images with the given transform.
% This method will transform the images given in Images using the
% transform in RegistrationTransform.
%
% NOTE: This method is just a wrapper for the MATLAB methods imref2D() and
%       imwarp().
%
% INPUTS:
%   RegistrationTransform: A MATLAB tform object containing information
%                          about the transformation to be used
%                          (tform object)
%   Images: A stack of images to be transformed (MxNxP numeric array)
%
% OUTPUTS:
%   TransformedImages: Input Images transformed using RegistrationTransform
%                      (MxNxP numeric array)

% Created by:
%   David J. Schodt (Lidke Lab, 2020)


% Apply the transform to the images.
if ~isempty(RegistrationTransform)
    ImRef2DObject = imref2d(size(Images(:, :, 1)));
    TransformedImages = imwarp(Images, RegistrationTransform, ...
        'OutputView', ImRef2DObject);
end


end
./MATLAB/+smi_core/README.md
### +smi_core

+smi_core is the namespace for the core lower-level classes of ***smite***:
- [@ChannelRegistration](@ChannelRegistration/README.md):
  channel registration
- [@DataToPhotons](@DataToPhotons/README.md):
  convert raw data to photons
- [@DriftCorrection](@DriftCorrection/README.md):
  drift correction on 2D/3D data
- [@FindROI](@FindROI/README.md):
  find/collate subregions from a 2D image stack
- [@FrameConnection](@FrameConnection/README.md):
  frame connection
- [@LoadData](@LoadData/README.md):
  load raw microscope data from .mat/.h5 files
- [@LocalizeData](@LocalizeData/README.md):
  find localizations in raw data
- [@SingleMoleculeData](@SingleMoleculeData/README.md):
  define SMD structure
- [@SingleMoleculeFitting](@SingleMoleculeFitting/README.md):
  define SMF structure
- [@Threshold](@Threshold/README.md):
  threshold based on various SMLM properties
- [@TrackingResults](@TrackingResults/README.md):
  define Tracking Results (TR) structure
- [GaussMLE](README_GaussMLE.md):
  max likelihood estimate of 2D Gaussian blobs

./MATLAB/+smi_core/@SingleMoleculeData/computeDensity.m
function [Density] = computeDensity(SMD)
%computeDensity estimates the per frame density of observed emitters.
% This method computes the number of observed localizations per pixel^2 
% present in each frame of data in the input SMD structure.  This is done
% by computing the area of the ROI in pixel^2, counting the number of
% localizations present in SMD for each frame, and then dividing the number
% of localizations in each frame by the area of the ROI.
%
% INPUTS:
%   SMD: Single Molecule Data structure.
%
% OUTPUTS:
%   Density: The density of observed emitters in each frame. 
%            (localizations / pixel^2)(NFrames x NDatasets numeric array)
%
% CITATION:

% Created by Derek Rinaldi (Diane Lidke Lab, 2018)
% Rewritten by David J. Schodt (Lidke Lab, 2020)


% Compute the area of the ROI in pixel^2.
ROIArea = SMD.XSize * SMD.YSize;

% Isolate some fields from the SMD/compute some new arrays as needed.
FrameNum = SMD.FrameNum;
UniqueFrames = sort(unique(FrameNum));
DatasetNum = SMD.DatasetNum;

% Loop through each data dataset present in the SMD structure and compute
% the per frame density of observed emitters.
Density = zeros(SMD.NFrames, SMD.NDatasets);
for dd = 1:SMD.NDatasets
    % Loop through each frame of this dataset.
    for ff = UniqueFrames.'
        % Identify all localizations in this frame and compute the density.
        Density(ff, dd) = sum((FrameNum==ff) & (DatasetNum==dd)) / ROIArea;
    end
end


end
./MATLAB/+smi_core/@SingleMoleculeData/isolateSubSMD.m
function [SMD] = isolateSubSMD(SMD, SubIndices)
%isolateSubSMD isolates a subset of SMD defined by SubIndices.
% This method will isolate a subset of SMD defined by the indices in
% SubIndices.  This is done automatically by indexing all SMD arrays which
% share the same size as SMD.FrameNum.
%
% WARNING: This method can fail if there are "constant" SMD fields that
%          happen to share the same array size as SMD.FrameNum.
%
% INPUTS:
%   SMD: A Single Molecule Data structure.
%   SubIndices: Set of indices/booleans corresponding to the desired 
%               entries of SMD. If not entered/left empty, this method
%               will attempt to copy all fields that don't share the same
%               size as SMD.FrameNum. (integer array/logical array)
%
% OUTPUTS:
%   SMD: A Single Molecule Data structure whose vector fields correspond to
%        the input SMD.*(SubIndices), with other fields left unchanged.

% Created by:
%   David J. Schodt (Lidke lab, 2021)


% Determine the length of vector fields and ensure consistency with the
% provided SubIndices.
ArrayLength = numel(SMD.FrameNum);
VectorCopy = (exist('SubIndices', 'var') && ~isempty(SubIndices));
if VectorCopy
    if islogical(SubIndices)
        assert(numel(SubIndices) == ArrayLength, ...
            ['If ''SubIndices'' is a boolean array, it must be the same ', ...
            'length as SMD.FrameNum'])
    else
        assert(max(SubIndices) <= ArrayLength, ...
            ['Provided ''SubIndices'' contains indices greater than the ', ...
            'length of SMD.FrameNum'])
    end
end

% Loop through all SMD fields and update the output SMD as necessary.
SMDIn = SMD;
SMDFields = fieldnames(SMD);
for ff = 1:numel(SMDFields)
    if (numel(SMDIn.(SMDFields{ff})) == ArrayLength)
        if VectorCopy
            SMD.(SMDFields{ff}) = SMDIn.(SMDFields{ff})(SubIndices);
        %else
        %    SMD.(SMDFields{ff}) = [];
        end
    end
end


end

./MATLAB/+smi_core/@SingleMoleculeData/computeDensityImage.m
function [DensityIm] = computeDensityImage(SMD, SigmaSmooth, Mag, ...
    NEmitters, TimeSeries, FastGauss)
%computeDensityImage estimates the local density of observed emitters.
% This method prepares a smoothed Gaussian image of the localizations in
% SMD, normalized such that it represents an approximate density of
% emitters.  Specifically, for a single image in DensityIm, each pixel is
% in units of emitters/(pixel^2), so the number of emitters in, e.g.,
% DensityIm(:, :, n) is sum_{i,j} (1px^2) * DensityIm(i, j, n) 
%   = sum(sum(DensityIm(:, :, n))
%
% INPUTS:
%   SMD: Single Molecule Data structure.
%   SigmaSmooth: Standard deviation of the smoothing filter applied to the
%                Gaussian image to generate the density image, given in
%                units of SMD coordinates.
%                (pixels)(Default = 0)
%   Mag: Approximate magnification from SMD pixels to output image pixels.
%        (Default = 1)
%   NEmitters: Total number of emitters from which SMD was generated.
%              (NFramesx1 or 1x1)(Default based on setting of TimeSeries)
%   TimeSeries: Flag to indicate SMD.NFrames density images are desired
%               (i.e., one per frame) as opposed to single density image.
%               (Default = false)
%   FastGauss: Flag indicating an approximate Gaussian filter should be
%              used to improve speed for large stacks of data at the
%              expense of potential artifacts. (Default = false)
%
% OUTPUTS:
%   DensityIm: Gaussian image representing the approximate emitter
%              densities within each pixel. ...
%              (emitters / pixel^2)(SMD.YSize x SMD.XSize float).
%
% REQUIRES:
%   Image Processing Toolbox 2015a or sooner if FastGauss = false
%
% CITATION:

% Created by David J. Schodt (Lidke Lab, 2021)


% Set defaults.
if (~exist('SigmaSmooth', 'var') || isempty(SigmaSmooth))
    SigmaSmooth = 0;
end
if (~exist('Mag', 'var') || isempty(Mag))
    Mag = 20;
end
if (~exist('TimeSeries', 'var') || isempty(TimeSeries))
    TimeSeries = false;
end
if (~exist('NEmitters', 'var') || isempty(NEmitters))
    % For time series, we'll use the number of localizations per frame as
    % our number of emitters (e.g., the density in each frame is a
    % localization density, which for something like SPT ~represents the
    % emitter density).
    NEmitters = groupcounts(SMD.FrameNum, 1:(SMD.NFrames+1), ...
        'IncludeEmptyGroups', true, 'IncludedEdge', 'left');
    if ~TimeSeries
        % In this case, we'll take the number of emitters to be the maximum
        % number of localizations seen in any single frame.
        NEmitters = max(NEmitters);
    end
end
if (~exist('FastGauss', 'var') || isempty(FastGauss))
    FastGauss = false;
end

% Rescale the data in SMD based on 'Mag'.
% NOTE: gaussBlobImage() below defines the Gaussians in terms of
%       SMD.PSFSigma.  For the density image, we want to use the standard
%       errors for the Gaussian st. devs., thus we need to overwrite
%       PSFSigma.
ImSize = ceil(Mag * [SMD.YSize, SMD.XSize]);
SMD.XSize = ImSize(2);
SMD.YSize = ImSize(1);
SMD.X = Mag*(SMD.X - 0.5) + 0.5;
SMD.Y = Mag*(SMD.Y - 0.5) + 0.5;
SMD.PSFSigma = Mag * [SMD.Y_SE, SMD.X_SE];

% Generate the Gaussian images of the localizations in SMD.
if ~TimeSeries
    % If we set all of SMD.FrameNum to 1, it'll put every localization in
    % the same frame.
    SMD.FrameNum = ones(size(SMD.FrameNum));
    SMD.NFrames = 1;
end
GaussIm = smi_sim.GaussBlobs.gaussBlobImage(SMD);

% Apply a Gaussian filter to the GaussIm of localizations.
% NOTE: gaussInPlace() is an approximation to a Gaussian filter.  As a
%       result, some artifacts appear.
Sigma = SigmaSmooth * Mag;
if (Sigma <= 0)
    DensityIm = GaussIm;
elseif FastGauss
    DensityIm = gather(smi_core.FindROI.gaussInPlace(GaussIm, Sigma));
else
    DensityIm = imgaussfilt(GaussIm, Sigma);
end

% Rescale the smoothed Gaussian so that each frame represents an
% approximate emitter density.
if (numel(NEmitters) == size(DensityIm, 3))
    % In this case, we have NEmitters defined for every image of our
    % smoothed image, so we should normalize frame-to-frame.
    for ff = 1:numel(NEmitters)
        if any(any(DensityIm(:, :, ff)))
            DensityIm(:, :, ff) = DensityIm(:, :, ff) ...
                - min(min(DensityIm(:, :, ff)));
            DensityIm(:, :, ff) = DensityIm(:, :, ff) ...
                / sum(sum(DensityIm(:, :, ff)));
            DensityIm(:, :, ff) = ...
                NEmitters(ff) * DensityIm(:, :, ff);
        end
    end
else
    % If this happens, it's not clear what the user wants, so we'll issue a
    % warning and then apply the average of NEmitters to normalize the
    % entire stack at once.
    warning('Provided ''NEmitters'' does not match the number of frames!')
    if any(DensityIm(:))
        NEmitters = mean(NEmitters);
        DensityIm = DensityIm - min(DensityIm(:));
        DensityIm = DensityIm / sum(DensityIm(:));
        DensityIm = NEmitters * DensityIm;
    end
end


end
./MATLAB/+smi_core/@SingleMoleculeData/extractDatasets.m
function [SMD, KeepBool] = extractDatasets(SMD, Datasets, Compress)
%extractDatasets extracts the 'Datasets' from 'SMD'.
% This method will return the localizations in 'SMD' that arose from the
% datasets defined by integers 'Datasets'.
%
% WARNING: This method can fail if there are "constant" SMD fields that
%          happen to share the same array size as SMD.FrameNum.
%
% INPUTS:
%   SMD: A Single Molecule Data structure.
%   Datasets: Array of dataset numbers whose localizations will be
%             extracted from SMD.
%   Compress: Flag indicating dataset numbers should be compressed (e.g.,
%             datasets [2; 5; 8] will be renamed [1; 2; 3]). 
%             (Default = false)
%
% OUTPUTS:
%   SMD: A Single Molecule Data structure containing only the data from the
%        datasets defined by 'Datasets'.
%   KeepBool: Boolean array indicating which localizations in the input SMD
%             are kept.

% Created by:
%   David J. Schodt (Lidke lab, 2021)


% Set defaults if needed.
if (~exist('Compress', 'var') || isempty(Compress))
    Compress = false;
end

% Extract the desired datasets.
KeepBool = ismember(SMD.DatasetNum, Datasets);
SMD = smi_core.SingleMoleculeData.isolateSubSMD(SMD, KeepBool);

% Modify the drift fields to only show the drift for the selected dataset.
if ~isempty(SMD.DriftX)
    SMD.DriftX = SMD.DriftX(:, Datasets);
end
if ~isempty(SMD.DriftY)
    SMD.DriftY = SMD.DriftY(:, Datasets);
end
if ~isempty(SMD.DriftZ)
    SMD.DriftZ = SMD.DriftZ(:, Datasets);
end

% Rename datasets if needed.
if Compress
    SMD.DatasetNum = smi_helpers.compressToRange(SMD.DatasetNum);
end


end
./MATLAB/+smi_core/@SingleMoleculeData/defineSMDMask.m
function [KeepBool] = defineSMDMask(SMD, Mask)
%defineSMDMask defines a boolean for masking SMD localizaions.
% This method takes the boolean image 'Mask' and converts it to a boolean
% array to mask the provided SMD.  That is, the output 'KeepBool' indicates
% localizations in 'SMD' that fall within the hot bits of 'Mask'.
%
% INPUTS:
%   SMD: A Single Molecule Data structure.
%   Mask: An SMD.YSize x SMD.XSize boolean image, where false values
%         represent regions that should be masked in the SMD.  If the mask
%         image is a different size than needed for SMD, it will be
%         silently resized within this method!
%
% OUTPUTS:
%   KeepBool: Boolean array used to define the output 'SMD' from the input
%             'SMD'.

% Created by:
%   David J. Schodt (Lidke lab, 2022)


% Validate the size of the input mask and define a rescaling if needed.
MaskSize = size(Mask);
Mag = max([SMD.YSize, SMD.XSize] ./ MaskSize);

% Define a boolean array for masking the SMD, accounting for the mask
% magnification if needed (e.g., we might have an upsampled mask to get
% sub-pixel masking resolution).
XInds = min(SMD.XSize, max(1, round(Mag*(SMD.X-0.5) + 0.5)));
YInds = min(SMD.YSize, max(1, round(Mag*(SMD.Y-0.5) + 0.5)));
KeepBool = Mask(sub2ind([SMD.YSize, SMD.XSize], YInds, XInds));


end
./MATLAB/+smi_core/@SingleMoleculeData/SingleMoleculeData.m
classdef SingleMoleculeData
    % SingleMoleculeData A class defining the Single Molecule Data structure
    %
    % This datatype is one of the primary results structures in the smite
    % enviroment. The SMD structure is an input and output of many smi
    % methods. It intended to be extensible.
    % The SMD class implements tools for working with SMD structures,
    % but the data strcuture itself is not an object of the class.
    %
    % The structure has the following Properties:
    %
    % SMD:
    %   NDims:          Number of dimensions in localization information (2,3)
    %   NFrames:        Number of image frames in raw data sets
    %   NDatasets:      Number of 3D image stacks
    %   FrameRate:      Acquisition frame rate (1/seconds)
    %   PixelSize       Pixel size of camera projected onto sample (micrometers)
    %   XSize:          Number of pixels in X dimension of raw data
    %   YSize:          Number of pixels in Y dimension of raw data
    %   XBoxCorner:     X coordinate of top right box corner
    %   YBoxCorner:     Y coordinate of top right box corner
    %   ZOffset:        Z position of focal plane of sequence
    %   X:              Estimated X position
    %   Y:              Estimated Y position
    %   Z:              Estimated Z position
    %   Photons:        Estimated Photons  (Integrated collected photons)
    %   Bg:             Estimated Background (Photons/Pixel)
    %   PSFSigma:       Estimated or Fixed Sigma of 2D Gaussian PSF Model (symmetric PSF)
    %   PSFSigmaX:      Estimated or FixedX Sigma of 2D Gaussian PSF Model (asymmetric PSF)
    %   PSFSigmaY:      Estimated or FixedY Sigma of 2D Gaussian PSF Model (asymmetric PSF)
    %   X_SE:           Standard Error of X
    %   Y_SE:           Standard Error of Y
    %   Z_SE:           Standard Error of Z
    %   Photons_SE:     Standard Error of Photons
    %   Bg_SE:          Standard Error of Bg
    %   PSFSigma_SE:    Standard Error of PSFSigma
    %   PSFSigmaX_SE:   Standard Error of PSFSigmaX
    %   PSFSigmaY_SE:   Standard Error of PSFSigmaY
    %   DatasetNum:     File number from which localization originates
    %   FrameNum:       Frame number from which localization originates
    %   PValue:         p-value of fit
    %   LogLikelihood:  Log likelihood of fit
    %   ConnectID:      Identifies the same emitter accross multiple frames
    %   IndSMD:         Indices in original SMD corresponding to frame
    %                   connected localizations (e.g., indices in SMD
    %                   corresponding to localizations in SMDCombined).
    %   ThreshFlag:     Indicates a valid fit.  0=valid.  See SMA_Core.ThresholdSM
    %   DriftX:         X drift relative to first frame (Pixels) (NFrames x NDatasets)
    %   DriftY:         Y drift relative to first frame (Pixels) (NFrames x NDatasets)
    %   DriftZ:         Z drift relative to first frame (Pixels) (NFrames x NDatasets)
    %   IsTransformed:  Flag indicating channel reg. was performed on this SMD
    %   RegError:       Error in channel registration. (Pixels)
    % SEE ALSO:
    %   smi_core.SMF, smi_core.TR
    %
    
    properties
        
    end
    
    methods (Static)
        function [SMD] = createSMD()
            %createSMD Creates an empty Single Molecule Data (SMD) structure
            SMD.DatasetNum=[];
            SMD.FrameNum=[];
            SMD.X=[];
            SMD.Y=[];
            SMD.Z=[];
            SMD.X_SE=[];
            SMD.Y_SE=[];
            SMD.Z_SE=[];
            SMD.Photons=[];
            SMD.Photons_SE=[];
            SMD.Bg=[];
            SMD.Bg_SE=[];
            SMD.PSFSigma=[];
            SMD.PSFSigmaX=[];
            SMD.PSFSigmaY=[];
            SMD.PSFSigma_SE=[];
            SMD.PSFSigmaX_SE=[];
            SMD.PSFSigmaY_SE=[];
            SMD.PValue=[];
            SMD.LogLikelihood=[];
            SMD.ThreshFlag=[];
            SMD.ConnectID=uint32([]);
            SMD.IndSMD={};
            SMD.DriftX=[];
            SMD.DriftY=[];
            SMD.DriftZ=[];
            SMD.XBoxCorner=[];
            SMD.YBoxCorner=[];
            SMD.ZOffset=[];
            SMD.NDims=[];
            SMD.NFrames=[];
            SMD.NDatasets=[];
            SMD.FrameRate=[];
            SMD.PixelSize=[];
            SMD.XSize=[];
            SMD.YSize=[];
            SMD.IsTransformed=[];
            SMD.RegError=[];
        end
        
        [SMD] = catSMD(SMD1, SMD2, NewDataFlag, ShowWarnings)
        [Density] = computeDensity(SMD);
        [DensityIm] = computeDensityImage(SMD, SigmaSmooth, Mag, ...
            NEmitters, TimeSeries, FastGauss);
        [SMD] = isolateSubSMD(SMD, SubIndices);
        [SMD] = isolateSubROI(SMD, ROI);
        [KeepBool] = defineSMDMask(SMD, Mask);
        [SMD, SMDMasked, KeepBool] = maskSMD(SMD, Mask);
        [SMD, KeepBool] = extractDatasets(SMD, Datasets, Compress);

    end
end
./MATLAB/+smi_core/@SingleMoleculeData/README.md
### +smi_core/@SingleMoleculeData

iSingleMoleculeData: A class defining the Single Molecule Data structure

This datatype is one of the primary results structures in the ***smite***
environment. The SMD structure is an input and output of many smi
methods. It intended to be extensible.
The SMD class implements tools for working with SMD structures,
but the data structure itself is not an object of the class.

The structure has these [properties](../../../doc/DataStructures/SMD.md).

---

methods:
- **[catSMD](catSMD.m)**:
  concatenates two SMD structures into one
- **[computeDensity](computeDensity.m)**:
  estimates the per frame density of observed emitters
- **[computeDensityImage](computeDensityImage.m)**:
  estimates the local density of observed emitters
- **[defineSMDMask](defineSMDMask.m)**:
  defines a boolean for masking SMD localizaions.
- **[extractDatasets](extractDatasets.m)**:
  extracts the 'Datasets' from 'SMD'
- **[isolateSubROI](isolateSubROI.m)**:
  isolates localizations within ROI
- **[isolateSubSMD](isolateSubSMD.m)**:
  isolates a subset of SMD defined by SubIndices
- **[maskSMD](maskSMD.m)**:
  masks the input SMD based on the image Mask

./MATLAB/+smi_core/@SingleMoleculeData/maskSMD.m
function [SMD, SMDMasked, KeepBool] = maskSMD(SMD, Mask)
%maskSMD masks the input SMD based on the image Mask.
% This method will isolate a subset of SMD defined by the boolean mask
% defined as an image in 'Mask'.
%
% INPUTS:
%   SMD: A Single Molecule Data structure.
%   Mask: An SMD.YSize x SMD.XSize boolean image, where false values
%         represent regions that should be masked in the SMD.  If the mask
%         image is a different size than needed for SMD, it will be
%         silently resized within this method!
%
% OUTPUTS:
%   SMD: A Single Molecule Data structure containing localizations from SMD 
%        that fall within true pixels of 'Mask'.
%   SMDMasked: Localizations of the input 'SMD' that fell within the false
%              pixels of 'Mask'.
%   KeepBool: Boolean array used to define the output 'SMD' from the input
%             'SMD'.

% Created by:
%   David J. Schodt (Lidke lab, 2022)


% Define a boolean array for masking the SMD, accounting for the mask
% magnification if needed (e.g., we might have an upsampled mask to get
% sub-pixel masking resolution).
KeepBool = smi_core.SingleMoleculeData.defineSMDMask(SMD, Mask);

% Extract the desired SMD as well as the masked localizations.
SMDMasked = smi_core.SingleMoleculeData.isolateSubSMD(SMD, ~KeepBool);
SMD = smi_core.SingleMoleculeData.isolateSubSMD(SMD, KeepBool);


end
./MATLAB/+smi_core/@SingleMoleculeData/catSMD.m
function [SMD] = catSMD(SMD1, SMD2, NewDataFlag, ShowWarnings)
%catSMD concatenates two SMD structures into one.
% This method will concatenate two SMD structures, SMD1 and SMD2, into a
% single output structure, SMD.  Vector fields are concatenated directly,
% i.e., SMD.X = [SMD1.X; SMD2.X] .  Scalar fields are checked for
% consistency (i.e., ensured they are equal) before being stored in the
% output SMD.  Scalar fields which are not consistent are stored in the
% output SMD concatenated in a cell array.
%
% NOTE: There is a hard-coded set of fields below called StackableFields,
%       which are the fields that can be safely concatenated as
%       SMD.Example = [SMD1.Example; SMD2.Example]. If these are changed in
%       SingleMoleculeData.m (or if they are used differently than usual in
%       some context), this set of fields may need to be revised.
%       Similarly, there is a set of "special" fields defined by
%       SpecialFields which are treated differently towards the end of this
%       method (their treatment will be different on a case-by-case basis).
%
% NOTE: When SMD1 and SMD2 are frame connected SMD's (e.g., the output
%       SMDCombined from the frame connection codes), the field 'IndSMD' is
%       only meaningful if you are also concatenating the corresponding
%       pre- frame connected SMD's.  As in, IndSMD after concatenation of
%       two SMDCombined's now refers to indices in the corresponding
%       concatenated pre- frame connection SMD's.
%
% INPUTS:
%   SMD1: A Single Molecule Data structure.
%   SMD2: A Single Molecule Data structure.
%   NewDataFlag: Flag indicating 'SMD2' represents new data from a distinct
%                set of datasets, such that DatasetNum is incremented as
%                SMD2.DatasetNum += SMD1.NDatasets before concatenation.
%                (Default = true)
%   ShowWarnings: Flag indicating warnings should be shown.
%                 (Default = true)
%
% OUTPUTS:
%   SMD: A Single Molecule Data structure whose vector fields are the
%        concatenated vector fields from SMD1 and SMD2.  The scalar fields
%        will be kept as scalar fields when equal in both SMD1 and SMD2,
%        and kept as cell arrays when they are not.

% Created by:
%   David J. Schodt (Lidke lab, 2020)


% Set defaults.
if (~exist('NewDataFlag', 'var') || isempty(NewDataFlag))
    NewDataFlag = true;
end
if (~exist('ShowWarnings', 'var') || isempty(ShowWarnings))
    ShowWarnings = true;
end

% Ensure neither of the input SMD's are empty.  If one of them is empty,
% output the other one without changes.  If both appear empty, return a
% default empty SMD.  Note that if SMD exists but SMD.X is empty, then
% there are no localizations present, so this is equivalent to SMD empty.
if ((isempty(SMD1)||isempty(SMD1.X)) && (isempty(SMD2)||isempty(SMD2.X)))
    SMD = smi_core.SingleMoleculeData.createSMD();
    return
elseif (isempty(SMD1) || isempty(SMD1.X))
    SMD = SMD2;
    return
elseif (isempty(SMD2) || isempty(SMD2.X))
    SMD = SMD1;
    return
end

% Define which SMD fields can be stacked directly (see note at top of code)
% NOTE: We could just check which fields are numeric vectors with
%       (numel() > 1), but that convenience limits us to SMD structures
%       with more than one localization.
StackableFields = {'XBoxCorner', 'YBoxCorner', ...
    'X', 'Y', 'Z', ...
    'X_SE', 'Y_SE', 'Z_SE', ...
    'Photons', 'Photons_SE', ...
    'Bg', 'Bg_SE', ...
    'PSFSigma', 'PSFSigmaX', 'PSFSigmaY', ...
    'PSFSigma_SE', 'PSFSigmaX_SE', 'PSFSigmaY_SE', ...
    'PValue', 'LogLikelihood', 'ThreshFlag', ...
    'NCombined', 'IndSMD', 'DatasetNum', 'FrameNum', 'ConnectID', ...
    'PreGCConnectID', 'RegError'};

% Define a set of "special" fields in SMD: these fields are treated
% differently on a case-by-case basis towards the end of this method.
% NOTE: I mostly added this to bypass the warnings that happen in the main
%       for loop below. In fact, not all of the "special" fields are even
%       in this list, e.g., PSFSigma is also treated differently in some
%       cases, but not included in this list.
SpecialFields = {'DriftX', 'DriftY', 'DriftZ', 'NDatasets', ...
    'ConnectID', 'IndSMD'};

% Create a list of fields present in each of SMD1 and SMD2.
FieldNames1 = fieldnames(SMD1);
FieldNames2 = fieldnames(SMD2);

% Check if SMD1 and SMD2 have the same fields, warning the user if this
% isn't the case.
UniqueFields1 = FieldNames1(~ismember(FieldNames1, FieldNames2));
UniqueFields2 = FieldNames2(~ismember(FieldNames2, FieldNames1));
if ~isempty(UniqueFields1)
    PrintFriendlyFields1 = cell2mat(cellfun(@(X) [X, ' '], ...
        UniqueFields1, 'UniformOutput', false).');
    if ShowWarnings
        warning(['smi_core.SingleMoleculeData.catSMD() - ', ...
            'The following SMD1 fields aren''t present in SMD2: ', ...
            PrintFriendlyFields1])
    end
end
if ~isempty(UniqueFields2)
    PrintFriendlyFields2 = cell2mat(cellfun(@(X) [X, ' '], ...
        UniqueFields2, 'UniformOutput', false).');
    if ShowWarnings
        warning(['smi_core.SingleMoleculeData.catSMD() - ', ...
            'The following SMD2 fields aren''t present in SMD1: ', ...
            PrintFriendlyFields2])
    end
end

% If needed, update SMD2.DatasetNum before proceeding.
if NewDataFlag
    SMD2.DatasetNum = SMD2.DatasetNum + SMD1.NDatasets;
end

% Place the unique fields (fields that are only in one of SMD1 or SMD2) in
% the SMD structure directly.
SMD = smi_core.SingleMoleculeData.createSMD();
for uu = 1:numel(UniqueFields1)
    SMD.(UniqueFields1{uu}) = SMD1.(UniqueFields1{uu});
end
for uu = 1:numel(UniqueFields2)
    SMD.(UniqueFields2{uu}) = SMD2.(UniqueFields2{uu});
end

% Loop through fields present in SMD1 and SMD2 and begin constructing the
% concatenated output SMD.
% NOTE: There are a several "special" fields (which aren't defined in
%       VectorFields above) that will be defined illogically/incorrectly in
%       this loop.  Those fields will be revised later on.
AllFieldNames = unique([FieldNames1; FieldNames2]);
SharedFields = AllFieldNames(ismember(AllFieldNames, FieldNames1) ...
    & ismember(AllFieldNames, FieldNames2));
IsStackable = ismember(SharedFields, StackableFields);
IsSpecialField = ismember(SharedFields, SpecialFields);
for ff = 1:numel(SharedFields)
    % Place the current field in the output SMD, concatenating when
    % appropriate.
    CurrentField = SharedFields{ff};
    if IsStackable(ff)
        % Stackable fields should be concatenated directly.
        SMD.(CurrentField) = [SMD1.(CurrentField); SMD2.(CurrentField)];
    elseif isequal(SMD1.(CurrentField), SMD2.(CurrentField))
        % We want to ensure non-stackable fields are consistent with one
        % another before setting the output field.
        SMD.(CurrentField) = SMD1.(CurrentField);
    elseif ~IsSpecialField(ff)
        % This appears to be a non-stackable field, but the field is not
        % equal in SMD1 and SMD2; we will trust the user and concatenate
        % these two as though it were a vector field.
        if ShowWarnings
            warning(['smi_core.SingleMoleculeData.catSMD() - ', ...
                'SMD field ''%s'' is different in each of ', ...
                'SMD1 and SMD2, attempting to concatenate.'], CurrentField)
        end
        try
            SMD.(CurrentField) = [SMD1.(CurrentField); ...
                SMD2.(CurrentField)];
        catch Exception
            if ShowWarnings
                warning(['smi_core.SingleMoleculeData.catSMD() - ', ...
                    'Concatenation of field ''%s'' failed, storing as ', ...
                    'cell array.\n%s, %s'], CurrentField, ...
                    Exception.identifier, Exception.message)
            end
            SMD.(CurrentField) = {SMD1.(CurrentField); ...
                SMD2.(CurrentField)};
        end
    end
end

% Revise fields that may or may not be vector fields (e.g., PSFSigma is
% either scalar or vector depending on the fit that was used).
if (numel(unique(SMD.PSFSigma)) == 1)
    SMD.PSFSigma = unique(SMD.PSFSigma);
    SMD.PSFSigma_SE = unique(SMD.PSFSigma_SE);
end

% Revise the drift related fields, which should be treated differently.
% NOTE: The dimensions of drift will be [NFrames, NDatasets].
SMD.DriftX = [SMD1.DriftX, SMD2.DriftX];
SMD.DriftY = [SMD1.DriftY, SMD2.DriftY];
SMD.DriftZ = [SMD1.DriftZ, SMD2.DriftZ];

% Define the output SMD.NDatasets in a manner consistent with
% SMD.DatasetNum.
SMD.NDatasets = numel(unique(SMD.DatasetNum));
if (SMD.NDatasets ~= (SMD1.NDatasets+SMD2.NDatasets))
    if ShowWarnings
        warning(['smi_core.SingleMoleculeData.catSMD() - ', ...
            'Concatenated SMD field ''NDatasets'' may not match ', ...
            'expectations: SMD.NDatasets set to ', ...
            'numel(unique(SMD.DatasetNum))'])
    end
end

% Define the outputs SMD.ConnectID and SMD.IndSMD ensuring consistency
% (their values represent indices which lose meaning after concatenation).
% NOTE: While this might make more sense to put at the top of this code, I
%       wanted to do it this way (with 'ConnectID' and 'IndSMD' added to
%       'SpecialFields') so that it's more clear to readers that something
%       special is being done with these fields.
MaxConnectIDSMD1 = max([0; SMD1.ConnectID]);
MaxIndSMD1 = max([0; cell2mat(SMD1.IndSMD)]);
SMD2.ConnectID = SMD2.ConnectID + MaxConnectIDSMD1;
SMD2.IndSMD = cellfun(@(X) X + MaxIndSMD1, SMD2.IndSMD, ...
    'UniformOutput', false);
SMD.ConnectID = [SMD1.ConnectID; SMD2.ConnectID];
SMD.IndSMD = [SMD1.IndSMD; SMD2.IndSMD];


end

./MATLAB/+smi_core/@SingleMoleculeData/isolateSubROI.m
function [SMD] = isolateSubROI(SMD, ROI)
%isolateSubROI isolates localizations within ROI.
% This method will isolate a subset of SMD defined by the region of
% interest ROI.
%
% NOTE: As written, the pixel convention used in this method is that the
%       left edge of pixel n has coordinate n-1 and the right edge has
%       coordinate n (where entries of ROI are defined as integers n>0).
%
% INPUTS:
%   SMD: A Single Molecule Data structure.
%   ROI: Region of interested with inclusive edges. 
%        (pixels)([YStart, XStart, YEnd, XEnd])
%
% OUTPUTS:
%   SMD: A Single Molecule Data structure whose vector fields correspond to
%        the input region of interested defined by ROI.

% Created by:
%   David J. Schodt (Lidke lab, 2021)


KeepBool = ((SMD.Y>=ROI(1)) & (SMD.Y<=ROI(3)) ...
    & (SMD.X>=ROI(2)) & (SMD.X<=ROI(4)));
SMD = smi_core.SingleMoleculeData.isolateSubSMD(SMD, KeepBool);


end
./MATLAB/+smi_core/@FindROI/extractROIs.m
function [ROIStack, CameraGain, CameraOffset, CameraReadNoise] = ...
    extractROIs(SMD, SMF, CorrectData)
%extractROIs reloads raw data and extracts ROIs corresponding to SMD locs.
% This method reloads raw data defined by SMF.Data.FileDir and
% SMF.Data.FileName{1} and cuts out the ROIs defined by SMD.XBoxCorner,
% SMD.YBoxCorner, and SMF.BoxFinding.BoxSize.

% INPUTS:
%   SMD: Single Molecule Data Structure (see smi_core.SingleMoleculeData)
%   SMF: Single Molecule Fitting Structure (see
%        smi_core.SingleMoleculeFitting)
%   CorrectData: Flag indicating we should apply gain/offset correction to
%                the raw data before extracting the ROIs. (Default = true)
%
% OUTPUTS:
%   ROIStack: Stack of sub-ROIs extracted from the raw data.  The third
%             dimension shares the same indexing as SMD.XBoxCorner.
%             (SMF.BoxFinding.BoxSize x SMF.BoxFinding.BoxSize
%              x length(SMD.XBoxCorner) numeric array)
%   CameraGain/Offset/ReadNoise: Returned as a convenience since they're
%                                used internally (see
%                                smi_core.DataToPhotons).  Note that
%                                CameraReadNoise is the UN-CORRECTED
%                                readnoise image (i.e., it has units of
%                                ADU^2)

% Created by:
%   David J. Schodt (Lidke Lab, 2022)


% Set defaults if needed.
if (~exist('CorrectData', 'var') || isempty(CorrectData))
    CorrectData = true;
end

% Load the calibration data.
if CorrectData
    DTP = smi_core.DataToPhotons(SMF);
else
    DTP = smi_core.DataToPhotons();
    DTP.CameraGain = 1;
    DTP.CameraOffset = 0;
end

% Loop over datasets in SMD, load data, and extract ROIs.
BoxSize = SMF.BoxFinding.BoxSize;
ROIStack = NaN(BoxSize, BoxSize, numel(SMD.XBoxCorner));
LD = smi_core.LoadData;
ROIStackInd = 1; % index to keep track of where to add new data in ROIStack
for nn = unique(SMD.DatasetNum.')
    % Load the raw data.
    [~, RawData] = LD.loadRawData(SMF, nn);

    % Apply gain/offset correction (note settings of DTP.CameraGain = 1 and
    % DTP.CameraOffset = 0 when CorrectData = false).
    DTP.RawData = RawData;
    CorrectedData = DTP.convertData();

    % Extract the ROIs.
    % NOTE: This code relies on SMD.XBoxCorner and SMD.YBoxCorner being
    %       defined such that the box length defined by
    %       SMF.BoxFinding.BoxSize does not push us beyond the border of
    %       the data (e.g., if the data is 256x256 and BoxSize=7,
    %       max(SMD.XBoxCorner)<=250 and max(SMD.YBoxCorner)<=250).
    SMDSub = ...
        smi_core.SingleMoleculeData.isolateSubSMD(SMD, SMD.DatasetNum==nn);
    for rr = 1:numel(SMDSub.XBoxCorner)
        ROIStack(:, :, ROIStackInd) = CorrectedData(...
            SMDSub.YBoxCorner(rr):(SMDSub.YBoxCorner(rr)+BoxSize-1), ...
            SMDSub.XBoxCorner(rr):(SMDSub.XBoxCorner(rr)+BoxSize-1), ...
            SMDSub.FrameNum(rr));
        ROIStackInd = ROIStackInd + 1;
    end
end

% Return extra outputs if needed.
if (nargout > 1)
    CameraGain = DTP.CameraGain;
    CameraOffset = DTP.CameraOffset;
    CameraReadNoise = DTP.CameraReadNoise;
end


end
./MATLAB/+smi_core/@FindROI/FindROI.m
classdef FindROI < handle
    % FindROI Finds and collates subregions from a stack of 2D images
    %
    % Subregions are found by filtering with a difference of Gaussians filter
    % followed by finding the local maximum.  Local maxima are used as the
    % center of ROIs if the estimated single molecule intesity is greater than
    % MinPhotons.
    %
    % Gaussian filtering is done using the recursive method of Young.
    % Local maximum finding is done using a novel separable filter (Lidke).
    %
    % Filtering and maximum finding are implemented on GPU using CUDA
    % and the Parallel Processsing Toolbox.
    %
    %
    % REQUIRES:
    %   MATLAB 2014a or later versions
    %   Parallel Procesing Toolbox
    %   NVidia GPU
    %   smi_cuda_FindROI.ptx
    %   smi_cuda_FindROI.cu
    %
    % CITATION:
    %   Ian T. Young, Lucas J. van Vliet,
    %   Recursive implementation of the Gaussian filter,
    %   Signal Processing, Volume 44, Issue 2, 1995
    
    
    properties
        Data            %Stack of 2D images
        BoxSize=7       %Linear box size for fitting (Pixels)(Default=7)
        BoxOverlap=2    %Overlap of boxes (Integer Pixels)(Default=2)
        MinPhotons=200  %Minimum number of photons from emitter (Default=200)
        PSFSigma=1.3    %Sigma of 2D Gaussian PSF (Pixels) (Default=1.3)
        ROIs            %Stack of subregions
        LocalMaxIm      %Binary Image showing local maxima above the threshold
        PlotBoxFrame=1  %If Verbose >= 3, plot boxes for this frame (Default=1)
        Verbose=1       %Verbosity level
        IsSCMOS         %Is a SCMOS Camera and will use Variance image 
        Varim           %Variance Image (photons^2)
    end
    
    properties (Access = protected)
        SigmaSmall      %Small smoothing kernel (Pixels)(Default=PSFSigma)
        SigmaLarge      %Large smoothing kernel (Pixels)(Default=2*PSFSigma) 
    end
    
    methods
        function [obj]=FindROI(SMF,Data)
        %FindROI Create a FindROI object
        %[obj]=FindROI(SMF,Data)
        %
        % [obj]=FindROI()
        % Creates an object with default property values.
        %
        % [obj]=FindROI(SMF)
        % Creates an object and copies SMF fields to Properties
        %
        % [obj]=FindROI(SMF,Data)
        % Creates an object and copies Data and SMF fields to Properties
        %
        % INPUTS
        %   SMF:    SMF structure with fields (Optional)
        %       BoxFinding:
        %           BoxSize         %Linear box size for fitting (Pixels)
        %           BoxOverlap      %Overlap of boxes allowed (Pixels)
        %           MinPhotons      %Minimum number of photons from emitter
        %       Fitting:
        %           PSFSigma        %Sigma of 2D Gaussian PSF Model (Pixels)
        %   Data:   Stack of 2D images (Optional)
        %
        % OUTPUTS
        %   obj:    FindROI object
        %
            if nargin > 0
                obj.BoxSize=SMF.BoxFinding.BoxSize;
                obj.BoxOverlap=SMF.BoxFinding.BoxOverlap;
                obj.MinPhotons=SMF.BoxFinding.MinPhotons;
                obj.PSFSigma=mean(SMF.Fitting.PSFSigma);
                obj.SigmaSmall=obj.PSFSigma;
                obj.SigmaLarge=2*obj.PSFSigma;
                switch SMF.Data.CameraType
                    case 'SCMOS'
                        obj.IsSCMOS = 1;
                        obj.Varim = gpuArray(single(SMF.Data.CameraReadNoise./SMF.Data.CameraGain.^2)); 
                    otherwise
                        obj.IsSCMOS = 0;
                end
                
            end
            
            if nargin > 1
                obj.Data=Data;
            end

        end
        
        function [ROIStack,SMD]=findROI(obj,SMD)
            %findROI Main method of FindROI
            %[ROIs]=obj.findROI()
            %
            % Finds and cuts out subregions of size BoxSize x BoxSize. If no
            % SMD is given as input, a default SMD is created.  The XBoxCorner
            % and YBoxCorner are modified in the SMD structure.
            %
            % INPUTS
            %   SMD      SMD data structure (Optional)
            %
            % OUTPUTS
            %   ROIStack Stack of N 2D subregions (BoxSize x BoxSize x N)
            %   SMD      SMD data structure based on input SMD structure if
            %            provided, or newly created.  Fields defined here are:
            %               XBoxCorner, YBoxCorner, FrameNum, NFrames, XSize,
            %               YSize, NDims (findROI assumes 2D)
            
            %Create SMD if needed
            if nargin<2
               SMD=smi_core.SingleMoleculeData.createSMD();
            end
            
            %Calculate min allowed local maximum value
            SigmaBlob=sqrt(obj.SigmaSmall^2+mean(obj.PSFSigma)^2);
            MinVal = obj.MinPhotons*(1/(2*pi*SigmaBlob^2));
            
            %Calculate Kernel Size
            LMKernelSize=obj.BoxSize-obj.BoxOverlap;
            
            %Break data into chunks that fit in GPU memory
            NCopies=8; %for out of place operations
            NBytesPerPixel=4; %single float
            NElem = numel(obj.Data);
            g = gpuDevice;
            NLoops = ceil(NBytesPerPixel*NCopies*NElem/(g.AvailableMemory));
            
            %Number of frames in each chunk.
            ZSize = size(obj.Data,3);
            ZChunkSize = floor(ZSize/NLoops);
            LocalMaxIm_Temp = zeros(size(obj.Data));
            
            %The loop sends one chunk of data at each iteration to the gpu.
            for ii = 1:NLoops
                
                ZStart=(ii-1)*ZChunkSize+1;
                ZEnd = ii*ZChunkSize;
                if ii == NLoops
                    ZEnd = ZSize;
                end
                
                %The chunk of data that is sent to the GPU
                SubStack = obj.Data(:,:,ZStart:ZEnd);
                
                %Call static methods
                switch obj.IsSCMOS
                    case 0
                        [D_A] = smi_core.FindROI.gaussInPlace(SubStack,obj.SigmaSmall);
                        [D_B] = smi_core.FindROI.gaussInPlace(SubStack,obj.SigmaLarge);
                    case 1
                        [D_A] = smi_core.FindROI.gauss_sCMOS(SubStack,obj.Varim, obj.SigmaSmall);
                        [D_B] = smi_core.FindROI.gauss_sCMOS(SubStack,obj.Varim, obj.SigmaLarge);    
                end
                D_A=D_A-D_B;
                [SubLocalMax]=smi_core.FindROI.localMax(D_A,LMKernelSize,MinVal);
                
                %Collect Results
                LocalMaxIm_Temp(:,:,ZStart:ZEnd) = SubLocalMax;
            end
            wait(g);
            obj.LocalMaxIm=LocalMaxIm_Temp;
            
            %Finding coordinates of the local maxima
            XSize = size(obj.Data,2);
            YSize = size(obj.Data,1);
            
            [Ind] = find(obj.LocalMaxIm);
            [YInd,XInd,ZInd]=ind2sub([YSize XSize ZSize],Ind);
            
            %Finding the boxes
            HalfBox = floor(obj.BoxSize/2+0.5);
            StartRow = YInd-HalfBox+1;
            minusRow = find(StartRow<1);
            StartRow(minusRow) = 1;
            StartCol = XInd-HalfBox+1;
            MinusCol = find(StartCol<1);
            StartCol(MinusCol) = 1;
            
            EndRow = StartRow + obj.BoxSize-1;
            EndRow(minusRow) = obj.BoxSize;
            LargeRow = find(EndRow > YSize);
            EndRow(LargeRow) = YSize;
            StartRow(LargeRow) = YSize - obj.BoxSize +1;
            
            EndCol = StartCol + obj.BoxSize-1;
            EndCol(MinusCol) = obj.BoxSize;
            LargeCol = find(EndCol > XSize);
            EndCol(LargeCol) = XSize;
            StartCol(LargeCol) = XSize - obj.BoxSize + 1;
            
            %Outputs:
            N = length(StartRow); 

            ROIStack = zeros(obj.BoxSize,obj.BoxSize,N);
            for nn = 1:N
                ROIStack(:,:,nn) = obj.Data(StartRow(nn):EndRow(nn), StartCol(nn):EndCol(nn), ZInd(nn));
            end
            SMD.XBoxCorner = StartCol;
            SMD.YBoxCorner = StartRow;
            SMD.FrameNum = ZInd;
            SMD.NFrames = ZSize;
            SMD.XSize = XSize;
            SMD.YSize = YSize;
            SMD.NDims = 2;

            if obj.Verbose >= 3
                Params.PercentileFloor = 1;
                Params.PercentileCeiling = 99;
                obj.plotBoxStack(SMD, obj.Data, obj.BoxSize, Params)
            end
        end
        
        function showOverlay(obj)
        %showOverlay Show local maxima on top of Data
        % 
        % REQUIRES:
        %   DipImage
        
        overlay(stretch(obj.Data),obj.LocalMaxIm)
            
        end
        
    end
    
    methods (Static)
        function [Stack] = gaussInPlace(Stack, Sigma)
        %gaussInPlace() In-place Gaussian filter  
        % [SubStack] = gaussInPlace(SubStack, Sigma)
        %
        % Filtering is applied using the recursive method of Young and Van
        % Vliet and implimented on the GPU using CUDA. 
        %
        % This is an in-place filter, meaning that input array is
        % modified and given back as the ouput.  
        %
        % If the input is not gpuArray, it is copied to the GPU, which has
        % the effect that the input is not modified. 
        % 
        % INPUTS:
        %   Stack:      Stack of 2D images to be filtered
        %   Sigma:      Gaussian Kernel (Pixels)
        %
        % OUTPUTS:
        %   Stack:      Modified 2D stack of images (gpuArray) 
        %
        % REQUIRES:
        %   MATLAB 2014a or later versions
        %   Parallel Procesing Toolbox
        %   NVidia GPU
        %   smi_cuda_FindROI.ptx
        %   smi_cuda_FindROI.cu
        %
        % CITATION:
        %   Ian T. Young, Lucas J. van Vliet,
        %   Recursive implementation of the Gaussian filter,
        %   Signal Processing, Volume 44, Issue 2, 1995
        
        %Setting up constants for the recursive method (See citation)
        if Sigma > 2.5
            Q = 0.98711*Sigma-0.96330;
        else
            Q = 3.97156-4.14554*sqrt(1-0.26891*Sigma);
        end
        
        Qq = Q*Q;
        Qqq = Qq*Q;
        
        B0 = 1.57825+2.44413*Q+1.4281*Qq+0.422205*Qqq;
        B1 = 2.44413*Q+2.85619*Qq+1.26661*Qqq;
        B2 = -1.4281*Qq-1.26661*Qqq;
        B3 = 0.422205*Qqq;
        B = 1 - (B1+B2+B3)/B0;
        
        %Creating GPU CUDA kernel objects from PTX and CU code
        K_Gauss = parallel.gpu.CUDAKernel('smi_cuda_FindROI.ptx','smi_cuda_FindROI.cu','kernel_gaussMajor');
        
        %Calling the gpu code to apply Gaussian filter along major
        %This is an in-place operation
        K_Gauss.GridSize(1) = size(Stack,3);
        K_Gauss.ThreadBlockSize(1) = size(Stack,2);
        Stack = feval(K_Gauss,Stack,size(Stack,1),B0,B1,B2,B3,B);
        
        %Permuting and doing the other dimension
        Stack=permute(Stack,[2 1 3]);
        
        K_Gauss.GridSize(1) = size(Stack,3);
        K_Gauss.ThreadBlockSize(1) = size(Stack,2);
        Stack = feval(K_Gauss,Stack,size(Stack,1),B0,B1,B2,B3,B);
        
        %Permute back.  
        Stack=permute(Stack,[2 1 3]);
        end
        
        function [Out] = gauss_sCMOS(Stack, Varim, Sigma)
        %gauss_sCMOS() Out of place, weighted Gaussian filter
        % [SubStack] = gauss_sCMOS(SubStack, Varim, Sigma)
        %
        % Filtering is applied using direct, weighted calcualtion, but done
        % separably along x and y. 
        %
        % This is an out of place filter, meaning that inputs are not
        % modified. 
        %
        % If the input is not gpuArray, it is copied to the GPU
        % 
        % INPUTS:
        %   Stack:      Stack of 2D images to be filtered
        %   Varim:      A gain-corrected variance image 
        %   Sigma:      Gaussian Kernel (Pixels)
        %
        % OUTPUTS:
        %   Out:        2D stack of images (gpuArray) 
        %
        % REQUIRES:
        %   MATLAB 2014a or later versions
        %   Parallel Procesing Toolbox
        %   NVidia GPU
        %   smi_cuda_FindROI.ptx
        %   smi_cuda_FindROI.cu
        %
        
        Out1=gpuArray(zeros(size(Stack),'single'));
        
        %Creating GPU CUDA kernel objects from PTX and CU code
        K_Gauss = parallel.gpu.CUDAKernel('smi_cuda_FindROI.ptx','smi_cuda_FindROI.cu','kernel_gaussMajor_sCMOS');
        K_Gauss.GridSize(1) = size(Stack,3);
        K_Gauss.ThreadBlockSize(1) = size(Stack,2);
        
        %Calling the gpu code to apply Gaussian filter along major
        Out1 = feval(K_Gauss,gpuArray(Stack),Varim,Out1,size(Stack,1),Sigma);
        
        %Permuting and doing the other dimension
        Out = gpuArray(zeros(size(Stack),'single'));
        Out = feval(K_Gauss,permute(Out1,[2 1 3]),permute(Varim,[2 1]),Out,size(Stack,1),Sigma);
        
        %Permute back
        Out = permute(Out,[2 1 3]);

        end
        
        function [LocalMaxIm]=localMax(Stack,KernelSize,MinVal)
        %localMax() Generates a binary image of local maxima
        %
        % Local maxima are found within a square area of size KernelSize+1.
        % This is a 2D operation applied to each image in the Stack.  The
        % output is a binary image that has true pixels at the locations of
        % the local maxima that are larger MinVal. 
        % 
        % Uses a x,y separable, out-of-place filter to find local maxima
        % in 2D images. 
        % 
        % INPUTS: 
        %   Stack:      Stack of 2D images. 
        %   KernelSize: Closest allowed local maxima in each dimension
        %   MinVal:     Minimum value of local maxima to be valid
        %
        % OUTPUTS: 
        %   LocalMaxIm: Stack of binary images indicating local maximum     
        %
        % REQUIRES:
        %   MATLAB 2014a or later versions
        %   Parallel Procesing Toolbox
        %   NVidia GPU
        %   smi_cuda_FindROI.ptx
        %   smi_cuda_FindROI.cu
        
            K_LM1 = parallel.gpu.CUDAKernel('smi_cuda_FindROI.ptx','smi_cuda_FindROI.cu','kernel_LocalMaxFirstPass');
            K_LM2 = parallel.gpu.CUDAKernel('smi_cuda_FindROI.ptx','smi_cuda_FindROI.cu','kernel_LocalMaxSecondPass');
            
            %Make out-of-place storage and final image
            TempStack=gpuArray(Stack);
            LocalMaxIm=gpuArray(Stack);
            
            K_LM1.GridSize = [size(Stack,2),size(Stack,3),1];
            K_LM1.ThreadBlockSize(1) = size(Stack,1);
            [TempStack] = feval(K_LM1,Stack,TempStack,KernelSize,MinVal);
            
            %Permute for faster cuda kernel
            TempStack=permute(TempStack,[2 1 3]);
            LocalMaxIm=permute(LocalMaxIm,[2 1 3]);
             
            K_LM2.GridSize = [size(TempStack,2),size(TempStack,3),1];
            K_LM2.ThreadBlockSize(1) = size(TempStack,1);
            [LocalMaxIm] = feval(K_LM2,TempStack,LocalMaxIm,KernelSize,MinVal);
            
            %Permute back and give host output
            LocalMaxIm=permute(LocalMaxIm,[2 1 3]);
            LocalMaxIm = gather(LocalMaxIm);
        end

        plotBox(SMD, Data, Frame, BoxSize)
        plotBoxStack(SMD, Data, BoxSize, Params)
        [ROIStack, CameraGain, CameraOffset, CameraReadNoise] = ...
            extractROIs(SMD, SMF, CorrectData);
    end
end



./MATLAB/+smi_core/@FindROI/README.md
### +smi_core/@FindROI

FindROI Finds and collates subregions from a stack of 2D images

Subregions are found by filtering with a difference of Gaussians filter
followed by finding the local maximum.  Local maxima are used as the
center of ROIs if the estimated single molecule intesity is greater than
MinPhotons.

Gaussian filtering is done using the recursive method of Young.
Local maximum finding is done using a novel separable filter (Lidke).

Filtering and maximum finding are implemented on GPU using CUDA
and the Parallel Processsing Toolbox.

REQUIRES:
- MATLAB 2014a or later versions
- Parallel Procesing Toolbox
- NVidia GPU
- smi_cuda_FindROI.ptx
- smi_cuda_FindROI.cu

CITATION:
  Ian T. Young, Lucas J. van Vliet,
  Recursive implementation of the Gaussian filter,
  Signal Processing, Volume 44, Issue 2, 1995

---

```
properties:
   Data            %Stack of 2D images
   BoxSize=7       %Linear box size for fitting (Pixels)(Default=7)
   BoxOverlap=2    %Overlap of boxes (Integer Pixels)(Default=2)
   MinPhotons=200  %Minimum number of photons from emitter (Default=200)
   PSFSigma=1.3    %Sigma of 2D Gaussian PSF (Pixels) (Default=1.3)
   ROIs            %Stack of subregions
   LocalMaxIm      %Binary Image showing local maxima above the threshold
   PlotBoxFrame=1  %If Verbose >= 3, plot boxes for this frame (Default=1)
   Verbose=1       %Verbosity level
   IsSCMOS         %Is a SCMOS Camera and will use Variance image 
   Varim           %Variance Image (photons^2)
```

---

methods:
- **[extractROIs](extractROIs.m)**:
  reloads raw data and extracts ROIs corresponding to SMD locs
- **[plotBox](plotBox.m)**:
  plots the found boxes in the given Frame of the Data/SMD structure
- **[plotBoxStack](plotBoxStack.m)**:
  plots the found boxes in Data/SMD structure

./MATLAB/+smi_core/@FindROI/plotBox.m
function plotBox(SMD,Data,Frame,BoxSize)
%plotBox plots the found boxes in the given Frame of the Data/SMD structure.
%
%plotBox takes the data and the structure containing the box info and the
%number of the frame that you are interested in and plots the found boxes.
%This routine is only really needed for debugging.
%
% INPUTS
%    SMD             SMD data structure with fields:
%       FrameNum     frame numbers of localizations
%       XBoxCorner   X coordinates of top right box corners (pixels)
%       YBoxCorner   Y coordinates of top right box corners (pixels)
%    Data            raw image data (XSize x YSize x NFrames)
%    Frame           user specified frame number of interest
%    BoxSize         linear box size for fitting (pixels)

% Created by
%    Mohamad Fazel

ParticleFrame = find(SMD.FrameNum==Frame);
XCorners = double(SMD.XBoxCorner(ParticleFrame));
YCorners = double(SMD.YBoxCorner(ParticleFrame));
PlotAxes = axes(figure());
imshow(Data(:,:,Frame), [], 'Parent', PlotAxes)
%PlotAxes.Visible = 'off';
hold(PlotAxes, 'on')
for nn = 1:length(ParticleFrame)
   plot(PlotAxes, XCorners(nn)*ones(1,BoxSize),YCorners(nn):YCorners(nn)+BoxSize-1,'y') 
   plot(PlotAxes, (XCorners(nn)+BoxSize-1)*ones(1,BoxSize),YCorners(nn):YCorners(nn)+BoxSize-1,'y')
   plot(PlotAxes, XCorners(nn):XCorners(nn)+BoxSize-1,YCorners(nn)*ones(1,BoxSize),'y') 
   plot(PlotAxes, XCorners(nn):XCorners(nn)+BoxSize-1,(YCorners(nn)+BoxSize-1)*ones(1,BoxSize),'y')
end
hold off

end

./MATLAB/+smi_core/@FindROI/plotBoxStack.m
function plotBoxStack(SMD, Data, BoxSize, Params)
%plotBoxStack plots the found boxes in Data/SMD structure.
% This method extends plotBox() to allow slices through multiple frames by
% interactive use of a slide bar.
%
% INPUTS
%    SMD: Single Molecule Data structure with fields
%         FrameNum: Frame numbers of localizations.
%         XBoxCorner: X coordinates of top right box corners. (pixels)
%         YBoxCorner: Y coordinates of top right box corners. (pixels)
%    Data: Raw data images. (XSize x YSize x NFrames)
%    BoxSize: Linear box size used for fitting. (pixels)
%    Params: Set of parameters that can be used to scale the data. 
%            (see image related parameters in
%            smi_vis.GenerateMovies.prepDefaults() as well as usage below). 
%            (Default = smi_vis.GenerateMovies.prepDefaults())

% Created by:
%    David J. Schodt (Lidke Lab, 2022)


% Set defaults.
if (~exist('Params', 'var') || isempty(Params))
    Params = smi_vis.GenerateMovies.prepDefaults();
else
    Params = smi_helpers.padStruct(Params, ...
        smi_vis.GenerateMovies.prepDefaults());
end

% Prepare the data.
Data = smi_vis.contrastStretch(single(Data), [0; 1], ...
    Params.PercentileCeiling, Params.PercentileFloor, ...
    Params.MinScaleIntensity);

% Prepare the slide bar.
PlotFigure = figure();
PlotFigure.Name = 'Raw data ROIs from SMD';
SlidePanel = uipanel(PlotFigure, ...
    'Units', 'normalized', 'Position', [0, 0, 1, 0.1]);
NFrames = size(Data, 3);
uicontrol('Parent', SlidePanel, ...
    'Style', 'slider', ...
    'Units', 'normalized', 'Position', [0, 0.5, 1, 0.5], ...
    'HorizontalAlignment', 'left', ...
    'Min', 1, 'Max', NFrames, ...
    'SliderStep', [1, 10] / NFrames, ...
    'Value', 1, ...
    'Callback', @frameSlider);
FrameNumDisplay = uicontrol('Parent', SlidePanel, ...
    'Style', 'text', 'String', sprintf('Frame %i of %i', 1, NFrames),...
    'Units', 'normalized', 'Position', [0, 0, 1, 0.5], ...
    'HorizontalAlignment', 'left');

% Prepare the data panel.
DataPanel = uipanel(PlotFigure, ...
    'Units', 'normalized', 'Position', [0, 0.1, 1, 0.9]);
PlotAxes = axes(DataPanel);
imshow(Data(:, :, 1), [0, 1], 'Parent', PlotAxes)
hold(PlotAxes, 'on')
axis(PlotAxes, 'tight')

% Isolate some bits of data for speed.
XCorners = double(SMD.XBoxCorner);
YCorners = double(SMD.YBoxCorner);
FrameNum = double(SMD.FrameNum);

% Plot the initial boxes.
OnesArray = ones(BoxSize, 1, 'double');
IndArray = (0:(BoxSize-1)).';
plotBoxes(XCorners, YCorners, BoxSize, FrameNum, 1)

% Define the action of the slide bar.
    function frameSlider(Source, ~)
        % Plot the raw data.
        cla(PlotAxes)
        FrameNumber = round(Source.Value);
        imshow(Data(:, :, FrameNumber), [0, 1], 'Parent', PlotAxes)
        FrameNumDisplay.String = sprintf('Frame %i of %i', FrameNumber, NFrames);

        % Plot the boxes.
        plotBoxes(XCorners, YCorners, BoxSize, FrameNum, FrameNumber)
    end

    function plotBoxes(XCorners, YCorners, BoxSize, FrameNum, FrameNumber)
        % Plot the boxes for the current frame.
        CurrentFrame = find(FrameNum == FrameNumber);
        for nn = CurrentFrame.'
            plot(PlotAxes, XCorners(nn)*OnesArray, ...
                YCorners(nn) + IndArray, 'y')
            plot(PlotAxes, (XCorners(nn)+BoxSize-1)*OnesArray, ...
                YCorners(nn) + IndArray, 'y')
            plot(PlotAxes, XCorners(nn) + IndArray, ...
                YCorners(nn)*OnesArray, 'y')
            plot(PlotAxes, XCorners(nn) + IndArray, ...
                (YCorners(nn)+BoxSize-1)*OnesArray, 'y')
        end
    end


end
./MATLAB/+smi_core/@LoadData/setSMFDatasetList.m
function SMF = setSMFDatasetList(SMF)
% setSMFDatasetList sets SMF.Data.DatasetList from DatasetMods and NDatasets.
%
% INPUT:
%
% SMF:  Fields that are structures: 
%    Data:
%       FileName:     File name (cell array of char array)
%       FileDir:      File directory (char array)
%       FileType:     Type of data specified by FileName. If using a custom 
%                     extension, you must set this field manually to the true 
%                     underlying file type (e.g., if using a .mat file saved 
%                     as exFile.spt, set obj.Data.FileType = 'mat')
%                     (char array)(Default set to extension of FileName{1})
%       DataVariable: Name of variable saved in FileName which contains the
%                     raw data. (char array)(Default='sequence')
%       DatasetMods:  Cell array containing datasets to be used/excluded from
%                     analysis (Mods <-> modifiers). This is meant to be the
%                     user-facing lists which define DatasetList, meaning that 
%                     this is what would be set in the GUI. DatasetMods{1} will 
%                     contain an array of the "inclusion" dataset numbers and 
%                     DatasetMods{2} will contain an array of the "exclusion" 
%                     datasets. DatasetList will be set elsewhere (e.g., 
%                     smi_core.LoadData) to include the set 
%                        intersect(intersect(1:NDatasets, DatasetMods{1}), ...
%                                    setdiff(1:NDatasets, DatasetMods{2})) 
%                     unless DatasetMods{1} is empty, in which case the first
%                     parantheses term is dropped. For example, if 
%                     NDatasets = 20 and you only want to analyze datasets 1:5,
%                     you can set DatasetMods{1} = 1:5. If you further decide
%                     to exclude datsaets 2 and 4, you could set 
%                     DatasetMods{2} = [2, 4]. 
%                     (cell array of int32 arrays)(Default={[]; []})
%
% OUTPUT:
%
% SMF:  Fields that are structures: 
%    Data:
%       DatasetList: List of datasets of the raw data to be analyzed.
%                    (array of int32)(Default=int32([]))

% Created by:
%    Michael J. Wester and David J. Schodt (Lidkelab, 2020)

   NDatasets = smi_core.LoadData.countNDatasets(SMF);
   if ~isempty(SMF.Data.DatasetMods{1})
      DatasetList = ...
         intersect(intersect(1:NDatasets, SMF.Data.DatasetMods{1}), ...
                     setdiff(1:NDatasets, SMF.Data.DatasetMods{2}));
   else
      DatasetList = setdiff(1:NDatasets, SMF.Data.DatasetMods{2});
   end
   SMF.Data.DatasetList = DatasetList;

end

./MATLAB/+smi_core/@LoadData/README.md
### +smi_core/@LoadData

LoadData has methods to load raw microsope dataset from .mat or
.h5 format files.

INPUTS:
- SMF - Single Molecule Fitting structure. The name and directory
  location of the data file is obtained from fields
  (SMF.Data.FileName and SMF.Data.FileDir) of SMF. If the fields are
  non-existent or are empty, data file selection will be required
  with a pop-up window.
- varargin - input arguments helping to locate the 'data' to be
  loaded from the data file. This varies for the different file
  extensions (.mat and .h5). For details please see
  documentation for the methods.

OUTPUTS:
- Data - data loaded from FileName, converted to type single
- SMF - SMF structure modified by adding fields FileName and FileDir,
  if not present.

---

methods:
- **[countNDatasets](countNDatasets.m)**:
  counts the number of datasets in SMF.Data.FileName .
- **[readH5File](readH5File.m)**:
  contents of an h5 file into H5Structure
- **[setSMFDatasetList](setSMFDatasetList.m)**:
  sets SMF.Data.DatasetList from DatasetMods and NDatasets

./MATLAB/+smi_core/@LoadData/readH5File.m
function [H5Structure] = readH5File(FilePath, GroupName)
%Extracts contents of an h5 file into H5Structure.
% This method will extract the Data and Attributes from a group
% named GroupName in the .h5 file specified by FilePath.
%
% Examples:
%   H5Structure = readH5File('C:\file.h5') will extract all
%       contents of file.h5 and store them in H5Structure.
%   H5Structure = readH5File('C:\file.h5', 'Laser647') will extract
%       contents of the group 'Laser647' from file.h5 given only
%       the group name.
%   H5Structure = readH5File('C:\file.h5', ...
%       '/Channel01/Zposition001/Laser647') will extract contents
%       of the group 'Laser647' from file.h5 given a full group
%       path.
%
% INPUTS: 
%   FilePath: String containing the path to the .h5 file of interest.
%   GroupName: (optional) Name of a specific group in the .h5 file to be
%              extracted.
%
% OUTPUTS:
%   H5Structure: Structured array containing the information extracted from
%                the .h5 file at FilePath.
%
% REQUIRES:
%   MATLAB 2016b or later
%
% CITATION:

% Created by:
%   David J. Schodt (LidkeLab, 2018)


% Ensure that FilePath points to a valid file.
% NOTE: == 2 means a file indeed exists at FilePath
if (exist(FilePath, 'file') ~= 2)
    error(['File specified by FilePath = ', ...
        '''%s'' does not exist.'], FilePath)
end

% If GroupName was not specified, set a flag to indicate we want to extract 
% all contents from the .h5 file.
SaveAll = ~exist('GroupName', 'var');

% Read in all of the information available about the structure of the h5
% file using MATLAB's built-in h5info() method.
CurrentGroups = h5info(FilePath);

% Determine the .h5 file structure being used (i.e. is each
% dataset in its own group or does one group contain all of
% the datasets).
% NOTE: DataFormat==1 means each dataset is in its own group,
%       DataFormat==0 means each dataset is contained in one
%       "supergroup" of all datasets.
DataFormat = contains(CurrentGroups.Groups.Groups.Groups(1).Name, 'Data');

% Search the .h5 file for the desired groups and store their location
% within the file for later extraction.
DesiredGroups = [];
if DataFormat
    % For .h5 files in the DataFormat, we need to continue searching
    % through the data groups so that we find all instances of the
    % requested group.
    DataGroupsSearched = false;
else
    % For .h5 files that do not have the DataFormat, there is only one data
    % group to search.
    DataGroupsSearched = true;
end
while (isempty(DesiredGroups) || ~DataGroupsSearched)
    % If we are extracting all contents in the .h5 file at FilePath, we 
    % don't want to perform the search procedure in this while loop.  Set 
    % DesiredGroups to CurrentGroups (all of the groups found in the .h5 
    % file) and break out of the loop.
    if SaveAll
        DesiredGroups = CurrentGroups;
        break
    end
    
    % Search the current groups for the group of interest.
    DesiredGroups = [DesiredGroups, ...
        findGroupPaths(CurrentGroups, GroupName)];
    
    % If using the data group format and we are at the .h5 structure data
    % group level, we need to search for the group of interest within the
    % sub-groups of each data group.  Otherwise, we need to move one level
    % deeper into the structure to continue the search.
    CurrentGroupNameFormat = extractGroupName(CurrentGroups(1).Name);
    if contains(CurrentGroupNameFormat, 'Data')
        % We are at the data group level and must search each data 
        % group individually.
        for ii = 1:numel(CurrentGroups)
            DesiredGroups = [DesiredGroups, ...
                findGroupPaths(CurrentGroups(ii).Groups, GroupName)];
        end
        
        % Set the DataGroupsSearched flag to indicate we've searched all of
        % the data groups.
        DataGroupsSearched = true;
    else
        % Move one level deeper into the structure and continue searching
        % for the group of interest.
        try
            % Attempt to move one level deeper into the structure.
            CurrentGroups = CurrentGroups.Groups;
        catch
            % We've reached the end of the structure, there are no more 
            % groups to explore.
            error(['No group named ''%s'' was found in ', ...
                'the file specified by FilePath = ''%s'''], ...
                GroupName, FilePath)
        end
    end
end

% Now that we've found the desired group(s), store the
% Attributes, Data, and Children in a more useable format.
for ii = 1:numel(DesiredGroups)
    % Set DesiredGroup = DesiredGroups(ii) to reduce indexing
    % clutter/improve code readability.
    DesiredGroup = DesiredGroups(ii);
    
    % Determine if the current group is the child of a data group (this 
    % will be needed later).
    DesiredGroupParentName = extractGroupName(DesiredGroup.Name, 2);
    IsDataGroupChild = (DataFormat ...
        && contains(DesiredGroupParentName, 'Data'));
    
    % If the desired group has attributes, store them in the
    % output structure.
    if ~isempty(DesiredGroup.Attributes)
        for jj = 1:numel(DesiredGroup.Attributes)
            % Store each attribute as a field in the output structure 
            % accesible directly by that attributes name.  If the
            % DesiredGroup is a data group, we'll place the attribute
            % information one level deeper into the output structure.
            AttributeName = DesiredGroup.Attributes(jj).Name;
            if IsDataGroupChild
                % For children of a datagroup, we need a different path
                % format within the structure (for consistency with the
                % structure produced for non-datagroup files).
                H5Structure(ii).Attributes.(AttributeName) = ...
                    DesiredGroup.Attributes(jj).Value;
            else
                H5Structure.Attributes.(AttributeName) = ...
                    DesiredGroup.Attributes(jj).Value;
            end
        end
    else
        % Create an empty field for the Attributes to prevent
        % issues with functions that may be using this method, proceeding
        % depending on whether or not we are currently storing a data group
        % (for files that contain separate groups for each dataset).
        if IsDataGroupChild
            % For children of a datagroup, we need a different path
            % format within the structure (for consistency with the
            % structure produced for non-datagroup files).
            H5Structure(ii).Attributes = [];
        else
            H5Structure.Attributes = [];
        end
    end
    
    % If the desired group has data, store the data in the output OldStruct
    % structure.
    if ~isempty(DesiredGroup.Datasets)
        for jj = 1:numel(DesiredGroup.Datasets)
            % Read the ii-th dataset from the h5 file and store the data 
            % in a field of the output structure, matching the datasets 
            % name in the h5 file to the name of the field in the output 
            % structure. If the DesiredGroup is a data group, we'll place 
            % the dataset information one level deeper into the output 
            % structure.
            DatasetName = DesiredGroup.Datasets(jj).Name;
            if IsDataGroupChild
                % For children of a datagroup, we need a different path
                % format within the structure (for consistency with the
                % structure produced for non-datagroup files).
                H5Structure(ii).Data.(DatasetName) = h5read(...
                    FilePath, [DesiredGroup.Name, '/', ...
                    DesiredGroup.Datasets(jj).Name]);
            else
                H5Structure.Data.(DatasetName) = ...
                    h5read(FilePath, [DesiredGroup.Name, '/', ...
                    DesiredGroup.Datasets(jj).Name]);
            end
        end
    else
        % Create an empty field for the Data to prevent issues
        % with functions that may be using this method, proceeding
        % depending on whether or not we are currently storing a data group
        % (for files that contain separate groups for each dataset).
        if IsDataGroupChild
            % For children of a datagroup, we need a different path
            % format within the structure (for consistency with the
            % structure produced for non-datagroup files).
            H5Structure(ii).Data = [];
        else
            H5Structure.Data = [];
        end
    end
    
    % If the desired group has Children (subgroups), recurse
    % through those to store their Attributes, Data, and
    % Children.
    if ~isempty(DesiredGroup.Groups)
        % Create a cell array of subgroup names (if subgroups
        % exist).
        % NOTE: If you are comparing the output structure to
        % the Data, Attributes, and Children format used in the
        % exportState() method, the subgroups are assumed to be
        % the Children.
        SubgroupNames = {DesiredGroup.Groups.Name};
        for jj = 1:numel(SubgroupNames)
            % Iteratively explore subgroups of the desired
            % group to store their attributes and data.
            SubgroupStructure = smi_core.LoadData.readH5File(...
                FilePath, SubgroupNames{jj});
            
            % Remove the path information from the subgroup name, e.g. 
            % /Channel01/Zposition001 will become Zposition001.
            SubgroupName = extractGroupName(SubgroupNames{jj});

            % Store the subgroup structure into the output H5Structure.
            H5Structure.Children.(SubgroupName) = SubgroupStructure;
        end
    else
        % Create an empty field for the Children to prevent
        % issues with functions that may be using this method, proceeding
        % depending on whether or not we are currently storing a data group
        % (for files that contain separate groups for each dataset).
        if IsDataGroupChild
            % For children of a datagroup, we need yet another path
            % format within the structure (for consistency with the
            % structure produced for non-datagroup files).
            H5Structure(ii).Children = [];
        else
            H5Structure.Children = [];
        end
    end
end

end

function [DesiredGroups] = findGroupPaths(CurrentGroups, GroupName)
% This function will create a list of paths to a group with name GroupName
% within the set of groups CurrentGroups.

% Iterate through each of the CurrentGroups to search for GroupName.
DesiredGroups = [];
CurrentGroupNames = {CurrentGroups.Name};
for ii = 1:numel(CurrentGroupNames)
    % If the GroupName isn't provided as a full path, simplify the current 
    % group name to remove group structure e.g. if
    % CurrentGroupNames{ii} = '/Channel01/Zposition001', simplify it to 
    % 'ZPosition001' for comparison to GroupName.
    if (GroupName(1) == '/')
        % If the first character of the input GroupName is '/', assume
        % that a full path was provided to the desired group.
        CurrentGroupName = CurrentGroupNames{ii};
    else
        % The full path was not given, just a raw group name was given.
        CurrentGroupName = extractGroupName(CurrentGroupNames{ii});
    end
    
    % Check if the CurrentGroupName matches the desired GroupName, storing
    % the path to the current group if we have a match.
    if strcmp(CurrentGroupName, GroupName)
        DesiredGroups = [DesiredGroups, CurrentGroups(ii)];
    end
end

end

function [GroupName] = extractGroupName(FullGroupName, PathLength)
% This function will extract the group name from a full group
% path within an .h5 file, e.g. input
% FullGroupName = '/Channel01/Zposition001/Data001'
% will yield GroupName = 'Data001'.  The optional input PathLength
% specifies how many levels from the bottom to extract, e.g. in the
% previous example PathLength would be 1, but if PathLength was 2 we would
% have GroupName = 'Zposition001'.

% Set default parameters if needed.
if ~exist('PathLength', 'var')
    PathLength = 1;
end

% If the last character of FullGroupName is a '/', we should remove it.
if ((FullGroupName(end)=='/') && (numel(FullGroupName)>1))
    FullGroupName = FullGroupName(end-1);
end

% Find the last PathLength indices within FullGroupName corresponding to
% the appearance of a '/' character.
LastSlashIndex = find(FullGroupName=='/', PathLength, 'last');

% Return either the GroupName of interest or the name of the lowest level
% group in FullGroupName as appropriate.
if (numel(LastSlashIndex) > 1)
    GroupName = FullGroupName((LastSlashIndex(1)+1):(LastSlashIndex(2)-1));
else
    GroupName = FullGroupName((LastSlashIndex+1):end);
end


end
./MATLAB/+smi_core/@LoadData/LoadData.m
classdef LoadData < handle
    % LoadData has methods to load raw microsope dataset from .mat or
    % .h5 format files.
    %
    % INPUTS:
    %   SMF - Single Molecule Fitting structure. The name and directory
    %   location of the data file is obtained from fields
    %   (SMF.Data.FileName and SMF.Data.FileDir) of SMF. If the fields are
    %   non-existent or are empty, data file selection will be required
    %   with a pop-up window.
    %   varargin - input arguments helping to locate the 'data' to be
    %   loaded from the data file. This varies for the different file
    %   extensions (.mat and .h5). For details please see
    %   documentation for the methods.
    %
    % OUTPUTS:
    %   Data - data loaded from FileName, converted to type single
    %   SMF - SMF structure modified by adding fields FileName and FileDir,
    %   if not present.
    %
    % METHODS:
    %   loadDataMat, loadDataH5
    %
    % CITATION:
    %   Sandeep Pallikkuth, Lidke Lab, 2020
    
    properties (SetAccess = 'protected')
        FileType           % Filetype determined from SMF.Data.FileName
        FullFileName       % Full file path
    end
    
    methods
        function obj = LoadData()
        % Constructor.
        end

        function [obj,Data,SMF] = loadRawData(obj,SMF,varargin)
            % INPUT
            %    SMF - single molecule fitting structure
            %    varargin - input parameters, different for each file type:
            %       mat: DatasetNum, number indicating the file in
            %               SMF.Data.FileName cell array
            %            
            %       h5: DatasetIdx, index of dataset to be loaded from h5 file
            %           ChannelIdx (optional), index of channel to be loaded, default is 1
            % OUTPUT
            %    Data - data loaded from FileName, converted to type single
            %    SMF - single molecule fitting structure with FileName,
            %    FileDir and ResultsDir added.
            
            if isfield(SMF.Data,'FileName')&&~isempty(SMF.Data.FileName)
                % determining FileTye from SMF entries of FileName
                if iscell(SMF.Data.FileName)
                    obj.FileType=SMF.Data.FileName{1}(end-2:end);
                else
                    obj.FileType = SMF.Data.FileName(end-2:end);
                end
                obj.FullFileName=fullfile(SMF.Data.FileDir,SMF.Data.FileName);
            else
                % If Filename entry not present in SMF, option to choose
                % the file/s
                [filename, pathname]=uigetfile('Y:\*.mat;*.mat;*.h5','MultiSelect','on');
                SMF.Data.FileName=filename;
                SMF.Data.FileDir=pathname;
                SMF.Data.ResultsDir=fullfile(pathname,'Results');
                obj.FullFileName=fullfile(SMF.Data.FileDir,SMF.Data.FileName);
                if iscell(SMF.Data.FileName)
                    obj.FileType=SMF.Data.FileName{1}(end-2:end);
                else
                    obj.FileType = SMF.Data.FileName(end-2:end);
                end
            end
            
            switch obj.FileType
                case 'mat'
                    % loading images from .mat file/s
                    % MatVarName, name of matlab variable containing the data
                    MatVarName = SMF.Data.DataVariable;
                    varargin = {varargin{:}, MatVarName};
                    Data=smi_core.LoadData.loadDataMat(obj.FullFileName,varargin);
                case '.h5'
                    % loading images from .h5 file
                    Data=smi_core.LoadData.loadDataH5(obj.FullFileName,varargin);
            end
            
            % If SMF.Data.DataROI is empty or larger than the available
            % data, set a default.
            DataSize = size(Data);
            if (isempty(SMF.Data.DataROI) ...
                    || any(DataSize(1:2)<SMF.Data.DataROI(3:4)))
                % For now, I'm doing this instead of 
                % [1, 1, size(Data, [1, 2])] because size(Data, [1, 2])
                % didn't work until MATLAB 2019b.
                SMF.Data.DataROI = [1, 1, DataSize(1:2), 1, 1];
            elseif (numel(SMF.Data.DataROI) < 6)
                SMF.Data.DataROI = [SMF.Data.DataROI, ...
                    ones(1, 6-numel(SMF.Data.DataROI))];
            end
                    
            % Isolate the portion of the Dataset defined by DataROI.
            Data = Data(SMF.Data.DataROI(1):SMF.Data.DataROI(3), ...
                SMF.Data.DataROI(2):SMF.Data.DataROI(4), ...
                SMF.Data.DataROI(5):SMF.Data.DataROI(6):end);
        end
    end
    
    methods (Static)
        function [Data]=loadDataMat(FullFileName,varargin)
            % static method for loading .mat file/s
            % INPUT
            %    FullFileName - full path to datafile, must be mat
            %    varargin - input parameters
            %           DatasetNum, number indicating the file in
            %            SMF.Data.FileName cell array
            %           MatVarName, name of matlab variable containing the data
            %            
            %           Eg:  [Data] = smi_core.LoadData.loadDataMat('FullFileName.mat',sequence,DatasetNum)
            % OUTPUT
            %    Data - data loaded from FileName, converted to type single
            if isempty(varargin)
                error('smi_core.LoadData.loadDataMat:','Not enough input arguments: Data = smi_core.LoadData.loadDataMat(FileName,MatVarName,DatasetNumber)');
            elseif nargin<2
                error('smi_core.LoadData.loadDataMat:','Not enough input arguments: Data = smi_core.LoadData.loadDataMat(FileName,MatVarName,DatasetNumber)');
            end
            while any(cellfun(@iscell,varargin))
                varargin = [varargin{cellfun(@iscell,varargin)} varargin(~cellfun(@iscell,varargin))];
            end

            DatasetNum = varargin{1};
            MatVarName = varargin{2};
            if iscell(MatVarName)
                MatVarName=MatVarName{2};
            end
            
            % load data
            if iscell(FullFileName)
                tmp = load(FullFileName{DatasetNum},MatVarName);
                Data = single(tmp.(MatVarName));
            else
                tmp = load(FullFileName,MatVarName);
                Data = single(tmp.(MatVarName));
            end
                
        end
        
        function [Data] = loadDataH5(FullFileName,varargin)
            % static method for loading .h5 file
            % INPUT
            %    FullFileName - full path to datafile, must be .h5
            %    varargin - input parameters
            %       h5: DatasetIdx, index of dataset to be loaded from h5 file
            %           ChannelIdx (optional), index of channel to be loaded, default is 1
            %           Eg:  [Data] = smi_core.LoadData.loadDataH5('FileName.h5',1,1)
            % OUTPUT
            %    Data - data loaded from FileName, converted to type single
            
            if isempty(varargin)
                error('smi_core:LoadData:noDatasetIndex','No dataset index given for h5 file, please give as input: Data = smi_core.LoadData.loadDataH5(FileName,DatasetIndex)')
            elseif nargin == 2
                ChannelIdx = 1;
            elseif nargin > 2
                ChannelIdx = varargin{2};
            end
            while any(cellfun(@iscell,varargin))
                varargin = [varargin{cellfun(@iscell,varargin)} varargin(~cellfun(@iscell,varargin))];
            end
            
            DatasetIdx = varargin{1};
            
            % FullFileName may be a cell array.
            if iscell(FullFileName)
                FullFileName = FullFileName{1};
            end
            HD5Info = h5info(FullFileName);
            
            % Define a flag to indicate the .h5 file structure: 0 indicates
            % that all of the data exists in a single group, 1 indicates each
            % dataset exists in its own group.
            DataStructFlag = isempty(HD5Info.Groups.Groups.Datasets);
            
            % setup directory into H5 file
            for ii = 1 : numel(HD5Info.Groups)
                if strcmp(HD5Info.Groups(ii).Name,'/Data')
                    ChannelName = sprintf('Channel%02i',ChannelIdx);
                    DataSetName = sprintf('Data%04i',DatasetIdx);
                    DataName = sprintf('/Data/%s/%s',ChannelName,DataSetName);
                elseif strcmp(HD5Info.Groups(ii).Name,'/Channel01')
                    ChannelName = sprintf('Zposition%03i', ChannelIdx);
                    DataSetName = sprintf('Data%04i', DatasetIdx);
                    
                    % Define the name (including path in .h5 file) to the data.
                    if DataStructFlag % each dataset exists in its own group
                        DataName = sprintf('/Channel01/%s/%s/%s', ...
                            ChannelName, DataSetName, DataSetName);
                    else % all of the datasets exist in a single group
                        DataName = sprintf('/Channel01/%s/%s', ...
                            ChannelName, DataSetName);
                    end
                end
            end
            % check whether channel and dataset exist
            for ii = 1 : numel(HD5Info.Groups)
                if strcmp(HD5Info.Groups(ii).Name,'/Data')
                    DataGroup = HD5Info.Groups(ii);
                    break
                elseif strcmp(HD5Info.Groups(ii).Name,'/Channel01')
                    DataGroup = HD5Info.Groups(ii);
                    break
                end
            end
            % check channel input
            ChannelExists = 0;
            for ii = 1 : numel(DataGroup.Groups)
                if strcmp(DataGroup.Groups(ii).Name,['/Data/' ChannelName])
                    ChannelGroup = DataGroup.Groups(ii);
                    ChannelExists = 1;
                    
                    % Create a list of the datasets in the current group.
                    DatasetList = DataGroup.Groups(ii).Datasets;
                    break
                elseif strcmp(DataGroup.Groups(ii).Name,['/Channel01/' ChannelName])
                    if DataStructFlag % each dataset exists in its own group
                        ChannelGroup = DataGroup.Groups(ii);
                        ChannelExists = 1;
                        
                        % Create a list of the datasets in the current group.
                        for jj = 1:numel(...
                                {DataGroup.Groups(ii).Groups.Datasets})
                            DatasetList(jj) = ...
                                DataGroup.Groups(ii).Groups(jj).Datasets;
                        end
                    else % all of the datasets exist in a single group
                        ChannelGroup = DataGroup.Groups(ii);
                        ChannelExists = 1;
                        
                        % Create a list of the datasets in the current group.
                        DatasetList = DataGroup.Groups(ii).Datasets;
                    end
                    break
                end
            end
            if ~ChannelExists
                error('smi_core:loadData:unknownChannel','h5 file does not contain %s, cannot load data from that channel',ChannelName);
            end
            % check dataset input
            DataSetExists = 0;
            for ii = 1 : numel(DatasetList)
                if strcmp(DatasetList(ii).Name, DataSetName)
                    DataSetExists = 1;
                    break
                end
            end
            if ~DataSetExists
                error('smi_core:loadData:unknownDataset','h5 file does not contain dataset %s in %s, cannot load data',DataSetName,ChannelName);
            end
            % load data
            Data=single(h5read(FullFileName,DataName));
        end

        DatasetList = setSMFDatasetList(SMF);
        NDatasets = countNDatasets(SMF);
        [H5Structure] = readH5File(FilePath, GroupName)
        
        function [Gain, Offset, ReadNoise, CalibrationROI] = ...
                loadDataCalibration(SMF)
            %loadDataCalibration loads calibration data from a file.
            % This method attempts to load the gain, offset, and readnoise
            % arrays from a file specified by SMF.Data.CalibrationFilePath. 
            % If these arrays aren't found in the file, a warning will be 
            % issued.
            
            % Load a "Params" struct from the file.
            load(SMF.Data.CalibrationFilePath, 'Params')
            
            % Attempt to extract the appropriate fields from 'Params'.
            Gain = Params.Gain;
            Offset = Params.CCDOffset;
            ReadNoise = Params.CCDVar;
            
            % If the ROI is defined as [YStart, YEnd, XStart, XEnd],
            % we'll want to swap the values to have
            % [YStart, XStart, YEnd, XEnd].
            CalibrationROI = Params.CameraObj.ROI;
            if ((CalibrationROI(2)>CalibrationROI(1)) ...
                    && (CalibrationROI(4)>CalibrationROI(3)))
                % If either of these are met, we'll assume it's defined
                % in the old style. Note that this might fail, but I
                % haven't thought of a better approach -D.J.S. 2/21
                OldROI = CalibrationROI;
                CalibrationROI = ...
                    [CalibrationROI(1), CalibrationROI(3), ...
                    CalibrationROI(2), CalibrationROI(4)];
                warning(['The CalibrationROI in %s was assumed to be ', ...
                    'in the format [YStart, YEnd, XStart, XEnd] and ', ...
                    'thus was re-ordered from ', ...
                    '[%i, %i, %i, %i] to [%i, %i, %i, %i]!'], ...
                    SMF.Data.CalibrationFilePath, ...
                    OldROI(1), OldROI(2), OldROI(3), OldROI(4), ...
                    CalibrationROI(1), CalibrationROI(2), ...
                    CalibrationROI(3), CalibrationROI(4))
            end
        end
    
    end
    
end

./MATLAB/+smi_core/@LoadData/countNDatasets.m
function NDatasets = countNDatasets(SMF)
% countNDatasets counts the number of datasets in SMF.Data.FileName .
%
% INPUT:
%
% SMF:  Fields that are structures: 
%    Data:
%       FileName:     File name (cell array of char array)
%       FileDir:      File directory (char array)
%       FileType:     Type of data specified by FileName. If using a custom 
%                     extension, you must set this field manually to the true 
%                     underlying file type (e.g., if using a .mat file saved 
%                     as exFile.spt, set obj.Data.FileType = 'mat')
%                     (char array)(Default set to extension of FileName{1})
%       DataVariable: Name of variable saved in FileName which contains the
%                     raw data. (char array)(Default='sequence')
%
% OUTPUT:
%
% NDatasets           Number of datasets counted

% Created by:
%    Michael J. Wester and David J. Schodt (Lidkelab, 2020)

    switch SMF.Data.FileType
        case 'mat'
            if iscell(SMF.Data.FileName)
                NDatasets = numel(SMF.Data.FileName);
                if NDatasets>1
                    return
                end
            end
            
            if iscell(SMF.Data.DataVariable)
                NDatasets = numel(SMF.Data.DataVariable);
                return
            end
            NDatasets = 1;

        case 'ics'
            NDatasets = numel(SMF.Data.FileName);

        case 'h5'
            FilePath = fullfile(SMF.Data.FileDir,SMF.Data.FileName{1});
            % find number of datasets in h5 file
            HD5Info = h5info(FilePath);
            
            % Define a flag to indicate the .h5 file structure: 
            % 0 indicates that all of the data exists in a single 
            % group, 1 indicates each dataset exists in its own 
            % group.
            DataStructFlag = isempty(HD5Info.Groups.Groups.Datasets);
            % Index of h5 file channel containing data.
            ChannelIdx = 1;

            for ii = 1 : numel(HD5Info.Groups)
                if strcmp(HD5Info.Groups(ii).Name,'/Data')
                    DataGroup = HD5Info.Groups(ii);
                    ChannelName = sprintf('Channel%02i',ChannelIdx);
                    break
                elseif strcmp(HD5Info.Groups(ii).Name,'/Channel01')
                    DataGroup = HD5Info.Groups(ii);
                    ChannelName = sprintf('Zposition%03i',ChannelIdx);
                    break
               end
            end
            for ii = 1 : numel(DataGroup.Groups)
                if strcmp(DataGroup.Groups(ii).Name,['/Data/' ChannelName])
                    ChannelGroup = DataGroup.Groups(ii);
                    break
                elseif strcmp(DataGroup.Groups(ii).Name, ...
                             ['/Channel01/' ChannelName])
                    if DataStructFlag 
                        % Each dataset exists in its own group.
                        ChannelGroup = DataGroup.Groups(ii).Groups;
                    else
                        % All of the datasets exist in a single
                        % group.
                        ChannelGroup = DataGroup.Groups(ii);
                    end
                    break
                end
            end
            if DataStructFlag 
                % Each dataset exists in its own group.
                NDatasets = numel(ChannelGroup);
            else
                % All of the datasets exist in a single
                % group.
                NDatasets = numel(ChannelGroup.Datasets);
            end
    end
end

./MATLAB/+smi_core/@LocalizeData/unitTest.m
function [Success] = unitTest()
%unitTest tests vital functionality of the LocalizeData class.
% This method performs various tests to ensure that vital functionality of
% the smi_core.LocalizeData class is working as intended.
%
% NOTE: Failure of this unit test may in fact be caused by failure of some
%       other class methods OUTSIDE of the LocalizeData class.  A more
%       direct/better test of this class could not be conceptualized at the
%       time of writing.
%
% INPUTS:
%
% OUTPUTS:
%   Success: An array of boolean flags to indicate success of various tests
%            performed.
%            Success(1): genLocalizations - SMD generated successfully.

% Created by:
%   David J. Schodt (Lidke Lab, 2020)

SaveDir = smi_helpers.mkSMITETmpDir('unitTest', 'LocalizeData');

% Seed the random number generator so that we always get the same results.
rng(1234)

% Generate some simulated data in units of photons.
FrameSizeFull = 256; % don't change this! other numbers assume = 256
NFrames = 10;
SMD = smi_core.SingleMoleculeData.createSMD();
SMD.X = repmat(128 + 64*[0; 1; 1; -1; -1], [NFrames, 1]);
SMD.Y = repmat(128 + 64*[0; 1; -1; 1; -1], [NFrames, 1]);
SMD.Photons = 1e3 * ones(5*NFrames, 1);
SMD.PSFSigma = 1.3;
SMD.FrameNum = repelem((1:NFrames).', 5);
SMD.Bg = zeros(5*NFrames, 1);
SMD.NFrames = NFrames;
SMD.YSize = FrameSizeFull;
SMD.XSize = FrameSizeFull;
[~, ScaledData] = smi_sim.GaussBlobs.gaussBlobImage(SMD);

% Generate an SMF structure.
SMF = smi_core.SingleMoleculeFitting;
SMF.BoxFinding.BoxSize = 10;
SMF.Fitting.PSFSigma = SMD.PSFSigma;

% Attempt to generate localizations from the simulated data.
LD = smi_core.LocalizeData(ScaledData, SMF, 3);
[SMDout, SMDPreThresh] = LD.genLocalizations();
saveas(gcf, fullfile(SaveDir, 'LD1.png'));

% Check that SMD and SMDPreThresh make sense and are consistent with each
% other (this isn't meant to be an exact check of individual fields).
NEmitters = 5;
Success(1) = ...
    (all(SMDout.FrameNum==repelem((1:NFrames).', NEmitters)) ...
    && (numel(SMDout.X)==NEmitters*NFrames) ...
    && (numel(SMDout.X)==sum(SMDPreThresh.ThreshFlag==0)));


end

./MATLAB/+smi_core/@LocalizeData/colorOverlay.m
function RGBImage=colorOverlay(obj)
% colorOverlay Displays an overlay of the (green) model with (red) data
% 
% Usage: 
% myObj.colorOverlay()    diplays a RBG Stack in a window
% RGBImage = myObj.colorOverlay()  returns an scaled RGB image 




if isempty(obj.SMF.Data.DataROI)
    SZ=size(obj.ScaledData,[1,2]);
    obj.SMF.Data.DataROI=[1 1 SZ SZ];
end
[Model] = smi_sim.GaussBlobs.gaussBlobImage(obj.SMD,obj.SMF,0,'SMF');

minData = prctile(obj.ScaledData(:),1);
maxData = prctile(obj.ScaledData(:),99);
minModel = prctile(Model(:),1);
maxModel = prctile(Model(:),99);

MinRange = min(minData,minModel);
MaxRange = max(maxData,maxModel);

% Deal with the rare case that can occur with very sparse data (such as the
% unitTest).
if MinRange == MaxRange
   minData = min(obj.ScaledData(:));
   maxData = min(obj.ScaledData(:));
   minModel = max(Model(:));
   maxModel = max(Model(:));

   MinRange = min(minData,minModel);
   MaxRange = max(maxData,maxModel);
end

R = (obj.ScaledData-MinRange)/(MaxRange-MinRange);
G = (Model-MinRange)/(MaxRange-MinRange);

RGBImage=cat(4,R,G,G*0);

if nargout <1
    F=figure;
    F.Name='Data(red) Model(green)';
    sliceViewer(RGBImage);
end

end

./MATLAB/+smi_core/@LocalizeData/LocalizeData.m
classdef LocalizeData < handle
    %LocalizeData contains methods used to find localizations in raw data.
    % This class contains method(s) to generate localizations from numeric
    % arrays of raw data in the form of images/stacks of images.
    %
    % NOTE: All default class properties are set in the constructor.  These
    %       properties are extracted/constructed from either in constructor
    %       input SMF or from a default SMF created as
    %       SMF = smi_core.SingleMoleculeFitting.createSMF();
    %
    % EXAMPLE USAGE:
    %   LD = smi_core.LocalizeData(RawData, SMF);
    %   [SMD, SMDPreThresh] = LD.genLocalizations();
    %   OR
    %   [~, SMD, SMDPreThresh] = smi_core.LocalizeData(RawData, SMF, 1);
    %
    % REQUIRES:
    %   Image Processing Toolbox
    %   Statistics and Machine Learning Toolbox
    
    
    properties
        SMF % see smi_core.SingleMoleculeFitting
        ScaledData  % (float array)(Photons) Gain/offset corrected data
        Verbose = 1 % verbosity level
        ResultsDir = [] % directory to save the color overlay if defined
    end
    
    properties (SetAccess = 'protected')
        SMD % fully thresholded SMD, see SingleMoleculeData class
        SMDPreThresh % "full" SMD including bad localizations w/ ThreshFlag
    end
    
    methods
        function [obj, SMD, SMDPreThresh] = LocalizeData(...
                ScaledData, SMF, Verbose, AutoRun)
            %LocalizeData creates an instance of the LocalizeData class.
            % This method will prepare the LocalizeData class, setting
            % inputs to class properties if provided. This constructor can
            % also be used to run the main run method of the class, as long
            % as ScaledData and SMF are provided. To do so, set AutoRun = 1
            
            % Set a default for the AutoRun flag, which specifies whether
            % or not we should run genLocalizations() in this constructor.
            if (~exist('AutoRun', 'var') || isempty(AutoRun))
                AutoRun = 0;
            end
            
            % Set a default for the SMF structure, whose fields will be
            % extracted and set to class properties/will be used to
            % construct class properties.
            if (exist('SMF', 'var') && ~isempty(SMF))
                % Pad the input SMF structure to ensure it contains all
                % fields defined in smi_core.SingleMoleculeFitting.
                obj.SMF = smi_core.SingleMoleculeFitting.padSMF(SMF);
            else
                obj.SMF = smi_core.SingleMoleculeFitting;
            end
            
            % Set the verbosity level if provided.
            if (exist('Verbose', 'var') && ~isempty(Verbose))
                obj.Verbose = Verbose;
            end
            if ((obj.Verbose>2) && (nargin()>0))
                fprintf(['\tLocalizeData constructor: ', ...
                    'Setting class properties based on constructor ', ...
                    'inputs...\n'])
            end
                        
            % Set the ScaledData as a class property if provided.
            if (exist('ScaledData', 'var') && ~isempty(ScaledData))
                obj.ScaledData = ScaledData;
                AllFieldsSet = 1;
            else
                AllFieldsSet = 0;
            end
            
            % Run genLocalizations() if desired.
            if (AutoRun && AllFieldsSet)
                if (obj.Verbose > 2)
                    fprintf(['\tLocalizeData constructor: ', ...
                        'Auto-running obj.genLocalizations()...\n'])
                end
                [SMD, SMDPreThresh] = obj.genLocalizations();
            else
                if ((obj.Verbose>0) && (nargout()>1))
                    warning(['Constructor outputs SMD and ', ...
                        'SMDPreThresh requested but ', ...
                        'localizations were not generated.'])
                end
                SMD = [];
            end
        end
        
        [SMD, SMDPreThresh] = genLocalizations(obj);
        
    end
    
    methods (Static)
        [Success] = unitTest();
    end
    
    
end

./MATLAB/+smi_core/@LocalizeData/README.md
### +smi_core/@LocalizeData

This class contains method(s) to generate localizations from numeric
arrays of raw data in the form of images/stacks of images.

NOTE: All default class properties are set in the constructor.  These
      properties are extracted/constructed from either in constructor
      input SMF or from a default SMF created as
      ```SMF = smi_core.SingleMoleculeFitting.createSMF();```

EXAMPLE USAGE:
```
  LD = smi_core.LocalizeData(RawData, SMF);
  [SMD, SMDPreThresh] = LD.genLocalizations();
  or
  [~, SMD, SMDPreThresh] = smi_core.LocalizeData(RawData, SMF, 1);
```
REQUIRES:
- Image Processing Toolbox
- Statistics and Machine Learning Toolbox

---

```
properties:
  SMF             % see smi_core.SingleMoleculeFitting
  ScaledData      % (float array)(Photons) Gain/offset corrected data
  Verbose = 1     % verbosity level
  ResultsDir = [] % directory to save the color overlay if defined
```

---

methods:
- **[colorOverlay](colorOverlay.m)**:
  Displays an overlay of the (green) model with (red) data
- **[genLocalizations](genLocalizations.m)**:
  generates localizations from scaled data
- **[unitTest](unitTest.m)**:
  tests vital functionality of the LocalizeData class

./MATLAB/+smi_core/@LocalizeData/genLocalizations.m
function [SMD, SMDPreThresh] = genLocalizations(obj)
%genLocalizations generates localizations from scaled data.
% This method will generate localizations from an array of data by first
% first finding candidate ROIs in the data that may contain emitters, 
% fitting a model function to the pixel values in that ROI, and then 
% thresholding the resulting localizations.
% 
% OUTPUTS: 
%   SMD: Single Molecule Data structure (see SingleMoleculeData class) with
%        only valid localizations (i.e., those that passed all thresholds).
%   SMDPreThresh: SMD structure with all found localizations, even those
%                 that did not pass the thresholds.

% Created by:
%   David J. Schodt (Lidke Lab, 2020)
%       based on SMA_Core.fitStack written by Keith Lidke and 
%       Hanieh Mazloom-Farsibaf


% Generate candidate ROIs from the gain and offset corrected data.
if (obj.Verbose > 1)
    fprintf(['\tLocalizeData.genLocalizations(): ', ...
        'Finding candidate ROIs from the input data...\n'])
elseif (obj.Verbose > 0)
    fprintf(['\tLocalizeData.genLocalizations(): ', ...
        'Generating localizations from the input data...\n'])
end
FindROI = smi_core.FindROI(obj.SMF, obj.ScaledData);
FindROI.Verbose = obj.Verbose;
[ROIStack, SMDCandidates] = FindROI.findROI();
if (obj.Verbose > 2)
    fprintf(['\t\tLocalizeData.genLocalizations(): ', ...
        '%i candidate ROIs found.\n'], numel(SMDCandidates.FrameNum))
end

% Pass the candidate ROIs to the fitting algorithm.  The output SMD from
% GaussMLE will contain localizations w.r.t. the ROIStack coordinates and
% thus we need to convert back to the full field of view before proceeding.
if (obj.Verbose > 1)
    fprintf(['\tLocalizeData.genLocalizations(): ', ...
        'Fitting candidate ROIs with smi_core.GaussMLE...\n'])
end
GaussMLE = smi_core.GaussMLE(obj.SMF, ROIStack);
[SMDCandidates] = GaussMLE.gaussMLE(SMDCandidates);
SMDCandidates.X = SMDCandidates.X + SMDCandidates.XBoxCorner;
SMDCandidates.Y = SMDCandidates.Y + SMDCandidates.YBoxCorner;

% Threshold localizations.
MinMax = smi_core.Threshold.setMinMax(obj.SMF);
if obj.SMF.Thresholding.AutoThreshLogL
    % If using the automatic LogL threshold, we'll ignore the PValue
    % threshold and choose a LogL threshold using the triangle method.
    MinLogL = smi_helpers.triangle_threshold(...
        SMDCandidates.LogLikelihood, obj.SMF.Thresholding.AutoThreshPrctile);
    MinMax.LogLikelihood = [MinLogL, inf];
    MinMax.PValue = [0, 1];
end
Threshold = smi_core.Threshold;
Threshold.Verbose = obj.Verbose;
[SMDPreThresh] = Threshold.setThreshFlag(SMDCandidates, MinMax);
if obj.SMF.Thresholding.On
   [SMD] = Threshold.applyThresh(SMDPreThresh, obj.Verbose);

   % Remove bright localizations that are likely to be more than one emitter,
   % that is, localizations satisfying
   %    intensity > InMeanMultiplier * mean(intensity)
   % are removed.
   SMD = smi_helpers.Filters.filterIntensity(SMD, obj.Verbose, ...
            obj.SMF.Thresholding.InMeanMultiplier);

   % Inflate standard errors.  This is used by BaGoL.
   SMD = smi_helpers.Filters.inflateSE(SMD, obj.Verbose, ...
                                            obj.SMF.Data.SEAdjust);
else
   SMD = SMDPreThresh;
end
obj.SMDPreThresh = SMDPreThresh;
obj.SMD = SMD;

% If needed, produce some color overlay plots.
% NOTE: Extra cases kept in case of later changes.
%switch obj.Verbose
%    case 0
%    case 1
%    case 2
%    case 3
%        obj.colorOverlay();
%    otherwise
%        obj.colorOverlay();
%end
if obj.Verbose >= 3
   if isempty(obj.ResultsDir)
      obj.colorOverlay();
   else
      ResultsDir = obj.ResultsDir;
      FileBaseName = 'LocalizeDataRGBImage';
      RGBImage = obj.colorOverlay();
      smi_helpers.writeMPEG4(ResultsDir, FileBaseName, RGBImage);
   end
end

end

./MATLAB/+smi_core/@FrameConnection/findConnected.m
function [SMDIndex] = findConnected(SMR, SMD, ID)
% findConnected finds localizations that were frame connected.
%
% Let N = numel(SMD.X) and M = numel(SMD_combined.X).  Then,
% i = find(SMD.ConnectID == id) where id = 1, ..., M produces the indices of
%    the SMD localizations that have been combined for each id.  Note id is the
%    number of a cluster in the internal frame connection algorithm and has
%    nothing to do with array indices.  Each localization in SMD_combined
%    corresponds to one cluster number, while one or more localizations in SMD
%    correspond to the same cluster number.
% j = find(SMD_combined.CombinedID == id) where id = 1, ..., M produces the
%    index of the SMD_combined localization that corresponds to the above
%    cluster id.
% Therefore, using the same id in both invocations produces the indices of the
% SMD localizations (i) that have been combined [via ConnectID] into a combined
% localization (j) [via CombinedID].
%
% INPUTS:
%    SMR:   SMR or SMD_combined structure from a frame-connected SMA_SR result
%    SMD:   SMD structure that contains threshold info, etc.
%    ID:    an index for a localization in a frame-connected SMR result
% OUTPUTS:
%    SMDIndex:  An array of indices for the SMD structure for the localizations
%               that were connected to form the localization ID in SMR. 

% Created by
%    Michael Wester (LidkeLab 2020)

   clusterID = SMR.ConnectID(ID);
   SMDIndex = find(SMD.ConnectID == clusterID);

end
./MATLAB/+smi_core/@FrameConnection/unitTest.m
function [Success] = unitTest()
%unitTest tests vital functionality of the class smi_core.FrameConnection
%
% This method tests various methods in the class smi_core.FrameConnection
% class to ensure that the vital functionality is working as intended.
% This is done by simulating a populated SMD structure with known
% associations between entries, performing the frame-connection procedure
% using smi_core.FrameConnection methods, and then checking the result.
%
% INPUTS:
%
% OUTPUTS:
%   Success: An array of flags specifying the success of various methods in
%            smi_core.FrameConnection, where 1 means success and 0 means
%            failure (of a specific method). (Boolean array)
%               Success(1): performFrameConnection(), 'XYNB'
%               Success(2): performFrameConnection(), 'XYNBS'
%               Success(3): performFrameConnection(), 'XYNBSXSY'
%               Success(4): performFrameConnection(), 'XYZNB'
%               Success(5): findConnected()

% Created by:
%   David J. Schodt (Lidke Lab, 2020)


% Initialize the Success output.
Success = zeros(1, 5, 'logical');

% Seed the random number generator so that the simulated SMD is predictable
% NOTE: If this is changed, there will almost certainly be entries of
%       Success that are 0.
rng(1234)

% Simulate several emitter positions.
% NOTE: Most of these parameters were chosen arbitrarily, HOWEVER, there
%       may be some checks below that might be affected by changing these
%       parameters (i.e., causing some elements of Success to be 0 even if
%       things worked correctly).
FrameSize = 64;
NEmitters = 7;
NFrames = 13;
PhotonSum = 1e3;
Background = 5;
SigmaNoise = 0.2;
PSFSigma = 1.3;
PSFSigmaXY = [1.2; 1.4];
PSFSigmaNoise = 0.123;
LogLikelihood = -40;
Coordinates = zeros(NEmitters, 2, NFrames);
Coordinates(:, :, 1) = FrameSize * rand(NEmitters, 2);
Coordinates(:, :, 2:NFrames) = Coordinates(:, :, 1) ...
    + SigmaNoise*randn(NEmitters, 2, NFrames-1);

% Construct the simulated SMD structure.
OnesArray =  ones(NEmitters*NFrames, 1);
SMDSim = smi_core.SingleMoleculeData.createSMD();
SMDSim.X = reshape(Coordinates(:, 1, :), NEmitters*NFrames, 1);
SMDSim.Y = reshape(Coordinates(:, 2, :), NEmitters*NFrames, 1);
SMDSim.Z = SigmaNoise * randn(NEmitters*NFrames, 1);
SMDSim.X_SE = SigmaNoise * OnesArray;
SMDSim.Y_SE = SMDSim.X_SE;
SMDSim.Z_SE = SMDSim.X_SE;
SMDSim.Photons = PhotonSum * OnesArray;
SMDSim.Bg = Background * OnesArray;
SMDSim.LogLikelihood = LogLikelihood * OnesArray;
SMDSim.PSFSigma = PSFSigma*OnesArray ...
    + PSFSigmaNoise*randn(NEmitters*NFrames, 1);
SMDSim.PSFSigma_SE = PSFSigmaNoise * OnesArray;
SMDSim.PSFSigmaX = PSFSigmaXY(1)*OnesArray ...
    + PSFSigmaNoise*randn(NEmitters*NFrames, 1);
SMDSim.PSFSigmaY = PSFSigmaXY(2)*OnesArray ...
    + PSFSigmaNoise*randn(NEmitters*NFrames, 1);
SMDSim.PSFSigmaX_SE = PSFSigmaNoise * OnesArray;
SMDSim.PSFSigmaY_SE = SMDSim.PSFSigmaX_SE;
SMDSim.FrameNum = repelem((1:NFrames).', NEmitters);
SMDSim.DatasetNum = OnesArray;
SMDSim.ThreshFlag = 0 * OnesArray;

% Prepare the frame-connection class.
SMF = smi_core.SingleMoleculeFitting;
SMF.Fitting.FitType = 'XYNB';
SMF.FrameConnection.LoS = 0.01023;
SMF.FrameConnection.MaxSeparation = 1.023;
SMF.FrameConnection.MaxFrameGap = 4;
FC = smi_core.FrameConnection(SMDSim, SMF, 3);

% Compute some expected arrays for the simulation.
% NOTE: We should also compute the expected values of PSFSigma,
%       PSFSigma_SE, ..., but I don't know how those work at the time of
%       writing this code!
ExpectedVariance = 1 / (NFrames/(SigmaNoise^2));
ExpectedXYZ_SE = sqrt(ExpectedVariance);
ExpectedX = sum(reshape(SMDSim.X, [], NFrames)/(SigmaNoise^2), 2) ...
    * ExpectedVariance;
ExpectedY = sum(reshape(SMDSim.Y, [], NFrames)/(SigmaNoise^2), 2) ...
    * ExpectedVariance;
ExpectedZ = sum(reshape(SMDSim.Z, [], NFrames)/(SigmaNoise^2), 2) ...
    * ExpectedVariance;
ExpectedPhotons = PhotonSum * NFrames;
ExpectedBg = Background * NFrames;
ExpectedLogLikelihood = LogLikelihood * NFrames;

% Perform the frame-connection procedure for the fit type 'XYNB' and
% perform various checks to see if it worked correctly.
[SMDCombined] = FC.performFrameConnection();
Success(1) = baseSuccess(SMDCombined, ...
    ExpectedX, ExpectedY, ExpectedXYZ_SE, ...
    ExpectedPhotons, ExpectedBg, ExpectedLogLikelihood, ...
    NFrames, NEmitters);

% Perform the frame-connection procedure for the fit type 'XYNBS' and
% perform various checks to see if it worked correctly.
% NOTE: The precision of my floating point comparisons below were chosen
%       arbitrarily.
FC.SMF.Fitting.FitType = 'XYNBS';
[SMDCombined] = FC.performFrameConnection();
BaseSuccess = baseSuccess(SMDCombined, ...
    ExpectedX, ExpectedY, ExpectedXYZ_SE, ...
    ExpectedPhotons, ExpectedBg, ExpectedLogLikelihood, ...
    NFrames, NEmitters);
Success(2) = (BaseSuccess ...
    && (abs(sum(SMDCombined.PSFSigma)-9.2274) <= 1e-4) ...
    && all(abs(SMDCombined.PSFSigma_SE-0.0341) <= 1e-4));

% Perform the frame-connection procedure for the fit type 'XYNBSXSY' and
% perform various checks to see if it worked correctly.
FC.SMF.Fitting.FitType = 'XYNBSXSY';
[SMDCombined] = FC.performFrameConnection();
BaseSuccess = baseSuccess(SMDCombined, ...
    ExpectedX, ExpectedY, ExpectedXYZ_SE, ...
    ExpectedPhotons, ExpectedBg, ExpectedLogLikelihood, ...
    NFrames, NEmitters);
Success(3) = (BaseSuccess ...
    && (abs(sum(SMDCombined.PSFSigmaX)-8.5437) <= 1e-4) ...
    && (abs(sum(SMDCombined.PSFSigmaY)-9.5851) <= 1e-4) ...
    && all(abs(SMDCombined.PSFSigmaX_SE-0.0341) <= 1e-4) ...
    && all(abs(SMDCombined.PSFSigmaY_SE-0.0341) <= 1e-4));

% Perform the frame-connection procedure for the fit type 'XYZNB' and
% perform various checks to see if it worked correctly.
FC.SMF.Fitting.FitType = 'XYZNB';
[SMDCombined] = FC.performFrameConnection();
BaseSuccess = baseSuccess(SMDCombined, ...
    ExpectedX, ExpectedY, ExpectedXYZ_SE, ...
    ExpectedPhotons, ExpectedBg, ExpectedLogLikelihood, ...
    NFrames, NEmitters);
Success(4) = (BaseSuccess ...
    && all(abs(SMDCombined.Z-ExpectedZ) < 1e-4) ...
    && all(abs(SMDCombined.Z_SE-ExpectedXYZ_SE) < 1e-4));

% Test FrameConnection.findConnected() on some new, incomplete 'SMD' type
% structures.  This is done by randomly permuting initial (pre frame
% connection) SMD.ConnectID indices, using findConnected() to determine the
% new permuted indices, and then summing over the permuted indices found
% for each element of SMDCombined.ConnectID to check the result.
% NOTE: In the computation of 'Success' below, I've used ismember instead
%       of == just in case the output dimensions of findConnected() are
%       changed someday.
SMDCombinedInc.ConnectID = (1:NEmitters).';
ConnectIDSMD = repelem((1:NEmitters).', NFrames, 1);
SMDInc.ConnectID = ConnectIDSMD(randperm(NEmitters * NFrames));
IndSMDSum = zeros(NEmitters, 1);
for ii = 1:NEmitters
    IndSMDSum(ii) = sum(FC.findConnected(SMDCombinedInc, SMDInc, ...
        SMDCombinedInc.ConnectID(ii)));
end
Success(5) = all(ismember(double(IndSMDSum), ...
    [573; 585; 693; 550; 605; 487; 693]));


    function [BaseSuccess] = baseSuccess(SMDCombined, ...
            ExpectedX, ExpectedY, ExpectedXYZ_SE, ...
            ExpectedPhotons, ExpectedBg, ExpectedLogLikelihood, ...
            NFrames, NEmitters)
        % This function computes the baseline success of the
        % frame-connection, meaning that it checks several fields in the
        % SMDCombined structure that will not change based on the fit-type.
        % NOTE: The precision of my floating point comparisons below were
        %       chosen arbitrarily.
        
        BaseSuccess = ...
            (all(abs(SMDCombined.X-ExpectedX) < 1e-4) ...
            && all(abs(SMDCombined.Y-ExpectedY) < 1e-4) ...
            && all(abs(SMDCombined.X_SE-ExpectedXYZ_SE) < 1e-4) ...
            && all(abs(SMDCombined.Y_SE-ExpectedXYZ_SE) < 1e-4) ...
            && all(abs(SMDCombined.Photons-ExpectedPhotons) < 1e-4) ...
            && all(abs(SMDCombined.LogLikelihood...
                -ExpectedLogLikelihood) < 1e-4) ...
            && all(abs(SMDCombined.Bg-ExpectedBg) < 1e-4) ...
            && all(uint32(SMDCombined.DatasetNum)==uint32(1)) ...
            && all(uint32(SMDCombined.FrameNum)==uint32(NFrames)) ...
            && all(uint32(SMDCombined.ConnectID)==uint32(1:NEmitters).')...
            && all(uint32(SMDCombined.NCombined)==uint32(NFrames)));
        
    end


end

./MATLAB/+smi_core/@FrameConnection/classicalFC.m
function [SMD] = classicalFC(SMD, SMF, Verbose)
%classicalFC connects localizations in 'SMD' by simple thresholds.
% This method solves the frame-connection problem by connecting
% localizations within hard spatiotemporal thresholds.
%
% NOTE: This method will add an additional field to SMD called
%       "ConnectID".  SMD.ConnectID is an integer array indicating
%       which localizations were connected during the frame connection
%       process.  For example, if
%       (SMD.ConnectID(nn) == SMD.ConnectID(mm)), the localizations
%       in SMD identified by the indices nn and mm were connected during
%       frame connection.  The exact value of the field "ConnectID" is
%       itself arbitrary and carries no meaning further than associating
%       localizations. This field is directly related to
%       SMDCombined.ConnectID as follows:
%           For a given ConnectID, say nn, the indices in arrays of SMD
%           that were combined to generate a field in SMDCombined can be
%           found as IndicesSMD = find(SMD.ConnectID == nn) (alternatively,
%           IndicesSMD = smi_core.FrameConnection.findConnected(...
%               SMDCombined, SMD, nn) )
%
% INPUTS:
%   SMD: SingleMoleculeData structure with the localizations that we wish
%        to frame-connect.
%   SMF: SingleMoleculeFitting structure defining relevant parameters.
%   Verbose: Integer specifying the verbosity level. (Default = 1)
%
% OUTPUTS:
%   SMD: SMD but with the field 'ConnectID' populated.
%
% CITATION:

% Created by:
%   David J. Schodt (Lidke Lab, 2021)


% Set defaults if needed.
if (~exist('SMF', 'var') || isempty(SMF))
    SMF = smi_core.SingleMoleculeFitting;
end
if (~exist('Verbose', 'var') || isempty(Verbose))
    Verbose = 1;
end    

% Gather/revise/reorganize some arrays for further use.
NLocalizations = numel(SMD.FrameNum);
[DatasetNum, SortIndices] = sort(SMD.DatasetNum);
X = SMD.X(SortIndices);
Y = SMD.Y(SortIndices);
FrameNum = SMD.FrameNum(SortIndices);
MaxFrameGap = SMF.FrameConnection.MaxFrameGap;
MaxSeparation = SMF.FrameConnection.MaxSeparation;

% Initialize each localization as a new cluster.
ConnectID = (1:NLocalizations).';

% Loop through datasets and perform frame-connection.
[NLocPerDataset, DatasetArray] = groupcounts(DatasetNum);
CumulativeDatasetLocs = [0; cumsum(NLocPerDataset)];
MaxID = NLocalizations;
for ii = 1:numel(DatasetArray)
    % Provide a Command Window update if needed.
    if (Verbose > 2)
        fprintf(['\tFrameConnection.classicalFC(): ', ...
            'Performing frame connection for dataset %i...\n'], ii)
    end
    
    % Isolate some arrays for the current dataset (CDS = current dataset)
    CurrentDatasetInd = (1:NLocPerDataset(ii)) + CumulativeDatasetLocs(ii);
    [FrameNumCDs, SortIndicesFN] = sort(FrameNum(CurrentDatasetInd));
    XCDs = X(CurrentDatasetInd(SortIndicesFN));
    YCDs = Y(CurrentDatasetInd(SortIndicesFN));
    ConnectIDCDs = ConnectID(CurrentDatasetInd(SortIndicesFN));
    
    % Loop through frames and add localizations to clusters.
    IsClustered = zeros(NLocPerDataset(ii), 1, 'logical');
    [NLocPerFrame, FrameArray] = groupcounts(FrameNumCDs);
    CumulativeLocs = [0; cumsum(NLocPerFrame)];
    for ff = 1:numel(FrameArray)
        % Determine which localizations should be considered for clustering
        CurrentFrameInd = (1:NLocPerFrame(ff)) + CumulativeLocs(ff);
        CandidateFrameInd = ...
            find((FrameNumCDs >= (FrameArray(ff)-MaxFrameGap)) ...
            & (FrameNumCDs<FrameArray(ff)));
        if isempty(CandidateFrameInd)
            ConnectID(CurrentFrameInd) = (1:NLocPerFrame(ff)).' + MaxID;
            MaxID = MaxID + NLocPerFrame(ff);
            continue
        end
        
        % Determine the nearest neighbor to the current localizations in
        % all candidate frames.
        [NNIndices, NNDistances] = knnsearch(...
            [XCDs(CandidateFrameInd), YCDs(CandidateFrameInd)], ...
            [XCDs(CurrentFrameInd), YCDs(CurrentFrameInd)], ...
            'k', 1);
        
        % Place the CurrentFrameInd localizations into clusters.
        ValidNNInd = find(NNDistances <= MaxSeparation);
        if isempty(ValidNNInd)
            continue
        end
        for nn = ValidNNInd.'
            % Place this localization into the same cluster as its nearest
            % neighbor.
            NNIndex = CandidateFrameInd(NNIndices(nn));
            if IsClustered(NNIndex)
                ConnectIDCDs(CurrentFrameInd(nn)) = ConnectIDCDs(NNIndex);
                IsClustered(CurrentFrameInd(nn)) = true;
            else
                MaxID = MaxID + 1;
                ConnectIDCDs([CurrentFrameInd(nn), NNIndex]) = MaxID;
                IsClustered([CurrentFrameInd(nn), NNIndex]) = true;
            end
        end
    end
    ConnectID(CurrentDatasetInd(SortIndicesFN)) = ConnectIDCDs;
end
SMD.ConnectID(SortIndices, 1) = smi_helpers.compressToRange(ConnectID);


end
./MATLAB/+smi_core/@FrameConnection/hypothesisTestFC.m
function [SMDCombined, SMD] = hypothesisTestFC(SMD, SMF, Verbose)
%hypothesisTestFC connects localizations in 'SMD' by the hyp. test method.
% This method solves the frame-connection problem using the hypothesis
% testing method for connecting localizations.  That is, a p-value is
% computed and compared to the level of significance to test the null
% hypothesis that the tested localizations arose from the same emitter.
%
% NOTE: This method will add an additional field to SMD called
%       "ConnectID".  SMD.ConnectID is an integer array indicating
%       which localizations were connected during the frame connection
%       process.  For example, if
%       (SMD.ConnectID(nn) == SMD.ConnectID(mm)), the localizations
%       in SMD identified by the indices nn and mm were connected during
%       frame connection.  The exact value of the field "ConnectID" is
%       itself arbitrary and carries no meaning further than associating
%       localizations. This field is directly related to
%       SMDCombined.ConnectID as follows:
%           For a given ConnectID, say nn, the indices in arrays of SMD
%           that were combined to generate a field in SMDCombined can be
%           found as IndicesSMD = find(SMD.ConnectID == nn) (alternatively,
%           IndicesSMD = smi_core.FrameConnection.findConnected(...
%               SMDCombined, SMD, nn) )
%
% INPUTS:
%   SMD: SingleMoleculeData structure with the localizations that we wish
%        to frame-connect.
%   SMF: SingleMoleculeFitting structure defining relevant parameters.
%   Verbose: Integer specifying the verbosity level. (Default = 1)
%
% OUTPUTS:
%   SMDCombined: SMDCombined contains the "frame-connected" localizations,
%                i.e., the result of performing frame-connection on SMD
%   SMD: SMD but with the field 'ConnectID' populated.
%
% CITATION:
%   Wester, M. J., Schodt, D. J., Mazloom-Farsibaf, H., Fazel, M., 
%   Pallikkuth, S., and Lidke, K. A. (2021). 
%   Robust, Fiducial-Free Drift Correction for Super-resolution Imaging.
%   bioRxiv , 2021.03.26.437196doi:10.1101/2021.03.26.437196

% Created by:
%   David J. Schodt (Lidke Lab, 2020)
%       based on a code written Hanieh Mazloom-Farsibaf


% Set defaults if needed.
if (~exist('SMF', 'var') || isempty(SMF))
    SMF = smi_core.SingleMoleculeFitting;
end
if (~exist('Verbose', 'var') || isempty(Verbose))
    Verbose = 1;
end    
    
% Initialize some temporary arrays (these are arrays like X, Y, ... which
% are concatenated inside of the main for loop below, and later stored in
% the output 'SMDCombined').
NCombined = [];
ConnectID = [];
X = [];
Y = [];
X_SE = [];
Y_SE = [];
Z = [];
Z_SE = [];
FrameNum = [];
Photons = [];
Bg = [];
LogLikelihood = [];
DatasetNum = [];
PSFSigma = [];
PSFSigma_SE = [];
PSFSigmaX = [];
PSFSigmaY = [];
PSFSigmaX_SE = [];
PSFSigmaY_SE = [];

% Loop through each dataset and perform the frame connection process.
% NOTE: Since numel(unique(SMD.DatasetNum)) is typically small (e.g.,
%       < 100) I don't anticipate any benefit to making local copies of any
%       arrays from SMD (as opposed to accessing them from SMD
%       inside the loop, as I'm doing here).
InputExtras = [];
InputExtrasSE = [];
SMD.ConnectID = zeros(numel(SMD.X), 1, 'uint32');
MaxConnectID = max(SMD.ConnectID);
UniqueDatasetNum = unique(SMD.DatasetNum);
if iscolumn(UniqueDatasetNum)
    UniqueDatasetNum = UniqueDatasetNum.';
end
for nn = UniqueDatasetNum
    % Provide a Command Window update if needed.
    if (Verbose > 2)
        fprintf(['\tFrameConnection.hypothesisTestFC(): ', ...
            'Performing frame connection for dataset %i...\n'], ...
            nn)
    end
    
    % Isolate all valid localizations in the nn-th dataset and typecast
    % certain arrays for smi_c_FrameConnection.mex* .
    CurrentBool = ((SMD.DatasetNum==nn) & (SMD.ThreshFlag==0));
    if ~any(CurrentBool)
        % All localizations in this dataset were thresholded out.
        if (Verbose > 2)
            fprintf(['\t\tAll dataset %i localizations ', ...
                'were thresholded.\n'], nn)
        end
        continue
    end
    InputFrameNum = uint32(SMD.FrameNum(CurrentBool));
    InputCoords = single([SMD.X(CurrentBool), ...
        SMD.Y(CurrentBool)]);
    InputCoordsSE = single([SMD.X_SE(CurrentBool), ...
        SMD.Y_SE(CurrentBool)]);
    InputPhotonsBgLogL = single([SMD.Photons(CurrentBool), ...
        SMD.Bg(CurrentBool), ...
        SMD.LogLikelihood(CurrentBool)]);
    
    % Determine if we need to append additional arrays (e.g., for 3D
    % fitting we'll need to append 'Z' associated arrays).
    switch SMF.Fitting.FitType
        case 'XYNBS'
            InputExtras = single(SMD.PSFSigma(CurrentBool));
            InputExtrasSE = single(SMD.PSFSigma_SE(CurrentBool));
        case 'XYNBSXSY'
            InputExtras = single([SMD.PSFSigmaX(CurrentBool), ...
                SMD.PSFSigmaY(CurrentBool)]);
            InputExtrasSE = single([SMD.PSFSigmaX_SE(CurrentBool), ...
                SMD.PSFSigmaY_SE(CurrentBool)]);
        case 'XYZNB'
            InputCoords = [InputCoords, ...
                single(SMD.Z(CurrentBool))];
            InputCoordsSE = [InputCoordsSE, ...
                single(SMD.Z_SE(CurrentBool))];
    end
    
    % Perform the frame-connection using smi_c_FrameConnection.mex*.
    if (Verbose > 2)
        fprintf('\t\tCalling smi_c_FrameConnection.mex*...\n')
    end
    [OutputCoords, OutputCoordsSE, NConnected, OutputFrames, ...
        OutputExtras, OutputExtrasSE, OutputPhotonsBgLogL, ...
        OutputConnectID, OutputConnectIDCombined] = ...
        smi_c_FrameConnection(SMF.FrameConnection.LoS, ...
        InputCoords, InputCoordsSE, InputFrameNum, ...
        InputExtras, InputExtrasSE, InputPhotonsBgLogL, ...
        SMF.FrameConnection.MaxSeparation, ...
        SMF.FrameConnection.MaxFrameGap, MaxConnectID);
    
    % Update 'SMD' to contain the current connection information.
    if (Verbose > 2)
        fprintf(['\t\t%i localizations combined to ', ...
            '%i localizations in dataset %i.\n'], ...
            numel(OutputConnectID), numel(OutputConnectIDCombined), nn)
    end
    SMD.ConnectID(CurrentBool) = OutputConnectID;
    MaxConnectID = max(OutputConnectID);
    
    % Store the outputs from smi_c_FrameConnection.mex* in temporary arrays
    % (these arrays will later be copied into the 'SMDCombined' output).
    X = [X; OutputCoords(:, 1)];
    Y = [Y; OutputCoords(:, 2)];
    X_SE = [X_SE; OutputCoordsSE(:, 1)];
    Y_SE = [Y_SE; OutputCoordsSE(:, 2)];
    NCombined = [NCombined; NConnected];
    FrameNum = [FrameNum; OutputFrames];
    Photons = [Photons; OutputPhotonsBgLogL(:, 1)];
    Bg = [Bg; OutputPhotonsBgLogL(:, 2)];
    LogLikelihood = [LogLikelihood; OutputPhotonsBgLogL(:, 3)];
    ConnectID = [ConnectID; OutputConnectIDCombined];
    DatasetNum = [DatasetNum; nn*ones(numel(OutputFrames), 1, 'uint32')];
    
    % Store some FitType dependent outputs if needed.
    switch SMF.Fitting.FitType
        case 'XYNBS'
            PSFSigma = [PSFSigma; OutputExtras];
            PSFSigma_SE = [PSFSigma_SE; OutputExtrasSE];
        case 'XYNBSXSY'
            PSFSigmaX = [PSFSigmaX; OutputExtras(:, 1)];
            PSFSigmaY = [PSFSigmaY; OutputExtras(:, 2)];
            PSFSigmaX_SE = [PSFSigmaX_SE; OutputExtrasSE(:, 1)];
            PSFSigmaY_SE = [PSFSigmaY_SE; OutputExtrasSE(:, 2)];
        case 'XYZNB'
            Z = [Z; OutputCoords(:, 3)];
            Z_SE = [Z_SE; OutputCoordsSE(:, 3)];
    end
end

% Store the temporary arrays from the main loop above into 'SMDCombined'
% (as well as some other things we'd like to carry along from SMD).
if (Verbose > 2)
    fprintf('\t\tPreparing output SMD structures...\n')
end
SMDCombined = smi_core.SingleMoleculeData.createSMD();
SMDCombined.NDims = SMD.NDims;
SMDCombined.NDatasets = SMD.NDatasets;
SMDCombined.NFrames = SMD.NFrames;
SMDCombined.XSize = SMD.XSize;
SMDCombined.YSize = SMD.YSize;
SMDCombined.NCombined = NCombined;
SMDCombined.ConnectID = ConnectID;
SMDCombined.X = X;
SMDCombined.Y = Y;
SMDCombined.X_SE = X_SE;
SMDCombined.Y_SE = Y_SE;
SMDCombined.Z = Z;
SMDCombined.Z_SE = Z_SE;
SMDCombined.FrameNum = FrameNum;
SMDCombined.Photons = Photons;
SMDCombined.Bg = Bg;
SMDCombined.LogLikelihood = LogLikelihood;
SMDCombined.PValue = smi_core.GaussMLE.pValue(...
    SMF.Fitting.NParams, SMF.BoxFinding.BoxSize, LogLikelihood);
SMDCombined.DatasetNum = DatasetNum;
SMDCombined.PSFSigma = PSFSigma;
SMDCombined.PSFSigma_SE = PSFSigma_SE;
SMDCombined.PSFSigmaX = PSFSigmaX;
SMDCombined.PSFSigmaY = PSFSigmaY;
SMDCombined.PSFSigmaX_SE = PSFSigmaX_SE;
SMDCombined.PSFSigmaY_SE = PSFSigmaY_SE;

% Add zeros to the ThreshFlag of SMDCombined (we should never be keeping
% localizations in SMDCombined which have non-zero ThreshFlag).
SMDCombined.ThreshFlag = zeros(numel(SMDCombined.FrameNum), 1);

% Provide a final message to summarize the results.
if (Verbose > 2)
    fprintf(['\tFrameConnection.hypothesisTestFC(): ', ...
        '%i localizations combined to %i localizations.\n'], ...
        numel(SMD.FrameNum), numel(SMDCombined.FrameNum))
end


end
./MATLAB/+smi_core/@FrameConnection/performFrameConnection.m
function [SMDCombined, SMD] = performFrameConnection(obj)
%performFrameConnection is the "run" method of the FrameConnection class.
%
% This method is intended to be used as the main "run" method of the
% FrameConnection class, meaning that most users will set the properties of
% the FrameConnection class, call this method, gather desired properties,
% and then move on to other analyses.
%
% NOTE: This method will add an additional field to obj.SMD called
%       "ConnectID".  obj.SMD.ConnectID is an integer array indicating
%       which localizations were connected during the frame connection
%       process.  For example, if
%       (obj.SMD.ConnectID(nn) == obj.SMD.ConnectID(mm)), the localizations
%       in SMD identified by the indices nn and mm were connected during
%       frame connection.  The exact value of the field "ConnectID" is
%       itself arbitrary and carries no meaning further than associating
%       localizations. This field is directly related to
%       obj.SMDCombined.ConnectID as follows:
%           For a given ConnectID, say nn, the indices in arrays of SMD
%           that were combined to generate a field in SMDCombined can be
%           found as IndicesSMD = find(SMD.ConnectID == nn) (alternatively,
%           IndicesSMD = smi_core.FrameConnection.findConnected(...
%               SMDCombined, SMD, nn) )
%
% INPUTS:
%   obj: An instance of the class smi_core/FrameConnection with all fields
%        populated with meaningful entries.
%
% OUTPUTS:
%   SMDCombined: SMDCombined contains the "frame-connected" localizations,
%                i.e., the result of performing frame-connection on obj.SMD
%   SMD: obj.SMD but with the field 'ConnectID' populated (see
%        smi_core.FrameConnection.findConnected() for a careful description
%        of 'ConnectID'.

% Created by:
%   David J. Schodt (Lidke Lab, 2021)


% Make sure obj.SMD contains temporal data.  If it doesn't, exit here
% (since there's nothing to frame-connect).
if (isempty(obj.SMD.FrameNum) || (numel(obj.SMD.FrameNum)==1))
    SMD = obj.SMD;
    SMDCombined = SMD;
    obj.SMDCombined = obj.SMDCombined;
    return
end

% Perform frame-connection using the requested method.
if (obj.Verbose > 0)
    fprintf(['FrameConnection.performFrameConnection(): ', ...
        'Performing frame connection...\n'])
end
switch lower(obj.SMF.FrameConnection.Method)
    case 'hypothesis test'
        % As it's written now,  obj.hypothesisTestFC() is fully
        % self-contained, so we should return after running it.
        [SMDCombined, SMD] = obj.hypothesisTestFC(obj.SMD, obj.SMF, ...
            obj.Verbose);
        obj.SMDCombined = SMDCombined;
        obj.SMD = SMD;
        return
    case 'lap-fc'
        [obj.SMD, obj.InternalParams] = ...
            obj.lapFC(obj.SMD, obj.SMF, obj.Verbose, obj.InternalParams);
    case 'classical'
        obj.SMD = obj.classicalFC(obj.SMD, obj.SMF, obj.Verbose);
    case 'revised classical'
        obj.SMD = obj.revisedClassicalFC(obj.SMD, obj.SMF, obj.Verbose);
end
SMDCombined = obj.combineLocalizations(obj.SMD, obj.SMF);
obj.SMDCombined = SMDCombined;
if (obj.Verbose > 0)
    fprintf(['FrameConnection.performFrameConnection(): ', ...
        'Frame connection complete.\n'])
    fprintf('FrameConnection: %d -> %d localizations\n', ...
        numel(obj.SMD.X), numel(SMDCombined.X));
end


end

./MATLAB/+smi_core/@FrameConnection/estimateRateParameters.m
function [KOn, KOff, KBleach, PMiss, NEmitters] = ...
    estimateRateParameters(ClusterData, Verbose)
%estimateRateParameters estimates rates from clustered localizations.
% This method will make an estimate of the blinking kinetics (KOn, KOff,
% and KBleach) based on the (pre-clustered) localizations in ClusterData.
% These are computed by assuming that each cluster corresponds to a single
% emitter.
%
% NOTE: Many of the output parameters are bounded either implicitly or
%       explicitly:
%       KOn: [1e-5, NLocalizations/NFrames]
%       KOff: [1/NLocalizations, 1]
%       KBleach: [1e-5, inf)
%       PMiss: [0, 1-1/NFrames]
%       NEmitters: [max(NLocOverTime), NClusters]
%
% INPUTS:
%   ClusterData: Cell array of cluster data (see organizeClusterData())
%
% OUTPUTS:
%   KOn: Rate parameter for blinking on. (1 / frame)
%   KOff: Rate parameter for blinking off. (1 / frame)
%   KBleach: Rate parameter for photobleaching. (1 / frame)
%   PMiss: Probability of missing a localization.
%   NEmitters: Total number of emitters present at the start of the
%              experiment.
%   Verbose: Flag to indicate verbosity of outputs. (Default = 1)
%
% CITATION:
%   David J. Schodt and Keith A. Lidke, "Spatiotemporal Clustering of
%   Repeated Super-Resolution Localizations via Linear Assignment
%   Problem", Frontiers in Bioinformatics, 2021
%   https://doi.org/10.3389/fbinf.2021.724325

% Created by:
%   David J. Schodt (Lidke Lab, 2021)


% Set defaults if needed.
if (~exist('Verbose', 'var') || isempty(Verbose))
    Verbose = 1;
end

% Compute some quantities needed from each cluster.
NClusters = numel(ClusterData);
ClusterDurations = NaN(NClusters, 1);
NObservations = NaN(NClusters, 1);
for nn = 1:NClusters
    % Compute the total duration of the cluster.
    CurrentFrames = ClusterData{nn}(:, 5);
    ClusterDurations(nn) = max(CurrentFrames) - min(CurrentFrames) + 1;

    % Compute the total number of observed localizations (clusters might
    % have multiple localizations per frame due to generous pre-clustering,
    % so we should make sure not to overcount those).
    NObservations(nn) = numel(unique(CurrentFrames));
end

% Estimate KOff+KBleach and PMiss, assuming each cluster was a single
% blinking event of a single emitter.
% NOTE: I've added the isinf() check to KOffPKBleach just to avoid crashing
%       this code (in case the user wants to run it in some strange
%       scenario).  It's important to note that if KOffPKBleach = inf, we
%       won't be using these parameters for frame-connection, as this can
%       only happen when each pre-cluster only had a single localization!
KOffPKBleach = -log(1 - 1/mean(ClusterDurations));
KOffPKBleach = smi_helpers.arrayMUX({KOffPKBleach, 1}, isinf(KOffPKBleach));
PMiss = 1 - (mean(NObservations./ClusterDurations));

% Compute some parameters from the sum of localizations present over time.
AllData = cell2mat(ClusterData);
[NLoc, Frames] = groupcounts(double(AllData(:, 5)));
NLocSum = cumsum(NLoc);
KOff = NClusters / NLocSum(end);
KBleach = max(1e-5, KOffPKBleach - KOff);
FitOptions = optimset('Display', ...
    smi_helpers.arrayMUX({'none', 'final'}, (Verbose > 1)));
K = @(KOn) KOn + KOffPKBleach;
L1 = @(KOn) KOn * KBleach / K(KOn);
L2 = @(KOn) (KOn+KOffPKBleach) - L1(KOn);
Model = @(X) ceil(X(1))*(1-PMiss)*(X(2)/K(X(2))) ...
    * ((1/L1(X(2)))*(1-exp(-L1(X(2))*(Frames-1))) ...
    - (1/L2(X(2)))*(1-exp(-L2(X(2))*(Frames-1))));
CostFunction = @(X) mean((NLocSum - Model(X)).^2);
NEmittersInitGuess = ceil(NClusters * KBleach / (KOff*(1-PMiss))); % DJS 22/06/23: better guess than suggested in paper
if ((NEmittersInitGuess<max(NLoc)) || (NEmittersInitGuess>NClusters))
    NEmittersInitGuess = (NClusters-max(NLoc)) / 2;
end
LocSumParams = fmincon(CostFunction, ...
    [NEmittersInitGuess, 1/Frames(end)], [], [], [], [], ...
    [max(NLoc), 1e-5], [NClusters, NLocSum(end)/Frames(end)], [], ...
    FitOptions);
NEmitters = ceil(LocSumParams(1));
KOn = LocSumParams(2);


end
./MATLAB/+smi_core/@FrameConnection/README.md
### +smi_core/@FrameConnection

FrameConnection performs frame-connection on data in an SMD structure

This class contains methods to perform frame-connection and to do
associated tasks.  More specifically, the main usage of this class
is to combine a time series of localizations arising from the same
emitter into a single localization with precision greater than any
one of the localizations in the time series.

EXAMPLE USAGE:
```
   FC = smi_core.FrameConnection(SMD, SMF);
   [SMDCombined, SMD] = FC.performFrameConnection();
   Alternatively, you can use this class as a "function" as follows:
   [~, SMDCombined, SMD] = smi_core.FrameConnection(SMD, SMF, 1);
```

REQUIRES:
- smi_c_FrameConnection.mex
- Optimization Toolbox
- Image Processing Toolbox
- Statistics and Machine Learning Toolbox

CITATION:
   David J. Schodt and Keith A. Lidke, "Spatiotemporal Clustering of
   Repeated Super-Resolution Localizations via Linear Assignment
   Problem", *Frontiers in Bioinformatics*, 2021 
   [https://doi.org/10.3389/fbinf.2021.724325](https://doi.org/10.3389/fbinf.2021.724325)

---

properties:
```
   SMF % see SingleMoleculeFitting class
   SMD % see SingleMoleculeData class
   Verbose = 1; % (Default = 1) Verbosity level of main workflow
```

---

methods:
- **[classicalFC](classicalFC.m)**:
  connects localizations in 'SMD' by simple thresholds
- **[combineLocalizations](combineLocalizations.m)**:
  combines localizations in SMD with the same ConnectID
- **[createCostMatrix](createCostMatrix.m)**:
  creates the cost matrix for frame connection
- **[estimateLocalDensity](estimateLocalDensity.m)**:
  estimates the local density for clustered localizations
- **[estimateRateParameters](estimateRateParameters.m)**:
  estimates rates from clustered localizations
- **[findConnected](findConnected.m)**:
  finds localizations that were frame connected
- **[hypothesisTestFC](hypothesisTestFC.m)**:
  connects localizations in 'SMD' by the hypothesis test method
- **[lapFC](lapFC.m)**:
  connects localizations in 'SMD' by solving a LAP
- **[linkClusters](linkClusters.m)**:
  updates cluster IDs based on the linkages in Link12
- **[organizeClusterData](organizeClusterData.m)**:
  organizes data according to SMD.ConnectID
- **[performFrameConnection](performFrameConnection.m)**:
  is the "run" method of the FrameConnection class
- **[revisedClassicalFC](revisedClassicalFC.m)**:
  connects localizations in 'SMD' by simple thresholds.  The "revision" with
  respect to classicalFC() is that the spatial thresholds are defined in 
  terms of the position standard errors of the localizations. 
- **[unitTest](unitTest.m)**:
  tests vital functionality of the class smi_core.FrameConnection

./MATLAB/+smi_core/@FrameConnection/FrameConnection.m
classdef FrameConnection < handle
    %FrameConnection performs frame-connection on data in an SMD structure
    %
    % This class contains methods to perform frame-connection and to do
    % associated tasks.  More specifically, the main usage of this class
    % is to combine a time series of localizations arising from the same
    % emitter into a single localization with precision greater than any
    % one of the localizations in the time series.
    %
    % EXAMPLE USAGE:
    %   FC = smi_core.FrameConnection(SMD, SMF);
    %   [SMDCombined, SMD] = FC.performFrameConnection();
    %   Alternatively, you can use this class as a "function" as follows:
    %   [~, SMDCombined, SMD] = smi_core.FrameConnection(SMD, SMF, 1);
    %
    % REQUIRES:
    %   smi_c_FrameConnection.mex*
    %   Optimization Toolbox
    %   Image Processing Toolbox
    %   Statistics and Machine Learning Toolbox
    %
    % CITATION:
    %   David J. Schodt and Keith A. Lidke, "Spatiotemporal Clustering of
    %   Repeated Super-Resolution Localizations via Linear Assignment
    %   Problem", Frontiers in Bioinformatics, 2021 
    %   https://doi.org/10.3389/fbinf.2021.724325
    
    % Created by:
    %   David J. Schodt (Lidke Lab 2020)
    
    
    properties
        SMF % see SingleMoleculeFitting class
        SMD % see SingleMoleculeData class
        Verbose = 1; % (Default = 1) Verbosity level of main workflow
    end
    
    properties (Hidden)
        InternalParams = struct([]); % set of parameters used in LAP-FC
    end
    
    properties (SetAccess = 'protected')
        SMDCombined % frame-connected SMD structure
    end
    
    methods
        function [obj, SMDCombined, SMD] = FrameConnection(SMD, SMF, ...
                Verbose, AutoRun)
            %FrameConnection prepares the FrameConnection class for use.
            % This constructor can be used to (optionally) set the input
            % SMD structure and/or "unwrap" an SMF structure to set the
            % available class properties.
            
            % Set a default for the AutoRun flag, which specifies whether
            % or not we should attempt to perform frame-connection
            % immediately (i.e., perform frame-connection in this
            % constructor).
            if (~exist('AutoRun', 'var') || isempty(AutoRun))
                AutoRun = 0;
            end
            
            % Set the verbosity level if provided.
            if (exist('Verbose', 'var') && ~isempty(Verbose))
                obj.Verbose = Verbose;
            end
            if ((obj.Verbose>2) && (nargin()>0))
                fprintf(['\tFrameConnection constructor: ', ...
                    'Setting class properties based on constructor ', ...
                    'inputs...\n'])
            end
            
            % Set the input SMD structure as a class property (if provided)
            if (exist('SMD', 'var') && ~isempty(SMD))
                if (obj.Verbose > 2)
                    fprintf(['\tFrameConnection constructor: ', ...
                        'Storing input SMD as a class property...\n'])
                end
                obj.SMD = SMD;
                AllFieldsSet = 1;
            else
                AllFieldsSet = 0;
            end
            
            % Store the SMF as a class property (if it was provided).
            if (exist('SMF', 'var') && ~isempty(SMF))
                % Pad the input SMF structure to ensure it contains all
                % fields defined in SingleMoleculeFitting.createSMF().
                obj.SMF = smi_core.SingleMoleculeFitting.padSMF(SMF);
            else
                obj.SMF = smi_core.SingleMoleculeFitting;
            end
            
            % If all required fields are set, run the frame-connection
            % process.
            if (AutoRun && AllFieldsSet)
                if (obj.Verbose > 2)
                    fprintf(['\tFrameConnection constructor: ', ...
                        'Auto-running obj.performFrameConnection()...\n'])
                end
                [SMDCombined, SMD] = obj.performFrameConnection();
            else
                if ((obj.Verbose>0) && (nargout()>1))
                    warning(['Constructor outputs SMD and ', ...
                        'SMDCombined were requested but ', ...
                        'frame-connection was not performed.'])
                end
                SMD = obj.SMD;
                SMDCombined = SMD;
            end
        end
        
        [SMDCombined, SMD] = performFrameConnection(obj)
        
    end
    
    methods (Static)
        [SMDIndex] = findConnected(SMR, SMD, ID);
        [SMDCombined, SMD] = hypothesisTestFC(SMD, SMF, Verbose);
        [SMD, InternalParams] = lapFC(SMD, SMF, Verbose, InternalParams);
        [SMD] = classicalFC(SMD, SMF, Verbose);
        [SMD] = revisedClassicalFC(SMD, SMF, Verbose);
        [ClusterData] = organizeClusterData(SMD);
        [KOn, KOff, KBleach, PMiss, NEmitters] = ...
            estimateRateParameters(ClusterData, Verbose);
        [InitialDensity] = estimateLocalDensity(ClusterData, ...
            NNearestClusters, KOn, KOff, KBleach, PMiss);
        [CostMatrix] = createCostMatrix(ClusterData, ...
            KOn, KOff, KBleach, PMiss, InitialDensity, MaxFrameGap, ...
            EndFrame, NonLinkMarker)
        [ConnectID, MaxConnectID] = ...
            linkClusters(ConnectID, MaxConnectID, UpdateIndices, Link12);
        [SMDCombined] = combineLocalizations(SMD, SMF);
        [Success] = unitTest();
    end
    
    
end
./MATLAB/+smi_core/@FrameConnection/revisedClassicalFC.m
function [SMD] = revisedClassicalFC(SMD, SMF, Verbose)
%revisedClassicalFC connects localizations in 'SMD' by simple thresholds.
% This method solves the frame-connection problem by connecting
% localizations within hard spatiotemporal thresholds.  The "revision" with
% respect to classicalFC() is that the spatial thresholds are defined in
% terms of the position standard errors of the localizations.
%
% NOTE: This method is nearly identical to
%       smi_cluster.clusterSTSigma(), with the only difference being
%       that localizations within the same frame are prohibited from being
%       connected to one another.
%
% NOTE: This method will add an additional field to SMD called
%       "ConnectID".  SMD.ConnectID is an integer array indicating
%       which localizations were connected during the frame connection
%       process.  For example, if
%       (SMD.ConnectID(nn) == SMD.ConnectID(mm)), the localizations
%       in SMD identified by the indices nn and mm were connected during
%       frame connection.  The exact value of the field "ConnectID" is
%       itself arbitrary and carries no meaning further than associating
%       localizations. This field is directly related to
%       SMDCombined.ConnectID as follows:
%           For a given ConnectID, say nn, the indices in arrays of SMD
%           that were combined to generate a field in SMDCombined can be
%           found as IndicesSMD = find(SMD.ConnectID == nn) (alternatively,
%           IndicesSMD = smi_core.FrameConnection.findConnected(...
%               SMDCombined, SMD, nn) )
%
% INPUTS:
%   SMD: SingleMoleculeData structure with the localizations that we wish
%        to frame-connect.
%   SMF: SingleMoleculeFitting structure defining relevant parameters.
%   Verbose: Integer specifying the verbosity level. (Default = 1)
%
% OUTPUTS:
%   SMD: SMD but with the field 'ConnectID' populated.
%
% CITATION:

% Created by:
%   David J. Schodt (Lidke Lab, 2021)


% Set defaults if needed.
if (~exist('SMF', 'var') || isempty(SMF))
    SMF = smi_core.SingleMoleculeFitting;
end
if (~exist('Verbose', 'var') || isempty(Verbose))
    Verbose = 1;
end    

% Gather/revise/reorganize some arrays for further use.
NLocalizations = numel(SMD.FrameNum);
[DatasetNum, SortIndices] = sort(SMD.DatasetNum);
X = SMD.X(SortIndices);
Y = SMD.Y(SortIndices);
X_SE = SMD.X_SE(SortIndices);
Y_SE = SMD.Y_SE(SortIndices);
FrameNum = SMD.FrameNum(SortIndices);
MeanXYSE = mean([X_SE, Y_SE], 2);
MaxFrameGap = SMF.FrameConnection.MaxFrameGap;
NSigmaDev = SMF.FrameConnection.NSigmaDev;

% Initialize each localization as a new cluster.
ConnectID = (1:NLocalizations).';

% Loop through datasets and perform the pre-clustering.
[NLocPerDataset, DatasetArray] = groupcounts(DatasetNum);
CumulativeDatasetLocs = [0; cumsum(NLocPerDataset)];
MaxID = NLocalizations;
for ii = 1:numel(DatasetArray)
    % Provide a Command Window update if needed.
    if (Verbose > 2)
        fprintf(['\tFrameConnection.revisedClassicalFC(): ', ...
            'Performing frame connection for dataset %i...\n'], ii)
    end
    
    % Isolate some arrays for the current dataset (CDS = current dataset)
    CurrentDatasetInd = (1:NLocPerDataset(ii)) + CumulativeDatasetLocs(ii);
    [FrameNumCDs, SortIndicesFN] = sort(FrameNum(CurrentDatasetInd));
    XCDs = X(CurrentDatasetInd(SortIndicesFN));
    YCDs = Y(CurrentDatasetInd(SortIndicesFN));
    MeanXYSECDs = MeanXYSE(CurrentDatasetInd(SortIndicesFN));
    ConnectIDCDs = ConnectID(CurrentDatasetInd(SortIndicesFN));
    
    % Loop through frames and add localizations to clusters.
    IsClustered = zeros(NLocPerDataset(ii), 1, 'logical');
    [NLocPerFrame, FrameArray] = groupcounts(FrameNumCDs);
    CumulativeLocs = [0; cumsum(NLocPerFrame)];
    for ff = 1:numel(FrameArray)
        % Determine which localizations should be considered for clustering.
        % NOTE: Even though we don't want clusters with multiple 
        %       localizations in the same frame for the final results, we 
        %       don't want to exclude those until later (since inclusion of
        %       WRONG localizations now can exclude CORRECT localizations 
        %       if we restrict same frame localizations).
        CurrentFrameInd = (1:NLocPerFrame(ff)) + CumulativeLocs(ff);
        CandidateFrameInd = ...
            find((FrameNumCDs >= (FrameArray(ff)-MaxFrameGap)) ...
            & (FrameNumCDs<FrameArray(ff)));
        if isempty(CandidateFrameInd)
            ConnectID(CurrentFrameInd) = (1:NLocPerFrame(ff)).' + MaxID;
            MaxID = MaxID + NLocPerFrame(ff);
            continue
        end
        
        % Determine the nearest neighbor to the current localizations in
        % all candidate frames.
        [NNIndices, NNDistances] = knnsearch(...
            [XCDs(CandidateFrameInd), YCDs(CandidateFrameInd)], ...
            [XCDs(CurrentFrameInd), YCDs(CurrentFrameInd)], ...
            'k', 1);
        
        % Place the CurrentFrameInd localizations into clusters.
        ValidNNInd = find(NNDistances ...
            <= (NSigmaDev*MeanXYSECDs(CurrentFrameInd)));
        if isempty(ValidNNInd)
            continue
        end
        for nn = ValidNNInd.'
            % Place this localization into the same cluster as its nearest
            % neighbor.
            NNIndex = CandidateFrameInd(NNIndices(nn));
            if IsClustered(NNIndex)
                ConnectIDCDs(CurrentFrameInd(nn)) = ConnectIDCDs(NNIndex);
                IsClustered(CurrentFrameInd(nn)) = true;
            else
                MaxID = MaxID + 1;
                ConnectIDCDs([CurrentFrameInd(nn), NNIndex]) = MaxID;
                IsClustered([CurrentFrameInd(nn), NNIndex]) = true;
            end
        end
    end
    ConnectID(CurrentDatasetInd(SortIndicesFN)) = ConnectIDCDs;
end
SMD.ConnectID(SortIndices, 1) = smi_helpers.compressToRange(ConnectID);


end
./MATLAB/+smi_core/@FrameConnection/lapFC.m
function [SMD, InternalParams] = lapFC(SMD, SMF, Verbose, InternalParams)
%lapFC connects localizations in 'SMD' by solving a LAP.
% This method solves the frame-connection problem by formulating it as a
% linear assignment problem, where the costs of connection/no connection
% are influenced by kinetic rates and local densities.
% NOTE: This method will add an additional field to SMD called
%       "ConnectID".  SMD.ConnectID is an integer array indicating
%       which localizations were connected during the frame connection
%       process.  For example, if
%       (SMD.ConnectID(nn) == SMD.ConnectID(mm)), the localizations
%       in SMD identified by the indices nn and mm were connected during
%       frame connection.  The exact value of the field "ConnectID" is
%       itself arbitrary and carries no meaning further than associating
%       localizations. This field is directly related to
%       SMDCombined.ConnectID as follows:
%           For a given ConnectID, say nn, the indices in arrays of SMD
%           that were combined to generate a field in SMDCombined can be
%           found as IndicesSMD = find(SMD.ConnectID == nn) (alternatively,
%           IndicesSMD = smi_core.FrameConnection.findConnected(...
%               SMDCombined, SMD, nn) )
%
% INPUTS:
%   SMD: SingleMoleculeData structure with the localizations that we wish
%        to frame-connect.
%   SMF: SingleMoleculeFitting structure defining relevant parameters.
%   Verbose: Integer specifying the verbosity level. (Default = 1)
%   InternalParams: Structure of parameters which are used in this method
%                   but are not present in SMF.  Typically, this input
%                   should not be provided (can be entered as []), however
%                   it is allowed as an input for testing purposes (e.g.,
%                   testing the algorithm performance with perfect inputs).
%                   (Default = [] so that these parameters are estimated
%                   internally from the data in SMD).
%
% OUTPUTS:
%   SMD: SMD but with the field 'ConnectID' populated.
%   InternalParams: Structure of parameters which are computed internally
%                   in this method (e.g., the rates KOn, KOff, and
%                   KBleach).  The field 'NEmitters' is provided for
%                   convenience (unless 'InternalParams' is provided as an
%                   input) but is not actually used anywhere in the
%                   algorithm.
%
% CITATION:

% Created by:
%   David J. Schodt (Lidke Lab, 2021)


% Set defaults if needed.
if (~exist('SMF', 'var') || isempty(SMF))
    SMF = smi_core.SingleMoleculeFitting;
end
if (~exist('InternalParams', 'var') || isempty(InternalParams))
    InternalParams = struct();
    EstimateParams = true;
else
    % This input was provided, so we'll extract some parameters for later
    % use.
    KOn = InternalParams.KOn;
    KOff = InternalParams.KOff;
    KBleach = InternalParams.KBleach;
    PMiss = InternalParams.PMiss; 
    InitialDensity = InternalParams.InitialDensity;
    EstimateParams = false;
end
if (~exist('Verbose', 'var') || isempty(Verbose))
    Verbose = 1;
end    

% Perform an initial pre-clustering of the data.
if (Verbose > 2)
    fprintf('\tFrameConnection.lapFC(): Pre-clustering localizations...\n')
end
SMDPreClustered = SMD;
SMDPreClustered.ConnectID = smi_cluster.clusterSTSigma(SMD, ...
    SMF.FrameConnection.MaxFrameGap, SMF.FrameConnection.NSigmaDev);
SMD.ConnectID = SMDPreClustered.ConnectID;
if (numel(unique(SMDPreClustered.ConnectID)) ...
        == numel(SMDPreClustered.ConnectID))
    % This condition checks if pre-clustering actually did anything.  If
    % not, we don't need to proceed (since each pre-cluster already has
    % only 1 localization).
    return
end

% Iteratively perform the frame-connection, using updated density and
% fluorophore transition rate estimates from the previous iteration.
for rr = 1:SMF.FrameConnection.NIterations
    if (Verbose > 2)
        fprintf(['\tFrameConnection.lapFC(): ', ...
            'LAP-FC iteration %i of %i...\n'], ...
            rr, SMF.FrameConnection.NIterations)
    end
    % Estimate the number of emitters present at the start of the
    % experiment.  For now, I'll just use the total number of clusters,
    % even though this breaks several assumptions made in the rate
    % parameter estimation step.
    if (Verbose > 1)
        fprintf(['\tFrameConnection.lapFC(): ', ...
            'Re-organizing precluster data...\n'])
    end
    ClusterData = smi_core.FrameConnection.organizeClusterData(SMD);
    
    % Estimate some needed parameters from the data.
    if EstimateParams
        % Estimate the fluorophore transition rate parameters.
        if (Verbose > 1)
            fprintf(['\tFrameConnection.lapFC(): ', ...
                'Estimating rate parameters from preclusters...\n'])
        end
        [KOn, KOff, KBleach, PMiss, NEmitters] = ...
            smi_core.FrameConnection.estimateRateParameters(...
            ClusterData, Verbose);
        InternalParams.NEmitters = NEmitters;
       
        % Estimate the local density around each cluster.
        if (Verbose > 1)
            fprintf(['\tFrameConnection.lapFC(): ', ...
                'Estimating local emitter densities...\n'])
        end
        InitialDensity = smi_core.FrameConnection.estimateLocalDensity(...
            ClusterData, SMF.FrameConnection.NNearestClusters, ...
            KOn, KOff, KBleach, PMiss);
    end

    % Grab a few arrays out of obj and SMD (to improve speed within the
    % for loop below).
    ConnectID = SMD.ConnectID;
    MaxFrameGap = SMF.FrameConnection.MaxFrameGap;
    NFramesMax = SMD.NFrames;
    if isempty(NFramesMax)
        NFramesMax = max(SMD.FrameNum);
    end

    % Loop through all clusters, construct and minimize the cost matrix, and
    % then cluster the localizations.
    if (Verbose > 1)
        fprintf(['\tFrameConnection.lapFC(): ', ...
            'Looping over clusters and solving the LAP...\n'])
    end
    MaxConnectID = numel(unique(ConnectID));
    ClustersToAnalyze = find(cellfun(@(X) size(X, 1) > 1, ClusterData));
    for nn = ClustersToAnalyze.'
        % Construct the cost matrix.
        CostMatrix = smi_core.FrameConnection.createCostMatrix(...
            ClusterData{nn}, ...
            KOn, KOff, KBleach, PMiss, InitialDensity(nn), ...
            MaxFrameGap, NFramesMax, -1);
        
        % Solve the linear assignment problem.
        Link12 = smi.SPT.solveLAP(CostMatrix, -1);
        
        % Update the connect IDs to indicate the linkage.
        [ConnectID, MaxConnectID] = ...
            smi_core.FrameConnection.linkClusters(...
            ConnectID, MaxConnectID, ...
            ClusterData{nn}(:, 8), Link12);
    end
    SMD.ConnectID = smi_helpers.compressToRange(ConnectID);
end
InternalParams.KOn = KOn;
InternalParams.KOff = KOff;
InternalParams.KBleach = KBleach;
InternalParams.PMiss = PMiss;
InternalParams.InitialDensity = InitialDensity;


end
./MATLAB/+smi_core/@FrameConnection/combineLocalizations.m
function [SMDCombined] = combineLocalizations(SMD, SMF)
%combineLocalizations combines localizations in SMD with the same ConnectID
% This method combines localizations in SMD which share the same value of
% SMD.ConnectID.  That is, this method combines the frame-connected
% localizations into a single localization with higher precision.
%
% INPUTS:
%   SMD: Single Molecule Data structure with a populated SMD.ConnectID.
%   SMF: Single Molecule Fitting structure (needed for the field
%        SMF.Fitting.FitType).
%
% OUTPUTS:
%   SMDCombined: Single Molecule Data structure with combined
%                localizations, where SMD.ConnectID is now unique for every
%                localization.

% Created by:
%   David J. Schodt (Lidke Lab, 2021)


% Define a default for 'FitType' if needed.
if (~exist('SMF', 'var') || isempty(SMF))
    SMF = smi_core.SingleMoleculeFitting;
end

% Isolate/organize some SMD arrays.
ConnectID = SMD.ConnectID;
[ConnectID, SortIndices] = sort(ConnectID);
X = SMD.X(SortIndices);
Y = SMD.Y(SortIndices);
X_SE = SMD.X_SE(SortIndices);
Y_SE = SMD.Y_SE(SortIndices);
FrameNum = SMD.FrameNum(SortIndices);
DatasetNum = SMD.DatasetNum(SortIndices);
Photons = SMD.Photons(SortIndices);
Bg = SMD.Bg(SortIndices);
switch SMF.Fitting.FitType
    case 'XYNBS'
        PSFSigma = SMD.PSFSigma(SortIndices);
        PSFSigma_SE = SMD.PSFSigma_SE(SortIndices);
    case 'XYNBSXSY'
        PSFSigmaX = SMD.PSFSigmaX(SortIndices);
        PSFSigmaY = SMD.PSFSigmaY(SortIndices);
        PSFSigmaX_SE = SMD.PSFSigmaX_SE(SortIndices);
        PSFSigmaY_SE = SMD.PSFSigmaY_SE(SortIndices);
    case 'XYZNB'
        Z = SMD.Z(SortIndices);
        Z_SE = SMD.Z_SE(SortIndices(1:numel(SMD.Z_SE)));
end

% Loop over the unique connect IDs and combine the associated
% localizations.
NLocPerID = groupcounts(ConnectID);
NLocCumulative = [0; cumsum(NLocPerID)];
UniqueIDs = unique(ConnectID);
NUnique = numel(UniqueIDs);
SMDCombined = smi_core.SingleMoleculeData.isolateSubSMD(SMD, 1);
for ii = 1:NUnique
    IndexArray = (1:NLocPerID(ii)).' + NLocCumulative(ii);
    SMDCombined.X(ii, 1) = sum(X(IndexArray)./X_SE(IndexArray).^2) ...
        / sum(1./X_SE(IndexArray).^2);
    SMDCombined.Y(ii, 1) = sum(Y(IndexArray)./Y_SE(IndexArray).^2) ...
        / sum(1./Y_SE(IndexArray).^2);
    SMDCombined.X_SE(ii, 1) = sqrt(1 ./ sum(1./X_SE(IndexArray).^2));
    SMDCombined.Y_SE(ii, 1) = sqrt(1 ./ sum(1./Y_SE(IndexArray).^2));
    SMDCombined.ConnectID(ii, 1) = ConnectID(IndexArray(1));
    SMDCombined.FrameNum(ii, 1) = FrameNum(IndexArray(NLocPerID(ii)));
    SMDCombined.DatasetNum(ii, 1) = DatasetNum(IndexArray(1));
    SMDCombined.Photons(ii, 1) = sum(Photons(IndexArray));
    SMDCombined.Bg(ii, 1) = sum(Bg(IndexArray));
end
SMDCombined.NCombined = NLocPerID;

% If the fit type wasn't 'XYNB', we still need to combine some other fields
% (I'm doing this in a separate loop down here for speed purposes, since we
% usually won't need to do this).
switch SMF.Fitting.FitType
    case 'XYNB'
        % For fit type 'XYNB', every value of PSFSigma should be the same.
        SMDCombined.PSFSigma = ...
            SMD.PSFSigma(1) * ones(size(SMDCombined.FrameNum));
    case 'XYNBS'
        for ii = 1:NUnique
            IndexArray = (1:NLocPerID(ii)).' + NLocCumulative(ii);
            SMDCombined.PSFSigma(ii, 1) = ...
                sum(PSFSigma(IndexArray)./PSFSigma_SE(IndexArray).^2) ...
                / sum(1./PSFSigma_SE(IndexArray).^2);
            SMDCombined.PSFSigma_SE(ii, 1) = ...
                sqrt(1 / sum(1./PSFSigma_SE(IndexArray).^2));
        end
    case 'XYNBSXSY'
        for ii = 1:NUnique
            IndexArray = (1:NLocPerID(ii)).' + NLocCumulative(ii);
            SMDCombined.PSFSigmaX(ii, 1) = ...
                sum(PSFSigmaX(IndexArray)./PSFSigmaX_SE(IndexArray).^2) ...
                / sum(1./PSFSigmaX_SE(IndexArray).^2);
            SMDCombined.PSFSigmaY(ii, 1) = ...
                sum(PSFSigmaY(IndexArray)./PSFSigmaY_SE(IndexArray).^2) ...
                / sum(1./PSFSigmaY_SE(IndexArray).^2);
            SMDCombined.PSFSigmaX_SE(ii, 1) = ...
                sqrt(1 / sum(1./PSFSigmaX_SE(IndexArray).^2));
            SMDCombined.PSFSigmaY_SE(ii, 1) = ...
                sqrt(1 / sum(1./PSFSigmaY_SE(IndexArray).^2));
        end
    case 'XYZNB'
        for ii = 1:NUnique
            IndexArray = (1:NLocPerID(ii)).' + NLocCumulative(ii);
            SMDCombined.Z(ii, 1) = ...
                sum(Z(IndexArray)./Z_SE(IndexArray).^2) ...
                / sum(1./Z_SE(IndexArray).^2);
            SMDCombined.Z_SE(ii, 1) = ...
                sqrt(1 / sum(1./Z_SE(IndexArray).^2));
        end
end

% Combine some fields that may or may not be in the SMD (e.g., a simulation
% might not produce a value for log-likelihood, which can become a burden
% to deal with).
% NOTE: For Photons_SE and Bg_SE, I'm not sure if this is the correct
%       result.  However, it's probably decent: these are the correct
%       results assuming only Poisson (shot) noise.
if ~isempty(SMD.Photons_SE)
    Photons_SE = SMD.Photons_SE(SortIndices);
    for ii = 1:NUnique
        IndexArray = (1:NLocPerID(ii)).' + NLocCumulative(ii);
        SMDCombined.Photons_SE(ii, 1) = sqrt(sum(Photons_SE(IndexArray).^2));
    end
end
if ~isempty(SMD.Bg_SE)
    Bg_SE = SMD.Bg_SE(SortIndices);
    for ii = 1:NUnique
        IndexArray = (1:NLocPerID(ii)).' + NLocCumulative(ii);
        SMDCombined.Bg_SE(ii, 1) = sqrt(sum(Bg_SE(IndexArray).^2));
    end
end
if ~isempty(SMD.LogLikelihood)
    LogLikelihood = SMD.LogLikelihood(SortIndices);
    for ii = 1:NUnique
        IndexArray = (1:NLocPerID(ii)).' + NLocCumulative(ii);
        SMDCombined.LogLikelihood(ii, 1) = sum(LogLikelihood(IndexArray));
    end
end
if ~isempty(SMD.PValue)
    SMDCombined.PValue = smi_core.GaussMLE.pValue(SMF.Fitting.NParams, ...
        SMF.BoxFinding.BoxSize, ...
        SMDCombined.LogLikelihood);
end
if ~isempty(SMD.ThreshFlag)
    ThreshFlag = SMD.ThreshFlag(SortIndices);
    for ii = 1:NUnique
        IndexArray = (1:NLocPerID(ii)).' + NLocCumulative(ii);
        SMDCombined.ThreshFlag(ii, 1) = sum(ThreshFlag(IndexArray));
    end
end
if ~(isempty(SMD.XBoxCorner) || isempty(SMD.YBoxCorner))
    XBoxCorner = SMD.XBoxCorner(SortIndices);
    YBoxCorner = SMD.YBoxCorner(SortIndices);
    for ii = 1:NUnique
        SMDCombined.XBoxCorner(ii, 1) = ...
            XBoxCorner(NLocPerID(ii) + NLocCumulative(ii), 1);
        SMDCombined.YBoxCorner(ii, 1) = ...
            YBoxCorner(NLocPerID(ii) + NLocCumulative(ii), 1);
    end
end


end
./MATLAB/+smi_core/@FrameConnection/organizeClusterData.m
function [ClusterData] = organizeClusterData(SMD)
%organizeClusterData organizes data according to SMD.ConnectID.
% This method organizes relevant data (X, Y, ...) for each cluster into a
% cell of cell array for later use.
%
% INPUTS:
%   SMD: Single Molecule Data structure with a populated SMD.ConnectID.
%
% OUTPUTS:
%   ClusterData: Cell array of cluster data, with the index corresponding
%                to the sorted unique cluster IDs (e.g., if 
%                unique(ConnectID) = [1, 2, 5], 
%                ClusterData{1}<->ConnectID 1, 
%                ClusterData{2}<->ConnectID 2,
%                ClusterData{3}<->ConnectID 5

% Created by:
%   David J. Schodt (Lidke Lab, 2021)


% Isolate/organize some SMD arrays.
ConnectID = SMD.ConnectID;
CombinedData = [SMD.X, SMD.Y, SMD.X_SE, SMD.Y_SE, ...
    single(SMD.FrameNum), single(SMD.DatasetNum), single(ConnectID)];
[~, SortIndices] = sort(ConnectID);
CombinedData = CombinedData(SortIndices, :);

% Loop over the unique connect IDs and prepare the output ClusterData.
NLocPerID = groupcounts(ConnectID);
NLocCumulative = [0; cumsum(NLocPerID)];
UniqueIDs = unique(ConnectID);
NUnique = numel(UniqueIDs);
ClusterData = cell(NUnique, 1);
for ii = 1:NUnique
    IndexArray = (1:NLocPerID(ii)) + NLocCumulative(ii);
    ClusterData{ii} = [CombinedData(IndexArray, :), ...
        SortIndices(IndexArray.')];
end


end
./MATLAB/+smi_core/@FrameConnection/linkClusters.m
function [ConnectID, MaxConnectID] = ...
    linkClusters(ConnectID, MaxConnectID, UpdateIndices, Link12)
%linkClusters updates cluster IDs based on the linkages in Link12.
% This method will take the linkage information provided in Link12 and
% reassign ConnectID as appropriate to ensure linked localizations
% share the same ID.
%
% INPUTS:
%   ConnectID: Array of cluster IDs which indicate the connection between
%              localizations. (NLocalizations x 1 integer array)
%   MaxConnectID: Current maximum value of ConnectID.
%   UpdateIndices: SMD indices that are to be updated based on Link12.
%                  (NLocalizations x 1 integer array)
%   Link12: Array containing the trajectory link data as found by
%           solveLAP(). (NLocalizations x 1 integer array)
%
% OUTPUTS:
%   ConnectID: Updated connect IDs based on the input Link12.
%              (NLocalizations x 1 integer array)
%   MaxConnectID: Current maximum value of ConnectID.
%
% CITATION:

% Created by:
%   David J. Schodt (Lidke Lab, 2021)


% Initialize each localization as being a new cluster.
NLocalizations = numel(Link12) / 2;
ConnectID(UpdateIndices) = MaxConnectID + (1:NLocalizations).';

% Loop through the first NLocalizations entries of Link12 and assign new 
% connect IDs as needed, noting that the symmetry of the cost matrix makes
% the last NLocalizations entries redundant.
ConnectIDCurrent = ConnectID(UpdateIndices);
ConnectIDCopy = ConnectIDCurrent;
for ii = 1:NLocalizations
    % Skip to the next iteration if this link indicates a birth.
    if (Link12(ii) > NLocalizations)
        continue
    end

    % Create a boolean array indicating which localizations we will
    % be updating.  We need to update the ii-th localization, the
    % Link12(ii)-th localization, as well as localizations previously
    % connected to either of those groups.
    UpdateBoolean = ismember(ConnectIDCopy, ConnectIDCopy([ii, Link12(ii)]));
    UpdateBoolean = (UpdateBoolean ...
        | ismember(ConnectIDCurrent, ConnectIDCurrent(UpdateBoolean)));

    % Determine the new ID which this cluster should be given.
    NewID = min([ConnectIDCurrent(ii), ConnectIDCurrent(Link12(ii)), ...
        ConnectIDCopy(ii), ConnectIDCopy(Link12(ii))]);
    
    % Update the connect IDs to reflect the connections.
    ConnectIDCurrent(UpdateBoolean) = NewID;
end

% Store the updated connect IDs, ensuring we don't use a previously used
% ID.
ConnectID(UpdateIndices) = ConnectIDCurrent + MaxConnectID;
MaxConnectID = MaxConnectID + NLocalizations;


end
./MATLAB/+smi_core/@FrameConnection/createCostMatrix.m
function [CostMatrix] = createCostMatrix(ClusterData, ...
    KOn, KOff, KBleach, PMiss, InitialDensity, MaxFrameGap, EndFrame, ...
    NonLinkMarker)
%createCostMatrix creates the cost matrix for frame connection
% This method creates a cost matrix whose elements represent the cost for
% connecting super-resolved localizations to one another as an alternative
% approach to frame connection.
%
% INPUTS:
%   ClusterData: Array of cluster data for a specific cluster, extracted
%                from the ClusterData cell array output from
%                organizeClusterData(). (NLocalizations x 6 numeric array)
%                [X, Y, X_SE, Y_SE, FrameNum, ConnectID]
%   KOn: Transition rate for emitters turning on from the dark state.
%        (1 / frame)
%   KOff: Transition rate for emitters reverting to the dark state.
%         (1 / frame)
%   KBleach: Transition rate for emitters bleaching.
%            (1 / frame)
%   PMiss: Probability of missing a localization (i.e., the probability
%          that an emitter is on but was missed during the localization
%          step).
%   InitialDensity: Initial emitter density associated with the current
%                   cluster. (emitters / pixel^2 at start of experiment)
%   MaxFrameGap: Maximum frame gap considered during the pre-clustering
%                step.
%   EndFrame: Last possible frame for the collected data (e.g., if the
%             experimental data consists of 2000 frames, EndFrame = 2000).
%   NonLinkMarker: A marker in the output CostMatrix that indicates we
%                  don't want to select that element in the linear
%                  assignment problem.
%                  (scalar, ~=inf, ~=nan, and typically < 0)
%
% OUTPUTS:
%   CostMatrix: The cost matrix whose elements represent the cost for
%               connecting one localization to another localization/cluster
%               of localizations.
%               (2*NLoc x 2*NLoc numeric array, where NLoc is the number
%               of localizations in the input SMD structure)
%
% CITATION:

% Created by:
%   David J. Schodt (Lidke Lab, 2021)


% Extract some arrays from the ClusterData to make the code more readable.
X = ClusterData(:, 1);
Y = ClusterData(:, 2);
X_SE = ClusterData(:, 3);
Y_SE = ClusterData(:, 4);
FrameNum = ClusterData(:, 5);

% Define various parameters.
NLocalizations = numel(FrameNum);
CMSize = 2 * NLocalizations;

% Populate the upper-left connection block.
CostMatrix = NonLinkMarker * ones(CMSize);
for mm = 1:NLocalizations
    % For each localization, define the cost of linking to the other
    % localizations (divided by two, since a selection of one of these
    % costs leads to the same selection in the auxillary block).  In this
    % case, it's the negative log-likelihood, where the likelihood is given
    % as p(observed separation | localization error) ...
    %  * p(missing last N frames localizations)p(not missing new loc.)...
    %       *p(not turning off or bleaching)
    for nn = (mm+1):NLocalizations
        DeltaFrame = abs(FrameNum(mm) - FrameNum(nn));
        if (DeltaFrame == 0)
            continue
        end
        SigmaX = sqrt(X_SE(mm)^2 + X_SE(nn)^2);
        SigmaY = sqrt(Y_SE(mm)^2 + Y_SE(nn)^2);
        SeparationCost = log(2*pi*SigmaX*SigmaY) ...
            + (X(mm)-X(nn))^2 / (2*SigmaX^2) ...
            + (Y(mm)-Y(nn))^2 / (2*SigmaY^2);
        ObservationCost = -log((PMiss^(DeltaFrame-1)) * (1-PMiss));
        StillOnCost = (KOff + KBleach) * DeltaFrame;
        CostMatrix(mm, nn) = ...
            (SeparationCost + ObservationCost + StillOnCost) / 2;
        CostMatrix(nn+NLocalizations, mm+NLocalizations) = ...
            CostMatrix(mm, nn);
    end
end

% Populate the lower-left birth block and the upper-right death block.
StartFrame = 1;
DutyCycle = KOn / (KOn+KOff+KBleach);
FrameArray = (1:max(FrameNum)).';
Lambda1 = KBleach * DutyCycle;
Lambda2 = (KOn+KOff+KBleach) - Lambda1;
RhoOn = InitialDensity * DutyCycle ...
    * (exp(-Lambda1*(FrameArray-1)) - exp(-Lambda2*(FrameArray-1)));
RhoOff = RhoOn * KOff / KOn;
IndexArray = 1:NLocalizations;
for nn = 1:NLocalizations
    FrameGapPast = min(MaxFrameGap, FrameNum(nn) - StartFrame);
    FrameGapFuture = min(MaxFrameGap, EndFrame - FrameNum(nn));
    BirthCost = -log(1-PMiss) ...
        -log(RhoOff(FrameNum(nn))*(1-exp(-KOn))*exp(-FrameGapPast*KOn) ...
        + RhoOn(FrameNum(nn)-FrameGapPast)*(PMiss^FrameGapPast));
    DeathCost = -log((1-exp(-KOff)) ...
        + (1-exp(-KBleach)) ...
        + (PMiss^FrameGapFuture));
    CostMatrix(IndexArray+NLocalizations, nn) = BirthCost;
    CostMatrix(nn, IndexArray+NLocalizations) = DeathCost;
end

% Set NaN/inf costs to be so high that they won't be chosen unless they're
% the only choice left.
BadValues = (isinf(CostMatrix) | isnan(CostMatrix));
CostMatrix(BadValues) = ...
    2 * sum(CostMatrix(~BadValues & (CostMatrix~=NonLinkMarker)));


end
./MATLAB/+smi_core/@FrameConnection/estimateLocalDensity.m
function [InitialDensity] = ...
    estimateLocalDensity(ClusterData, NNearestClusters, ...
    KOn, KOff, KBleach, PMiss)
%estimateLocalDensity estimates the local density for clustered locs.
% This method will make an estimate of the local density of clusters for
% each cluster in ClusterData.
%
% INPUTS:
%   ClusterData: Cell array of cluster data (see organizeClusterData())
%   NNearestClusters: Number of nearest clusters that we'll search for to
%                     estimate the density.
%   KOn: Rate parameter for blinking on. (1 / frame)
%   KOff: Rate parameter for blinking off. (1 / frame)
%   KBleach: Rate parameter for photobleaching. (1 / frame)
%   PMiss: Probability of missing a localization of a visible emitter. 
%
% OUTPUTS:
%   InitialDensity: Estimate of underlying emitter density at the start of
%                   the experiment for each cluster. (emitters / pixel^2)

% Created by:
%   David J. Schodt (Lidke Lab, 2021)


% Compute the center of each cluster.  If there is only one cluster we'll
% stop early before doing the knnsearch() below.
DutyCycle = KOn / (KOn+KOff+KBleach);
NClusters = numel(ClusterData);
MaxFrame = double(max(cellfun(@(X) max(X(:, 5) .* X(:, 6)), ClusterData)));
if (NClusters == 1)
    % If we only have 1 cluster, we'll just assume it's spatial extent is
    % the area.
    if (numel(ClusterData{1}(:, 1)) == 1)
        InitialDensity = 1;
    else
        Area = (max(ClusterData{1}(:, 1))-min(ClusterData{1}(:, 1))) ...
            * (max(ClusterData{1}(:, 2))-min(ClusterData{1}(:, 2)));
        InitialDensity = (1/Area) * ((KBleach/KOff) / (1-PMiss)) ...
            / (1-exp(-KBleach*DutyCycle*(MaxFrame-1)));
    end
    return
end
ClusterCenters = NaN(NClusters, 2);
for nn = 1:NClusters
    % Isolate some arrays to improve readability.
    X = ClusterData{nn}(:, 1);
    Y = ClusterData{nn}(:, 2);
    X_SE = ClusterData{nn}(:, 3);
    Y_SE = ClusterData{nn}(:, 4);
    
    % Compute the cluster center to be the MLE of the position if all
    % cluster localizations are combined into one.
    ClusterCenters(nn, :) = [sum(X./X_SE.^2) / sum(1./X_SE.^2), ...
        sum(Y./Y_SE.^2) / sum(1./Y_SE.^2)];
end

% For each cluster, estimate the cluster density by assuming each of the
% NNearestClusters are individual emitters.
NNearestClusters = min(NNearestClusters, NClusters-1);
[~, NNClusterDistances] = knnsearch(ClusterCenters, ClusterCenters, ...
    'k', NNearestClusters + 1);
LocalClusterDensity = (NNearestClusters+1) ...
    ./ (pi*NNClusterDistances(:, NNearestClusters+1).^2);

% Based on the cluster density, make an estimate of the initial underlying
% emitter density.
Lambda1 = KBleach * DutyCycle;
Lambda2 = (KOn+KOff+KBleach) - Lambda1;
InitialDensity = LocalClusterDensity ...
    * (1/DutyCycle) * (1/KOff) * (1/(1-PMiss)) ...
    ./ ((1/Lambda1)*(1-exp(-Lambda1*(MaxFrame-1))) ...
    - (1/Lambda2)*(1-exp(-Lambda2*(MaxFrame-1))));


end
./MATLAB/+smi_core/@SingleMoleculeFitting/gui.m
function gui(obj, GUIParent)
%gui is the GUI method for the SingleMoleculeFitting class.
% This method generates a GUI for the SingleMoleculeFitting class which
% allows the user to interactively view/set the class properties and the
% fields of the class properties (which are structs).
%
% NOTE: There are some properties in smi_core.SingleMoleculeFitting.m
%       whose values directly influence how this GUI works. These fields
%       should be kept up-to-date with any changes made to the
%       organization/contents of the SMF class/structures. These fields
%       include:
%           SMFPropertyNames: A cell array of char arrays/strings which
%                             will define the class properties for which we
%                             want to make a tab in this GUI.
%           SMFFieldNotes: A struct of similar organization to the SMF
%                          structures/class property organization, where
%                          the elements contain a field 'Units', which are
%                          char/string notes to be written in text boxes
%                          next to certain GUI elements. There is an
%                          additional field 'Tip', which are char/string
%                          notes to be displayed as a Tooltip when the
%                          cursor is hovered over certain GUI elements
%                          associated with that property. These notes are
%                          defined in the class constructor.
%
% NOTE: I've tried to write this to accomodate changes to the properties
%       and property sub-fields of the smi_core.SingleMoleculeFitting
%       class, but several pieces of this GUI probably still won't work
%       correctly if major changes are made. In writing this GUI this way,
%       there are a few things to keep in mind for future changes to SMF:
%           Scalar fields will automatically be given an edit box uicontrol
%           Logical fields will automatically be given a checkbox uicontrol
%           Fields whose behavior is unique should be added to the
%               hard-coded list 'SpecialFields'.  GUI elements for these
%               fields have to be manually defined below and their behavior
%               modified in propertiesToGUI(), guiToProperties(), and
%               perhaps in other places (look for usage of the variable
%               'SpecialFields' and the method ismember()). Note that you
%               should update and use the nested function
%               'processUserInput()' inside of propertiesToGUI() when
%               appropriate.
%           Fields that don't fit any of the categories above may or may
%               not work without change to the code below.
%       If you would like special behavior for a field, you must add that
%       field manually to the list given in a cell array in 'SpecialFields'
%       below. You must then manually add the special behavior to the
%       various appearances throughout this code (look for usage of the
%       variable 'SpecialFields' and the method ismember()).
%
% INPUTS:
%   GUIParent: The 'Parent' of this GUI, e.g., a figure handle.
%              (Default = figure(...))

% Created by:
%   David J. Schodt (Lidke lab, 2020)


% Define a list of 'special' fields which are treated differently below
% (i.e., we want to manually create special GUI elements for these fields
% below).
SpecialFields = {'Data.FileName', 'Data.CameraType', ...
    'Data.CameraGain', 'Data.CameraOffset', 'Data.CameraReadNoise', ...
    'Data.CalibrationFilePath', 'Data.RegistrationFilePath', ...
    'Data.DatasetList', 'Data.DatasetMods', ...
    'DriftCorrection.Method', ...
    'Fitting.FitType', 'Fitting.ZFitStruct', ...
    'FrameConnection.Method', 'Tracking.Method', 'Tracking.ParamsHistory'};

% Create a figure handle for the GUI if needed.
if ~(exist('GUIParent', 'var') && ~isempty(GUIParent) ...
        && isgraphics(GUIParent))
    DefaultFigurePosition = get(0, 'defaultFigurePosition');
    GUIParent = figure('MenuBar', 'none', ...
        'Name', 'SMF Editor', 'NumberTitle', 'off', ...
        'Units', 'pixels', ...
        'Position', [DefaultFigurePosition(1:2), 485, 350]);
end

% Generate some tabs in the GUI, one per class property. While doing so,
% determine how many fields will be in each tab (we'll use this info. to
% scale certain GUI objects).
NSMFFields = numel(obj.SMFPropertyNames);
TabGroup = uitabgroup(GUIParent, 'Units', 'normalized', ...
    'Position', [0, 0.06, 1, 0.94]);
PropertyTabs = cell(NSMFFields, 1);
NFieldsMax = 0;
for ff = 1:NSMFFields
    % Create the tab.
    PropertyTabs{ff} = uitab(TabGroup, ...
        'Title', obj.SMFPropertyNames{ff}, 'units', 'normalized');
    
    % Determine how many fields will be represented in the current tab.
    NFieldsMax = max(NFieldsMax, ...
        numel(fieldnames(obj.(obj.SMFPropertyNames{ff}))));
end

% Populate each tab with useful ui features, e.g., edit boxes.
% NOTE: I've moved this into a separate loop over fields just to clean up
%       the code a bit.
TabHeight = PropertyTabs{1}.Position(4) - PropertyTabs{1}.Position(2);
TextInitPos = [0, 0, 0.25, (TabHeight/(NFieldsMax+1)) * 0.8];
UIControlInitPos = [TextInitPos(1)...
    + TextInitPos(3), 0, 0.25, TabHeight / (NFieldsMax+1)];
UIControls = cell(NSMFFields, 1);
SubfieldNames = cell(NSMFFields, 1);
for ff = 1:NSMFFields
    % Generate a list of the sub-fields to be displayed in the current tab.
    CurrentProperty = obj.(obj.SMFPropertyNames{ff});
    SubfieldNames{ff} = fieldnames(CurrentProperty);
    NSubFields = numel(SubfieldNames{ff});
    UIControls{ff} = cell(NSubFields, 1);
    
    % Create the edit boxes for simple properties (e.g., scalar
    % properties) and their associated labels, filling the edit boxes with
    % initial values if appropriate. Logical scalars will be given a
    % checkbox style uicontrol instead of an edit box. Other items
    % contained in the SpecialFields list hard-coded above will be treated
    % differently on a case-by-case basis.
    TopPosition = PropertyTabs{ff}.InnerPosition(2) ...
        + PropertyTabs{ff}.InnerPosition(4);
    for ss = 1:NSubFields
        % Create uicontrols for each sub-field. We will create either an
        % edit box or a check box (for logicals) for sub-fields unless
        % special behavior is defined (for the list of 'SpecialFields').
        % NOTE: Some numbers were added to positions arbitrarily to
        %       improve appearance.
        CurrentSubfield = CurrentProperty.(SubfieldNames{ff}{ss});
        CurrentSubfieldName = [obj.SMFPropertyNames{ff}, ...
            '.', SubfieldNames{ff}{ss}];
        CurrentFieldNote = obj.SMFFieldNotes.(...
            obj.SMFPropertyNames{ff}).(SubfieldNames{ff}{ss});
        CurrentYPosition = TopPosition - UIControlInitPos(4)*(ss+0.5);
        uicontrol(PropertyTabs{ff}, 'Style', 'text', ...
            'String', [SubfieldNames{ff}{ss}, ': '], ...
            'HorizontalAlignment', 'right', ...
            'Tooltip', CurrentFieldNote.Tip, ...
            'Units', 'normalized', ...
            'Position', TextInitPos + [0, CurrentYPosition, 0, 0])
        if ismember(CurrentSubfieldName, SpecialFields)
            % Create a listbox uicontrol to show the file names.
            switch CurrentSubfieldName
                case 'Data.FileName'
                    % Create the listbox.
                    UIControls{ff}{ss}{1} = uicontrol(PropertyTabs{ff}, ...
                        'Style', 'popupmenu', ...
                        'String', CurrentSubfield, ...
                        'Tooltip', CurrentFieldNote.Tip, ...
                        'Units', 'normalized', ...
                        'Position', UIControlInitPos ...
                        + [0, CurrentYPosition, 0, 0]);
                    
                    % Create a button to allow for selection of other
                    % files.
                    UIControls{ff}{ss}{2} = uicontrol(PropertyTabs{ff}, ...
                        'Style', 'pushbutton', ...
                        'String', 'Select File(s)', ...
                        'Tooltip', CurrentFieldNote.Tip, ...
                        'Units', 'normalized', ...
                        'Position', UIControlInitPos ...
                        + [UIControlInitPos(3), CurrentYPosition, 0, 0],...
                        'Callback', @selectRawDataFiles);
                case 'Data.CameraType'
                    % Add a pop-up menu for the CameraType options.
                    UIControls{ff}{ss}{1} = uicontrol(PropertyTabs{ff}, ...
                        'Style', 'popupmenu', ...
                        'String', {'EMCCD', 'SCMOS'}, ...
                        'Tooltip', CurrentFieldNote.Tip, ...
                        'Units', 'normalized', ...
                        'Position', UIControlInitPos ...
                        + [0, CurrentYPosition, 0, 0], ...
                        'Callback', @guiToProperties);
                case 'Data.DatasetMods'
                    % Add a pop-up menu for the dataset modifier options.
                    UIControls{ff}{ss}{1} = uicontrol(PropertyTabs{ff}, ...
                        'Style', 'popupmenu', ...
                        'String', ...
                        {'Include Datasets', 'Exclude Datasets'}, ...
                        'Tooltip', CurrentFieldNote.Tip, ...
                        'Units', 'normalized', ...
                        'Position', UIControlInitPos ...
                        + [0, CurrentYPosition, 0, 0], ...
                        'Callback', @guiToProperties);
                    
                    % Add an edit box associated with the pop-up menu.
                    UIControls{ff}{ss}{2} = uicontrol(PropertyTabs{ff}, ...
                        'Style', 'edit', 'Units', 'normalized',...
                        'String', num2str(CurrentSubfield{1}), ...
                        'Tooltip', CurrentFieldNote.Tip, ...
                        'Position', UIControls{ff}{ss}{1}.Position ...
                        + [UIControls{ff}{ss}{1}.Position(3), 0, 0, 0], ...
                        'Callback', @guiToProperties);
                case 'Data.CalibrationFilePath'
                    % Make an edit box for the file path.
                    UIControls{ff}{ss}{1} = uicontrol(PropertyTabs{ff}, ...
                        'Style', 'edit', ...
                        'String', num2str(CurrentSubfield),...
                        'Tooltip', CurrentFieldNote.Tip, ...
                        'Units', 'normalized', ...
                        'Position', UIControlInitPos ...
                        + [0, CurrentYPosition, 0, 0], ...
                        'Callback', @guiToProperties);
                    
                    % Create a button to allow for selection of the file.
                    UIControls{ff}{ss}{2} = uicontrol(PropertyTabs{ff}, ...
                        'Style', 'pushbutton', 'String', 'Select File', ...
                        'Tooltip', CurrentFieldNote.Tip, ...
                        'Units', 'normalized', ...
                        'Position',  UIControls{ff}{ss}{1}.Position ...
                        + [UIControls{ff}{ss}{1}.Position(3), 0, 0, 0], ...
                        'Callback', @selectCalDataFiles);
                case 'Data.RegistrationFilePath'
                    % Make an edit box for the file path.
                    UIControls{ff}{ss}{1} = uicontrol(PropertyTabs{ff}, ...
                        'Style', 'edit', ...
                        'String', num2str(CurrentSubfield),...
                        'Tooltip', CurrentFieldNote.Tip, ...
                        'Units', 'normalized', ...
                        'Position', UIControlInitPos ...
                        + [0, CurrentYPosition, 0, 0], ...
                        'Callback', @guiToProperties);
                    
                    % Create a button to allow for selection of the file.
                    UIControls{ff}{ss}{2} = uicontrol(PropertyTabs{ff}, ...
                        'Style', 'pushbutton', 'String', 'Select File', ...
                        'Tooltip', CurrentFieldNote.Tip, ...
                        'Units', 'normalized', ...
                        'Position',  UIControls{ff}{ss}{1}.Position ...
                        + [UIControls{ff}{ss}{1}.Position(3), 0, 0, 0], ...
                        'Callback', @selectRegDataFiles);
                case 'Fitting.FitType'
                    % Add a pop-up menu for the FitType options.
                    UIControls{ff}{ss}{1} = uicontrol(PropertyTabs{ff}, ...
                        'Style', 'popupmenu', ...
                        'String', ...
                        {'XYNB', 'XYNBS', 'XYNBSXSY', 'XYZNB'}, ...
                        'Tooltip', CurrentFieldNote.Tip, ...
                        'Units', 'normalized', ...
                        'Position', UIControlInitPos ...
                        + [0, CurrentYPosition, 0, 0], ...
                        'Callback', @guiToProperties);
                case 'Fitting.ZFitStruct'
                    % Add an edit box associated with the pop-up menu
                    % defined below.
                    SubSubfields = fieldnames(CurrentSubfield);
                    UIControls{ff}{ss}{2} = uicontrol(PropertyTabs{ff}, ...
                        'Style', 'edit', 'Units', 'normalized',...
                        'String', ...
                        num2str(CurrentSubfield.(SubSubfields{1})), ...
                        'Tooltip', CurrentFieldNote.Tip, ...
                        'Position', UIControlInitPos ...
                        + [UIControlInitPos(3), CurrentYPosition, 0, 0],...
                        'Callback', @guiToProperties);
                    
                    % Make the pop-up menu.
                    UIControls{ff}{ss}{1} = uicontrol(PropertyTabs{ff}, ...
                        'Style', 'popupmenu', ...
                        'String', fieldnames(CurrentSubfield), ...
                        'Tooltip', CurrentFieldNote.Tip, ...
                        'Units', 'normalized', ...
                        'Position', UIControlInitPos ...
                        + [0, CurrentYPosition, 0, 0], ...
                        'Callback', @propertiesToGUI);
                case 'Tracking.Method'
                    % Add a pop-up menu for the tracking method options.
                    UIControls{ff}{ss}{1} = uicontrol(PropertyTabs{ff}, ...
                        'Style', 'popupmenu', ...
                        'String', {CurrentSubfield}, ...
                        'Tooltip', CurrentFieldNote.Tip, ...
                        'Units', 'normalized', ...
                        'Position', UIControlInitPos ...
                        + [0, CurrentYPosition, 0, 0], ...
                        'Callback', @guiToProperties);
                case 'Tracking.ParamsHistory'
                    % We don't want any user input options for this field,
                    % so I'll add a disabled edit box.
                    UIControls{ff}{ss}{1} = uicontrol(PropertyTabs{ff}, ...
                        'Style', 'edit', 'Enable', 'off', ...
                        'String', sprintf('%ix%i struct', ...
                        size(CurrentSubfield)), ...
                        'Tooltip', CurrentFieldNote.Tip, ...
                        'Units', 'normalized', 'Position', UIControlInitPos ...
                        + [0, CurrentYPosition, 0, 0], ...
                        'Callback', @guiToProperties);
                case 'FrameConnection.Method'
                    % Add a pop-up menu for the frame-connection method
                    % options.
                    UIControls{ff}{ss}{1} = uicontrol(PropertyTabs{ff}, ...
                        'Style', 'popupmenu', ...
                        'String', {'Hypothesis test', 'LAP-FC', ...
                        'Classical', 'Revised classical'}, ...
                        'Tooltip', CurrentFieldNote.Tip, ...
                        'Units', 'normalized', ...
                        'Position', UIControlInitPos ...
                        + [0, CurrentYPosition, 0, 0], ...
                        'Callback', @guiToProperties);
                case 'DriftCorrection.Method'
                    % Add a pop-up menu for the drift-correction method
                    % options.
                    UIControls{ff}{ss}{1} = uicontrol(PropertyTabs{ff}, ...
                        'Style', 'popupmenu', ...
                        'String', {'DC-KNN', 'DC-BF'}, ...
                        'Tooltip', CurrentFieldNote.Tip, ...
                        'Units', 'normalized', ...
                        'Position', UIControlInitPos ...
                        + [0, CurrentYPosition, 0, 0], ...
                        'Callback', @guiToProperties);
            end
        end
        if isempty(UIControls{ff}{ss})
            % Instead of just adding a default else condition to the
            % previous if/elseif block, we should check if
            % UIControls{ff}{ss} was even defined above. This might be
            % nice because somebody may want to add something related to
            % one of the 'SpecialFields' while still keeping the default
            % check/edit uicontrols defined here.
            if islogical(CurrentSubfield)
                % If this field is a logical type, we'll make a checkbox
                % instead of an edit box.
                UIControls{ff}{ss}{1} = uicontrol(PropertyTabs{ff}, ...
                    'Style', 'checkbox', 'Value', CurrentSubfield, ...
                    'Tooltip', CurrentFieldNote.Tip, ...
                    'Units', 'normalized', 'Position', UIControlInitPos ...
                    + [UIControlInitPos(3)/2, CurrentYPosition, ...
                    -UIControlInitPos(3)/2, 0], ...
                    'Callback', @guiToProperties);
            else
                % Make the edit box (the default behavior for property
                % fields).
                if iscolumn(CurrentSubfield)
                    CurrentSubfield = CurrentSubfield.';
                end
                UIControls{ff}{ss}{1} = uicontrol(PropertyTabs{ff}, ...
                    'Style', 'edit', ...
                    'String', num2str(CurrentSubfield), ...
                    'Tooltip', CurrentFieldNote.Tip, ...
                    'Units', 'normalized', 'Position', UIControlInitPos ...
                    + [0, CurrentYPosition, 0, 0], ...
                    'Callback', @guiToProperties);
            end
        end
        
        % Define the location of an additional note (the note contained in
        % obj.SMFPropertyNames, to be used below).
        NotePosition = TextInitPos ...
            + [UIControls{ff}{ss}{end}.Position(1)...
            + UIControls{ff}{ss}{end}.Position(3), ...
            CurrentYPosition, TextInitPos(3), 0];
        
        % Add the additional message for this field present in
        % obj.SMFFieldNotes.
        uicontrol(PropertyTabs{ff}, 'Style', 'text', ...
            'String', CurrentFieldNote.Units, ...
            'Tooltip', CurrentFieldNote.Tip, ...
            'HorizontalAlignment', 'left', 'Units', 'normalized', ...
            'Position', NotePosition)
    end
end

% Add a button which will update the GUI (could be useful if the SMF gets
% changed outside of the open GUI).
ExtraButtonsInitPos = UIControlInitPos .* [0, 0, 1, 1];
uicontrol(GUIParent, 'Style', 'pushbutton', 'String', 'Refresh GUI', ...
    'Tooltip', ...
    sprintf(['This button updates the GUI to reflect changes\n', ...
    'made to SMF properties outside of the GUI.']), ...
    'Units', 'normalized', 'Position', ExtraButtonsInitPos, ...
    'Callback', @propertiesToGUI);

% Add a button which can import a previously saved SMF.
uicontrol(GUIParent, 'Style', 'pushbutton', 'String', 'Import SMF', ...
    'Tooltip', ...
    sprintf(['This button allows you to import an SMF structure\n', ...
    'saved in a .mat file']), ...
    'Units', 'normalized', ...
    'Position', ExtraButtonsInitPos ...
    + [ExtraButtonsInitPos(1)+ExtraButtonsInitPos(3), 0, 0, 0],...
    'Callback', @importSMF);

% Add a button which can export the SMF (save as a struct in a .mat file).
uicontrol(GUIParent, 'Style', 'pushbutton', 'String', 'Export SMF', ...
    'Tooltip', ...
    sprintf(['This button allows you to export the current settings\n', ...
    'displayed in this GUI as a SMF structure in a .mat file']), ...
    'Units', 'normalized', ...
    'Position', ExtraButtonsInitPos ...
    + [ExtraButtonsInitPos(1) + 2*ExtraButtonsInitPos(3), 0, 0, 0],...
    'Callback', @exportSMF);

% Add a button which can reset the SMF to the default values.
uicontrol(GUIParent, 'Style', 'pushbutton', 'String', 'Reset SMF', ...
    'Tooltip', ...
    sprintf(['This button allows you to reset the current settings\n', ...
    'to their default values defined in\n', ...
    'smi_core.SingleMoleculeFitting.m']), ...
    'Units', 'normalized', ...
    'Position', ExtraButtonsInitPos ...
    + [ExtraButtonsInitPos(1) + 3*ExtraButtonsInitPos(3), 0, 0, 0],...
    'Callback', @resetSMF);

% Call PropertiesToGUI here, just as a safeguard (this isn't going to do
% anything unless code has been revised above).
propertiesToGUI()

    function propertiesToGUI(~, ~)
        % This function will update the GUI with the current properties
        % present in the SingleMoleculeFitting object 'obj'.
        
        % Loop through the class properties and set the sub-fields values
        % whenever possible.
        PropertyNames = obj.SMFPropertyNames;
        for nn = 1:numel(PropertyNames)
            ClassProperty = obj.(PropertyNames{nn});
            PropertyFields = fieldnames(ClassProperty);
            for mm = 1:numel(PropertyFields)
                % Check if the current value of UIControls is itself a cell
                % array. If it is, it should have 2 elements (we assume
                % here that the first element is something like a pop-up
                % menu and the second element is the control whose string
                % we'll update). If the current field is in the
                % SpecialFields list defined at the top of this code, we'll
                % do something different on a case-by-case basis.
                CurrentField = ClassProperty.(PropertyFields{mm});
                CurrentFieldName = [PropertyNames{nn}, ...
                    '.', PropertyFields{mm}];
                if ismember(CurrentFieldName, SpecialFields)
                    switch CurrentFieldName
                        case 'Data.FileName'
                            % Data.FileName is just a cell array of
                            % strings, which is exactly what we set the
                            % uicontrol string to.
                            UIControls{nn}{mm}{1}.String = CurrentField;
                        case 'Data.DatasetList'
                            % It looks nicer to make the values separated
                            % by commas.
                            NewString = sprintf('%i,', CurrentField);
                            UIControls{nn}{mm}{1}.String = ...
                                NewString(1:end-1);
                        case 'Data.DatasetMods'
                            % Data.DatasetMods has a pop-up menu defining
                            % which index of itself should be displayed
                            % (e.g., display Data.DatasetMods{2}).
                            NewString = sprintf('%i,', ...
                                CurrentField{UIControls{nn}{mm}{1}.Value});
                            UIControls{nn}{mm}{2}.String = ...
                                NewString(1:end-1);
                        case {'Data.CameraGain', ...
                                'Data.CameraOffset', ...
                                'Data.CameraReadNoise'}
                            % These fields might be arrays, in which case
                            % we don't want to show its elements (instead,
                            % we'll just display the size).
                            if (numel(CurrentField) > 1)
                                SizeString = ...
                                    sprintf('%ix', size(CurrentField));
                                UIControls{nn}{mm}{1}.String = ...
                                    [SizeString(1:end-1), ' array'];
                            else
                                UIControls{nn}{mm}{1}.String = ...
                                    CurrentField;
                            end
                        case {'Data.CalibrationFilePath', ...
                                'Data.RegistrationFilePath'}
                            % Data.*FilePath should be displayed
                            % in the edit box (i.e., UIControls{nn}{mm}{1})
                            UIControls{nn}{mm}{1}.String = CurrentField;
                        case {'Data.CameraType', ...
                                'DriftCorrection.Method', ...
                                'Fitting.FitType', ...
                                'FrameConnection.Method', ...
                                'Tracking.Method'}
                            % All of these fields are defined by the item
                            % selected in a pop-up menu.
                            UIControls{nn}{mm}{1}.Value = find(...
                                strcmp(UIControls{nn}{mm}{1}.String, ...
                                CurrentField));
                        case 'Fitting.ZFitStruct'
                            % Fitting.ZFitStruct is defined by an edit box,
                            % but the property the edit box changes is
                            % specified by a pop-up menu.
                            UIControls{nn}{mm}{2}.String = ...
                                num2str(CurrentField ...
                                .(UIControls{nn}{mm}{1}.String{...
                                UIControls{nn}{mm}{1}.Value}));
                    end
                else
                    % Logical fields are defined by a checkbox, and we
                    % don't really care to update the 'string' of those
                    % uicontrols.
                    PropertyValue = CurrentField;
                    if islogical(PropertyValue)
                        UIControls{nn}{mm}{1}.Value = PropertyValue;
                    else
                        if iscolumn(PropertyValue)
                            PropertyValue = PropertyValue.';
                        end
                        UIControls{nn}{mm}{1}.String = ...
                            num2str(PropertyValue);
                    end
                end
            end
        end
    end

    function guiToProperties(~, ~)
        % This function will update the class instance obj to reflect
        % property changes made in the GUI. This function will call
        % propertiesToGUI after making all property changes (this is done
        % both to ensure the user set value was stored as expected and to
        % show updates to "dependent" properties).
        
        % Loop through the appropriate GUI elements and update the
        % corresponding class properties.
        PropertyNames = obj.SMFPropertyNames;
        for nn = 1:numel(PropertyNames)
            PropertyFields = fieldnames(obj.(PropertyNames{nn}));
            for mm = 1:numel(PropertyFields)
                % Check if the current property is contained in the
                % SpecialFields list defined above. If it is, we'll need to
                % take special care in setting the corresponding class
                % property.
                CurrentPropertyName = [PropertyNames{nn}, ...
                    '.', PropertyFields{mm}];
                NotUpdated = true;
                if ismember(CurrentPropertyName, SpecialFields)
                    NotUpdated = false;
                    switch CurrentPropertyName
                        case 'Data.FileName'
                            % Data.FileName is just a cell array of char
                            % arrays, with the char arrays being exactly
                            % what we've set in
                            % UIControls{nn}{mm}{1}.String.
                            obj.(PropertyNames{nn}) ...
                                .(PropertyFields{mm}) = ...
                                UIControls{nn}{mm}{1}.String;
                        case 'Data.DatasetMods'
                            % Data.DatasetMods is a cell array, and we want
                            % to update the element specified by a pop-up
                            % menu.
                            CellIndex = UIControls{nn}{mm}{1}.Value;
                            CurrentPropertyValue = ...
                                obj.(PropertyNames{nn}) ...
                                .(PropertyFields{mm}){CellIndex};
                            obj.(PropertyNames{nn}) ...
                                .(PropertyFields{mm}){CellIndex} = ...
                                processUserInput(...
                                UIControls{nn}{mm}{2}, ...
                                CurrentPropertyValue);
                        case {'Data.CalibrationFilePath', ...
                                'Data.RegistrationFilePath'}
                            % Data.*FilePath can be updated
                            % directly with the string stored in
                            % UIControls{nn}{mm}{1}.
                            obj.(PropertyNames{nn}) ...
                                .(PropertyFields{mm}) = ...
                                UIControls{nn}{mm}{1}.String;
                        case {'Data.CameraType', ...
                                'DriftCorrection.Method', ...
                                'Fitting.FitType', ...
                                'FrameConnection.Method', ...
                                'Tracking.Method'}
                            % All of these fields are defined by the item
                            % selected in a pop-up menu, with the string
                            % for those items being exactly the value we
                            % want to set for the class property.
                            obj.(PropertyNames{nn}) ...
                                .(PropertyFields{mm}) = ...
                                UIControls{nn}{mm}{1}.String{ ...
                                UIControls{nn}{mm}{1}.Value};
                        case 'Fitting.ZFitStruct'
                            % Fitting.ZFitStruct has several sub-fields
                            % which we will set according to the current
                            % state of UIControls{nn}{mm}{1}.
                            CurrentPropertyValue = ...
                                obj.(PropertyNames{nn}) ...
                                .(PropertyFields{mm}) ...
                                .(UIControls{nn}{mm}{1}.String{ ...
                                UIControls{nn}{mm}{1}.Value});
                            obj.(PropertyNames{nn})...
                                .(PropertyFields{mm}) ...
                                .(UIControls{nn}{mm}{1}.String{...
                                UIControls{nn}{mm}{1}.Value}) = ...
                                processUserInput(UIControls{nn}{mm}{2}, ...
                                CurrentPropertyValue);
                        case 'Tracking.ParamsHistory'
                            % We don't want to update ParamsHistory based
                            % on the GUI.
                        otherwise
                            NotUpdated = true;
                    end
                end
                if NotUpdated
                    % This is the default behavior for non-special fields/
                    % special fields that didn't get updated: the property
                    % is updated based on a single input in an edit box or
                    % based on the value of a checkbox (for logicals).
                    CurrentPropertyValue = ...
                        obj.(PropertyNames{nn}).(PropertyFields{mm});
                    obj.(PropertyNames{nn}).(PropertyFields{mm}) = ...
                        processUserInput(UIControls{nn}{mm}{1}, ...
                        CurrentPropertyValue);
                end
            end
        end
        
        % Update the GUI based on the class properties.
        propertiesToGUI();
    end

    function selectRawDataFiles(~, ~)
        % This is a callback function for the SMF.Data.FileName file
        % selection button of the GUI. This callback will call uiputfile()
        % to allow the user to select a set of files.
        
        % Create the file selection dialog.
        [FileName, FileDir] = uigetfile(...
            {'*.h5;*.mat', 'HDF5, MATLAB (*.h5, *.mat)'; ...
            '*.*', 'Other file types (*.*)'}, ...
            'Multiselect', 'on');
        if (isequal(FileName, 0) || isequal(FileDir, 0))
            return
        end
        
        % Update obj with these newly selected files.
        obj.Data.FileDir = FileDir;
        obj.Data.FileName = FileName;
        
        % Update the GUI.
        propertiesToGUI();
    end

    function selectCalDataFiles(~, ~)
        % This is a callback function for the SMF.Data.CalibrationFilePath
        % file selection button of the GUI. This callback will call
        % uiputfile() to allow the user to select the calibration file.
        
        % Create the file selection dialog.
        [FileName, FileDir] = uigetfile({'*.mat', 'MATLAB (*.mat)'; ...
            '*.*', 'Other file types (*.*)'}, ...
            'Multiselect', 'off');
        if (isequal(FileName, 0) || isequal(FileDir, 0))
            return
        end
        
        % Update obj with these newly selected files.
        obj.Data.CalibrationFilePath = fullfile(FileDir, FileName);
        
        % Update the GUI.
        propertiesToGUI();
    end

    function selectRegDataFiles(~, ~)
        % This is a callback function for the SMF.Data.selectRegDataFiles
        % file selection button of the GUI. This callback will call
        % uiputfile() to allow the user to select the registration file.
        
        % Create the file selection dialog.
        [FileName, FileDir] = uigetfile({'*.mat', 'MATLAB (*.mat)'; ...
            '*.*', 'Other file types (*.*)'}, ...
            'Multiselect', 'off');
        if (isequal(FileName, 0) || isequal(FileDir, 0))
            return
        end
        
        % Update obj with these newly selected files.
        obj.Data.RegistrationFilePath = fullfile(FileDir, FileName);
        
        % Update the GUI.
        propertiesToGUI();
    end

    function importSMF(~, ~)
        % This function will ask the user to select the desired SMF (saved
        % in a .mat file) and then call obj.importSMF() to load the
        % properties stored in that SMF.
        
        % Ask the user to select the saved SMF and load it.
        [FileName, FilePath] = uigetfile('Y:\*.mat');
        if (isequal(FileName, 0) || isequal(FilePath, 0))
            return
        end
        load(fullfile(FilePath, FileName), 'SMF')
        
        % Ensure all GUI inputs are saved to obj (the saved SMF might not
        % have all properties set, so it could make sense that the user
        % still wanted some of the manually entered GUI fields to be kept.
        guiToProperties();
        
        % Update obj with the fields present in the loaded SMF.
        obj.importSMF(SMF)
        
        % Update the GUI to reflect potential changes.
        propertiesToGUI();
    end

    function exportSMF(~, ~)
        % This function will ask the user to define the desired save
        % filename and path before calling obj.packageSMF() to create a
        % struct containing the class properties. The struct will be saved
        % as a .mat at the desired file location.
        
        % Ask the user to specify a save location.
        [FileName, FilePath] = uiputfile('Y:\SMF.mat');
        if (isequal(FileName, 0) || isequal(FilePath, 0))
            return
        end
        
        % Ensure all GUI inputs are saved to obj.
        guiToProperties();
        
        % Package the class into a struct.
        [SMF] = obj.packageSMF();
        
        % Save the SMF in the desired location.
        save(fullfile(FilePath, FileName), 'SMF', '-v7.3')
    end

    function resetSMF(~, ~)
        % This function will reset the current class instance obj to all
        % default values. This is done after first asking the user if they
        % are sure they want to proceed (accidentally clicking this would
        % be very annoying!).
        
        % Ask the user if they are sure they want to reset the SMF.
        Response = questdlg(['Are you sure you want to reset the SMF ', ...
            'properties to their defaults?'], 'Warning', ...
            'yes', 'no', 'no');
        if (strcmp(Response, 'no') || isempty(Response))
            return
        end
        
        % Proceed to reset the SMF properties.
        obj.resetSMF();
        
        % Update the GUI to reflect the changes.
        propertiesToGUI();
    end

    function [ProcessedInput] = processUserInput(UIControl, ...
            CurrentPropertyValue)
        % This function will process a user input to various uicontrols and
        % processes that input as appropriate (this is meant to be a giant
        % block of if/else statements depending on several things,
        % including property type and uicontrol type).
        
        % Process the input based on the existing property value.
        if isnumeric(CurrentPropertyValue)
            % Numeric properties are expected to always be modified through
            % an edit box uicontrol.
            % NOTE: If properties should be a specific type, that should be
            %       taken care of in a set method inside
            %       SingleMoleculeFitting.m
            % NOTE: I'm using str2num() here instead of, e.g., str2double()
            %       because str2num('') = [], but str2double('') = NaN (in
            %       MATLAB 2020b at least).
            ProcessedInput = str2num(UIControl.String);
        elseif islogical(CurrentPropertyValue)
            % Logical fields are set by checkbox uicontrols, meaning that
            % we care about the 'value' of the uicontrol (not its
            % 'string').
            % NOTE: str2num() works nicely on logicals, e.g.,
            %       str2num('true') will be a logical (not numeric).
            ProcessedInput = logical(UIControl.Value);
        else
            % Note that some of the fields might be cell arrays, e.g., file
            % names.  If the user has input a string to the corresponding
            % edit box then we'll just assume they want to overwrite the
            % existing cell array.
            ProcessedInput = UIControl.String;
        end
    end


end

./MATLAB/+smi_core/@SingleMoleculeFitting/padSMF.m
function [SMFPadded, PaddedFields] = padSMF(SMF, SMFPadding, ...
    DisplayMessages)
%padSMF adds fields in SMFPadding to SMF that weren't already present.
% This method will search for fields present in the union of the SMF
% fields and SMFPadding fields and set them in the output SMFPadded.  When
% fields are in both SMF and SMFPadding, the output SMFPadded will contain
% the value present in SMFPadding.
%
% EXAMPLE USAGE:
%   SMF.Data.CameraGain = 1.23;
%   SMFPadding.Data.CameraGain = 10;
%   SMFPadding.Fitting.FitType = 'XYNBS';
%   [SMFPadded] = smi_core.SingleMoleculeFitting.padSMF(SMF, SMFPadding);
%       SMFPadded.Data.CameraGain==1.23, but SMFPadded.Fitting.FitType will
%       be set to 'XYNBS'.
%   [SMFPadded] = smi_core.SingleMoleculeFitting.padSMF(SMF);
%       SMFPadded will be a complete SMF structure with all default values
%       present except Data.CameraGain, which will be set to
%       SMF.Data.CameraGain (this can be used to ensure an incomplete SMF
%       is padded to contain all fields defined in the
%       SingleMoleculeFitting class).
%
% INPUTS:
%   SMF: Single Molecule Fitting structure whose existing entries are
%        retained in the output SMFPadded.
%   SMFPadding: An SMF structure with additional fields not present in SMF
%               (e.g., SMF might be an incomplete SMF structure and
%               SMFPadding might be an SMF with all default values).
%               (Default = smi_core.SingleMoleculeFitting)
%   DisplayMessages: A flag to specify whether or not a message should be
%                    displayed in the Command Window when a field gets
%                    padded. (Default = 0)
%
% OUTPUTS:
%   SMFPadded: An SMF structure containing all fields present in the union
%              of SMF and SMFPadding, with values of the intersecting
%              fields always being taken from the input SMF.  Additionally,
%              this output is guaranteed to have all fields defined in
%              smi_core.SingleMoleculeFitting, even if they weren't in
%              either of SMF or SMFPadding.
%   PaddedFields: A structure with similar organization to an SMF structure
%                 whose fields are the fields in SMFPadded that were not
%                 present in the input SMF (i.e., these are all of the
%                 fields that were added to SMF to generate SMFPadded).

% Created by:
%   David J. Schodt (Lidke Lab, 2020)


% Set defaults if needed.
if (~exist('SMFPadding', 'var') || isempty(SMFPadding))
    SMFPadding = smi_core.SingleMoleculeFitting;
end
if (~exist('DisplayMessages', 'var') || isempty(DisplayMessages))
    DisplayMessages = 0;
end
if ((nargin>1) && ~isempty(inputname(2)))
    SecondInputName = inputname(2);
else
    SecondInputName = 'default SMF';
end

% Create a default SMF structure to initialize the output.
SMFDefault = smi_core.SingleMoleculeFitting;

% Merge the input SMF and SMFPadding structs, treating the SMF as the
% "primary" struct (i.e., the merged field values are only taken from
% SMFPadding when they aren't present in SMF).
[SMFInputMerged, PaddingStruct] = mergeStructs(SMF, SMFPadding, ...
    inputname(1), SecondInputName, DisplayMessages);

% Merge the complete (but default valued) SMFDefault with the merged input
% structures to generate the desired output SMFPadded.
[SMFPadded, PaddingStructDefaults] = ...
    mergeStructs(SMFInputMerged, SMFDefault, ...
    inputname(1), 'default SMF', DisplayMessages);

% Merge the padding structures to generate the output PaddedFields.
[PaddedFields] = mergeStructs(PaddingStruct, PaddingStructDefaults);

    function [MergedStruct, PaddingStruct] = mergeStructs(...
            PrimaryStruct, SecondaryStruct, ...
            PrimaryStructName, SecondaryStructName, DisplayMessages)
        % This function will merge PrimaryStruct and SecondaryStruct, with
        % field values coming from SecondaryStruct only if not present in
        % PrimaryStruct.  The additional output PaddingStruct will be a
        % structure of similar organization to
        % PrimaryStruct/SecondaryStruct whose fields are those which were
        % padded to PrimaryStruct to generate MergedStruct. If the optional
        % flag DisplayMessages==1, a warning will be displayed in the
        % Command Window each time a field is padded.
        
        % Set default inputs if needed.
        if (~exist('DisplayMessages', 'var') || isempty(DisplayMessages))
            DisplayMessages = 0;
        end
        if (~exist('PrimaryStructName', 'var') ...
                || isempty(PrimaryStructName))
            PrimaryStructName = 'PrimaryStruct';
        end
        if (~exist('SecondaryStructName', 'var') ...
                || isempty(SecondaryStructName))
            SecondaryStructName = 'SecondaryStruct';
        end
        
        % Create a list of fields in the input structs.
        FieldsPrimary = fieldnames(PrimaryStruct);
        FieldsSecondary = fieldnames(SecondaryStruct);
        
        % Loop through the fields in SecondaryStruct and add them to
        % PrimaryStruct if needed.
        PaddingStruct = struct();
        MergedStruct = PrimaryStruct;
        for ii = 1:numel(FieldsSecondary)
            CurrentSubField = FieldsSecondary{ii};
            AddToOutput = 0;
            if isstruct(SecondaryStruct.(CurrentSubField))
                if ismember(CurrentSubField, FieldsPrimary)
                    % This sub-structure is present in PrimaryStruct, but
                    % we still want to ensure that it's complete, so we'll
                    % call the mergeStructs() function recursively.
                    PrimarySubStructName = sprintf('%s.%s', ...
                        PrimaryStructName, CurrentSubField);
                    SecondarySubStructName = sprintf('%s.%s', ...
                        SecondaryStructName, CurrentSubField);
                    [MergedStruct.(CurrentSubField), SubPadStruct] = ...
                        mergeStructs(PrimaryStruct.(CurrentSubField), ...
                        SecondaryStruct.(CurrentSubField), ...
                        PrimarySubStructName, SecondarySubStructName, ...
                        DisplayMessages);
                    if ~isempty(fieldnames(SubPadStruct))
                        % NOTE: When we're only padding part of the
                        %       sub-structure, we don't want to set the
                        %       AddToOutput flag to 1.
                        PaddingStruct.(CurrentSubField) = SubPadStruct;
                    end
                else
                    % In this case, the entire sub-structure didn't exist
                    % in PrimaryStruct, so we'll add it in its entirety.
                    AddToOutput = 1;
                end
            elseif ~ismember(CurrentSubField, FieldsPrimary)
                % This field is unique to SecondaryStruct so we need to add
                % it to the output structure.
                AddToOutput = 1;
            end
            
            % Update the output structure (note that partial sub-structures
            % were already padded in the if/else block(s) above).
            if AddToOutput
                MergedStruct.(CurrentSubField) = ...
                    SecondaryStruct.(CurrentSubField);
                PaddingStruct.(CurrentSubField) = ...
                    SecondaryStruct.(CurrentSubField);
                if DisplayMessages
                    fprintf('Field ''%s'' in %s padded from %s\n', ...
                        CurrentSubField, ...
                        PrimaryStructName, ...
                        SecondaryStructName)
                end
            end
        end
    end


end
./MATLAB/+smi_core/@SingleMoleculeFitting/SingleMoleculeFitting.m
classdef SingleMoleculeFitting < matlab.mixin.Copyable
    % SingleMoleculeFitting A class defining the Single Molecule Fitting structure
    %
    % The SMF structure is a structure of structures that collectively contain
    % all parameters required to go from raw data to an SMD results structure.
    % The SMF structure is an input of many smi methods. It
    % intended to be extensible to enable new analysis tools and methods.
    % The SMF class implements tools for working with SMF structures,
    % but the data structure itself is not an object of the class.
    %
    % Parameters of sub-structures are explained in more detail in
    % the classes and methods that use them.  An incomplete list of classes
    % that use each sub-structure is listed in {}.
    %
    % The SMF structure has the following sub-structures and fields:
    %
    % SMF:  Fields that are structures:
    %
    % Data:             {LoadData}
    %   FileName:       File name (cell array of char array)
    %   FileDir:        File directory (char array)
    %   ResultsDir:     Results directory (char array)(Default='FileDir/Results')
    %   AnalysisID:     ID tagged onto saved results (char array)(Default='')
    %   FileType:       Type of data specified by FileName. If using a custom
    %                   extension, you must set this field manually to the true
    %                   underlying file type (e.g., if using a .mat file saved
    %                   as exFile.spt, set obj.Data.FileType = 'mat')
    %                   (char array)(Default set to extension of FileName{1})
    %   DataVariable:   Name of variable saved in FileName which contains the
    %                   raw data. (char array)(Default='sequence')
    %   DatasetList:    List of datasets of the raw data to be analyzed.
    %                   (array of int32)(Default=int32([]))
    %   DatasetMods: Cell array containing datasets to be used/excluded from
    %                analysis (Mods <-> modifiers). This is meant to be the
    %                user-facing lists which define DatasetList, meaning that
    %                this is what would be set in the GUI. DatasetMods{1} will
    %                contain an array of the "inclusion" dataset numbers and
    %                DatasetMods{2} will contain an array of the "exclusion"
    %                datasets. DatasetList will be set elsewhere (e.g.,
    %                smi_core.LoadData) to include the set
    %                   intersect(intersect(1:NDatasets, DatasetMods{1}), ...
    %                   setdiff(1:NDatasets, DatasetMods{2}))
    %                unless DatasetMods{1} is empty, in which case the first
    %                parantheses term is dropped. For example, if
    %                NDatasets = 20, and you only want to analyze datasets 1:5,
    %                you can set DatasetMods{1} = 1:5. If you further decide to
    %                exclude datsaets 2 and 4, you could set
    %                DatasetMods{2} = [2, 4].
    %                (cell array of int32 arrays)(Default={[]; []})
    %   CameraType:     'EMCCD','SCMOS' (Default='EMCCD')
    %                   NOTE: The next 3 quantities (CameraGain, CameraOffset,
    %                   CameraReadNoise) should be scalars if the CameraType is
    %                   'EMCCD' while if 'SCMOS', square arrays taken from the
    %                   CalibrationFile located at the CalibrationFilePath.
    %   CameraGain:     Camera Gain, scalar or image (Default=1)
    %   CameraOffset:   Camera Offset, scalar or image (Default=0)
    %   CameraNoise:    Camera readnoise, scalar or image (Default=0)
    %   CalibrationFilePath: Path to the camera calibration file (Default='')
    %   RegistrationFilePath: Path to channel registration file (Default='')
    %   DataROI:        Region of interest of data file to be used (Default=[])
    %   FrameRate:      Data Collection Frame Rate (1/s)
    %   PixelSize:      Camera back-projected pixel size (micrometers)
    %   SEAdjust:       Standard error inflation per localization (Pixels)(Default=0)
    %
    % BoxFinding:       {FindROI}
    %   BoxSize:        Linear box size for fitting (Pixels)(Default=7)
    %   BoxOverlap:     Overlap of boxes allowed (Pixels)(Default=2)
    %   MinPhotons:     Minimum number of photons from emitter (Default=200)
    %
    % Fitting           {GaussMLE}
    %   PSFSigma:   Initial or fixed Sigma of 2D Gaussian PSF Model (Pixels)(Default=1)
    %   FitType:    See fit class for options  (Default='XYNB')
    %   NParams:    Number of fitting parameters (auto-set based on FitType)
    %   Iterations: Newton Raphson iterations (Default=20)
    %   ZFitStruct: Structure for astigmatic fitting:
    %       Ax:         Astigmatism fit parameter (see GaussMLE)
    %       Ay:         Astigmatism fit parameter (see GaussMLE)
    %       Bx:         Astigmatism fit parameter (see GaussMLE)
    %       By:         Astigmatism fit parameter (see GaussMLE)
    %       Gamma:      Astigmatism fit parameter (see GaussMLE)
    %       D:          Astigmatism fit parameter (see GaussMLE)
    %
    % Thresholding      {ThresholdFits,SRA}
    %   On              Perform thresholding? (Default=true)
    %   MaxXY_SE:       Maximum allowed precision in x,y (Pixels)(Default=.2)
    %   MaxZ_SE:        Maximum allowed precision in z (Microns)(Default=.5)
    %   MinPValue:      Minimum accepted p-value from fit (Default=.01)
    %   AutoThreshLogL: Automatically threshold on LogL and ignore MinPValue (Default = false)
    %   AutoThreshPrctile: Extrema percentile thrown out when computing LogL auto-threshold (Default = 1e-4)
    %   MinPSFSigma:    Minimum PSF Sigma from fit (Pixels)(Default=.5);
    %   MaxPSFSigma:    Maximum PSF Sigma from fit (Pixels)(Default=2);
    %   MinPhotons:     Minimum accepted photons from fit (Default=100)
    %   MaxBg:          Maximum background accepted from fit (Default=Inf)
    %   InMeanMultiplier:   Determines maximum intensity accepted (Default=Inf)
    %   NNMedianMultiplier: Nearest neighbor acceptance region (Default=3)
    %   MinNumNeighbors:    Minimum number of neighbors in above (Default=0)
    %
    % FrameConnection:  {FrameConnect,SRA}
    %   On              Perform frame connection? (Default=true)
    %   Method:         Frame connection method being used (Default='LAP-FC')
    %   MaxSeparation:  Maximum separation for connection (Pixels)(Default=1)
    %   LoS:            Minimum accepted p-value for connection (Default=.01)
    %   MaxFrameGap:    Maximum frame gap for connection (Frames)(Default=5)
    %   NSigmaDev:      SE multiplier for pre-cluster distance threshold (Default=5)
    %   NNearestClusters: Number of clusters used in density estimates (Default=2)
    %   NIterations:    Number of iterative FC attempts when Method=lap-fc (Default=1)
    %   MinNFrameConns  Minimum accepted number of frame connections (Default=1)
    %
    % DriftCorrection   {DriftCorrection,SRA}
    %  On               Perform drift correction? (Default=true)
    %  Method:          Drift correction method being used (Default='DC-KNN')
    %  BFRegistration   Was brightfield registration performed? (Default=true)
    %  L_intra          Intra-dataset threshold (Pixel)(Default=1)
    %  L_inter          Inter-dataset threshold (Pixel)(Default=2)
    %  PixelSizeZUnit   X/Y pixel size (3D drift correction) (um)(Default=0.1)
    %  PDegree          Degree intra-dataset fitting poly for drift rate (Default=1)
    %
    % Tracking          {SPT}
    %   Method:         Type of method used for tracking (Default='CostMatrix')
    %   D:              Diffusion Constant (Pixels^2/Frame) (Default=0.01)
    %   TrajwiseD:      Use traj.-wise value for D (logical)(Default=true)
    %   K_on:           Off to On Rate (Frame^-1) (Default=.9)
    %   K_off:          On to Off Rate (Frame^-1) (Default=.1)
    %   MaxDistFF:      Maximum distance gap for frame-to-frame connection (Pixels)(Default=5)
    %   MaxDistGC:      Maximum distance gap for Gap Closing (Pixels) (Default=10)
    %   MaxFrameGap:    Maximum frame gap for Gap Closing (Pixels) (Default=10)
    %   MinTrackLength: Minimum track length of trajectory (Frames) (Default=3)
    %   NIterMax: Max. number of iterative tracking attempts (Integer)(Default = 5)
    %   NIterMaxBatch: Max. number of batch tracking iterations (Integer)(Default = 5)
    %   MaxRelativeChange: Max. relative param. change to end iterations (Default = 1e-5)
    %   MaxZScoreDist:  Max. abs(z-score) x/y jump size (Default=inf)
    %   MaxZScorePhotons: Max. abs(z-score) for photon diffs. (Default=inf)
    %   TryLowPValueLocs: Try to incorporate low p-val. locs. (Default=false)
    
    % created by:
    % Keith Lidke, Hanieh Mazloom-Farsibaf, David Schodt. Lidke Lab 2018
    
    properties
        Data struct {mustBeNonempty} = struct();
        BoxFinding struct {mustBeNonempty} = struct();
        Fitting struct {mustBeNonempty} = struct();
        Thresholding struct {mustBeNonempty} = struct();
        FrameConnection struct {mustBeNonempty} = struct();
        DriftCorrection struct {mustBeNonempty} = struct();
        Tracking struct {mustBeNonempty} = struct();
    end
    
    properties (Access = protected)
        % Current version of the SingleMoleculeFitting class/structs.
        % NOTE: Should stay 1.0 until we decide as a group to change it!
        SMFVersion = 1.0;
        
        % This is a cell array of class property names to be present in GUI
        SMFPropertyNames = {'Data', 'BoxFinding', 'Fitting', ...
            'Thresholding', 'FrameConnection', 'DriftCorrection', ...
            'Tracking'};
        
        % This is a structure similar to SMF but field entries define units
        % This is basically an SMF structure but the sub-fields are all
        % char arrays defining the units/datatype/other notes. For example,
        % SMFFieldNotes.Data.CameraGain.Units = 'ADU'. This can also be
        % used to specify a datatype where the unit isn't relevant, e.g.,
        % SMFFieldNotes.Data.FileName.Units = 'cell array'.
        SMFFieldNotes struct = struct();
    end
    
    methods
        
        function obj = SingleMoleculeFitting()
            % Class constructor used to set default property values.
            
            %Data
            obj.Data.FileName={''};
            obj.Data.FileDir='';
            obj.Data.ResultsDir='';
            obj.Data.AnalysisID='';
            obj.Data.FileType='';
            obj.Data.DataVariable='sequence';
            obj.Data.DatasetList=[];
            obj.Data.DatasetMods={[]; []};
            obj.Data.CameraType='EMCCD';
            obj.Data.CameraGain=1;
            obj.Data.CameraOffset=0;
            obj.Data.CameraReadNoise=0;
            obj.Data.CalibrationFilePath='';
            obj.Data.RegistrationFilePath='';
            obj.Data.DataROI=[];
            obj.Data.FrameRate=1;
            obj.Data.PixelSize=0.1;
            obj.Data.SEAdjust=0;
            
            %BoxFinding
            obj.BoxFinding.BoxSize=7;
            obj.BoxFinding.BoxOverlap=2;
            obj.BoxFinding.MinPhotons=200;
            
            %Fitting
            obj.Fitting.PSFSigma=1;
            obj.Fitting.FitType='XYNB';
            obj.Fitting.NParams=4;
            obj.Fitting.Iterations=20;
            obj.Fitting.ZFitStruct.Ax=[];
            obj.Fitting.ZFitStruct.Ay=[];
            obj.Fitting.ZFitStruct.Bx=[];
            obj.Fitting.ZFitStruct.By=[];
            obj.Fitting.ZFitStruct.Gamma=[];
            obj.Fitting.ZFitStruct.D=[];
            
            %Thresholding
            obj.Thresholding.On=true;
            obj.Thresholding.MaxXY_SE=.2;
            obj.Thresholding.MaxZ_SE=.05;
            obj.Thresholding.MinPValue=.01;
            obj.Thresholding.AutoThreshLogL=false;
            obj.Thresholding.AutoThreshPrctile=1e-4;
            obj.Thresholding.MinPSFSigma=0.5;
            obj.Thresholding.MaxPSFSigma=2;
            obj.Thresholding.MinPhotons=100;
            obj.Thresholding.MaxBg=Inf;
            obj.Thresholding.InMeanMultiplier=Inf;
            obj.Thresholding.NNMedianMultiplier=3;
            obj.Thresholding.MinNumNeighbors=0;
            
            %FrameConnection
            obj.FrameConnection.On=true;
            obj.FrameConnection.Method='LAP-FC';
            obj.FrameConnection.MaxSeparation=1; % pixels
            obj.FrameConnection.LoS=.01;
            obj.FrameConnection.MaxFrameGap=5; % frames
            obj.FrameConnection.NSigmaDev=5;
            obj.FrameConnection.NNearestClusters=2;
            obj.FrameConnection.NIterations=1;
            obj.FrameConnection.MinNFrameConns=1;
            
            %DriftCorrection
            obj.DriftCorrection.On = true;
            obj.DriftCorrection.Method = 'DC-KNN';
            obj.DriftCorrection.BFRegistration = true;
            obj.DriftCorrection.L_intra = 1; % pixel
            obj.DriftCorrection.L_inter = 2; % pixel
            obj.DriftCorrection.PixelSizeZUnit = 0.1; % um
            obj.DriftCorrection.PDegree = 1;
            
            %Tracking
            obj.Tracking.Method='CostMatrix';
            obj.Tracking.D=0.01;
            obj.Tracking.TrajwiseD=true;
            obj.Tracking.K_on=.9;
            obj.Tracking.K_off=.1;
            obj.Tracking.MaxDistFF=5;
            obj.Tracking.MaxDistGC=10;
            obj.Tracking.MaxFrameGap=10;
            obj.Tracking.MinTrackLength=3;
            obj.Tracking.MaxZScoreDist=inf;
            obj.Tracking.MaxZScorePhotons=inf;
            obj.Tracking.NIterMax=5;
            obj.Tracking.NIterMaxBatch=5;
            obj.Tracking.ParamsHistory={};
            obj.Tracking.MaxRelativeChange=1e-5;
            obj.Tracking.TryLowPValueLocs=false;
            
            % Store a note about the unit/type of various sub-fields.
            % NOTE: Sub-structs (e.g., SMF.Fitting.ZFitStruct, should only
            %       have one note pertaining to the overall structure!).
            obj.SMFFieldNotes.Data.FileName.Units = 'cell array';
            obj.SMFFieldNotes.Data.FileDir.Units = 'char array';
            obj.SMFFieldNotes.Data.ResultsDir.Units = 'char array';
            obj.SMFFieldNotes.Data.AnalysisID.Units = 'char array';
            obj.SMFFieldNotes.Data.FileType.Units = 'char array';
            obj.SMFFieldNotes.Data.DataVariable.Units = 'char array';
            obj.SMFFieldNotes.Data.DatasetList.Units = 'integer array';
            obj.SMFFieldNotes.Data.DatasetMods.Units = 'integer array';
            obj.SMFFieldNotes.Data.CameraType.Units = 'EMCCD, SCMOS';
            obj.SMFFieldNotes.Data.CameraGain.Units = 'ADU / e-';
            obj.SMFFieldNotes.Data.CameraOffset.Units = 'ADU';
            obj.SMFFieldNotes.Data.CameraReadNoise.Units = 'ADU^2';
            obj.SMFFieldNotes.Data.CalibrationFilePath.Units = ...
                'char array';
            obj.SMFFieldNotes.Data.RegistrationFilePath.Units = ...
                'char array';
            obj.SMFFieldNotes.Data.DataROI.Units = ...
                'pixels, [YStart, XStart, YEnd, XEnd, ZStart, ZPeriod]';
            obj.SMFFieldNotes.Data.FrameRate.Units = ...
                'frames / second';
            obj.SMFFieldNotes.Data.PixelSize.Units = 'micrometers';
            obj.SMFFieldNotes.Data.SEAdjust.Units = 'pixels';
            obj.SMFFieldNotes.BoxFinding.BoxSize.Units = 'pixels';
            obj.SMFFieldNotes.BoxFinding.BoxOverlap.Units = 'pixels';
            obj.SMFFieldNotes.BoxFinding.MinPhotons.Units = 'photons';
            obj.SMFFieldNotes.Fitting.PSFSigma.Units = 'pixels';
            obj.SMFFieldNotes.Fitting.FitType.Units = ...
                'XYNB, XYNBS, XYNBSXSY, XYZNB';
            obj.SMFFieldNotes.Fitting.NParams.Units = '(not set by user)';
            obj.SMFFieldNotes.Fitting.Iterations.Units = '';
            obj.SMFFieldNotes.Fitting.ZFitStruct.Units = 'see GaussMLE';
            obj.SMFFieldNotes.Thresholding.On.Units = 'logical';
            obj.SMFFieldNotes.Thresholding.MaxXY_SE.Units = 'pixels';
            obj.SMFFieldNotes.Thresholding.MaxZ_SE.Units = 'pixels';
            obj.SMFFieldNotes.Thresholding.MinPValue.Units = ...
                'number between 0 and 1';
            obj.SMFFieldNotes.Thresholding.AutoThreshLogL.Units = 'logical';
            obj.SMFFieldNotes.Thresholding.AutoThreshPrctile.Units = ...
                'number between 0 and 100';
            obj.SMFFieldNotes.Thresholding.MinPSFSigma.Units = 'pixels';
            obj.SMFFieldNotes.Thresholding.MaxPSFSigma.Units = 'pixels';
            obj.SMFFieldNotes.Thresholding.MinPhotons.Units = 'photons';
            obj.SMFFieldNotes.Thresholding.MaxBg.Units = 'photons';
            obj.SMFFieldNotes.Thresholding.InMeanMultiplier.Units = ...
                'positive number';
            obj.SMFFieldNotes.Thresholding.NNMedianMultiplier.Units = ...
                'positive number';
            obj.SMFFieldNotes.Thresholding.MinNumNeighbors.Units = ...
                'non-negative integer';
            obj.SMFFieldNotes.FrameConnection.On.Units = 'logical';
            obj.SMFFieldNotes.FrameConnection.Method.Units = '';
            obj.SMFFieldNotes.FrameConnection.MaxSeparation.Units = ...
                'pixels';
            obj.SMFFieldNotes.FrameConnection.LoS.Units = ...
                'number between 0 and 1';
            obj.SMFFieldNotes.FrameConnection.MaxFrameGap.Units = 'frames';
            obj.SMFFieldNotes.FrameConnection.NSigmaDev.Units = ...
                'non-negative number';
            obj.SMFFieldNotes.FrameConnection.NNearestClusters.Units = ...
                'positive integer';
            obj.SMFFieldNotes.FrameConnection.NIterations.Units = ...
                'positive integer';
            obj.SMFFieldNotes.FrameConnection.MinNFrameConns.Units = ...
                'positive integer';
            obj.SMFFieldNotes.DriftCorrection.On.Units = 'logical';
            obj.SMFFieldNotes.DriftCorrection.Method.Units = '';
            obj.SMFFieldNotes.DriftCorrection.BFRegistration.Units = ...
                'logical';
            obj.SMFFieldNotes.DriftCorrection.L_intra.Units = 'pixels';
            obj.SMFFieldNotes.DriftCorrection.L_inter.Units = 'pixels';
            obj.SMFFieldNotes.DriftCorrection.PixelSizeZUnit.Units = ...
                'micrometers';
            obj.SMFFieldNotes.DriftCorrection.PDegree.Units = '';
            obj.SMFFieldNotes.Tracking.Method.Units = ...
                'must be CostMatrix for now';
            obj.SMFFieldNotes.Tracking.D.Units = 'pixel^2 / frame';
            obj.SMFFieldNotes.Tracking.TrajwiseD.Units = 'logical';
            obj.SMFFieldNotes.Tracking.K_on.Units = '1 / frame';
            obj.SMFFieldNotes.Tracking.K_off.Units = '1 / frame';
            obj.SMFFieldNotes.Tracking.MaxDistFF.Units = 'pixels';
            obj.SMFFieldNotes.Tracking.MaxDistGC.Units = 'pixels';
            obj.SMFFieldNotes.Tracking.MaxZScoreDist.Units = '';
            obj.SMFFieldNotes.Tracking.MaxZScorePhotons.Units = '';
            obj.SMFFieldNotes.Tracking.MaxFrameGap.Units = 'frames';
            obj.SMFFieldNotes.Tracking.MinTrackLength.Units = ...
                'observations';
            obj.SMFFieldNotes.Tracking.NIterMax.Units = '';
            obj.SMFFieldNotes.Tracking.NIterMaxBatch.Units = '';
            obj.SMFFieldNotes.Tracking.ParamsHistory.Units = '';
            obj.SMFFieldNotes.Tracking.MaxRelativeChange.Units = '';
            obj.SMFFieldNotes.Tracking.TryLowPValueLocs.Units = 'logical';
            
            % Store a 'tip' for certain sub-fields (intended to be
            % displayed in the GUI as a tooltip when hovering over
            % associated GUI elements).
            % NOTE: Sub-structs (e.g., SMF.Fitting.ZFitStruct, should only
            %       have one tip pertaining to the overall structure!).
            % NOTE: If you want multi-line tooltips displayed in the GUI,
            %       use sprintf() here with the \n control.
            obj.SMFFieldNotes.Data.FileName.Tip = ...
                sprintf(['Name of the raw data file(s) you wish to\n', ...
                'analyze. Note that selecting a specific file in\n', ...
                'the popup-menu has no effect.']);
            obj.SMFFieldNotes.Data.FileDir.Tip = ...
                'Name of the directory containing the raw data file(s)';
            obj.SMFFieldNotes.Data.ResultsDir.Tip = ...
                'Name of the directory in which results will be saved';
            obj.SMFFieldNotes.Data.AnalysisID.Tip = ...
                sprintf(['Optional identifier to be tagged onto\n', ...
                'the filenames of saved results.']);
            obj.SMFFieldNotes.Data.FileType.Tip = ...
                sprintf(['Underlying type of the raw data file,\n' ...
                'e.g., ''mat'', ''h5'', ...']);
            obj.SMFFieldNotes.Data.DataVariable.Tip = ...
                'Name of variable in raw data file(s) containing the data';
            obj.SMFFieldNotes.Data.DatasetList.Tip = ...
                'Array specifying the dataset number(s) to be analyzed';
            obj.SMFFieldNotes.Data.DatasetMods.Tip = ...
                sprintf(['DatasetMods{1} (Include Datasets) is a set\n',...
                'of integers specifying which datasets should be\n', ...
                'included in the analysis. This can be set to empty\n', ...
                'to include all datasets.\n', ...
                'DatasetMods{2} (Exclude Datasets) is a set\n', ...
                'of integers specifying which datasets should be\n', ...
                'strictly excluded from the analysis. This set takes\n',...
                'precedence over the inclusion set']);
            obj.SMFFieldNotes.Data.CameraType.Tip = ...
                sprintf(['Type of camera used to collect the raw data.\n', ...
                'CameraGain, CameraOffset, CameraReadNoise) should be\n', ...
                'scalars if the CameraType is EMCCD while if SCMOS,\n', ...
                'square arrays taken from the file located at the ', ...
                'CalibrationFilePath.']);
            obj.SMFFieldNotes.Data.CameraGain.Tip = ...
                'Gain of the camera used to collect the raw data';
            obj.SMFFieldNotes.Data.CameraOffset.Tip = ...
                'Offset of the camera used to collect the raw data';
            obj.SMFFieldNotes.Data.CameraReadNoise.Tip = ...
                sprintf(['Variance of the read-noise of the camera\n', ...
                'used to collect the raw data']);
            obj.SMFFieldNotes.Data.CalibrationFilePath.Tip = ...
                'Path to the camera calibration file to be used.';
            obj.SMFFieldNotes.Data.RegistrationFilePath.Tip = ...
                sprintf(['Path to a channel registration file ', ...
                'containing a\n transform that will be applied to the data']);
            obj.SMFFieldNotes.Data.DataROI.Tip = ...
                sprintf(['ROI of data to be analyzed (currently only ', ...
                'used in smi.SPT).\nThis should be organized as ', ...
                '[YStart, XStart, YEnd, XEnd, ZStart, ZPeriod]. \nThe ', ...
                'elements ZStart and ZPeriod are used to unmix data ', ...
                'shuffled along their\nthird dimension (e.g., for ', ...
                'stacked two-channel data, ZStart = 1 and\n', ...
                'ZPeriod = 2 would select images 1:2:end).']);
            obj.SMFFieldNotes.Data.FrameRate.Tip = ...
                sprintf(['Acquisition frame rate of the camera used\n', ...
                'to collect the raw data']);
            obj.SMFFieldNotes.Data.PixelSize.Tip = ...
                sprintf(['Pixel size of the camera used to collect\n', ...
                'the raw data, back-projected to the objective\n', ...
                'focal plane.']);
            obj.SMFFieldNotes.Data.SEAdjust.Tip = ...
                'Standard error inflation to be applied to each localization';
            obj.SMFFieldNotes.BoxFinding.BoxSize.Tip = ...
                'See FindROI for usage';
            obj.SMFFieldNotes.BoxFinding.BoxOverlap.Tip = ...
                'See FindROI for usage';
            obj.SMFFieldNotes.BoxFinding.MinPhotons.Tip = ...
                'See FindROI for usage';
            obj.SMFFieldNotes.Fitting.PSFSigma.Tip = ...
                'See GaussMLE for usage';
            obj.SMFFieldNotes.Fitting.FitType.Tip = ...
                'See GaussMLE for usage';
            obj.SMFFieldNotes.Fitting.NParams.Tip = ...
                sprintf(['Number of fitting parameters.  This is\n', ...
                'set automatically based on the FitType.']);
            obj.SMFFieldNotes.Fitting.Iterations.Tip = ...
                'See GaussMLE for usage';
            obj.SMFFieldNotes.Fitting.ZFitStruct.Tip = ...
                'See GaussMLE for usage';
            obj.SMFFieldNotes.Thresholding.On.Tip = ...
                'Indicates whether or not thresholding will be performed';
            obj.SMFFieldNotes.Thresholding.MaxXY_SE.Tip = ...
                sprintf(['Maximum value of X or Y standard error of\n', ...
                'localizations retained after thresholding']);
            obj.SMFFieldNotes.Thresholding.MaxZ_SE.Tip = ...
                sprintf(['Maximum value of Z standard error of\n', ...
                'localizations retained after thresholding']);
            obj.SMFFieldNotes.Thresholding.MinPValue.Tip = ...
                sprintf(['Minimum value of the p-value of\n', ...
                'localizations retained after thresholding. In this\n', ...
                'context, the p-value is bigger for good\n', ...
                'localizations and smaller for bad localizations']);
            obj.SMFFieldNotes.Thresholding.AutoThreshLogL.Tip = ...
                sprintf(['Automatically select a threshold for the ', ...
                'log-likelihood \n using the triangle method and use ', ...
                'it in place of the \nMinPValue threshold.']);
            obj.SMFFieldNotes.Thresholding.AutoThreshPrctile.Tip = ...
                sprintf(['Percentile of extrema of log-likelihood ', ...
                'thrown out\nbefore computing the auto-threshold when ', ...
                'using\nAutoThreshLogL. ' ...
                '(see smi_helpers.triangle_threshold())']);
            obj.SMFFieldNotes.Thresholding.MinPSFSigma.Tip = ...
                sprintf(['Minimum value of PSF sigma of\n', ...
                'localizations retained after thresholding']);
            obj.SMFFieldNotes.Thresholding.MaxPSFSigma.Tip = ...
                sprintf(['Maximum value of PSF sigma of\n', ...
                'localizations retained after thresholding']);
            obj.SMFFieldNotes.Thresholding.MinPhotons.Tip = ...
                sprintf(['Minimum number of photons in\n', ...
                'localizations retained after thresholding']);
            obj.SMFFieldNotes.Thresholding.MaxBg.Tip = ...
                sprintf(['Maximum number of background photons of\n', ...
                'localizations retained after thresholding']);
            obj.SMFFieldNotes.Thresholding.InMeanMultiplier.Tip = ...
                sprintf(['Intensity mean multiplier defining maximum\n', ...
                'photons allowed to retain a localization']);
            obj.SMFFieldNotes.Thresholding.NNMedianMultiplier.Tip = ...
                sprintf(['Standard error mean multiplier defining the\n'...
                'acceptance region for counting numbers of neighbors\n', ...
                '(Do not use on dSTORM data)']);
            obj.SMFFieldNotes.Thresholding.MinNumNeighbors.Tip = ...
                sprintf(['In conjunction with ''NNMedianMultiplier'',\n', ...
                'the minumum number of neighbors that must be in the\n', ...
                'acceptance region to retain a localization\n', ...
                '(Do not use on dSTORM data)']);
            obj.SMFFieldNotes.FrameConnection.On.Tip = ...
                sprintf(['Indicates whether or not frame connection\n', ...
                'will be performed']);
            obj.SMFFieldNotes.FrameConnection.Method.Tip = ...
                sprintf(['Method used to connect repeated\n', ...
                'localizations of the same emitter on event']);
            obj.SMFFieldNotes.FrameConnection.MaxSeparation.Tip = ...
                sprintf(['Maximum separation between two\n', ...
                'localizations such that they can still be\n', ...
                'considered candidates for frame connection']);
            obj.SMFFieldNotes.FrameConnection.LoS.Tip = ...
                sprintf(['Level of Significance compared to\n', ...
                'p-values computed in the frame-connection\n', ...
                'procedure. In this context, a lower value of LoS\n', ...
                'corresponds to a more liberal connection of\n', ...
                'localizations.']);
            obj.SMFFieldNotes.FrameConnection.MaxFrameGap.Tip = ...
                sprintf(['Maximum number of frames separating two\n', ...
                'localizations in time such that they can still be\n', ...
                'considered candidates for frame connection']);
            obj.SMFFieldNotes.FrameConnection.NSigmaDev.Tip = ...
                sprintf(['Localization error multiplier used to set\n', ...
                'pre-clustering separation threshold when\n', ...
                'Method = ''LAP-FC''.']);
            obj.SMFFieldNotes.FrameConnection.NNearestClusters.Tip = ...
                sprintf(['Number of nearest clusters used in local\n', ...
                'emitter density estimation when Method=''LAP-FC''']);
            obj.SMFFieldNotes.FrameConnection.NIterations.Tip = ...
                sprintf(['Number of iterative calls to the LAP-FC\n', ...
                'algorithm when Method=''LAP-FC''.  With each\n', ...
                'iteration, internal parameters are re-estimated\n', ...
                'from the previous iteration''s results.']);
            obj.SMFFieldNotes.FrameConnection.MinNFrameConns.Tip = ...
                sprintf(['Do not retain localizations representing\n', ...
                'this or fewer frame connection sequences\n', ...
                '(Do not use on dSTORM data)']);
            obj.SMFFieldNotes.DriftCorrection.On.Tip = ...
                sprintf(['Indicates whether or not drift correction\n', ...
                'will be performed']);
            obj.SMFFieldNotes.DriftCorrection.Method.Tip = ...
                sprintf(['Method used to correct for emitter drift']);
            obj.SMFFieldNotes.DriftCorrection.BFRegistration.Tip = ...
                sprintf(['Indicates whether or not brightfield\n', ...
                'registration was performed during data collection']);
            obj.SMFFieldNotes.DriftCorrection.L_intra.Tip = ...
                'See DriftCorrection for usage';
            obj.SMFFieldNotes.DriftCorrection.L_inter.Tip = ...
                'See DriftCorrection for usage';
            obj.SMFFieldNotes.DriftCorrection.PixelSizeZUnit.Tip = ...
                'See DriftCorrection for usage';
            obj.SMFFieldNotes.DriftCorrection.PDegree.Tip = ...
                'See DriftCorrection for usage';
            obj.SMFFieldNotes.Tracking.Method.Tip = ...
                sprintf(['Method used for tracking. Note that\n', ...
                'currently there is only one option; this is just\n', ...
                'a placeholder!']);
            obj.SMFFieldNotes.Tracking.D.Tip = ...
                sprintf(['Known/anticipated diffusion constant of\n', ...
                'emitters present in the raw data.']);
            obj.SMFFieldNotes.Tracking.TrajwiseD.Tip = ...
                sprintf(['Use trajectory-wise value for D when', ...
                'iteratively tracking.\n''NIterMax'' or ''NIterMaxBatch''', ...
                'must beat least 2 to use this property']);
            obj.SMFFieldNotes.Tracking.K_on.Tip = ...
                sprintf(['Known/anticipated rate at which dark\n', ...
                'emitters become fluorescent/return from a dark state.']);
            obj.SMFFieldNotes.Tracking.K_off.Tip = ...
                sprintf(['Known/anticipated rate at which emitters\n', ...
                'transition to a dark state.']);
            obj.SMFFieldNotes.Tracking.MaxDistFF.Tip = ...
                sprintf(['Maximum separation between localizations\n', ...
                'such that they can still be considered candidates\n', ...
                'for the frame-to-frame connection procedure']);
            obj.SMFFieldNotes.Tracking.MaxDistGC.Tip = ...
                sprintf(['Maximum separation between localizations\n', ...
                'such that they can still be considered candidates\n', ...
                'for the gap closing procedure']);
            obj.SMFFieldNotes.Tracking.MaxZScoreDist.Tip = ...
                sprintf(['Maximum z-score for jump sizes allowed\n', ...
                'for trajectory connections.']);
            obj.SMFFieldNotes.Tracking.MaxZScorePhotons.Tip = ...
                sprintf(['Maximum z-score for photon differences\n', ...
                'allowed for trajectory connections.']);
            obj.SMFFieldNotes.Tracking.MaxFrameGap.Tip = ...
                sprintf(['Maximum number of frames elapsed between\n', ...
                'localizations such that they can still be\n', ...
                'considered candidates for the gap closing procedure']);
            obj.SMFFieldNotes.Tracking.MinTrackLength.Tip = ...
                sprintf(['Minimum number of observations\n', ...
                '(localizations) a trajectory must have to not be\n', ...
                'culled after tracking']);
            obj.SMFFieldNotes.Tracking.NIterMax.Tip = ...
                'Max. # of iterations permitted if iteratively tracking.';
            obj.SMFFieldNotes.Tracking.NIterMaxBatch.Tip = ...
                ['Max. # of iterations permitted if iteratively ', ...
                'tracking over batches.'];
            obj.SMFFieldNotes.Tracking.ParamsHistory.Tip = ...
                sprintf(['History of parameters used if iteratively ', ...
                'tracking.\nNot to be edited by the user.  If using ', ...
                'smi.SPT.batchTrack(),\nthis will show the history over ', ...
                'the ''NIterMaxBatch''\niterations.  Otherwise, it''s ', ...
                'the history over ''NIterMax''\niterations.']);
            obj.SMFFieldNotes.Tracking.MaxRelativeChange.Tip = ...
                sprintf(['Max. relative change in parameters allowed\n', ...
                'before ending iterative tracking']);
            obj.SMFFieldNotes.Tracking.TryLowPValueLocs.Tip = ...
                sprintf(['Attempt to track with localizations that\n', ...
                'were thresholded based on their p-value.  If those\n', ...
                'localizations are incorporated into trajectories,\n', ...
                'they are kept, otherwise they are discarded.']);
            
            % Check that the protected property 'SMFFieldNames' makes
            % sense, i.e., it doesn't have entries that don't exist as
            % properties.
            PropertyNames = fieldnames(obj);
            if ~all(ismember(obj.SMFPropertyNames, PropertyNames))
                warning(['smi_core.SingleMoleculeFitting: Not all ', ...
                    'entries in the protected property ', ...
                    '''SMFPropertyNames'' exist as class properties. ', ...
                    'Please revise in SingleMoleculeFitting.m'])
            end
        end
        
        function set.Data(obj, DataInput)
            % This is a set method for the class property Data.
            
            % Validate the inputs given in DataInput.
            if isfield(DataInput, 'FileName')
                if ~(ischar(DataInput.FileName) ...
                        || isstring(DataInput.FileName) ...
                        || iscell(DataInput.FileName))
                    error(['''SMF.Data.FileName'' must be of type ', ...
                        'char, string, or cell.'])
                elseif (ischar(DataInput.FileName) ...
                        || isstring(DataInput.FileName))
                    DataInput.FileName = {DataInput.FileName};
                elseif (size(DataInput.FileName, 1) ...
                        < size(DataInput.FileName, 2))
                    % I prefer column arrays so I'll transpose if needed.
                    DataInput.FileName = DataInput.FileName.';
                end
                
                % Attempt to set obj.Data.FileType, if needed.
                if (isfield(obj.Data, 'FileType') ...
                        && isempty(obj.Data.FileType) ...
                        && isempty(DataInput.FileType))
                    [~, ~, FileType] = fileparts(DataInput.FileName{1});
                    DataInput.FileType = FileType(2:end);
                end
            end
            if isfield(DataInput, 'FileDir')
                if ~(ischar(DataInput.FileDir) ...
                        || isstring(DataInput.FileDir) ...
                        || iscell(DataInput.FileDir))
                    error(['''SMF.Data.FileDir'' must be of type ', ...
                        'char, string, or cell.'])
                elseif ~isempty(DataInput.FileDir)
                    % Note that if the FileDir isn't being changed, we
                    % don't want to update ResultsDir since that might
                    % overwrite a change to ResultsDir intended by the
                    % user. Similarly, if the current ResultsDir isn't the
                    % expected default value, we should assume the user has
                    % specified some custom directory that shouldn't be
                    % changed.
                    if (isfield(obj.Data, 'FileDir') ...
                            && ~strcmp(DataInput.FileDir, ...
                            obj.Data.FileDir))
                        DefaultResultsDir = ...
                            fullfile(DataInput.FileDir, 'Results');
                        if isfield(obj.Data, 'ResultsDir')
                            OldDefaultResultsDir = ...
                                fullfile(obj.Data.FileDir, 'Results');
                            if (strcmp(obj.Data.ResultsDir, ...
                                    OldDefaultResultsDir) ...
                                    || isempty(obj.Data.ResultsDir))
                                % If this condition isn't met, I'm assuming
                                % the ResultsDir is set to a custom
                                % directory and shouldn't be changed.
                                DataInput.ResultsDir = DefaultResultsDir;
                            end
                        else
                            DataInput.ResultsDir = DefaultResultsDir;
                        end
                    end
                end
            end
            if isfield(DataInput, 'ResultsDir')
                if ~(ischar(DataInput.ResultsDir) ...
                        || isstring(DataInput.ResultsDir))
                    error(['''SMF.Data.ResultsDir'' must be of type ', ...
                        'char or string.'])
                end
            end
            if isfield(DataInput, 'AnalysisID')
                if ~(ischar(DataInput.AnalysisID) ...
                        || isstring(DataInput.AnalysisID))
                    error(['''SMF.Data.AnalysisID'' must be of type ', ...
                        'char or string.'])
                end
            end
            if isfield(DataInput, 'FileType')
                if ~(ischar(DataInput.FileType) ...
                        || isstring(DataInput.FileType))
                    error(['''SMF.Data.FileType'' must be of type ', ...
                        'char or string.'])
                end
            end
            if isfield(DataInput, 'DataVariable')
                if ~(ischar(DataInput.DataVariable) ...
                        || isstring(DataInput.DataVariable))
                    error(['''SMF.Data.DataVariable'' must be of type ',...
                        'char or string.'])
                end
            end
            if isfield(DataInput, 'DatasetList')
                if (~isempty(DataInput.DatasetList) ...
                        && any(mod(DataInput.DatasetList, 1)))
                    % NOTE: This condition allows obj.Data.DatasetList to
                    %       be set to empty, which may cause issues
                    %       depending on how it's used.
                    error(['''SMF.Data.DatasetList must be an array ', ...
                        'of integers.'])
                end
            end
            if isfield(DataInput, 'DatasetMods')
                if (~isempty(DataInput.DatasetMods{1}) ...
                        && any(mod(DataInput.DatasetMods{1}, 1)))
                    error(['''SMF.Data.DatasetMods{1}'' ', ...
                        'must be an array of integers']);
                elseif (size(DataInput.DatasetMods{1}, 1) ...
                        > size(DataInput.DatasetMods{1}, 2))
                    % Row arrays work nicely for use in for loops.
                    DataInput.DatasetMods{1} = DataInput.DatasetMods{1}.';
                end
                if (~isempty(DataInput.DatasetMods{2}) ...
                        && any(mod(DataInput.DatasetMods{2}, 1)))
                    error(['''SMF.Data.DatasetMods{2}'' ', ...
                        'must be an array of integers']);
                elseif (size(DataInput.DatasetMods{2}, 1) ...
                        > size(DataInput.DatasetMods{2}, 2))
                    % Row arrays work nicely for use in for loops.
                    DataInput.DatasetMods{2} = DataInput.DatasetMods{2}.';
                end
            end
            if isfield(DataInput, 'CameraType')
                if ~ismember(DataInput.CameraType, {'EMCCD', 'SCMOS'})
                    error(['''SMF.Data.CameraType'' must be either ', ...
                        '''EMCCD'' or ''SCMOS'''])
                end
            end
            if isfield(DataInput, 'CameraGain')
                if ~isnumeric(DataInput.CameraGain)
                    error('''SMF.Data.CameraGain'' must be numeric.')
                end
            end
            if isfield(DataInput, 'CameraOffset')
                if ~isnumeric(DataInput.CameraOffset)
                    error('''SMF.Data.CameraOffset'' must be numeric.')
                end
            end
            if isfield(DataInput, 'CameraReadNoise')
                if ~isnumeric(DataInput.CameraReadNoise)
                    error('''SMF.Data.CameraReadNoise'' must be numeric.')
                end
            end
            if isfield(DataInput, 'CalibrationFilePath')
                if ~(ischar(DataInput.CalibrationFilePath) ...
                        || isstring(DataInput.CalibrationFilePath))
                    error(['''SMF.Data.CalibrationFilePath'' must ', ...
                        'be of type char or string'])
                end
            end
            if isfield(DataInput, 'RegistrationFilePath')
                if ~(ischar(DataInput.RegistrationFilePath) ...
                        || isstring(DataInput.RegistrationFilePath))
                    error(['''SMF.Data.RegistrationFilePath'' must ', ...
                        'be of type char or string'])
                end
            end
            if isfield(DataInput, 'DataROI')
                if (~isempty(DataInput.DataROI) ...
                        && any(mod(DataInput.DataROI, 1)))
                    % NOTE: This condition allows obj.Data.DataROI to
                    %       be set to empty, which may cause issues
                    %       depending on how it's used.
                    error(['''SMF.Data.DataROI must be an array ', ...
                        'of integers.'])
                end
            end
            if isfield(DataInput, 'FrameRate')
                if ~isnumeric(DataInput.FrameRate)
                    error('''SMF.Data.FrameRate'' must be numeric.')
                end
            end
            if isfield(DataInput, 'PixelSize')
                if ~isnumeric(DataInput.PixelSize)
                    error('''SMF.Data.PixelSize'' must be numeric.')
                end
            end
            if isfield(DataInput, 'SEAdjust')
                if ~isnumeric(DataInput.SEAdjust)
                    error('''SMF.Data.SEAdjust'' must be numeric.')
                end
            end
            
            % Set the input fields as class properties.
            InputFields = fieldnames(DataInput);
            for ff = 1:numel(InputFields)
                obj.Data.(InputFields{ff}) = DataInput.(InputFields{ff});
            end
        end
        
        function set.BoxFinding(obj, BoxFindingInput)
            % This is a set method for the class property BoxFinding.
            
            % Validate the inputs given in BoxFindingInput.
            if isfield(BoxFindingInput, 'BoxSize')
                if mod(BoxFindingInput.BoxSize, 1)
                    error(['''SMF.BoxFinding.BoxSize'' ', ...
                        'must be an integer.'])
                end
            end
            if isfield(BoxFindingInput, 'BoxOverlap')
                if mod(BoxFindingInput.BoxOverlap, 1)
                    error(['''SMF.BoxFinding.BoxOverlap'' ', ...
                        'must be an integer.'])
                end
            end
            if isfield(BoxFindingInput, 'MinPhotons')
                if ~isnumeric(BoxFindingInput.MinPhotons)
                    error(['''SMF.BoxFinding.MinPhotons'' ', ...
                        'must be numeric.'])
                end
            end
            
            % Set the input fields as class properties.
            InputFields = fieldnames(BoxFindingInput);
            for ff = 1:numel(InputFields)
                obj.BoxFinding.(InputFields{ff}) = ...
                    BoxFindingInput.(InputFields{ff});
            end
        end
        
        function set.Fitting(obj, FittingInput)
            % This is a set method for the class property Fitting.
            
            % Validate the inputs given in FittingInput.
            if isfield(FittingInput, 'PSFSigma')
                if ~isnumeric(FittingInput.PSFSigma)
                    error('''SMF.Fitting.PSFSigma'' must be numeric.')
                end
            end
            if isfield(FittingInput, 'FitType')
                if ismember(FittingInput.FitType, ...
                        {'XYNB', 'XYNBS', 'XYNBSXSY', 'XYZNB'})
                    % Set the NParams field automatically based on this
                    % selection.
                    switch FittingInput.FitType
                        case 'XYNB'
                            FittingInput.NParams = 4;
                        case {'XYNBS', 'XYZNB'}
                            FittingInput.NParams = 5;
                        case 'XYNBSXSY'
                            FittingInput.NParams = 6;
                    end
                else
                    error(['SMF.Fitting.FitType must be one of ', ...
                        'XYNB, XYNBS, XYNBSXSY, or XYZNB'])
                end
            end
            if isfield(FittingInput, 'NParams')
                % Set the NParams field automatically based on the FitType,
                % regardless of what the user tried to enter.
                switch FittingInput.FitType
                    case 'XYNB'
                        FittingInput.NParams = 4;
                    case {'XYNBS', 'XYZNB'}
                        FittingInput.NParams = 5;
                    case 'XYNBSXSY'
                        FittingInput.NParams = 6;
                end
            end
            if isfield(FittingInput, 'Iterations')
                if mod(FittingInput.Iterations, 1)
                    error('''SMF.Fitting.Iterations'' must be an integer.')
                end
            end
            if isfield(FittingInput, 'ZFitStruct')
                if ~isstruct(FittingInput.ZFitStruct)
                    error(['''SMF.Fitting.ZFitStruct'' must be of ', ...
                        'type struct.'])
                end
            end
            
            % Set the input fields as class properties.
            InputFields = fieldnames(FittingInput);
            for ff = 1:numel(InputFields)
                obj.Fitting.(InputFields{ff}) = ...
                    FittingInput.(InputFields{ff});
            end
        end
        
        function set.Thresholding(obj, ThresholdingInput)
            % This is a set method for the class property Thresholding.
            
            % Validate the inputs given in ThresholdingInput.
            if isfield(ThresholdingInput, 'On')
                if ~(islogical(ThresholdingInput.On) ...
                        || isnumeric(ThresholdingInput.On))
                    error(['''SMF.Thresholding.On'' must be logical ', ...
                        'or interpretable as logical (numeric).'])
                elseif isnumeric(ThresholdingInput.On)
                    ThresholdingInput.On = logical(ThresholdingInput.On);
                end
            end
            if isfield(ThresholdingInput, 'MaxXY_SE')
                if ~isnumeric(ThresholdingInput.MaxXY_SE)
                    error('''SMF.Thresholding.MaxXY_SE'' must be numeric.')
                end
            end
            if isfield(ThresholdingInput, 'MaxZ_SE')
                if ~isnumeric(ThresholdingInput.MaxZ_SE)
                    error('''SMF.Thresholding.MaxZ_SE'' must be numeric.')
                end
            end
            if isfield(ThresholdingInput, 'MinPValue')
                if ~(isnumeric(ThresholdingInput.MinPValue) ...
                        && (ThresholdingInput.MinPValue<=1) ...
                        && (ThresholdingInput.MinPValue>=0))
                    error(['''SMF.Thresholding.MinPValue'' ', ...
                        'must be a number in the interval [0, 1].'])
                end
            end
            if isfield(ThresholdingInput, 'AutoThreshLogL')
                if ~(islogical(ThresholdingInput.AutoThreshLogL) ...
                        || isnumeric(ThresholdingInput.AutoThreshLogL))
                    error(['''SMF.Thresholding.AutoThreshLogL'' must be logical ', ...
                        'or interpretable as logical (numeric).'])
                elseif isnumeric(ThresholdingInput.AutoThreshLogL)
                    ThresholdingInput.AutoThreshLogL = ...
                        logical(ThresholdingInput.AutoThreshLogL);
                end
            end
            if isfield(ThresholdingInput, 'AutoThreshPrctile')
                if ~(isnumeric(ThresholdingInput.AutoThreshPrctile) ...
                        && (ThresholdingInput.AutoThreshPrctile<=100) ...
                        && (ThresholdingInput.AutoThreshPrctile>=0))
                    error(['''SMF.Thresholding.AutoThreshPrctile'' ', ...
                        'must be a number in the interval [0, 100].'])
                end
            end
            if isfield(ThresholdingInput, 'MinPSFSigma')
                if ~isnumeric(ThresholdingInput.MinPSFSigma)
                    error(['''SMF.Thresholding.MinPSFSigma'' ', ...
                        'must be numeric.'])
                end
            end
            if isfield(ThresholdingInput, 'MaxPSFSigma')
                if ~isnumeric(ThresholdingInput.MaxPSFSigma)
                    error(['''SMF.Thresholding.MaxPSFSigma'' ', ...
                        'must be numeric.'])
                end
            end
            if isfield(ThresholdingInput, 'MinPhotons')
                if ~isnumeric(ThresholdingInput.MinPhotons)
                    error(['''SMF.Thresholding.MinPhotons'' ', ...
                        'must be numeric.'])
                end
            end
            if isfield(ThresholdingInput, 'MaxBg')
                if ~isnumeric(ThresholdingInput.MaxBg)
                    error('''SMF.Thresholding.MaxBg'' must be numeric.')
                end
            end
            if isfield(ThresholdingInput, 'InMeanMultiplier')
                if ~isnumeric(ThresholdingInput.InMeanMultiplier)
                    error('''SMF.Thresholding.InMeanMultiplier'' must be numeric.')
                end
            end
            if isfield(ThresholdingInput, 'NNMedianMultiplier')
                if ~isnumeric(ThresholdingInput.NNMedianMultiplier)
                    error('''SMF.Thresholding.NNMedianMultiplier'' must be numeric.')
                end
            end
            if isfield(ThresholdingInput, 'MinNumNeighbors')
                if (mod(ThresholdingInput.MinNumNeighbors, 1) || (ThresholdingInput.MinNumNeighbors<0))
                    error(['''SMF.Thresholding.MinNumNeighbors'' ', ...
                        'must be a non-negative integer.'])
                end
            end
            
            % Set the input fields as class properties.
            InputFields = fieldnames(ThresholdingInput);
            for ff = 1:numel(InputFields)
                obj.Thresholding.(InputFields{ff}) = ...
                    ThresholdingInput.(InputFields{ff});
            end
        end
        
        function set.FrameConnection(obj, FCInput)
            % This is a set method for the class property FrameConnection.
            
            % Validate the inputs given in FCInput.
            if isfield(FCInput, 'On')
                if ~(islogical(FCInput.On) || isnumeric(FCInput.On))
                    error(['''SMF.FrameConnection.On'' must be ', ...
                        'logical or interpretable as logical (numeric).'])
                elseif isnumeric(FCInput.On)
                    FCInput.On = logical(FCInput.On);
                end
            end
            if isfield(FCInput, 'Method')
                if ~ismember(lower(FCInput.Method), ...
                        {'hypothesis test', 'lap-fc', ...
                        'classical', 'revised classical'})
                    error(['''SMF.FrameConnection.Method'' must be ', ...
                        '''Hypothesis test'', ''LAP-FC'', ', ...
                        '''Classical'', or ''Revised classical''.'])
                end
            end
            if isfield(FCInput, 'MaxSeparation')
                if ~isnumeric(FCInput.MaxSeparation)
                    error(['''SMF.FrameConnection.MaxSeparation'' ', ...
                        'must be numeric.'])
                end
            end
            if isfield(FCInput, 'LoS')
                if ~(isnumeric(FCInput.LoS) ...
                        && (FCInput.LoS<=1) ...
                        && (FCInput.LoS>=0))
                    error(['''SMF.FrameConnection.LoS'' ', ...
                        'must be a number in the interval [0, 1].'])
                end
            end
            if isfield(FCInput, 'MaxFrameGap')
                if mod(FCInput.MaxFrameGap, 1)
                    error(['''SMF.FrameConnection.MaxFrameGap'' ', ...
                        'must be an integer.'])
                end
            end
            if isfield(FCInput, 'NNearestClusters')
                if (mod(FCInput.NNearestClusters, 1) ...
                        || (FCInput.NNearestClusters<1))
                    error(['''SMF.FrameConnection.NNearestClusters'' ', ...
                        'must be a positive integer.'])
                end
            end
            if isfield(FCInput, 'NIterations')
                if (mod(FCInput.NIterations, 1) || (FCInput.NIterations<1))
                    error(['''SMF.FrameConnection.NIterations'' ', ...
                        'must be a positive integer.'])
                end
            end
            if isfield(FCInput, 'MinNFrameConns')
                if (mod(FCInput.MinNFrameConns, 1) || (FCInput.MinNFrameConns<1))
                    error(['''SMF.FrameConnection.MinNFrameConns'' ', ...
                        'must be a positive integer.'])
                end
            end
            if isfield(FCInput, 'NSigmaDev')
                if ~(isnumeric(FCInput.NSigmaDev) ...
                        && (FCInput.NSigmaDev>=0))
                    error(['''SMF.FrameConnection.NSigmaDev'' ', ...
                        'must be a non-negative number.'])
                end
            end
            
            % Set the input fields as class properties.
            InputFields = fieldnames(FCInput);
            for ff = 1:numel(InputFields)
                obj.FrameConnection.(InputFields{ff}) = ...
                    FCInput.(InputFields{ff});
            end
        end
        
        function set.DriftCorrection(obj, DCInput)
            % This is a set method for the class property DriftCorrection.
            
            % Validate the inputs given in DCInput.
            if isfield(DCInput, 'On')
                if ~(islogical(DCInput.On) || isnumeric(DCInput.On))
                    error(['''SMF.DriftCorrection.On'' must be ', ...
                        'logical or interpretable as logical (numeric).'])
                elseif isnumeric(DCInput.On)
                    DCInput.On = logical(DCInput.On);
                end
            end
            if isfield(DCInput, 'Method')
                if ~ismember(lower(DCInput.Method), ...
                        {'dc-knn', 'dc-bf'})
                    error(['''SMF.DriftCorrection.Method'' must be ', ...
                        '''DC-KNN'' or ''DC-BF''.'])
                end
            end
            if isfield(DCInput, 'L_intra')
                if ~isnumeric(DCInput.L_intra)
                    error(['''SMF.DriftCorrection.L_intra'' ', ...
                        'must be numeric.'])
                end
            end
            if isfield(DCInput, 'L_inter')
                if ~isnumeric(DCInput.L_inter)
                    error(['''SMF.DriftCorrection.L_inter'' ', ...
                        'must be numeric.'])
                end
            end
            if isfield(DCInput, 'PixelSizeZUnit')
                if ~isnumeric(DCInput.PixelSizeZUnit)
                    error(['''SMF.DriftCorrection.PixelSizeZUnit'' ', ...
                        'must be numeric.'])
                end
            end
            if isfield(DCInput, 'PDegree')
                if mod(DCInput.PDegree, 1)
                    error(['''SMF.DriftCorrection.PDegree'' ', ...
                        'must be an integer.'])
                end
            end
            
            % Set the input fields as class properties.
            InputFields = fieldnames(DCInput);
            for ff = 1:numel(InputFields)
                obj.DriftCorrection.(InputFields{ff}) = ...
                    DCInput.(InputFields{ff});
            end
        end
        
        function set.Tracking(obj, TrackingInput)
            % This is a set method for the class property Tracking.
            
            % Validate the inputs given in TrackingInput.
            if (isfield(TrackingInput, 'Method') ...
                    && ~ismember(TrackingInput.Method, {'CostMatrix'}))
                error('SMF.Tracking.Method must be one of CostMatrix,')
            end
            if isfield(TrackingInput, 'D')
                if ~isnumeric(TrackingInput.D)
                    error('''SMF.Tracking.D'' must be numeric.')
                end
            end
            if isfield(TrackingInput, 'TrajwiseD')
                if ~(islogical(TrackingInput.TrajwiseD) ...
                        || isnumeric(TrackingInput.TrajwiseD))
                    error(['''SMF.Tracking.TrajwiseD'' must be ', ...
                        'logical or interpretable as logical (numeric).'])
                elseif isnumeric(TrackingInput.TrajwiseD)
                    TrackingInput.TrajwiseD = ...
                        logical(TrackingInput.TrajwiseD);
                end
            end
            if isfield(TrackingInput, 'K_on')
                if ~isnumeric(TrackingInput.K_on)
                    error('''SMF.Tracking.K_on'' must be numeric.')
                end
            end
            if isfield(TrackingInput, 'K_off')
                if ~isnumeric(TrackingInput.K_off)
                    error('''SMF.Tracking.K_off'' must be numeric.')
                end
            end
            if isfield(TrackingInput, 'MaxDistFF')
                if ~isnumeric(TrackingInput.MaxDistFF)
                    error('''SMF.Tracking.MaxDistFF'' must be numeric.')
                end
            end
            if isfield(TrackingInput, 'MaxDistGC')
                if ~isnumeric(TrackingInput.MaxDistGC)
                    error('''SMF.Tracking.MaxDistGC'' must be numeric.')
                end
            end
            if isfield(TrackingInput, 'MaxZScoreDist')
                if ~isnumeric(TrackingInput.MaxZScoreDist)
                    error('''SMF.Tracking.MaxZScoreDist'' must be numeric.')
                end
            end
            if isfield(TrackingInput, 'MaxZScorePhotons')
                if ~isnumeric(TrackingInput.MaxZScorePhotons)
                    error(['''SMF.Tracking.MaxZScorePhotons'' ', ...
                        'must be numeric.'])
                end
            end
            if isfield(TrackingInput, 'MaxFrameGap')
                if mod(TrackingInput.MaxFrameGap, 1)
                    error(['''SMF.Tracking.MaxFrameGap'' ', ...
                        'must be an integer.'])
                end
            end
            if isfield(TrackingInput, 'MinTrackLength')
                if mod(TrackingInput.MinTrackLength, 1)
                    error(['''SMF.Tracking.MinTrackLength'' ', ...
                        'must be an integer.'])
                end
            end
            if isfield(TrackingInput, 'NIterMax')
                if mod(TrackingInput.NIterMax, 1)
                    error(['''SMF.Tracking.NIterMax'' ', ...
                        'must be an integer.'])
                end
            end
            if isfield(TrackingInput, 'NIterMaxBatch')
                if mod(TrackingInput.NIterMaxBatch, 1)
                    error(['''SMF.Tracking.NIterMaxBatch'' ', ...
                        'must be an integer.'])
                end
            end
            if isfield(TrackingInput, 'ParamsHistory')
                if ~iscell(TrackingInput.ParamsHistory)
                    error(['''SMF.Tracking.ParamsHistory'' ', ...
                        'must be a cell array.'])
                end
            end
            if isfield(TrackingInput, 'MaxRelativeChange')
                if ~isnumeric(TrackingInput.MaxRelativeChange)
                    error(['''SMF.Tracking.MaxRelativeChange'' ', ...
                        'must be numeric'])
                end
            end
            if isfield(TrackingInput, 'TryLowPValueLocs')
                if ~(islogical(TrackingInput.TryLowPValueLocs) ...
                        || isnumeric(TrackingInput.TryLowPValueLocs))
                    error(['''SMF.Tracking.TryLowPValueLocs'' must be ', ...
                        'logical or interpretable as logical (numeric).'])
                elseif isnumeric(TrackingInput.TryLowPValueLocs)
                    TrackingInput.TryLowPValueLocs = ...
                        logical(TrackingInput.TryLowPValueLocs);
                end
            end
            
            % Set the input fields as class properties.
            InputFields = fieldnames(TrackingInput);
            for ff = 1:numel(InputFields)
                obj.Tracking.(InputFields{ff}) = ...
                    TrackingInput.(InputFields{ff});
            end
        end
        
        
        function [SMFStruct] = packageSMF(obj)
            %packageSMF converts class instance obj to a structure array.
            % This method will convert the class instance into a structure
            % array by setting all class properties as fields in the
            % structure array.
            
            % Generate the output SMFStruct.
            ClassFields = fieldnames(obj);
            for ff = 1:numel(ClassFields)
                SMFStruct.(ClassFields{ff}) = obj.(ClassFields{ff});
            end
            SMFStruct.SMFVersion = obj.SMFVersion;
        end
        
        function importSMF(obj, SMFStruct)
            %importSMF imports fields from SMF into the class instance obj.
            % This method will take the fields given in the structure array
            % SMFStruct and set them to the corresponding class properties
            % in obj.
            
            % Update class properties based on fields in SMFStruct.
            InputFields = fieldnames(SMFStruct);
            ClassFields = fieldnames(obj);
            ValidFields = InputFields(ismember(InputFields, ClassFields));
            for ff = 1:numel(ValidFields)
                obj.(ValidFields{ff}) = SMFStruct.(ValidFields{ff});
            end
        end
        
        function resetSMF(obj)
            %resetSMF resets all SMF fields to their default values.
            % This method will overwrite all properties of the class
            % instance obj with their default values defined by the class
            % constructor. This is done by creating a new instance of the
            % SMF class and then importing those properties to the current
            % instance obj using importSMF().
            SMFDefault = smi_core.SingleMoleculeFitting;
            obj.importSMF(SMFDefault);
        end
        
        [GUIParent] = gui(obj, GUIParent);
        
    end
    
    methods (Static)
        function [SMF] = reloadSMF(SMFStruct)
            %reloadSMF loads a struct type SMF into a class instance SMF
            % This method will take the fields given in the structure array
            % SMFStruct and set them to the corresponding class properties,
            % i.e., it creates an SMF class instance from an input
            % SMFStruct.
            % NOTE: This is basically a static wrapper for the non-static
            %       method importSMF(), which needed to be non-static due
            %       to its intended usage in the GUI.
            
            % Create an instance of the SingleMoleculeFitting class.
            SMF = smi_core.SingleMoleculeFitting;
            
            % Update class properties based on fields in SMFStruct.
            SMF.importSMF(SMFStruct)
        end
        
        [SMFPadded, PaddedFields] = padSMF(SMF, SMFPadding, ...
            DisplayMessages);
    end
    
end

./MATLAB/+smi_core/@SingleMoleculeFitting/README.md
### +smi_core/@SingleMoleculeFitting

SingleMoleculeFitting: A class defining the Single Molecule Fitting structure

The SMF structure is a structure of structures that collectively contain
all parameters required to go from raw data to an SMD results structure.
The SMF structure is an input of many smi methods. It
intended to be extensible to enable new analysis tools and methods.
The SMF class implements tools for working with SMF structures,
but the data structure itself is not an object of the class.

Parameters of sub-structures are explained in more detail in
the classes and methods that use them.  An incomplete list of classes
that use each sub-structure is listed in {}.

The SMF structure has these
[sub-structures and fields](../../../doc/DataStructures/SMF.md).

---

methods:
- **[gui](gui.m)**:
  the GUI method for the SingleMoleculeFitting class
- **[padSMF](padSMF.m)**:
  adds fields in SMFPadding to SMF that weren't already present

./MATLAB/+smi_core/@TrackingResults/joinTraj.m
function [TR] = joinTraj(TR, TrajectoryIDs, Verbose)
%joinTraj joins a set of trajectories into one trajectory.
% This method joins the trajectorys with IDs 'TrajectoryIDs' into a single
% trajectory with the new ID being min(TrajectoryIDs).
%
% INPUTS:
%   TR: Tracking Results structure.
%   TrajectoryIDs: Array of trajectory IDs present in TR which will be
%                  joined together. (integer array)
%   Verbose: Verbosity level describing the types of output messages made
%            during calls to this method. (Default = 1)
%
% OUTPUTS:
%   TR: Tracking Results Structure with specified trajectories combined
%       into one trajectory.

% Created by:
%   David J. Schodt (Lidke Lab, 2021)


% Set defaults if needed.
if (~exist('Verbose', 'var') || isempty(Verbose))
    Verbose = 1;
end
    
% Remove duplicates and sort the TrajectoryIDs input.
TrajectoryIDs = sort(unique(TrajectoryIDs), 'ascend');

% Loop through each of TrajectoryIDs and begin merging together.
TRIndices = smi_core.TrackingResults.getTRIndex(TR, TrajectoryIDs);
for ii = 2:numel(TrajectoryIDs)
    if any(intersect(TR(TRIndices(1)).FrameNum, ...
            TR(TRIndices(ii)).FrameNum))
        if Verbose
            warning(['smi_core.TrackingResults.joinTraj(): ', ...
                'Trajectories %i and %i cannot be joined ', ...
                'because they were observed in the same frame'], ...
                TR(TRIndices(1)).TrajectoryID, ...
                TR(TRIndices(ii)).TrajectoryID)
        end
        continue
    end
    TR(TRIndices(1)).X = [TR(TRIndices(1)).X; TR(TRIndices(ii)).X];
    TR(TRIndices(1)).Y = [TR(TRIndices(1)).Y; TR(TRIndices(ii)).Y];
    TR(TRIndices(1)).X_SE = [TR(TRIndices(1)).X_SE; ...
        TR(TRIndices(ii)).X_SE];
    TR(TRIndices(1)).Y_SE = [TR(TRIndices(1)).Y_SE; ...
        TR(TRIndices(ii)).Y_SE];
    TR(TRIndices(1)).FrameNum = [TR(TRIndices(1)).FrameNum; ...
        TR(TRIndices(ii)).FrameNum];
    TR(TRIndices(1)).Photons = [TR(TRIndices(1)).Photons; ...
        TR(TRIndices(ii)).Photons];
    TR(TRIndices(1)).Bg = [TR(TRIndices(1)).Bg; ...
        TR(TRIndices(ii)).Bg];
    TR(TRIndices(1)).IndSMD = [TR(TRIndices(1)).IndSMD; ...
        TR(TRIndices(ii)).IndSMD];
    TR(TRIndices(ii)) = [];
end

% Sort the resulting trajectory w.r.t. FrameNum.
[TR(TRIndices(1)).FrameNum, SortIndices] = sort(TR(TRIndices(1)).FrameNum);
TR(TRIndices(1)).X = TR(TRIndices(1)).X(SortIndices);
TR(TRIndices(1)).Y = TR(TRIndices(1)).Y(SortIndices);
TR(TRIndices(1)).X_SE = TR(TRIndices(1)).X_SE(SortIndices);
TR(TRIndices(1)).Y_SE = TR(TRIndices(1)).Y_SE(SortIndices);
TR(TRIndices(1)).Photons = TR(TRIndices(1)).Photons(SortIndices);
TR(TRIndices(1)).Bg = TR(TRIndices(1)).Bg(SortIndices);
TR(TRIndices(1)).IndSMD = TR(TRIndices(1)).IndSMD(SortIndices);



end
./MATLAB/+smi_core/@TrackingResults/catTR.m
function [TR] = catTR(TR1, TR2, CheckDims)
%catTR concatenates two TR structures.
% This method pads each of the inputs 'TR1' and 'TR2' to ensure they share
% the same fields and then concatenates them into a larger structure 'TR'.
%
% INPUTS:
%   TR1: Tracking Results structure.
%   TR2: Tracking Results structure.
%   CheckDims: Flag to indicate manual checking of dimensions should be
%              done (e.g., try to force inputs to be columns). 
%              (Default = true)
%
% OUTPUTS:
%   TR: Concatenation of 'TR1' and 'TR2'.

% Created by:
%   David J. Schodt (Lidke Lab, 2021)


% Set defaults if needed.
if (~exist('CheckDims', 'var') || isempty(CheckDims))
    CheckDims = true;
end

% If one of the arrays is empty, we'll just return the non-empty array.
if isempty(TR1)
    TR = TR2;
    return
elseif isempty(TR2)
    TR = TR1;
    return
end

% Pad 'TR1' and 'TR2' to ensure they share the same fields.
TR1 = smi_core.TrackingResults.padTR(TR1, TR2);
TR2 = smi_core.TrackingResults.padTR(TR2, TR1);

% Ensure both 'TR1' and 'TR2' are column structs.
if CheckDims
    if isrow(TR1)
        TR1 = TR1.';
    end
    if isrow(TR2)
        TR2 = TR2.';
    end
end

% Concatenate the two TR structures.
TR = [TR1; TR2];


end
./MATLAB/+smi_core/@TrackingResults/TrackingResults.m
classdef TrackingResults
    % TrackingResults A class defining the Tracking Results structure
    %
    % This datatype is one of the primary results structures in the smite
    % enviroment. The Tracking Results (TR) structure is an input/output of
    % many methods in smite which are related to single-particle tracking
    % (SPT) analysis.  TR structures are organized as follows: each
    % structure element corresponds to a single trajectory, i.e., TR(n)
    % contains all relevant properties of the n-th trajectory. The TR
    % structure is intended to carry all necessary information from an SMD
    % structure (see smi_core.SingleMoleculeData) but organized in a more
    % user-friendly manner for SPT data.
    %
    % The TR structure is just an array of SMD structures, with each array
    % element being an SMD structure corresponding to a single trajectory.
    %
    % SEE ALSO:
    %   smi_core.SingleMoleculeData, smi_core.SingleMoleculeFitting
    
    properties
        
    end
    
    methods (Static)
        function [TR] = createTR()
            %createTR creates an empty Tracking Results (TR) structure.
            TR = smi_core.SingleMoleculeData.createSMD();
        end
        
        [Durations] = computeTrajDurations(TR);
        [NObservations] = computeTrajLengths(TR);
        [Fidelity] = computeTrajFidelity(TR);
        [TR] = convertSMDToTR(SMD);
        [SMD] = convertTRToSMD(TR);
        [TRIndex] = getTRIndex(TR, TrajectoryIDs);
        [TR] = joinTraj(TR, TrajectoryIDs, Verbose);
        [TR] = threshTrajLength(TR, MinTrackLength);
        [TR] = padTR(TR, TRPadding);
        [TR] = catTR(TR1, TR2, CheckDims);
        
    end


end
./MATLAB/+smi_core/@TrackingResults/convertSMDToTR.m
function [TR] = convertSMDToTR(SMD)
%convertSMDToTR converts an SMD into a TR structure.
% This method takes an SMD structure (see smi_core.SingleMoleculeData) and
% converts it into a TR structure.
% 
% INPUTS:
%   SMD: Single Molecule Data structure with a properly populated field
%        'ConnectID'.
% 
% OUTPUTS:
%   TR: Tracking Results.  The TR structure is a structure array containing
%       several fields present in the SMD structure but reorganized such
%       that each element of TR, e.g., TR(7), corresponds to a single
%       unique trajectory.
% 
% CITATION:

% Created by:
%   Hanieh Mazloom-Farsibaf (Lidke Lab, 2018)
%   Rewritten in smite, David J. Schodt (Lidke Lab, 2021)


% Create an empty TR structure, ending after this piece of code if no SMD
% was input (it might sometimes be useful to produce an empty TR
% structure).
TR = smi_core.TrackingResults.createTR();
if (~exist('SMD', 'var') || isempty(SMD))
    return
end

% Loop through each trajectory in SMD and place it in the output TR.
% NOTE: Some fields will be the same for all trajectories and are added
%       outside of the loop.
UniqueTrajIDs = unique(SMD.ConnectID);
NLocalizations = numel(SMD.FrameNum);
SMDFields = fieldnames(SMD);
NSMDFields = numel(SMDFields);
for ii = numel(UniqueTrajIDs):-1:1
    % Create an index array corresponding only to the current trajectory.
    CurrentTrajIndices = find(SMD.ConnectID == UniqueTrajIDs(ii));
    
    % Loop through each relevant SMD field and place it in the TR.
    for ff = 1:NSMDFields
        if (numel(SMD.(SMDFields{ff})) == NLocalizations)
            TR(ii, 1).(SMDFields{ff}) = ...
                SMD.(SMDFields{ff})(CurrentTrajIndices);
        else
            TR(ii, 1).(SMDFields{ff}) = SMD.(SMDFields{ff});
        end
    end
    
    % Store some other fields in the TR.
    TR(ii, 1).ConnectID = SMD.ConnectID(CurrentTrajIndices(1));
    TR(ii, 1).IndSMD = CurrentTrajIndices;
end


end
./MATLAB/+smi_core/@TrackingResults/computeTrajFidelity.m
function [Fidelity] = computeTrajFidelity(TR)
%computeTrajFidelity computes the trajectory length divided by duration.
% This method computes the length (number of observations) in each
% trajectory in TR divided by the duration (max-min frame + 1).
% 
% INPUTS:
%   TR: Tracking Results structure.
% 
% OUTPUTS:
%   Fidelity: Fidelity (length/duration) for each trajectory in TR.
% 
% CITATION:

% Created by:
%   David J. Schodt (Lidke Lab, 2022)


% Loop through trajectories and compute the trajectory fidelities.
Fidelity = NaN(size(TR));
for nn = 1:numel(TR)
    Fidelity(nn) = smi_core.TrackingResults.computeTrajLengths(TR(nn)) ...
        / smi_core.TrackingResults.computeTrajDurations(TR(nn));
end


end
./MATLAB/+smi_core/@TrackingResults/threshTrajLength.m
function [TR] = threshTrajLength(TR, MinTrackLength)
%threshTrajLength removes trajectories smaller than a minimum track length.
% Given a TR and a MinTrackLength, this method will remove trajectories
% which are shorter than MinTrackLength from the TR structure, returning
% the updated TR structure with only sufficiently long trajectories.
%
% INPUTS:
%   TR: Tracking results structure containing information about single 
%       particle localizations and their trajectories.
%   MinTrackLength: Minimum trajectory length that will be kept in the
%                   output TR structure.
%   
% OUTPUTS:
%   TR: TR structure with short trajectories now removed. 
%
% CITATION:

% Created by:
%   David J. Schodt (Lidke Lab, 2018)


% Remove trajectories with too few observations.
TrajLengths = smi_core.TrackingResults.computeTrajLengths(TR);
TR(TrajLengths < MinTrackLength) = [];


end
./MATLAB/+smi_core/@TrackingResults/computeTrajDurations.m
function [Durations] = computeTrajDurations(TR)
%computeTrajDurations computes the duration of trajectories in TR.
% This method computes the duration of all trajectories in the provided TR
% structure.
% 
% INPUTS:
%   TR: Tracking Results structure.
% 
% OUTPUTS:
%   Durations: Duration of each trajectory in TR.  The indexing is matched
%              to TR, e.g., trajectory TR(m) had a duration of Durations(m)
%              frames. (frames)
% 
% CITATION:

% Created by:
%   David J. Schodt (Lidke Lab, 2021)


% Compute the trajectory durations.
Durations = cellfun(@(X) max(X) - min(X) + 1, {TR.FrameNum}.');


end
./MATLAB/+smi_core/@TrackingResults/README.md
### +smi_core/@TrackingResults

TrackingResults: A class defining the Tracking Results structure

This datatype is one of the primary results structures in the smite
enviroment. The Tracking Results (TR) structure is an input/output of
many methods in smite which are related to single-particle tracking
(SPT) analysis.  TR structures are organized as follows: each
structure element corresponds to a single trajectory, i.e., TR(n)
contains all relevant properties of the n-th trajectory. The TR
structure is intended to carry all necessary information from an SMD
structure (see (smi_core.SingleMoleculeData)[SMD.md]) but organized
in a more user-friendly manner for SPT data.

The TR structure is just an array of SMD structures, with each array
element being an SMD structure corresponding to a single trajectory.

SEE ALSO:
- [smi_core.SingleMoleculeData](../@SingleMoleculeData/README.md)
- [smi_core.SingleMoleculeFitting](../@SingleMoleculeFitting/README.md)

---

methods:
- **[catTR](catTR.m)**:
  concatenates two TR structures
- **[computeTrajDurations](computeTrajDurations.m)**:
  computes the duration of trajectories in TR
- **[computeTrajFidelity](computeTrajFidelity.m)**:
  computes the trajectory length divided by duration
- **[computeTrajLengths](computeTrajLengths.m)**:
  computes the length of trajectories in TR
- **[convertSMDToTR](convertSMDToTR.m)**:
  converts an SMD into a TR structure
- **[convertTRToSMD](convertTRToSMD.m)**:
  converts a TR back into an SMD structure.
- **[getTRIndex](getTRIndex.m)**:
  returns the indices in TR corresponding to TrajectoryIDs
- **[joinTraj](joinTraj.m)**:
  joins a set of trajectories into one trajectory
- **[padTR](padTR.m)**:
  pads the input 'TR' with fields present in 'TRPadding'
- **[threshTrajLength](threshTrajLength.m)**:
  removes trajectories smaller than a minimum track length

./MATLAB/+smi_core/@TrackingResults/padTR.m
function [TR] = padTR(TR, TRPadding)
%padTR pads the input 'TR' with fields present in 'TRPadding'.
% This method ensures that the output 'TR' contains all of the fields
% present in 'TRPadding'.  This method is intended to fix some forward and
% backward compatability issues, where old/new TR structures have a
% differing number of fields but still need to be concatenated. 
%
% INPUTS:
%   TR: TR structure which is to be padded.
%   TRPadding: TR structure containing the "complete" set of fields, some
%              of which may need to be added to 'TR'.
%
% OUTPUTS:
%   TR: Input 'TR' padded with fields from 'TRPadding'.

% Created by:
%   David J. Schodt (Lidke Lab, 2021)


% Loop through the fields of the padding fields and add them to 'TR' as 
% needed.
PaddingFieldNames = fieldnames(TRPadding);
InputFieldNames = fieldnames(TR);
for pp = 1:numel(PaddingFieldNames)
    if ~any(ismember(PaddingFieldNames{pp}, InputFieldNames))
        % The field PaddingFieldNames{pp} is not present so the default 
        % must be added.
        if iscell(TRPadding(1).(PaddingFieldNames{pp}))
            [TR.(PaddingFieldNames{pp})] = deal({});
        elseif isstruct(TRPadding(1).(PaddingFieldNames{pp}))
            [TR.(PaddingFieldNames{pp})] = deal(struct([]));
        else
            [TR.(PaddingFieldNames{pp})] = deal([]);
        end
    end
end


end
./MATLAB/+smi_core/@TrackingResults/computeTrajLengths.m
function [NObservations] = computeTrajLengths(TR)
%computeTrajLengths computes the length of trajectories in TR.
% This method computes the length (number of observations) in each
% trajectory in TR.
% 
% INPUTS:
%   TR: Tracking Results structure.
% 
% OUTPUTS:
%   NObservations: Length of each trajectory in TR.  The indexing is 
%                  matched to TR, e.g., trajectory TR(m) had a duration of
%                  NObservations(m) frames. (frames)
% 
% CITATION:

% Created by:
%   David J. Schodt (Lidke Lab, 2022)


% Compute the trajectory lengths.
NObservations = cellfun(@numel, {TR.FrameNum}.');


end
./MATLAB/+smi_core/@TrackingResults/convertTRToSMD.m
function [SMD] = convertTRToSMD(TR)
%convertTRToSMD converts a TR back into an SMD structure.
% This method acts as the inverse of convertSMDToTR().
% 
% INPUTS:
%   TR: Tracking Results.  The TR structure is a structure array containing
%       several fields present in the SMD structure but reorganized such
%       that each element of TR, e.g., TR(7), corresponds to a single
%       unique trajectory.
% 
% OUTPUTS:
%   SMD: Single Molecule Data structure with a properly populated field
%        'ConnectID'.
% 
% CITATION:

% Created by:
%   David J. Schodt (Lidke Lab, 2022)


% Create an empty SMD structure, ending after this piece of code if no TR
% was input (it might sometimes be useful to produce an empty SMD
% structure).
SMD = smi_core.SingleMoleculeData.createSMD();
if (~exist('TR', 'var') || isempty(TR))
    return
end

% Loop through each trajectory in TR and place its localizations in the
% output SMD.
for ii = 1:length(TR)
    TR(ii).IndSMD = {TR(ii).IndSMD};
    SMD = smi_core.SingleMoleculeData.catSMD(SMD, TR(ii), false, false);
end

% Fix some fields that don't exactly match our expectations.
SMD.IndSMD = {};
SMD.ConnectID = ones(size(SMD.FrameNum));
NLoc = smi_core.TrackingResults.computeTrajLengths(TR);
NLocCumulative = [0; cumsum(NLoc)];
for ii = 1:length(TR)
    IndArray = (1:NLoc(ii)) + NLocCumulative(ii);
    SMD.ConnectID(IndArray) = TR(ii).ConnectID * ones(NLoc(ii), 1);
end


end
./MATLAB/+smi_core/@TrackingResults/getTRIndex.m
function [TRIndex] = getTRIndex(TR, TrajectoryIDs)
%getTRIndex returns the indices in TR corresponding to TrajectoryIDs.
% This method determines the indices in TR which contain info. about the
% trajectories 'TrajectoryIDs'.  For example, If TR(n).TrajectoryID = m, 
% getTRIndex(TR, m) will return n.
% 
% INPUTS:
%   TR: Tracking Results structure.
%   TrajectoryIDs: Array of trajectory IDs present in TR which will be
%                  joined together. (integer array)
%
% OUTPUTS:
%   TRIndex: Indices in the input TR structure corresponding to the
%            input TrajectoryIDs. If the requested TrajectoryID wasn't
%            found, the corresponding index is returned as NaN. 
%            (integer array, same size as TrajectoryIDs)

% Created by:
%   David J. Schodt (Lidke Lab, 2021)


% Ensure TrajectoryIDs is a row vector (see usage in find() below).
if iscolumn(TrajectoryIDs)
    TrajectoryIDs = TrajectoryIDs.';
end

% Find the requested indices in TR.
% NOTE: We need the ~ for the second output of find() because requesting
%       that output produces the desired behavior.  If it's removed, find()
%       returns a "column stacked" index which we'd have to convert
%       ourselves.
TrajectoryIDAll = cell2mat({TR.TrajectoryID}.');
[TRIndexTemp, ~] = find(TrajectoryIDAll == TrajectoryIDs);
TRIndex = NaN(numel(TrajectoryIDs), 1);
TRIndex(ismember(TrajectoryIDs, TrajectoryIDAll)) = TRIndexTemp;


end
./MATLAB/+smi_core/GaussMLE.m
classdef GaussMLE < handle
    % GaussMLE Maximum Likelihood Estimate of 2D Gaussian blob parameters
    %
    % GaussMLE fits a 2D Gaussian blob model to the each image in a stack of 2D
    % images.  Several fit types are available. The MLE is maximized with an
    % iterative Newton-Raphson method and implemented on GPU using NVIDIA
    % CUDA as described by Smith et al.
    %
    % The input is assumed to be gain and offset corrected so that
    % pixel values indicate effective photon counts. Noise model is 'Poisson',
    % which is suitable for EMCCD cameras used at high gain, or 'SCMOS' which
    % includes a pixel-wise readnoise as described by Huang et al.
    %
    % REQUIRES:
    %   MATLAB 2014a or later versions
    %   Parallel Procesing Toolbox
    %   NVidia GPU
    %   smi_cuda_FindROI.ptx
    %   smi_cuda_FindROI.cu
    %
    % CITATION:
    %   Smith, C., Joseph, N., Rieger, B. et al.
    %   Fast, single-molecule localization that achieves theoretically minimum
    %   uncertainty. Nat Methods 7, 373375 (2010).
    %   https://doi.org/10.1038/nmeth.1449
    %
    %   Huang, F., Hartwich, T., Rivera-Molina, F. et al. Video-rate nanoscopy
    %   using sCMOS cameraspecific single-molecule localization algorithms.
    %   Nat Methods 10, 653658 (2013).
    %   https://doi.org/10.1038/nmeth.2488
    
    
    properties
        Data                %Stack of 2D subregions (NxNxM)
        FitType='XYNB'      %One of {'XYNB','XYNBS','XYNBSXSY','XYZNB'} (Default='XYNB')
        Iterations=20;      %Newton-Raphson iterations
        CameraType='EMCCD'  %One of {'EMCCD','SCMOS'} (Default='EMCCD')
        PSFSigma=1.3        %Known or initial PSF Sigma (Pixels) Scalar or [SigmaX SigmaY] (Default=1.3)
        VarianceIm      %The variance image used for SCMOS noise model (Optional)
        XBoxCorner      %Location of fit box within VarianceIm (Pixel) (Optional)
        YBoxCorner      %Location of fit box within VarianceIm (Pixel) (Optional)
        ZFitStruct      %Structure for astigmatic fitting with fields:
            Ax      %
            Ay
            Bx
            By
            Gamma
            D
        Statistics      %Structure with compuational performance info
        SMD
    end
    
    methods
        
        function [obj]=GaussMLE(SMF,Data)
        %   %GaussMLE Create a GaussMLE object
        %[obj]=GaussMLE(Data,SMF)
        %
        % [obj]=GaussMLE()
        % Creates an object with default property values.
        %
        % [obj]=GaussMLE(SMF)
        % Creates an object and copies SMF fields to Properties
        %
        % [obj]=GaussMLE(SMF,Data)
        % Creates an object and copies Data and SMF fields to Properties
        %
        % INPUTS
        %   
        %   SMF:    SMF structure with fields (Optional)
        %       Fitting:
        %           PSFSigma: Sigma of 2D Gaussian PSF Model (Pixels)
        %   Data:   Stack of 2D images (Optional)
        %
        % OUTPUTS
        %   obj:    FindROI object
        %
        
            if nargin > 0
                obj.FitType=SMF.Fitting.FitType;
                obj.PSFSigma=SMF.Fitting.PSFSigma;
                obj.Iterations=SMF.Fitting.Iterations;
                obj.CameraType=SMF.Data.CameraType;
                obj.VarianceIm=SMF.Data.CameraReadNoise;
                obj.ZFitStruct=SMF.Fitting.ZFitStruct;
            end
            
            if nargin > 1
                obj.Data=Data;
            end
        
        end
        
        
        function [Results, Statistics]=gaussMLE(obj,SMD)
        %gaussMLE Fits 2D stack of images to Gaussian blob model     
        %
        % INPUTS:
        %   SMD:        SMD structure to be modified (Optional)
        % OUTPUTS:
        %   Results     SMD stucture with modified fields:
        %       X:          Found position in X (Mx1)(Pixels)
        %       Y:          Found position in Y (Mx1)(Pixels)
        %       Z:          Found position in Z (Mx1)(microns) ('XYZNB')
        %       Photons:    Found number of photons from emitter (Mx1)     
        %       Bg:         Found background (Photons/Pixel) (Mx1)
        %       PSFSigma    Found PSFSigma (Mx1)or(Mx2)(Pixels) ('XYNBS','XYNBSXSY')
        %       X_SE:           Uncertainly as standard error (Mx1)
        %       Y_SE:           Uncertainly as standard error (Mx1)
        %       Z_SE:           Uncertainly as standard error (Mx1)
        %       Photons_SE:     Uncertainly as standard error (Mx1)
        %       Bg_SE:          Uncertainly as standard error (Mx1)
        %       PSFSigma_SE     Uncertainly as standard error (Mx1)or(Mx2)
        %       LogLikelihood:  Log likelihood at MLE (Mx1)
        %       PValue:         PValue (Mx1)
        %
        % REQUIRES:
        %       Parallel Computing Toolbox
        %       NVidia GPU
        %       smi_cuda_gaussMLEv2.cu
        %       smi_cuda_gaussMLEv2.ptx
        %
        
        if nargin<2
            SMD=smi_core.SingleMoleculeData.createSMD();
        end
        Results=SMD;
        
        %Set up kernels and number of parameters
        switch obj.FitType
            case 'XYNB'
                NP=4;
                KernelID='_XYNB_';
            case 'XYNBS'
                NP=5;
                KernelID='_XYNBS_';
            case 'XYZNB'
                NP=5;
                KernelID='_XYNBZ_';
            case 'XYNBSXSY'
                NP=6;
                KernelID='_XYNBSXSY_';
        end
        
        switch obj.CameraType
            case 'SCMOS'
                KernelID=['_SCMOS' KernelID(2:end)];
        end
        
        k = parallel.gpu.CUDAKernel('smi_cuda_gaussMLEv2.ptx','smi_cuda_gaussMLEv2.cu',KernelID);
        
        N=size(obj.Data,3);
        SZ=size(obj.Data,1);
        G=gpuDevice();
        AM=G.AvailableMemory;
        BytesPerFloat=4;
        MemoryPerFit=BytesPerFloat*(SZ*SZ+NP+NP+1); %Data plus outputs
        MaxFits=floor(AM/MemoryPerFit/2); %Factor of 2 to be conservative
        
        BSZ=128; %Threads per block hard-coded into kernel
        NKernelsCalls = ceil(N/MaxFits);
        NFitsPerCall=min(MaxFits,N);
        
        %Setup output arrays
        Params_out=zeros(N,NP,'single');
        CRLB_out=zeros(N,NP,'single');
        LL_out=zeros(N,1,'single');
        
        tic
        for nn=1:NKernelsCalls
            StartIndex=(nn-1)*NFitsPerCall+1;
            EndIndex=min((nn+1)*NFitsPerCall,N); %Don't go past data size
            NFitsActual = EndIndex-StartIndex+1;
            SubData=obj.Data(:,:,StartIndex:EndIndex);
            k.GridSize = [ceil(NFitsActual/BSZ) 1];
            k.ThreadBlockSize = [BSZ 1];
            d_Parameters=zeros(NFitsActual,NP,'single');
            d_CRLBs=zeros(NFitsActual,NP,'single');
            d_LogLikelihood=zeros(NFitsActual,1,'single');
            switch obj.CameraType
                case 'EMCCD'
                    switch obj.FitType
                        case {'XYNB','XYNBS','XYNBSXSY'}
                            [P, CRLB,LL] = feval(k,SubData,mean(obj.PSFSigma),SZ,obj.Iterations,d_Parameters,d_CRLBs,d_LogLikelihood,NFitsActual);
                        case 'XYZNB'
                            [P, CRLB,LL] = feval(k,SubData,obj.PSFSigma(1),...
                                obj.ZFitStruct.Ax,obj.ZFitStruct.Ay, obj.ZFitStruct.Bx, obj.ZFitStruct.By,obj.ZFitStruct.Gamma,obj.ZFitStruct.D,obj.PSFSigma,...
                                SZ,obj.Iterations,d_Parameters,d_CRLBs,d_LogLikelihood,NFitsActual);
                        otherwise
                            error('gaussMLE: Unknown fit type: %s',obj.FitType)
                    end
                    
                case 'SCMOS'
                    switch obj.FitType
                        case {'XYNB','XYNBS','XYNBSXSY'}
                            [P, CRLB,LL] = feval(k,SubData,[SMD.YBoxCorner, SMD.XBoxCorner],obj.VarianceIm,...
                                mean(obj.PSFSigma),SZ,size(obj.VarianceIm,1),obj.Iterations,...
                                d_Parameters,d_CRLBs,d_LogLikelihood,NFitsActual);
                        case 'XYZNB'
                            Z0=zeros(NFitsActual,1,'single');
                            [P, CRLB,LL] = feval(k,SubData,[SMD.YBoxCorner, SMD.XBoxCorner],obj.VarianceIm,Z0,...
                                obj.PSFSigma(1),obj.ZFitStruct.Ax,obj.ZFitStruct.Ay, obj.ZFitStruct.Bx,obj.ZFitStruct.By,...
                                obj.ZFitStruct.Gamma,obj.ZFitStruct.D,obj.PSFSigma(2),...
                                SZ,size(VarianceImage,1),obj.Iterations,d_Parameters,d_CRLBs,d_LogLikelihood,NFitsActual);
                        otherwise
                            error('gaussMLE: Unknown fit type: %s',obj.FitType)
                    end
                otherwise
                    error('gaussMLE: Unknown camera type: %s',obj.CameraType)
            end
            Params_out(StartIndex:EndIndex,:)=gather(P);
            CRLB_out(StartIndex:EndIndex,:)=gather(CRLB);
            LL_out(StartIndex:EndIndex)=gather(LL);
        end
        
        Results.Y=Params_out(:,1);
        Results.X=Params_out(:,2);
        Results.Photons=Params_out(:,3);
        Results.Bg=Params_out(:,4);
        Results.Y_SE=sqrt(CRLB_out(:,1));
        Results.X_SE=sqrt(CRLB_out(:,2));
        Results.Photons_SE=sqrt(CRLB_out(:,3));
        Results.Bg_SE=sqrt(CRLB_out(:,4));
        
        switch obj.FitType
            case 'XYNB'
                Results.PSFSigma = obj.PSFSigma * ones(size(Results.X));
            case 'XYNBS'
                Results.PSFSigma=Params_out(:,5);
                Results.PSFSigma_SE=sqrt(CRLB_out(:,5));
            case 'XYZNB'
                Results.Z=Params_out(:,5);
                Results.Z_SE=sqrt(CRLB_out(:,5));
            case 'XYNBSXSY'
                Results.PSFSigmaY=Params_out(:,5);
                Results.PSFSigmaX=Params_out(:,6);
                Results.PSFSigmaY_SE=sqrt(CRLB_out(:,5));
                Results.PSFSigmaX_SE=sqrt(CRLB_out(:,6));
        end
        Results.LogLikelihood=LL_out;
        
        %Calculate p values
        Results.PValue=smi_core.GaussMLE.pValue(NP,size(obj.Data,1), ...
            Results.LogLikelihood);
        
        Statistics.FitTime=toc;
        Statistics.FitPerSecond=N/Statistics.FitTime;
        Statistics.NKernelsCalls = NKernelsCalls;
        Statistics.NFitsPerCall=NFitsPerCall;
        end
        
    end
    
    methods (Static)
        function [PValue]=pValue(NParams,FitBoxSize,LLR)
        %pValue Calculate p values from Log Likelihood Ratio
        %
        % INPUTS 
        %   NParams:    Number of fit parameters
        %   FitBoxSize: Linear size of fit box (Pixels)
        %   LLR:        Log Likelihood Ratio
        % OUTPUTS
        %   PValue:     P value of fit
        %
            X2_CDF=@(k,x)gammainc(x/2,k/2);
            K=FitBoxSize^2-NParams;
            X2=-2*LLR;
            PValue=1-X2_CDF(K,X2);
        end
    end
end

./MATLAB/+smi_stat/frequencyMask.m
function [FreqMask, FreqSqEllipse, YMesh, XMesh, ZMesh] = ...
    frequencyMask(ImSize, FreqCutoff)
%frequencyMask prepares a boolean mask defining a frequency cutoff.
% This method prepares a boolean array that defines the indices of a
% Fourier transform image that are <= or > the cutoff frequency.  For
% Fourier transforms with radially increasing frequency (i.e., max
% frequency at center of image), the output mask defines signal below or at
% the cutoff frequency.  For Fourier transforms with radially decreasing
% frequency, the mask defines signal above the cutoff frequency.
%
% INPUTS:
%   ImSize: Size of the Fourier transform image, obtained by, e.g.,
%           size(FT). (RowsxColsxZ)
%   FreqCutoff: Cutoff (cuton) frequency of the mask (see note above).
%               (1/pixels)(Default = Nyquist frequency)           
%
% OUTPUTS:
%   FreqMask: Boolean array defining the indices to be masked. 
%             (1xprod(ImSize))
%   FreqSqEllipse: Ellipse defining the squared image frequencies (can be 
%                  restored to as an image by doing reshape(FreqEllipse, 
%                  ImSize)). This is defined by the convention that 
%                  frequency is radially increasing from the image center, 
%                  with each pixel defining the frequency at the pixel 
%                  center (as opposed to, e.g., the far edge of the pixel, 
%                  which would give a more restrictive mask). 
%                  (1xprod(ImSize))
%   YMesh, XMesh, ZMesh: Results from 
%                        meshgrid(1:ImSize(2), 1:ImSize(1), 1:ImSize(3)).
%                        This is the most expensive piece of this code, so
%                        it's returned just in case the user still needs
%                        it.

% Created by:
%   David J. Schodt (Lidke Lab 2021)


% Prepare defaults.
FNyquist = 0.5;
if (~exist('FreqCutoff', 'var') || isempty(FreqCutoff))
    % Define the default frequency as the Nyquist frequency 
    % FNyquist = FSampling / 2 = (1 sample/pixel)/2 = 0.5 / pixel
    FreqCutoff = FNyquist;
end

% Reshape and pad inputs if needed.
if isrow(ImSize)
    ImSize = ImSize.';
end
ImSize = padarray(ImSize, [3-numel(ImSize), 0], 1, 'post');

% Compute the image frequencies at each pixel of an image sized 'ImSize'.
[XMesh, YMesh, ZMesh] = meshgrid(1:ImSize(2), 1:ImSize(1), 1:ImSize(3));
FreqSqEllipse = ((YMesh-ImSize(1)/2-0.5) / (ImSize(1)/2)).^2 ...
    + ((XMesh-ImSize(2)/2-0.5) / (ImSize(2)/2)).^2 ...
    + ((ZMesh-ImSize(3)/2-0.5) / (ImSize(3)/2)).^2;

% Compute the binary mask.
% NOTE: FreqEllipse==1 lies right on the Nyquist frequency of the image,
%       so we can compare the ellipse to FreqCutoff * (RNyquist/FNyquist) =
%       FreqCutoff * (1/FNyquist) to get the desired cutoff.
FreqMask = (FreqSqEllipse > (FreqCutoff*(1/FNyquist))^2);


end
./MATLAB/+smi_stat/bootstrapFit.m
function [ParamsHat, ParamsHatSE] = bootstrapFit(XData, YData, ...
    ParamsInitialGuess, CostFunction, NBootstrap, FitOptions)
%bootstrapFit minimizes CostFunction and performs a basic boostrap.
% This function takes random samples (with replacement) from XData/YData
% and minimizes the associated cost function to find the parameters from
% that bootstrap. The output  FitParamsSE is the standard deviation of the
% NBootstrap fits. FitParams is the fit obtained for all of the data.
% Note that this approach may not be valid for all cost functions and data.
%
% NOTE: The Statistics and Machine Learning toolbox has several functions
%       for bootstrapping that may be better/more robust than this 
%       function. I've made this function to avoid the need for toolboxes.
%
% INPUTS:
%   XData: X data. (NDatax1 array)
%   YData: Y data. (NDatax1 array)
%   ParamsInitialGuess: Initial guess for the first input Params to the
%                       'CostFunction'. After the first bootstrap sample,
%                       this value will no longer be used (the first result
%                       will take its place).
%   CostFunction: Function handle which takes three inputs Params, XData,
%                 and YData, in that order. Params is an array containing
%                 the parameters that the cost function will be minimized
%                 with respect to. (Function handle)(Default = 
%                 sum((Params(1) + Params(2)*XData - YData).^2))
%   NBootstrap: Number of bootstrap samples to be made from the data.
%               (Default = 100)
%   FitOptions: Fit options sent directly to fminsearch (see doc fminsearch
%               for details)(Default = optimset(@fminsearch))
%
% OUTPUTS:
%   ParamsHat: Estimated fit parameters. (numeric array)
%   ParamsHatSE: Estimated standard errors in the fit parameters.
%                (numeric array)

% Created by:
%   David J. Schodt (Lidke lab, 2021)


% Set default parameters and reshape arrays as needed.
if isrow(XData)
    XData = XData.';
end
if isrow(YData)
    YData = YData.';
end
if isrow(ParamsInitialGuess)
    ParamsInitialGuess = ParamsInitialGuess.';
end
if (~exist('CostFunction', 'var') || isempty(CostFunction))
    CostFunction = @(Params, XData, YData) ...
        sum((Params(1) + Params(2)*XData - YData).^2);
end
if (~exist('NBootstrap', 'var') || isempty(NBootstrap))
    NBootstrap = 100;
end
if (~exist('FitOptions', 'var') || isempty(FitOptions))
    FitOptions = optimset(@fminsearch);
end

% Estimate ParamsHat (I'm not sure if this is appropriate. Should I instead
% use ParamsHat = mean(ParamsBootstrap) below? I don't think so, but I
% don't know for sure! -DJS).
CostFunctionSingleInput = @(Params) CostFunction(Params, XData, YData);
ParamsHat = ...
    fminsearch(CostFunctionSingleInput, ParamsInitialGuess, FitOptions);

% Perform the bootstrap.
NData =  numel(YData);
NParams = numel(ParamsInitialGuess);
ParamsBootstrap = zeros(NParams, NBootstrap);
for nn = 1:NBootstrap
    % Select our NData samples (with replacement) from the data and perform
    % the minimization.
    SampleIndices = randi(NData, NData, 1);
    
    % Prepare a cost function that can be passed to fminsearch.
    CostFunctionSingleInput = @(Params) CostFunction(Params, ...
        XData(SampleIndices), YData(SampleIndices));

    % Minimize the cost function.
    ParamsBootstrap(:, nn) = ...
        fminsearch(CostFunctionSingleInput, ParamsHat, FitOptions);
end
ParamsHatSE = std(ParamsBootstrap, [], 2);


end
./MATLAB/+smi_stat/computeHessian.m
function [HessianMatrix] = computeHessian(FunctionHandle, Location, ...
    DeltaHFraction, DeltaHBound)
%computeHessian computes the Hessian of FunctionHandle around ParamsHat.
% This method computes the Hessian matrix of the function handle
% FunctionHandle evaluated at Location.
%
% INPUTS:
%   FunctionHandle: A function handle which expects numel(Location)
%                   parameters, with the indices corresponding to those of
%                   Location.  FunctionHandle must output a single value.
%   Location: The arguments of FunctionHandle at which we'll estimate the
%             Hessian.
%   DeltaHFraction: Fraction of each element of Location, where the step 
%                   size (i.e., Delta h) along each dimension will be set
%                   to, e.g., h_n = DeltaHFraction*Location(n) subject to
%                   the bounds given in DeltaHBound.
%                   (Default = 1e-2 chosen arbitrarily)
%   DeltaHBound: Bounds to the step size Delta h.
%                ([min. value, max. value])
%                (Default = [1e-9; 1e-1] chosen arbitrarily)
%
% OUTPUTS:
%   HessianMatrix: The matrix containing an estimate of the Hessian of
%                  FunctionHandle evaluated at Location.
%                  (numel(Location) x numel(Location) numeric array)

% Created by:
%   David J. Schodt (Lidke Lab, 2021) based on an earlier code from
%       someone (unknown) in the Lidke lab


% Set defaults if needed.
if (~exist('DeltaHFraction', 'var') || isempty(DeltaHFraction))
    DeltaHFraction = 1e-2;
end
if (~exist('DeltaHBound', 'var') || isempty(DeltaHBound))
    DeltaHBound = [1e-9; 1e-1];
end

% Loop through the parameters and construct the Hessian element by element.
% NOTE: We do this by finding the numerical derivative of the function
%       handle w.r.t. the parameter Location(ii) at two different 
%       positions of Location(jj), and then finding the (1/DeltaH) scaled
%       difference between those two derivatives.
NParams = numel(Location);
HessianMatrix = zeros(NParams);
for ii = 1:NParams
    for jj = 1:NParams
        % Define the step sizes along each dimension for the derivative.
        DeltaI = min(DeltaHBound(2), ...
            max(DeltaHBound(1), DeltaHFraction*Location(ii)));
        DeltaJ = min(DeltaHBound(2), ...
            max(DeltaHBound(1), DeltaHFraction*Location(jj)));
        if (ii == jj)
            % Estimate the derivative of the function handle w.r.t.
            % parameter ii to the left of Location.
            InputParams1 = Location; % initialize
            InputParams2 = Location; % initialize
            InputParams1(ii) = Location(ii) - DeltaI;
            Derivative1 = (1/DeltaI) ...
                * (FunctionHandle(InputParams2) ...
                - FunctionHandle(InputParams1));
            
            % Estimate the derivative of the function handle w.r.t. 
            % parameter ii to the right of Location.
            InputParams1 = Location; % initialize
            InputParams2 = Location; % initialize
            InputParams2(ii) = Location(ii) + DeltaI;
            Derivative2 = (1/DeltaI) ...
                * (FunctionHandle(InputParams2) ...
                - FunctionHandle(InputParams1));
        else
            % Estimate the derivative of the function handle w.r.t. 
            % parameter ii at a set value of parameter jj (set jj to the 
            % left parameter value).
            InputParams1 = Location;
            InputParams2 = Location;
            InputParams1(ii) = Location(ii) - DeltaI/2;
            InputParams2(ii) = Location(ii) + DeltaI/2;
            InputParams1(jj) = Location(jj) - DeltaJ/2;
            InputParams2(jj) = Location(jj) - DeltaJ/2;
            Derivative1 = (1/DeltaI) ...
                * (FunctionHandle(InputParams2) ...
                - FunctionHandle(InputParams1));
            
            % Estimate the derivative of the function handle w.r.t. 
            % parameter ii at a different set value of parameter jj (set 
            % jj to the right parameter value).
            InputParams1 = Location;
            InputParams2 = Location; %
            InputParams1(ii) = Location(ii) - DeltaI/2;
            InputParams2(ii) = Location(ii) + DeltaI/2;
            InputParams1(jj) = Location(jj) + DeltaJ/2;
            InputParams2(jj) = Location(jj) + DeltaJ/2;
            Derivative2 = (1/DeltaI) ...
                * (FunctionHandle(InputParams2) ...
                - FunctionHandle(InputParams1));
        end
        
        % Compute Hessian(ii, jj) based on the difference between the above
        % two partial derivatives.
        HessianMatrix(ii, jj) = (1/DeltaJ) * (Derivative2-Derivative1);
    end
end


end
./MATLAB/+smi_stat/findOffsetIter.m
function [Shift, IntShift, CorrData, CorrParams, ShiftParams] = ...
    findOffsetIter(RefStack, MovingStack, NIterMax, Tolerance, ...
    CorrParams, ShiftParams)
%findOffsetIter estimates the sub-pixel shift between images.
% This method esimates the shift between 'RefStack' and 'MovingStack' by
% iteratively fitting a polynomial to a scaled cross-correlation between
% the stacks, shifting the stacks via FFT, and then re-computing the shift.
%
% INPUTS:
%   RefStack: Reference stack. (YSizexXSizexNImages)
%   MovingStack: Stack that has moved w.r.t. RefStack (YSizexXSizexNImages)
%   NIterMax: Maximum number of iterations. (Default = 5)
%   Tolerance: Tolerance of the shifts allowing early stopping before
%              NIterMax. That is, we stop before NIterMax when the newest
%              estimated shift is less than 'Tolerance'.
%              (3x1 float)(Default = [0; 0; 0])
%   CorrParams: Structure of parameters passed to smi_stat.findOffset().
%   ShiftParams: Structure of parameters passed to smi_stat.shiftImage()
%
% OUTPUTS:
%   Shift: Shift between the image stacks. ([Y; X; Z])
%   IntShift: Integer shift between the image stacks. ([Y; X; Z])
%
% CITATION:
%   Cross-correlation shift finding method:
%       Wester, M.J., Schodt, D.J., Mazloom-Farsibaf, H. et al. Robust,
%       fiducial-free drift correction for super-resolution imaging.
%       Sci Rep 11, 23672 (2021).
%       https://doi.org/10.1038/s41598-021-02850-7
%   Iterative idea motivated by https://doi.org/10.1117/12.603304 , noting
%       that the xcorr bias should approach zero as the shift approaches
%       zero.

% Created by:
%   David J. Schodt (Lidke Lab 2021)


% Set defaults/validate inputs.
if (~exist('NIterMax', 'var') || isempty(NIterMax))
    NIterMax = 5;
end
if (~exist('Tolerance', 'var') || isempty(Tolerance))
    Tolerance = [0; 0; 0];
end
StackSize = size(RefStack, 1:3);
if (~exist('CorrParams', 'var') || isempty(CorrParams) ...
        || ~isfield(CorrParams, 'FTSize') || isempty(CorrParams.FTSize))
    CorrParams.FTSize = 2 .^ nextpow2(StackSize);
end
if (~exist('ShiftParams', 'var') || isempty(ShiftParams))
    ShiftParams = struct([]);
end
Tolerance = padarray(Tolerance, max(0, sum(StackSize>1)-numel(Tolerance)), ...
    'post');

% Prepare a Nyquist mask for findStackOffset().
% NOTE: The extra scaling of FNyquist (which is 0.5) accounts for the size
%       difference between the Fourier transform and the input images.
if (~isfield(CorrParams, 'FTMask') || isempty(CorrParams.FTMask))
    FNyquist = 0.5 * (StackSize/CorrParams.FTSize);
    CorrParams.FTMask = smi_stat.frequencyMask(CorrParams.FTSize, FNyquist);
end

% Iteratively estimate the shift, plotting the correlation for the first
% iteration (the first iteration will ~show the actual shift, and if all
% goes well, the later iterations will show a nearly 0 shift).
[Shift, IntShift, CorrData, CorrParams] = ...
    smi_stat.findOffset(RefStack, MovingStack, CorrParams);
PlotFlagInit = CorrParams.PlotFlag;
CorrParams.PlotFlag = false;
NewShift = Shift;
ii = 1;
while (any(abs(NewShift)>Tolerance) && (ii<NIterMax))
    % Shift the image stack.
    ii = ii + 1;
    MovingStack =smi_stat.shiftImage(MovingStack, NewShift, ShiftParams);

    % Remove the border behind the shift direction (this border now
    % contains junk data that we don't want influencing the
    % cross-correlation).
    StackHalfWidth = floor(size(MovingStack, 1:3) / 2);
    for nn = 1:3
        BorderDirection = ...
            smi_helpers.arrayMUX({'pre', 'post'}, NewShift(nn) < 0);
        Border = [0, 0, 0];
        Border(nn) = ceil(abs(NewShift(nn)));
        if ((StackHalfWidth(nn)-Border(nn)) >= CorrParams.FitOffset(nn))
            % We should only remove the border if there is enough data to
            % still allow for a fit.
            MovingStack = smi_helpers.removeBorder(MovingStack, Border, ...
                BorderDirection);
            RefStack = smi_helpers.removeBorder(RefStack, Border, ...
                BorderDirection);
            CorrParams.BinaryMask = ...
                smi_helpers.removeBorder(CorrParams.BinaryMask, Border, ...
                BorderDirection);
        end
    end

    % Compute the shift.
    [NewShift, NewIntShift, CorrData, CorrParams] = ...
        smi_stat.findOffset(RefStack, MovingStack, CorrParams);
    Shift = Shift + NewShift;
    IntShift = IntShift + NewIntShift;
end
CorrParams.PlotFlag = PlotFlagInit;


end
./MATLAB/+smi_stat/bootstrapFitCon.m
function [ParamsHat, ParamsHatSE] = bootstrapFitCon(XData, YData, ...
    ParamsInitialGuess, CostFunction, NBootstrap, AMatrix, BVector, ...
    AEq, BEq, LowerBounds, UpperBounds, FitOptions)
%bootstrapFitCon minimizes CostFunction and performs a basic boostrap.
% This function takes random samples (with replacement) from XData/YData
% and minimizes the associated cost function subject to the provided
% constraints to find the parameters from that bootstrap. The output
% FitParamsSE is the standard deviation of the NBootstrap fits. FitParams
% is the fit obtained for all of the data.
%
% WARNING: Doing a bootstrap on a constrained fit (as is done here) may not
%          be valid in many/most cases. I've purposefully made this a 
%          separate function from bootstrapFit() in an attempt to make the
%          user aware of the risks being taken here.
%
% INPUTS:
%   XData: X data. (NDatax1 array)
%   YData: Y data. (NDatax1 array)
%   ParamsInitialGuess: Initial guess for the first input Params to the
%                       'CostFunction'. After the first bootstrap sample,
%                       this value will no longer be used (the first result
%                       will take its place).
%   CostFunction: Function handle which takes three inputs Params, XData,
%                 and YData, in that order. Params is an array containing
%                 the parameters that the cost function will be minimized
%                 with respect to. (Function handle)(Default =
%                 sum((Params(1) + Params(2)*XData - YData).^2))
%   NBootstrap: Number of bootstrap samples to be made from the data.
%               (Default = 100)
%   AMatrix: See 'A' input to fmincon(). (Default = [])
%   BVector: See 'b' input to fmincon(). (Default = [])
%   AEq: See 'Aeq' input to fmincon(). (Default = [])
%   BEq: See 'beq' input to fmincon(). (Default = [])
%   LowerBounds, UpperBounds: Please see the inputs to fmincon() for
%                             descriptions. Although my naming is
%                             different, the ordering is maintained.
%                             (Default = [] for all of these)
%   FitOptions: Fit options sent directly to fmincon (see doc fmincon
%               for details)(Default = optimoptions('fmincon'))
%
% OUTPUTS:
%   ParamsHat: Estimated fit parameters. (numeric array)
%   ParamsHatSE: Estimated standard errors in the fit parameters.
%                (numeric array)
%
% REQUIRES:
%   Optimization Toolbox (for fmincon())

% Created by:
%   David J. Schodt (Lidke lab, 2021)


% Set default parameters and reshape arrays as needed.
if isrow(XData)
    XData = XData.';
end
if isrow(YData)
    YData = YData.';
end
if isrow(ParamsInitialGuess)
    ParamsInitialGuess = ParamsInitialGuess.';
end
if (~exist('CostFunction', 'var') || isempty(CostFunction))
    CostFunction = @(Params, XData, YData) ...
        sum((Params(1) + Params(2)*XData - YData).^2);
end
if (~exist('NBootstrap', 'var') || isempty(NBootstrap))
    NBootstrap = 100;
end
if (~exist('AMatrix', 'var') || isempty(AMatrix))
    AMatrix = [];
end
if (~exist('BVector', 'var') || isempty(BVector))
    BVector = [];
end
if (~exist('AEq', 'var') || isempty(AEq))
    AEq = [];
end
if (~exist('BEq', 'var') || isempty(BEq))
    BEq = [];
end
if (~exist('LowerBounds', 'var') || isempty(LowerBounds))
    LowerBounds = [];
end
if (~exist('UpperBounds', 'var') || isempty(UpperBounds))
    UpperBounds = [];
end
if (~exist('FitOptions', 'var') || isempty(FitOptions))
    FitOptions = optimoptions('fmincon');
end

% Estimate ParamsHat (I'm not sure if this is appropriate. Should I instead
% use ParamsHat = mean(ParamsBootstrap) below? I don't think so, but I
% don't know for sure! -DJS).
CostFunctionSingleInput = @(Params) CostFunction(Params, XData, YData);
ParamsHat = fmincon(CostFunctionSingleInput, ParamsInitialGuess, ...
    AMatrix, BVector, AEq, BEq, LowerBounds, UpperBounds, [], FitOptions);

% Perform the bootstrap.
NData =  numel(YData);
NParams = numel(ParamsInitialGuess);
ParamsBootstrap = zeros(NParams, NBootstrap);
for nn = 1:NBootstrap
    % Select our NData samples (with replacement) from the data and perform
    % the minimization.
    SampleIndices = randi(NData, NData, 1);
    
    % Prepare a cost function that can be passed to fminsearch.
    CostFunctionSingleInput = @(Params) CostFunction(Params, ...
        XData(SampleIndices), YData(SampleIndices));
    
    % Minimize the cost function.
    ParamsBootstrap(:, nn) = ...
        fmincon(CostFunctionSingleInput, ParamsHat, ...
        AMatrix, BVector, AEq, BEq, LowerBounds, UpperBounds, ...
        [], FitOptions);
end
ParamsHatSE = std(ParamsBootstrap, [], 2);


end
./MATLAB/+smi_stat/findZOffset.m
function [Shift, IntShift, CorrData, Params] = ...
    findZOffset(Image, Stack, Params)
%findZOffset finds the offset between Image and Stack along Z.
% findZOffset() uses a cross-correlation fit by a polynomial to determine
% the z-shift between Image and Stack, where the central image in 'Stack' 
% defines the 0 coordinate.
%
% INPUTS:
%   Image: The image to be compared to 'Stack'. (MxNx1) 
%   Stack: The stack of images to be compared to Image. (MxNxNImages)
%   Params: Structure of parameters.
%           FitOffset: Maximum offset from the peak of the 
%                      cross-correlation curve for which data will be fit
%                      to determine 'Shift'. (Default = 2) 
%           BinaryMask: Mask to multiply the images before computing the
%                       shift. (Default = zeros(size(Image)))
%           PlotFlag: Specifies whether or not plot(s) will be generated.
%           UseGPU: Flag indicating GPU should be used.
%                   (boolean)(Default = false)
%           SuppressWarnings: Flag indicating we should suppress all
%                             warnings. (Default = false)
%
% OUTPUTS:
%   Shift: The approximate shift along z from 'Image' to the center image
%          in 'Stack'.
%   IntShift: The integer pixel offset of Image relative to Stack.
%   CorrData: Structure array containing the cross-correlation maxima
%             corresponding to MaxOffset as well as the fitting results 
%             which were used to determine 'Shift'.
%   Params: Input 'Params' padded with defaults/with values modified based
%           on the data.
% 
% REQUIRES:
%   MATLAB Parallel Computing Toolbox (if setting UseGPU = 1)
%   Supported NVIDIA CUDA GPU (if setting UseGPU = 1)
%
% CITATION:

% Created by:
%   David J. Schodt (LidkeLab 2021)


% Set default parameter values if needed.
ImSize = size(Image);
DefaultParams.FitOffset = 2;
DefaultParams.BinaryMask = ones(ImSize);
DefaultParams.PlotFlag = false;
DefaultParams.UseGPU = false;
DefaultParams.SuppressWarnings = false;
if (~exist('Params', 'var') || isempty(Params))
    Params = DefaultParams;
else
    Params = smi_helpers.padStruct(Params, DefaultParams);
end

% If requested, turn of warnings.
if Params.SuppressWarnings
    WarningState = warning('off');
end

% Convert the stacks to gpuArrays if needed.
if Params.UseGPU
    Image = gpuArray(Image);
    Stack = gpuArray(Stack);
    Params.BinaryMask = gpuArray(Params.BinaryMask);
end

% Ensure the stacks are floating point arrays.
% NOTE: If using the GPU, we should convert to single after sending the
%       stacks to the GPU with gpuArray() (it's faster this way).
Image = single(Image);
Stack = single(Stack);
Params.BinaryMask = single(Params.BinaryMask);

% Ensure that FitOffset is valid, modifying if needed.
NImages = size(Stack, 3);
if (Params.FitOffset > floor(NImages/2))
    warning('FitOffset = %i is too big and was reset to %i', ...
        Params.FitOffset, floor(NImages/2))
    Params.FitOffset = floor(NImages / 2);
end

% Scale each image in the stack by intensity to reduce linear trends in 
% the cross-correlation.
Stack = Stack ./ sum(Stack, [1, 2]);

% Whiten the image and apply the binary mask.
ImageMasked = Image .* Params.BinaryMask;
StackMasked = Stack .* repmat(Params.BinaryMask, [1, 1, NImages]);
ImageWhitened = (ImageMasked-mean(ImageMasked(:))) ...
    / (std(ImageMasked(:)) * sqrt(numel(ImageMasked)-1));

% Loop through images in the stack and compute the maximum of the
% cross-correlation.
XCorrMax = zeros(NImages, 1);
for nn = 1:NImages
    % Whiten the current stack image.
    CurrentIm = StackMasked(:, :, nn);
    CurrentIm = (CurrentIm-mean(CurrentIm(:))) ...
        / (std(CurrentIm(:)) * sqrt(numel(CurrentIm)-1));

    % Compute the maximum of the cross-correlation.
    XCorrMax(nn) = sum(Params.BinaryMask .* ImageWhitened .* CurrentIm, 1:2);
end

% Compute the integer offset between the two stacks.
[~, IndexOfMax] = max(XCorrMax);
ZeroImageInd = ceil(NImages / 2);
IntShift = ZeroImageInd - IndexOfMax;

% Fit a second order polynomial through the xcorr maxima to determine a
% sub-pixel offset.
XArray = (max(1, IndexOfMax-Params.FitOffset) ...
    : min(NImages, IndexOfMax+Params.FitOffset)).';
X = [ones(numel(XArray), 1), XArray, XArray.^2];
Beta = ((X.'*X) \ X.') * XCorrMax(XArray);
Shift = ZeroImageInd + Beta(2) / (2*Beta(3));
PolyFitFunction = @(R) Beta(1) + Beta(2)*R + Beta(3)*R.^2;

% Create arrays of the polynomial fits to use for visualization.
XArrayDense = linspace(XArray(1), XArray(end), max(ImSize));
FitAtPeak = PolyFitFunction(XArrayDense);

% Populate the CorrData struct.
CorrData.XCorrMax = XCorrMax;
CorrData.FitAtPeak = FitAtPeak;

% Display line sections through the integer location of the
% cross-correlation, overlain on the fit along those lines.
if Params.PlotFlag
    PlotFigure = findobj('Tag', 'CorrWindow');
    if isempty(PlotFigure)
        PlotFigure = figure('Tag', 'CorrWindow');
    end
    clf(PlotFigure);
    PlotAxes = axes(PlotFigure);
    plot(PlotAxes, ZeroImageInd - XArray, XCorrMax(XArray), 'x')
    hold(PlotAxes, 'on')
    plot(PlotAxes, ZeroImageInd - XArrayDense, FitAtPeak)
    title(PlotAxes, 'Max. Correlation') 
end

% Restore the warning state.
if Params.SuppressWarnings
    warning(WarningState)
end


end
./MATLAB/+smi_stat/shiftImage.m
function [ImageStack, Params] = shiftImage(ImageStack, Shift, Params)
%shiftImage shifts an image by the provided shift.
% This method uses the Fourier shift theorem to apply the provided 'Shift'
% to the 'ImageStack'.
% INPUTS:
%   ImageStack: Image(s) to be shifted. (YSizexXSizexNImages float)
%   Shift: Shift to be applied to ImageStack. (2x1 or 3x1 float)(YxXxZ)
%   Params: Structure of parameters.
%           UseGPU: Flag indicating GPU should be used. (Default = false)
%           RemoveEdges: Flag indicating false edges should be removed.
%                        For example, if we shift an image by 
%                        [0.3; -2.2; 1.6],
%                        we'll set row ceil(0.3)=1 to PadValue, column
%                        X-ceil(2.2)=X-3 to PadValue, and images
%                        1:ceil(1.6)=1:2 to PadValue. (Default = false)
%           PadValue: Value used to replace the removed periodic edges when
%                     RemoveEdges = true.  If set to [], PadValue will be
%                     set to mean(ImageStack(:)). (Default = [])
%
% OUTPUTS:
%   ImageStack: Shifted image stack. (YSizexXSizexNImages float)
%   Params: Input parameters padded with defaults.

% Created by:
%   David J. Schodt (Lidke Lab 2021)


% Set defaults.
DefaultParams.UseGPU = false;
DefaultParams.RemoveEdges = false;
DefaultParams.PadValue = [];
if (~exist('Params', 'var') || isempty(Params))
    Params = DefaultParams;
else
    Params = smi_helpers.padStruct(Params, DefaultParams);
end

% Validate inputs.
ImSize = size(ImageStack, 1:3);
Shift = padarray(Shift, max(0, sum(ImSize>1)-numel(Shift)), 'post');

% Fourier transform the image stack.
if Params.UseGPU
    ImageStack = gpuArray(ImageStack);
end
ImageStackFT = fftshift(fftn(ImageStack));

% Shift the coordinates and then mask signal beyond the Nyquist frequency.
FNyquist = 0.5;
[NyquistMask, ~, Ky, Kx, Kz] = smi_stat.frequencyMask(ImSize, FNyquist);
ShiftedImFT = ImageStackFT .* exp(-2*pi*1i*(Shift(1)*Ky/ImSize(1) ...
    + Shift(2)*Kx/ImSize(2) ...
    + Shift(3)*Kz/ImSize(3)));
ShiftedImFT(NyquistMask) = 0;

% Invert the image back to the spatial domain.
ImageStack = abs(ifftn(fftshift(ShiftedImFT)));

% Remove the periodic edges if requested.
if Params.RemoveEdges
    if isempty(Params.PadValue)
        Params.PadValue = mean(ImageStack(:));
    end
    YDelete = (1:min(ImSize(1), ceil(abs(Shift(1))))) ...
        + (Shift(1)<0)*mod(floor(Shift(1)), ImSize(1));
    ImageStack(YDelete, :, :) = Params.PadValue;
    XDelete = (1:min(ImSize(2), ceil(abs(Shift(2))))) ...
        + (Shift(2)<0)*mod(floor(Shift(2)), ImSize(2));
    ImageStack(:, XDelete, :) = Params.PadValue;
    ZDelete = (1:min(ImSize(3), ceil(abs(Shift(3))))) ...
        + (Shift(3)<0)*mod(floor(Shift(3)), ImSize(3));
    ImageStack(:, :, ZDelete) = Params.PadValue;
end
if Params.UseGPU
    ImageStack = gather(ImageStack);
end


end
./MATLAB/+smi_stat/findOffset.m
function [Shift, IntShift, CorrData, Params] = ...
    findOffset(Stack1, Stack2, Params)
%findOffset estimates a sub-pixel offset between two stacks of images.
% findOffset() will estimate the offset between two 3D stacks of
% images.  This method computes an integer pixel offset between the two
% stacks via a cross-correlation and then fits 2nd order polynomials to the
% resulting cross-correlation.  An estimate of a sub-pixel offset is then
% produced by determining the location of the peaks of the three (y, x, z)
% 2nd order polynomial fits.
%
% NOTE: The convention used here for the offset is based on indices as
%       follows: If Stack is a 3D stack of images, and
%       Stack1 = Stack(m:n, m:n, m:n)
%       Stack2 = Stack((m:n)+y, (m:n)+x, (m:n)+z)
%       then PixelOffset = findStackOffset(Stack1, Stack2) == [y; x; z]
% NOTE: All inputs besides Stack1 and Stack2 are optional and can be
%       replaced by [] (an empty array).
% NOTE: Stack1 and Stack2 must be the same size in all 3 dimensions
%       (y, x, and z)
%
% INPUTS:
%   Stack1: The stack to which Stack2 is compared to, i.e. Stack1 is the
%           reference stack. (MxNxO)
%   Stack2: The stack for which the offset relative to Stack1 is to be
%           determined. (MxNxO)
%   Params: Structure of parameters.
%           MaxOffset: Maximum offset between Stack1 and Stack2 to be
%                      considered in the calculation of 'Shift' and
%                      'IntShift'.  This also gets applied as a maximum
%                      shift for the output 'Shift'.
%                      (1x3)(Default = ceil(size(Stack1)/2))
%           FitOffset: Maximum offset from the peak of the
%                      cross-correlation curve for which data will be fit
%                      to determine 'Shift'.
%                      (1x3)(Default = [2; 2; 2])
%           SymmetrizeFit: Flag indicating we should attempt to symmetrize
%                          the fit offset points (sometimes the peak is off
%                          by +-1 due to noise, and this will attempt to
%                          shift the fit points to reflect that).
%                          (Default = true)
%           BinaryMask: Mask to multiply the stacks with before computing
%                       to cross-correlation.
%                       (MxNxO)(Default = ones(M, N, O))
%           FTSize: Size of the Fourier transform used internally.  It's
%                   best to set this to be a power of 2 along each
%                   dimension as doing so improves FFT speed.
%                   (Default = 2 ^ nextpow2(Stack1Size))
%           FTMask: Mask to apply to the Fourier domain cross-correlation
%                   before inverting. (FTSize array)
%           PlotFlag: Specifies whether or not plot(s) will be generated.
%           UseGPU: Flag indicating GPU should be used.
%                   (boolean)(Default = false)
%           SuppressWarnings: Flag indicating we should suppress all
%                             warnings. (Default = false)
%
% OUTPUTS:
%   Shift: The sub-pixel offset of Stack2 relative to Stack1, approximated
%          based on a 2nd order polynomial fit(s) to a scaled
%          cross-correlation. (3x1)([y; x; z])
%   IntShift: The integer pixel offset of Stack2 relative to Stack1,
%             determined based on the location of the peak of the xcorr
%             coefficient field between the two stacks. (3x1)([y; x; z])
%   CorrData: Structure array containing the scaled cross-correlation
%             corresponding to MaxOffset as well as the fitting results
%             which were used to determine 'Shift'.
%   Params: Input 'Params' padded with defaults/with values modified based
%           on the data.
%
% REQUIRES:
%   MATLAB Statistics and Machine Learning Toolbox (if setting
%       SymmetrizeFit = true)
%   MATLAB Parallel Computing Toolbox (if setting UseGPU = true)
%   Supported NVIDIA CUDA GPU (if setting UseGPU = true)
%
% CITATION:
%   Wester, M.J., Schodt, D.J., Mazloom-Farsibaf, H. et al. Robust,
%   fiducial-free drift correction for super-resolution imaging.
%   Sci Rep 11, 23672 (2021). https://doi.org/10.1038/s41598-021-02850-7

% Created by:
%   David J. Schodt (LidkeLab 2018)


% Set default parameter values if needed.
Stack1Size = size(Stack1, 1:3);
Stack2Size = size(Stack2, 1:3);
DefaultParams.MaxOffset = ceil(Stack1Size / 2);
DefaultParams.FitOffset = [2, 2, 2];
DefaultParams.SymmetrizeFit = true;
DefaultParams.BinaryMask = ones(Stack1Size);
DefaultParams.FTSize = 2 .^ nextpow2(Stack1Size);
DefaultParams.FTMask = [];
DefaultParams.PlotFlag = false;
DefaultParams.UseGPU = logical(gpuDeviceCount());
DefaultParams.SuppressWarnings = false;
if (~exist('Params', 'var') || isempty(Params))
    Params = DefaultParams;
else
    Params = smi_helpers.padStruct(Params, DefaultParams);
end
if isempty(Params.FTMask)
    Params.FTMask = ones(Params.FTSize);
elseif ~all(size(Params.FTMask, 1:3) == Params.FTSize)
    if ~Params.SuppressWarnings
        warning(['Params.FTMask reset to ones: size not ', ...
            'compatible with Params.FTSize.'])
    end
    Params.FTMask = ones(Params.FTSize);
end

% If requested, turn of warnings.
if Params.SuppressWarnings
    WarningState = warning('off');
end

% Ensure MaxOffset and FitOffset are row vectors.
if iscolumn(Params.MaxOffset)
    Params.MaxOffset = Params.MaxOffset.';
end
if iscolumn(Params.FitOffset)
    Params.FitOffset = Params.FitOffset.';
end

% Check if the stacks are actually stacks (i.e. multiple images in each
% stack).  If they are not, copy the given image to match the stack size of
% the other stack.
if ((Stack1Size(3)==1) || (Stack2Size(3)==1))
    % One of the two stacks is just a single image, copy that image to
    % match the size of the other stack.
    if (Stack1Size(3) < Stack2Size(3))
        % Stack1 is a single image: create copies of this image to ensure
        % Stack1 and Stack2 are the same size.
        Stack1 = repmat(Stack1, [1, 1, Stack2Size(3)]);
    elseif (Stack1Size(3) > Stack2Size(3))
        % Stack2 is a single image: create copies of this image to ensure
        % Stack1 and Stack2 are the same size.
        Stack2 = repmat(Stack2, [1, 1, Stack1Size(3)]);
    else
        % Both stacks contain only a single image.  Make these stacks of
        % two images so that we can still proceed with the shift finding in
        % the x and y dimensions.
        Stack1 = repmat(Stack1, [1, 1, 2]);
        Stack2 = repmat(Stack2, [1, 1, 2]);
    end

    % We no longer care about the z shift, so change the third element of
    % MaxOffset to 0 to reduce computation time.
    Params.MaxOffset(3) = 0;
    Params.FitOffset(3) = 0;
end

% Convert the stacks to gpuArrays if needed.
if Params.UseGPU
    Stack1 = gpuArray(Stack1);
    Stack2 = gpuArray(Stack2);
    Params.BinaryMask = gpuArray(Params.BinaryMask);
    Params.FTMask = gpuArray(Params.FTMask);
end

% Ensure the stacks are floating point arrays.
% NOTE: If using the GPU, we should convert to single after sending the
%       stacks to the GPU with gpuArray() (it's faster this way).
Stack1 = single(Stack1);
Stack2 = single(Stack2);
Params.BinaryMask = single(Params.BinaryMask);
Params.FTMask = single(Params.FTMask);

% Ensure that MaxOffset is valid.
% NOTE: This is just ensuring that the MaxOffset corresponds to shifts
%       between the two stacks that still maintain some overlap.
MaxAllowedOffset = max(0, floor(Params.FTSize / 2) - 1);
IndicesToModify = find(Params.MaxOffset > MaxAllowedOffset);
for ii = IndicesToModify
    warning('MaxOffset(%i) = %g is too big and was reset to %i', ...
        ii, Params.MaxOffset(ii), MaxAllowedOffset(ii))
    Params.MaxOffset(ii) = MaxAllowedOffset(ii);
end

% Scale each image in each stack by intensity to reduce linear trends in
% the cross-correlation.
Stack1 = Stack1 ./ sum(Stack1, [1, 2]);
Stack2 = Stack2 ./ sum(Stack2, [1, 2]);

% Whiten each image in the stack with respect to the entire stack, ignoring
% the parts which are covered by the BinaryMask when computing mean, std.,
% etc.
Stack1Masked = Stack1 .* Params.BinaryMask;
Stack2Masked = Stack2 .* Params.BinaryMask;
Stack1Whitened = (Stack1-mean(Stack1Masked(:))) ...
    / (std(Stack1Masked(:)) * sqrt(numel(Stack1Masked)-1));
Stack2Whitened = (Stack2-mean(Stack2Masked(:))) ...
    / (std(Stack2Masked(:)) * sqrt(numel(Stack2Masked)-1));

% Compute the 3D FFT's of each stack, padding with zeros before computing.
% Also, ensure that the Params.BinaryMask is reapplied.
Stack1PaddedFFT = fftn(Params.BinaryMask .* Stack1Whitened, Params.FTSize);
Stack2PaddedFFT = fftn(Params.BinaryMask .* Stack2Whitened, Params.FTSize);

% Compute the 3D cross-correlation in the Fourier domain.
XCorr3D = ...
    real(ifftn(conj(Stack1PaddedFFT) .* Stack2PaddedFFT .* Params.FTMask));

% Compute the binary cross-correlation for later use in scaling.
BinaryStackFFT = fftn(Params.BinaryMask, Params.FTSize);
XCorr3DBinary = ...
    real(ifftn(conj(BinaryStackFFT) .* BinaryStackFFT .* Params.FTMask));

% Scale the 3D cross-correlation by the cross-correlation of the
% zero-padded binary images (an attempt to reduce the bias to a [0, 0, 0]
% offset introduced by the zero-padded edge effects), scaling by
% max(XCorr3DBinary(:)) to re-convert to a correlation coefficient.
XCorr3D = (XCorr3D./XCorr3DBinary) * max(XCorr3DBinary(:));

% Shift the cross-correlation image such that an auto-correlation image
% will have it's energy peak at the center of the 3D image.
XCorr3D = circshift(XCorr3D, ceil(Params.FTSize/2) - 1);

% Define the indices within the cross-correlation that we wish to inspect.
CorrCenter = floor(Params.FTSize / 2) + rem(Params.FTSize, 2);
CorrOffsetIndicesY = (-Params.MaxOffset(2):Params.MaxOffset(2)) ...
    + CorrCenter(2);
CorrOffsetIndicesX = (-Params.MaxOffset(1):Params.MaxOffset(1)) ...
    + CorrCenter(1);
CorrOffsetIndicesZ = (-Params.MaxOffset(3):Params.MaxOffset(3)) ...
    + CorrCenter(3);

% Isolate the central chunk of the cross-correlation.
XCorr3D = XCorr3D(CorrOffsetIndicesY, ...
    CorrOffsetIndicesX, ...
    CorrOffsetIndicesZ);

% Fetch the cross-correlation result from the GPU (if needed).
if Params.UseGPU
    XCorr3D = gather(XCorr3D);
end

% Determine the integer offset between the two stacks.
[~, IndexOfMax] = max(XCorr3D(:));
[PeakRow, PeakColumn, PeakHeight] = ind2sub(size(XCorr3D), IndexOfMax);
RawOffsetIndices = [PeakRow; PeakColumn; PeakHeight];

% Define some arrays w.r.t. the integer offset.
YArray = (max(1, RawOffsetIndices(1)-Params.FitOffset(1)) ...
    : min(size(XCorr3D, 1), RawOffsetIndices(1)+Params.FitOffset(1))).';
YData = XCorr3D(YArray, RawOffsetIndices(2), RawOffsetIndices(3));
XArray = (max(1, RawOffsetIndices(2)-Params.FitOffset(2)) ...
    : min(size(XCorr3D, 2), RawOffsetIndices(2)+Params.FitOffset(2))).';
XData = XCorr3D(RawOffsetIndices(1), XArray, RawOffsetIndices(3)).';
ZArray = (max(1, RawOffsetIndices(3)-Params.FitOffset(3)) ...
    : min(size(XCorr3D, 3), RawOffsetIndices(3)+Params.FitOffset(3))).';
ZData = squeeze(XCorr3D(RawOffsetIndices(1), RawOffsetIndices(2), ZArray));

% If requested, attempt to "symmetrize" our fit points (sometimes the peak
% xcorr is +-1 off from the visual symmetry center due to noise, which
% might negatively affect fit results).
if Params.SymmetrizeFit
    % Symmetrize Z arrays.
    % NOTE: Experimentally, this asymmetry issue is more prevalent for Z,
    %       so it's probably best to resymmetrize Z first.
    NeighborInds = min(numel(ZData), ...
        max(1, Params.FitOffset(3) + [0, 2]));
    [~, MaxNeighborInd] = max(ZData(NeighborInds));
    ProposedInd = RawOffsetIndices(3) ...
        + (MaxNeighborInd==2) - (MaxNeighborInd==1);
    ProposedInd = min(size(XCorr3D, 3), max(1, ProposedInd));
    ZArrayProposed = (max(1, ProposedInd-Params.FitOffset(3)) ...
        : min(size(XCorr3D, 3), ProposedInd+Params.FitOffset(3))).';
    ZDataProposed = squeeze(...
        XCorr3D(RawOffsetIndices(1), RawOffsetIndices(2), ZArrayProposed));
    if (abs(skewness(ZDataProposed)) < abs(skewness(ZData)))
        RawOffsetIndices(3) = ProposedInd;
        ZArray = ZArrayProposed;
        ZData = ZDataProposed;
        YArray = (max(1, RawOffsetIndices(1)-Params.FitOffset(1)) ...
            : min(size(XCorr3D, 1), RawOffsetIndices(1)+Params.FitOffset(1))).';
        YData = XCorr3D(YArray, RawOffsetIndices(2), RawOffsetIndices(3));
        XArray = (max(1, RawOffsetIndices(2)-Params.FitOffset(2)) ...
            : min(size(XCorr3D, 2), RawOffsetIndices(2)+Params.FitOffset(2))).';
        XData = XCorr3D(RawOffsetIndices(1), XArray, RawOffsetIndices(3)).';
    end

    % Symmetrize Y arrays.
    NeighborInds = min(numel(YData), ...
        max(1, Params.FitOffset(1) + [0, 2]));
    [~, MaxNeighborInd] = max(YData(NeighborInds));
    ProposedInd = RawOffsetIndices(1) ...
        + (MaxNeighborInd==2) - (MaxNeighborInd==1);
    ProposedInd = min(size(XCorr3D, 1), max(1, ProposedInd));
    YArrayProposed = (max(1, ProposedInd-Params.FitOffset(1)) ...
        : min(size(XCorr3D, 1), ProposedInd+Params.FitOffset(1))).';
    YDataProposed = ...
        XCorr3D(YArrayProposed, RawOffsetIndices(2), RawOffsetIndices(3));
    if (abs(skewness(YDataProposed)) < abs(skewness(YData)))
        RawOffsetIndices(1) = ProposedInd;
        YArray = YArrayProposed;
        YData = YDataProposed;
        XArray = (max(1, RawOffsetIndices(2)-Params.FitOffset(2)) ...
            : min(size(XCorr3D, 2), RawOffsetIndices(2)+Params.FitOffset(2))).';
        XData = XCorr3D(RawOffsetIndices(1), XArray, RawOffsetIndices(3)).';
        ZArray = (max(1, RawOffsetIndices(3)-Params.FitOffset(3)) ...
            : min(size(XCorr3D, 3), RawOffsetIndices(3)+Params.FitOffset(3))).';
        ZData = squeeze(XCorr3D(RawOffsetIndices(1), RawOffsetIndices(2), ...
            ZArray));
    end

    % Symmetrize X arrays.
    NeighborInds = min(numel(XData), ...
        max(1, Params.FitOffset(2) + [0, 2]));
    [~, MaxNeighborInd] = max(XData(NeighborInds));
    ProposedInd = RawOffsetIndices(2) ...
        + (MaxNeighborInd==2) - (MaxNeighborInd==1);
    ProposedInd = min(size(XCorr3D, 2), max(1, ProposedInd));
    XArrayProposed = (max(1, ProposedInd-Params.FitOffset(2)) ...
        : min(size(XCorr3D, 2), ProposedInd+Params.FitOffset(2))).';
    XDataProposed = ...
        XCorr3D(RawOffsetIndices(1), XArrayProposed, RawOffsetIndices(3)).';
    if (abs(skewness(XDataProposed)) < abs(skewness(XData)))
        RawOffsetIndices(2) = ProposedInd;
        XArray = XArrayProposed;
        XData = XDataProposed;
        YArray = (max(1, RawOffsetIndices(1)-Params.FitOffset(1)) ...
            : min(size(XCorr3D, 1), RawOffsetIndices(1)+Params.FitOffset(1))).';
        YData = XCorr3D(YArray, RawOffsetIndices(2), RawOffsetIndices(3));
        ZArray = (max(1, RawOffsetIndices(3)-Params.FitOffset(3)) ...
            : min(size(XCorr3D, 3), RawOffsetIndices(3)+Params.FitOffset(3))).';
        ZData = squeeze(XCorr3D(RawOffsetIndices(1), RawOffsetIndices(2), ...
            ZArray));
    end
end

% Compute the integer offset between the two stacks.
IntShift = Params.MaxOffset.' - RawOffsetIndices + 1;
IntShift(isnan(IntShift)) = 0;

% Fit a second order polynomial through a line varying with y at the peak
% of the cross-correlation in x, z, and use that polynomial to predict an
% offset.  If possible, center the fit around the integer peak of the
% cross-correlation.
X = [ones(numel(YArray), 1), YArray, YArray.^2];
Beta = ((X.'*X) \ X.') * YData;
RawOffsetFitY = -Beta(2) / (2 * Beta(3));
PolyFitFunctionY = @(R) Beta(1) + Beta(2)*R + Beta(3)*R.^2;

% Fit a second order polynomial through a line varying with x at the peak
% of the cross-correlation in y, z.
X = [ones(numel(XArray), 1), XArray, XArray.^2];
Beta = ((X.'*X) \ X.') * XData;
RawOffsetFitX = -Beta(2) / (2 * Beta(3));
PolyFitFunctionX = @(R) Beta(1) + Beta(2)*R + Beta(3)*R.^2;

% Fit a second order polynomial through a line varying with z
% at the peak of the cross-correlation in x, y.
X = [ones(numel(ZArray), 1), ZArray, ZArray.^2];
Beta = ((X.'*X) \ X.') * ZData;
RawOffsetFitZ = -Beta(2) / (2 * Beta(3));
PolyFitFunctionZ = @(R) Beta(1) + Beta(2)*R + Beta(3)*R.^2;

% Compute the predicted offset based on the polynomial fits.
RawOffsetFit = [RawOffsetFitY; RawOffsetFitX; RawOffsetFitZ];

% Determine the predicted offset between the stack.
Shift = Params.MaxOffset.' - RawOffsetFit + 1;
Shift(isnan(Shift)) = 0;
Shift = min(Params.MaxOffset.', max(-Params.MaxOffset.', Shift));

% Create arrays of the polynomial fits to use for visualization.
XArrayDense = linspace(XArray(1), XArray(end), 8*Params.FitOffset(2));
YArrayDense = linspace(YArray(1), YArray(end), 8*Params.FitOffset(1));
ZArrayDense = linspace(ZArray(1), ZArray(end), 8*Params.FitOffset(3));
XFitAtPeak = PolyFitFunctionX(XArrayDense);
YFitAtPeak = PolyFitFunctionY(YArrayDense);
ZFitAtPeak = PolyFitFunctionZ(ZArrayDense);

% Populate the CorrData struct.
CorrData.XCorr3D = XCorr3D;
CorrData.XFitAtPeak = XFitAtPeak;
CorrData.YFitAtPeak = YFitAtPeak;
CorrData.ZFitAtPeak = ZFitAtPeak;

% Display line sections through the integer location of the
% cross-correlation, overlain on the fit along those lines.
if Params.PlotFlag
    PlotFigure = findobj('Tag', 'CorrWindow');
    if isempty(PlotFigure)
        PlotFigure = figure('Tag', 'CorrWindow');
    end
    clf(PlotFigure);
    PlotAxes = subplot(3, 1, 1, 'Parent', PlotFigure);
    plot(PlotAxes, -Params.MaxOffset(1):Params.MaxOffset(1), ...
        XCorr3D(:, RawOffsetIndices(2), RawOffsetIndices(3)), 'x')
    hold(PlotAxes, 'on')
    plot(PlotAxes, YArrayDense-Params.MaxOffset(1)-1, YFitAtPeak)
    title(PlotAxes, 'Y Correlation')
    PlotAxes = subplot(3, 1, 2, 'Parent', PlotFigure);
    plot(PlotAxes, -Params.MaxOffset(2):Params.MaxOffset(2), ...
        XCorr3D(RawOffsetIndices(1), :, RawOffsetIndices(3)), 'x')
    hold(PlotAxes, 'on')
    plot(PlotAxes, XArrayDense-Params.MaxOffset(2)-1, XFitAtPeak)
    title(PlotAxes, 'X Correlation')
    ylabel(PlotAxes, 'Correlation Coefficient')
    PlotAxes = subplot(3, 1, 3, 'Parent', PlotFigure);
    plot(PlotAxes, -Params.MaxOffset(3):Params.MaxOffset(3), ...
        squeeze(XCorr3D(RawOffsetIndices(1), RawOffsetIndices(2), :)), 'x')
    hold(PlotAxes, 'on')
    plot(PlotAxes, ZArrayDense-Params.MaxOffset(3)-1, ZFitAtPeak)
    title(PlotAxes, 'Z Correlation')
    xlabel(PlotAxes, 'Pixel Offset')
end

% Restore the warning state.
if Params.SuppressWarnings
    warning(WarningState)
end


end
./MATLAB/+smi_stat/README.md
### +smi_stat

+smi_stat is the namespace for various statistical functions and classes of
***smite***:
- [@ChangeDetection](@ChangeDetection/README.md):
  change detection analysis methods
- [@DiffusionEstimator](@DiffusionEstimator/README.md):
  diffusion estimation methods
- [@HMM](@HMM/README.md):
  hidden Markov model methods

---

Functions:
- **[bootstrapFit](bootstrapFit.m)**:
  minimizes CostFunction with constraints and performs a basic bootstrap
- **[bootstrapFitCon](bootstrapFitCon.m)**:
  minimizes CostFunction and performs a basic bootstrap
- **[computeHessian](computeHessian.m)**:
  computes the Hessian of FunctionHandle around ParamsHat
- **[findCoordAffine](findCoordAffine.m)**:
  finds an affine transform to transform Coords2 to Coords1
- **[findOffset](findOffset.m)**:
  estimates a sub-pixel offset between two stacks of images
- **[findOffsetIter](findOffsetIter.m)**:
  iteratively estimates the sub-pixel shift between images
- **[findZOffset](findZOffset.m)**:
  finds the offset between Image and Stack along Z
- **[frequencyMask](frequencyMask.m)**:
  prepares a boolean mask defining a frequency cutoff
- **[leastSquaresFit](leastSquaresFit.m)**:
  performs a least squares fit on the provided data
- **[shiftImage](shiftImage.m)**:
  shifts an image by the provided shift

./MATLAB/+smi_stat/leastSquaresFit.m
function [BetaHat, BetaHatSE] = leastSquaresFit(XData, YData, Weights, ...
    CovariateFunctions)
%leastSquaresFit performs a least squares fit on the provided data.
% This function computes a least squares fit for the paired data in XData,
% YData, and Weights.
%
% NOTE: The output 'BetaHatSE' is estimated in the "standard" way presented
%       for linear least squares fitting (at least, it's how I've seen it
%       in all sources I've found). It can be derived by manipulating 
%       var(Beta) = var((X.'*W*X) \ (X.'*W*YData)), estimating var(YData) 
%       by assuming YData(ii) ~ N(Model(ii), Sn(ii)), and then computing 
%       Sn = (1 / (NData-NCovariates)) * (WeightedResiduals).^2.
%
% INPUTS:
%   XData: X data. (NDatax1 array)
%   YData: Y data. (NDatax1 array)
%   Weights: Array of weights used for a weighted least squares fit. These
%            would usually be chosen to be (proportional to) the inverse of
%            the variance of the data in YData.
%            (NDatax1 array)(Default = ones(numel(YData), 1))
%   CovariateFunctions: Cell array of function handles of the "covariates"
%                       (I think covariates might actually mean the results
%                       of applying the function to XData but I'm not
%                       sure). (cell array of function handles)
%                       (Default = {@(X) ones(numel(X), 1); @(X) X},
%                       which is just a line)
%
% OUTPUTS:
%   BetaHat: Estimated fit parameters. (NCovariatesx1 array)
%   BetaHatSE: Estimated standard errors in the fit parameters.
%              (NCovariatesx1 array)

% Created by:
%   David J. Schodt (Lidke lab, 2021)


% Set default parameters and reshape arrays as needed.
NData = numel(YData);
if (~exist('Weights', 'var') || isempty(Weights))
    Weights = ones(NData, 1);
end
if (~exist('CovariateFunctions', 'var') || isempty(CovariateFunctions))
    CovariateFunctions = {@(X) ones(numel(X), 1); @(X) X};
end
if isrow(XData)
    XData = XData.';
end
if isrow(YData)
    YData = YData.';
end

% Prepare the X matrix (I'm not sure what it's called, but X is standard
% notation).
NCovariates = numel(CovariateFunctions);
X = zeros(NData, NCovariates);
for ii = 1:NCovariates
    X(:, ii) = CovariateFunctions{ii}(XData);
end

% Perform the least squares fit.
WeightsMatrix = diag(Weights);
XTransposeWXInverse = inv(X.' * WeightsMatrix * X);
BetaHat = XTransposeWXInverse * (X.'*WeightsMatrix*YData);
SumOfWeightedSqResiduals = sum(Weights .* (X*BetaHat-YData).^2);
YDataVarianceEstimate = SumOfWeightedSqResiduals / (NData-NCovariates);
BetaHatSE = sqrt(abs(diag(XTransposeWXInverse * YDataVarianceEstimate)));


end
./MATLAB/+smi_stat/@ChangeDetection/unitTest.m
% Test calling smi_stat.ChangeDetection routines.
function success = unitTest()

success = 0;

SaveDir = smi_helpers.mkSMITETmpDir('unitTest', 'ChangeDetection');

% This script demonstrates the basic usage of the smi_stat.ChangeDetection class.

%% simulate data
NObservations = 50;  % Scalar integer: length of data sequence
ChangePoints = round([0.2,0.6]*NObservations); %vector: indexs of change point locations
Intensity = [200,100,60]; %vector: length=length(ChangePoints)+1: mean intensities for each subinterval
Data=smi_stat.ChangeDetection.simulate(NObservations, ChangePoints, Intensity);

% change detection
LogBayesThreshold = 10;
Icp = smi_stat.ChangeDetection(Data,LogBayesThreshold);
Icp.plotIntensityEstimate();
IntensityModel = Icp.IntensityModel; % intensity of the model sequence (no noise)
saveas(gcf, fullfile(SaveDir, 'CD1.png'));

%% alternative simulation methods
% given change points
NObservations = 50;  % Scalar integer: length of data sequence
ChangePoints = round([0.2,0.6]*NObservations); %vector: indexs of change point locations
Intensity = [200,100,60]; %vector: length=length(ChangePoints)+1: mean intensities for each subinterval
LogBayesThreshold = 10;
Data=smi_stat.ChangeDetection.simulate(NObservations, ChangePoints, Intensity);

[Icp,F]=smi_stat.ChangeDetection.plotSimulatedEstimate(NObservations, ChangePoints, Intensity, LogBayesThreshold);
saveas(gcf, fullfile(SaveDir, 'CD2.png'));

%% random change points
NObservations = 50;  % Scalar integer: length of data sequence
NChangePoints = 2; % Scalar integer: number of change points to simulate
Meanintensity = 100; % scalar for mean intensity.  Intensities are uniformly distributed on [1, 2*meanIntensity]
LogBayesThreshold = 10;
[Icp,F]=smi_stat.ChangeDetection.plotRandSimulatedEstimate(NObservations, NChangePoints, Meanintensity, LogBayesThreshold);
saveas(gcf, fullfile(SaveDir, 'CD3.png'));

success = 1;

end

./MATLAB/+smi_stat/@ChangeDetection/fitClusterIntensity.m
function icp=fitClusterIntensity( data, logBayesThreshold, plotit)
    if nargin==2
        plotit=false;
    end
    data=round(data);
    firstZero=find(~data,1);
    if ~isempty(firstZero)
        assert(firstZero>1); %The data does not start with a 0
        positiveData=data(1:firstZero-1);
        assert(all(positiveData>0)); %Check we got all non-zero values
        assert(all(data(firstZero:end)==0)); %Check we did not leave any photons behind
        data=positiveData;
    end
    data=data(3:end);
    icp=smi_stat.ChangeDetection(data, logBayesThreshold);
    if plotit
        icp.plotIntensityEstimate();
    end
end

./MATLAB/+smi_stat/@ChangeDetection/private/logSum.m
% Mark J. Olah [mjo@cs.unm.edu]
% 2014
function logS = logSum(varargin)
    % This allows for efficient computation of the log of the sum
    % of a bunch of values that are only known in logarithm.
    % Returns logS = log(sum(exp(logX)))
    if nargin==2
        log_a = max(varargin{1},varargin{2});
        delta = abs(varargin{1}-varargin{2});
        if delta > 20
            logS = log_a + log1p(exp(-delta));
        else
            logS = log_a + log(1+exp(-delta));
        end        
    else
        if nargin==1
            logX=varargin{1};
        else
            logX=[varargin{:}];
        end
        C = max(logX);
        logX = logX-C;
        MIN_LOG = -1e2;
        logS = C + log(sum(exp( logX(logX>MIN_LOG) )));
    end
end

./MATLAB/+smi_stat/@ChangeDetection/private/logFactorialSum.m
% Mark J. Olah (mjo@cs.unm.edu)
%
% 06-2014
%
function LF=logFactorialSum(data)
    %
    % Compute the sum of the log of the factorial of all value in an array of values.
    % For numbers less than the threshold, we compute the factorial directly
    % For larger values we use stirlings approximation with the first order
    % correction term.
    %
    % Inputs:
    %   data: vector of integers to take log factorial of
    %
    % Outputs:
    %   LF: A scalar = sum(log(factorial(data))).
    threshold=30;
    bigvals=data(data>threshold);
    smallvals=data(data<=threshold);
    LFsmall=sum(log(factorial(smallvals)));
    LFbig=sum(bigvals.*log(bigvals)-bigvals+0.5*log(2*pi*bigvals));
    LF=LFbig+LFsmall;
end

./MATLAB/+smi_stat/@ChangeDetection/private/logFactorial.m
% Mark J. Olah (mjo@cs.unm.edu)
%
% 06-2014
%

function LF=logFactorial(data)
    %
    % Compute the log of the factorial of each value in an array of values.
    % For numbers less than the threshold, we compute the factorial directly
    % For larger values we use stirlings approximation with the first order
    % correction term.
    %
    % Inputs:
    %   data: vector of integers to take log factorial of
    %
    % Outputs:
    %   LF: A vector of the same size as the inputs where each value is
    %       log(data(i)!).
    threshold=30;
    bigvals=data(data>threshold);
    smallvals=data(data<=threshold);
    LFsmall=log(factorial(smallvals));
    LFbig=bigvals.*log(bigvals)-bigvals+0.5*log(2*pi*bigvals);
    LF=zeros(size(data));
    LF(data<=threshold)=LFsmall;
    LF(data>threshold)=LFbig;
end

./MATLAB/+smi_stat/@ChangeDetection/README.md
### +smi_stat/@ChangeDetection

ChangeDetection contains methods for change detection analysis.
This class contains several methods used to detect change points 
from a sequence of intensity data, e.g. intensity trace from 
single-particle tracking.

See reference:
Daniel L. Ensign and Vijay S. Pande, Bayesian (2010), 
Detection of Intensity Changes in Single Molecule and 
Molecular Dynamics Trajectories, J. Phys. Chem. B 2010
https://doi.org/10.1021/jp906786b

---

```
properties:
   % Input variables

   Data;   % Input data given to constructor or set with setData
   LogBayesThreshold; % Input threshold for deciding on signficance level of
                      % Bayes factors
   Nobservations;     % Length of data

   % Output variables

   NchangePoints;   % The number of change points detected
   ChangePoints;    % The discrete times at which a change point was detected
                    % (size=NchangePoints)
   Intensity;       % The mean intensities for each subsequence
                    % (size=NchangePoints+1)
   IntensityModel;  % Intensity of model sequence
   LogBayesFactors; % The Bayes factors for each accepted change points
                    % (size=NchangePoints)
   NrejectedChangePoints;   % The number of rejected change points
   RejectedChangePoints;    % The rejected change points
                            % (size=NrejectedChangePoints)
   RejectedLogBayesFactors; % The Bayes factors for each rejected change points
                            % (size=NrejectedChangePoints)
```
---

Function **estimateChangePoints**(Data,LogBayesFactorThreshold)
is the main recursive method for identifiying change points
since it and other helper methods work on parts of the data set
recursively we make it a static method that takes in only the
portion of the data that it is to operate on

For a detailed example, see
[Example_ChangeDetection.m](../../examples/Example_ChangeDetection.m).

./MATLAB/+smi_stat/@ChangeDetection/ChangeDetection.m
classdef ChangeDetection < handle
    %ChangeDetection contains methods for change detection analysis.
    % This class contains several methods used to detect change points 
    % from a sequence of intensity data, e.g. intensity trace from 
    % single-particle tracking.
    %
    % See reference 
    % Daniel L. Ensign and Vijay S. Pande, Bayesian (2010), 
    % Detection of Intensity Changes in Single Molecule and 
    % Molecular Dynamics Trajectories, J. Phys. Chem. B 2010
    % https://doi.org/10.1021/jp906786b
    % 
    % Created by:
    %   Mark J. Olah (Lidke Lab, 2014)

    properties (SetAccess=protected)
        %Input variables
        Data; % Input data given to constructor or set with setData
        LogBayesThreshold; % Input threshold for deciding on signficance level of bayes factors
        Nobservations; % Length of data

        %Output variables
        NchangePoints; % Output - The number of change points detected
        ChangePoints; % Output - The discrete times at which a change point was detected (size=NchangePoints)
        Intensity; % Output - The mean intensities for each subsequence  (size=NchangePoints+1)
        IntensityModel; % Output - Intensity of model sequence
        LogBayesFactors; % Output - The bayes factors for each accepted change points (size=NchangePoints)
        NrejectedChangePoints; % Output - The number of rejected change points
        RejectedChangePoints;  % Output - The rejected change points (size=NrejectedChangePoints)
        RejectedLogBayesFactors;  % Output - The bayes factors for each rejected change points (size=NrejectedChangePoints)
    end

    methods
        function obj=ChangeDetection(Data, LogBayesThreshold)
            % Inputs:
            %   data: a vector of integer values representing poission
            %       distributed values from a sequence where the mean of the poisson
            %       process changes at discrete times
            %   LogBayesThreshold: the log of the Bayes factor to accept a
            %       change point with.  Should be positive. Larger values will estimate 
            %       fewer change points.  Values will need to be larger when the counts 
            %       in the data are bigger.   Start with 1e1 and increase as needed for lower
            %       sensitivity.
            obj.setData(Data, LogBayesThreshold);
        end

        function setData(obj, Data, LogBayesThreshold)
            % Inputs:
            %   Data: a vector of integer values representing poission
            %       distributed values from a sequence where the mean of the poisson
            %       process changes at discrete times
            %   LogBayesThreshold: the log of the Bayes factor to accept a
            %       change point with.  Should be negative. Smaller values will estimate fewer change
            %       points.  Values will need to be smaller when the counts in the
            %       data are bigger.   Try something in the range of -10 to -1E6.
            if ~isvector(Data)
                error('ChangePoint:setData','data must be a vector')
            end
            if ~all(round(Data)==Data)
                error('ChangePoint:setData','data must be integer valued')
            end
            obj.Data=Data;
            obj.Nobservations=length(obj.Data);
            if nargin==3
                if LogBayesThreshold<=0
                    error('ChangePoint:setData','logBayesThreshold should be positive')
                end
                obj.LogBayesThreshold=LogBayesThreshold;
            end
            obj.estimateSequence();
        end
        
        function F=plotIntensityEstimate(obj)
            % plot estimated step trace and probablity of change point at
            % each observation
            F=figure();
            xs=1:obj.Nobservations;
            subplot(2,1,1);
            stairs(xs, obj.Data, '-ko');
            hold on;
            Is=obj.IntensityModel;
            stairs(xs, Is, '-r', 'LineWidth', 2.0);
            yl=ylim;
            ylim([0,yl(2)]);
            hold off;
            xlabel('time');
            ylabel('intensity');
            legend('Data', 'Estimated', 'Location', 'North');
            subplot(2,1,2);
            xs=2:obj.Nobservations;
            pCP=arrayfun(@(CP) smi_stat.ChangeDetection.logP_H2(obj.Data,CP), xs);
            plot(xs, pCP, '-ko');
            xlabel('time');
            ylabel('logP(cp|H_2)');
        end
    end %public methods

    methods(Static=true)
        success = unitTest()

        function Data=simulate(NObservations, ChangePoints, Intensity)
            % Simulate an intensity sequence
            % Inputs:
            %   NObservations - Scalar integer: length of data sequence
            %   ChangePoints - vector: indexs of change point locations
            %   intensity - vector: length=length(ChangePoints)+1: mean intensities
            %       for each subinterval
            % Outputs:
            %   Data - A 1xNObservations vector of integer intensity values for
            %      specified change point sequence
            assert(length(Intensity)==length(ChangePoints)+1);%Correct number of intenisites
            assert(all(ChangePoints>1)); % Not too small
            assert(all(ChangePoints)<=NObservations); %Not too big
            assert(length(unique(ChangePoints))==length(ChangePoints)); %No identical change points
            assert(all(sort(ChangePoints)==ChangePoints)); % alrady sorted
            assert(all(Intensity(2:end)~=Intensity(1:end-1))); %Change points actually change intensity
            Data=zeros(1,NObservations);
            nCP=length(ChangePoints);
            CP=1;
            for n=1:NObservations
                if CP<=nCP && ChangePoints(CP)==n
                    CP=CP+1;
                end
                Data(n)=poissrnd(Intensity(CP),1,1);
            end
        end

        function [Icp,F]=plotSimulatedEstimate(NObservations, ChangePoints, Intensity, LogBayesThreshold)
            % Given a fixed set of changepoints and intensities, 
            % simulate, analyze and plot a data sets.  Arguments are similar to
            % the simulate method.
            % Inputs:
            %   NObservations - Scalar integer: length of data sequence
            %   ChangePoints - vector: indexs of change point locations
            %   Intensity - vector: length=length(ChangePoints)+1: mean intensities
            %       for each subinterval
            %   LogBayesThreshold - positive scalar.  Threshold for accepting
            %       change points
            % Outputs:
            %   Icp - The object instance of ChangeDetection
            %   f - figure handle
            Data=smi_stat.ChangeDetection.simulate(NObservations, ChangePoints, Intensity);
            Icp=smi_stat.ChangeDetection(Data,LogBayesThreshold);
            F=figure();
            xs=1:NObservations;
            subplot(2,1,1);
            stairs(xs, Data, '-ko');
            hold on;
            modelIs=smi_stat.ChangeDetection.modelIntensity(NObservations, ChangePoints, Intensity);
            estimatedIs=Icp.IntensityModel;
            stairs(xs, modelIs , '-b','LineWidth', 2.0);
            stairs(xs, estimatedIs, '-r', 'LineWidth', 2.0);
            yl=ylim;
            ylim([0,yl(2)]);
            hold off;
            xlabel('time');
            ylabel('Intensity');
            legend('Data', 'Model', 'Estimated', 'Location', 'North');
            subplot(2,1,2);
            xs=2:NObservations;
            pCP=arrayfun(@(CP) smi_stat.ChangeDetection.logP_H2(Data,CP), xs);
            plot(xs, pCP, '-ko');
            xlabel('time');
            ylabel('logP(cp|H_2)');
        end

        function [Icp,F]=plotRandSimulatedEstimate(NObservations, NChangePoints, meanIntensity, LogBayesThreshold)
            % Generate a random sequence of change points and intensities, then 
            % simulate, analyze and plot the data.
            % Inputs:
            %   NObservations - Scalar integer: length of data sequence
            %   NChangePoints - Scalar integer: number of change points to
            %                   simulate
            %   meanIntensity - scalar for mean intensity.  Intensities are
            %                   uniformly distributed on [1, 2*meanIntensity]
            %   LogBayesThreshold - positive scalar.  Threshold for accepting
            %                       change points
            % Outputs:
            %   Icp - The ChangePoint for this data
            %   F - figure handle
            ChangePoints=sort(round(rand(1,NChangePoints)*(NObservations-1)+2));
            while length(unique(ChangePoints))~=length(ChangePoints)
                ChangePoints=sort(round(rand(1,NChangePoints)*(NObservations-1)+2));
            end
            Intensity=round(1+rand(1,NChangePoints+1)*2*meanIntensity);
            while any(Intensity(2:end)==Intensity(1:end-1))
                Intensity=round(1+rand(1,NChangePoints+1)*2*meanIntensity);
            end
            [Icp,F]=smi_stat.ChangeDetection.plotSimulatedEstimate(NObservations, ChangePoints, Intensity, LogBayesThreshold);
        end
    end %public static methods


    methods(Access=protected)
        function estimateSequence(obj)
            %
            % This is the primary estimation routine entry point
            %
            cP=obj.estimateChangePoints(obj.Data, obj.LogBayesThreshold);
            [obj.ChangePoints, obj.LogBayesFactors, obj.RejectedChangePoints, ...
                obj.RejectedLogBayesFactors]=obj.filterChangePoints(obj.Data,cP, obj.LogBayesThreshold);
            obj.NchangePoints=numel(obj.ChangePoints);
            obj.NrejectedChangePoints=numel(obj.RejectedChangePoints);
            if obj.NchangePoints==0
                obj.Intensity=obj.estimateIntensity(obj.Data);
                return
            end
            obj.Intensity=zeros(1, obj.NchangePoints+1);
            for n=1:obj.NchangePoints+1
                if n==1
                    first=1;
                else
                    first=obj.ChangePoints(n-1);
                end
                if n>obj.NchangePoints
                    last=length(obj.Data);
                else
                    last=obj.ChangePoints(n)-1;
                end
                obj.Intensity(n)=smi_stat.ChangeDetection.estimateIntensity(obj.Data(first:last));
            end
            obj.IntensityModel=smi_stat.ChangeDetection.modelIntensity(obj.Nobservations, obj.ChangePoints, obj.Intensity);
        end
    end % Protected methods

    methods(Static=true)
        
        function [ChangePoints, AccLogBayesFactors, RejLogBayesFactors]=estimateChangePoints(Data,LogBayesFactorThreshold)
            % This is the main recursive method for identifiying change points
            % since it and other helper methods work on parts of the data set
            % recursivly we make it a static method that takes in only the
            % portion of the data that it is to operate on
            % Inputs:
            %   data: a vector of integer values representing poission
            %       distributed values from a sequence where the mean of the poisson
            %       process changes at discrete times
            %   LogBayesThreshold - positive scalar.  Threshold for accepting
            %                       change points
            % Outputs:
            %   ChangePoints - The ChangePoint for this data
            %   AccLogBayesFactors - accepted logBayesThreshold
            %   RejLogBayesFactors - rejected logBayesThreshold

            LogBF=smi_stat.ChangeDetection.logBayesFactor(Data);
            if ~isempty(LogBF) && LogBF>=LogBayesFactorThreshold && numel(Data)>=2
                %split data into two parts at the change point
                CP=smi_stat.ChangeDetection.estimateChangePointLocation(Data);
                Data1=Data(1:CP-1);
                Data2=Data(CP:end);
                [cP1, accLogBF1, rejLogBF1]=smi_stat.ChangeDetection.estimateChangePoints(Data1,LogBayesFactorThreshold);
                [cP2, accLogBF2, rejLogBF2]=smi_stat.ChangeDetection.estimateChangePoints(Data2,LogBayesFactorThreshold);
                AccLogBayesFactors=[accLogBF1 LogBF accLogBF2];
                RejLogBayesFactors=[rejLogBF1 rejLogBF2];
                ChangePoints=[cP1 CP cP2+CP-1];
            else
                ChangePoints=[];
                RejLogBayesFactors=LogBF;
                AccLogBayesFactors=[];
            end
        end

        function [Accepted, AccLogBayesFactors, Rejected, RejLogBayesFactors]=filterChangePoints(Data,ChangePoints, LogBayesFactorThreshold)
            %remove change points that are below the logBayesFactorThreshold
            % Inputs:
            %   Data: a vector of integer values representing poission
            %       distributed values from a sequence where the mean of the poisson
            %       process changes at discrete times
            %   ChangePoints - The ChangePoint for this data
            %
            %   LogBayesFactorThreshold - positive scalar.  Threshold for accepting
            %                             change points
            % Outputs:
            %   Accepted - accepted Change Points
            %   AccLogBayesFactors - accepted logBayesThreshold
            %   Rejected - rejected Change Points
            %   RejLogBayesFactors - rejected logBayesThreshold

            NChangePoints=length(ChangePoints);
            
            if NChangePoints==0
                Accepted=[];
                AccLogBayesFactors=[];
                Rejected=[];
                RejLogBayesFactors=[];
                return
            end
            lBF=zeros(1,NChangePoints);
            for n=1:NChangePoints
                if n==1
                    first=1;
                else
                    first=ChangePoints(n-1);
                end
                if n==NChangePoints
                    last=length(Data);
                else
                    last=ChangePoints(n+1)-1;
                end
                lBF(n)=smi_stat.ChangeDetection.logBayesFactorPoint(Data(first:last),ChangePoints(n)-(first-1));
            end
            rejIdx=find(lBF<LogBayesFactorThreshold);
            accIdx=setdiff(1:NChangePoints,rejIdx);
            Accepted=ChangePoints(accIdx);
            AccLogBayesFactors=lBF(accIdx);
            Rejected=ChangePoints(rejIdx);
            RejLogBayesFactors=lBF(rejIdx);
            if ~isempty(Rejected)
                [Accepted, AccLogBayesFactors, New_rejected, New_rejLogBayesFactors]=smi_stat.ChangeDetection.filterChangePoints(Data,Accepted, LogBayesFactorThreshold);
                Rejected=[Rejected New_rejected];
                RejLogBayesFactors=[RejLogBayesFactors New_rejLogBayesFactors];
                [Rejected, shuffle]=sort(Rejected);
                RejLogBayesFactors=RejLogBayesFactors(shuffle);
            end
        end

        function LogP=logP_H1(Data)
            % Compute the unnormalized log probability of hypothesis H1 (there
            % are no change points and all data comes from the same poisson
            % distribution)
            % This is unnormalized as we don't have the Jeffery's prior constant
            N=length(Data);
            C=sum(Data);
            logR=-logFactorialSum(Data);
            LogP=logR+(C-.5)*log(C)-C*(1+log(N))+.5*log(2*pi);
        end

        function LogP=logP_H2(Data, change_point)
            % Compute the unnormalized log probability of hypothesis H2 (there
            % is a change point at change_points from a poisson process with one mean
            % to a poisson process witha second mean after marginalizing accross all possible
            % intensities).
            % This is unnormalized as we don't have the Jeffery's prior constant
            N=length(Data);
            assert(change_point>1 && change_point<=N);
            N1=change_point-1;
            N2=N-N1;
            C1=sum(Data(1:N1));
            C2=sum(Data(N1+1:end));
            
            term1=(2/pi)/((C1/N1)^2+(C2/N2)^2);
            
            logR=-logFactorialSum(Data);
            LFC1=logFactorial(C1);
            LFC2=logFactorial(C2);

            LogP=log(term1)+logR+LFC1+LFC2-(C1+1)*log(N1)-(C2+1)*log(N2);
        end

        function LogP=mean_LogP_H2(Data)
            % compute the total log probability of hypothesis H2 (there
            % is a change point from the data
            LogP=log(mean(arrayfun(@(CP) exp(smi_stat.ChangeDetection.logP_H2(Data, CP)), 2:length(Data))));
        end

        function LogBF=logBayesFactor(Data)
            %compute the total Bayes Factor, which is total log probability
            %of hypothesis H2 (one change point) minus the log probability of
            %hypothesis H1 (no change point)
            N=length(Data);
            C=sum(Data);
            H2LogTerms=zeros(1,N-1);
            C1=Data(1);
            C2=C-C1;
            N1=1;
            N2=N-N1;
            for CP=2:N
                H2LogTerms(CP-1)= logFactorial(C1)+logFactorial(C2)-(C1+1)*log(N1)-(C2+1)*log(N2) ...
                                    - log((C1/N1)^2+(C2/N2)^2);
                C1=C1+Data(CP);
                C2=C2-Data(CP);
                N1=N1+1;
                N2=N2-1;
            end
            LogBF=log(2/pi) + C*log(N) - logFactorial(C-1)-log(N-1)+logSum(H2LogTerms);
        end

        function LogBF=logBayesFactorPoint(Data, ChangePoint)
            %compute the Bayes Factor at the change point, which is the
            %log probability of hypothesis H2 (one change point) minus the log probability of
            %hypothesis H1 (no change point)
            LogBF=smi_stat.ChangeDetection.logP_H2(Data,ChangePoint) - smi_stat.ChangeDetection.logP_H1(Data);
        end

        function LogPs=logP_ChangePoint(Data)
            %compute the log probability of the change point
            LogPs=zeros(1,length(Data));
            N=length(Data);
            C=sum(Data);
            C1=Data(1);
            C2=C-C1;
            N1=1;
            N2=N-N1;
            for CP=2:length(Data)
                LogPs(CP)=logFactorial(C1)+logFactorial(C2)-(C1+1)*log(N1)-(C2+1)*log(N2)...
                                - log((C1/N1)^2+(C2/N2)^2);
                C1=C1+Data(CP);
                C2=C2-Data(CP);
                N1=N1+1;
                N2=N2-1;
            end
        end

        function CP=estimateChangePointLocation(Data)
            % get the location of the change point
            LogPs=smi_stat.ChangeDetection.logP_ChangePoint(Data);
            [~,CP]=max(LogPs(2:end)); %the first time cannot be a change point
            CP=CP+1; %correct for dropping first point
        end

        function LogP=logPLambda(Data, Lambda)
            %compute log probability of the mean intensity (Lambda)
            N=length(Data);
            C=sum(Data);
            LogP=C*log(N) + (C-1)*log(Lambda) - N*Lambda - logFactorial(C-1);
        end

        function Lambda=estimateIntensity(Data)
            % compute the mean intensity of the data
            N=length(Data);
            C=sum(Data);
            Lambda=C/N;
        end

        function Model_intensity=modelIntensity(NObservations, ChangePoints, Intensity)
            % Helper for plotting an input intensity sequence
            %   NObservations - Scalar integer: length of data sequence
            %   ChangePoints - vector: indexs of change point locations
            %   intensity - vector: length=length(ChangePoints)+1: mean intensities
            %       for each subinterval
            % Outputs:
            %   Model_intensity -intensity of model sequence (no noise)
            Model_intensity=zeros(1,NObservations);
            nCP=length(ChangePoints);
            CP=1;
            for n=1:NObservations
                if CP<=nCP && ChangePoints(CP)==n
                    CP=CP+1;
                end
                Model_intensity(n)=Intensity(CP);
            end
        end


    end %static protected methods
end

./MATLAB/+smi_stat/@DiffusionEstimator/unitTest.m
% Test calling smi_stat.DiffusionEstimator routines.
function success = unitTest()

success = 0;

SaveDir = smi_helpers.mkSMITETmpDir('unitTest', 'DiffusionEstimator');

% This script demonstrates the usage of smi_stat.DiffusionEstimator.

%% Single diffusing population, estimating D as the slope of the MSD.
% Simulate some trajectories.
SimParams = smi_sim.SimSPT.defineDefaultParams();
SimParams.ParticleDensity = 0.01; % particles / px^2
SimParams.NFrames = 1000;
SimParams.SubframeDensity = 1;
SimParams.FrameSize = [128, 128];
SimParams.BoundaryCondition = 'Periodic';
SimParams.KOffToOn = 1;
SimParams.KOnToOff = 0;
SimParams.D = 0.0123; % px^2 / frame
SPTSim = smi_sim.SimSPT(SimParams);
SPTSim.createSimulation();
TR = SPTSim.TR;

% Prepare the DiffusionEstimator class and estimate D.
% NOTE: For MSD fitting, the important parameters are 'DiffusionModel', 
%       'FitMethod', 'FrameLagRange', and 'NFitPoints'.  
SMF = smi_core.SingleMoleculeFitting; % used for PixelSize and FrameRate
DE = smi_stat.DiffusionEstimator(TR, SMF);
DE.FitTarget = 'MSD';
DE.DiffusionModel = 'Brownian'; % must be 'Brownian' for MSD fitting
DE.NComponents = 1; % must be 1 for MSD fitting
DE.FitMethod = 'WeightedLS'; % 'WeightedLS' or 'LS'
DE.FrameLagRange = [1, 50]; % range of frame lags computed in MSD
DE.NFitPoints = 5; % # of points in MSD used for fit.
DE.EstimateSEs = true; % estimate standard errors of fit D values
DE.FitIndividualTrajectories = true; % fit each trajectory MSD
DE.UnitFlag = false;
DE.Verbose = 1;
DE.estimateDiffusionConstant();

% Plot the MSD and fit results.
DE.plotEnsembleMSD(axes(figure()), DE.MSDEnsemble, DE.DiffusionStruct, ...
    DE.DiffusionModel, DE.UnitFlag);
saveas(gcf, fullfile(SaveDir, 'DE1.png'));

%% Two diffusing populations, estimating D by fitting the CDF of jumps.
% Simulate some trajectories.
SimParams = smi_sim.SimSPT.defineDefaultParams();
SimParams.ParticleDensity = 0.01; % particles / px^2
SimParams.NFrames = 1000;
SimParams.SubframeDensity = 1;
SimParams.FrameSize = [128, 128];
SimParams.BoundaryCondition = 'Periodic';
SimParams.KOffToOn = 1;
SimParams.KOnToOff = 0;
SimParams.D = [0.0123, 0.00321, 0.00321]; % px^2 / frame
SPTSim = smi_sim.SimSPT(SimParams);
SPTSim.createSimulation();
TR = SPTSim.TR;

% Prepare the DiffusionEstimator class and estimate D.
% NOTE: For CDF fitting, the important parameters are 'DiffusionModel' and
%       'FrameLagRange'.
SMF = smi_core.SingleMoleculeFitting; % used for PixelSize and FrameRate
DE = smi_stat.DiffusionEstimator(TR, SMF);
DE.FitTarget = 'CDFOfJumps';
DE.DiffusionModel = 'Brownian';
DE.NComponents = 2;
DE.FrameLagRange = [2, 2]; % range of frame lags computed in MSD
DE.EstimateSEs = false; % estimate standard errors of fit D values
DE.FitIndividualTrajectories = false; % fit each trajectory MSD
DE.UnitFlag = false;
DE.Verbose = 1;
DE.estimateDiffusionConstant();

% Plot the CDF and fit results.
DE.plotEnsembleCDFOfJumps(axes(figure()), ...
    DE.MSDEnsemble, DE.DiffusionStruct, DE.UnitFlag);
saveas(gcf, fullfile(SaveDir, 'DE2.png'));

%% Two diffusing populations, estimating D with an MLE for the jumps.
% (If estimating standard errors, this is faster than fitting the CDF, and
% the results are similar).

% Prepare the DiffusionEstimator class and estimate D.
% NOTE: For LikelihoodOfJumps maximization, the important parameters are
%       'DiffusionModel' and 'FrameLagRange'.
SMF = smi_core.SingleMoleculeFitting; % used for PixelSize and FrameRate
DE = smi_stat.DiffusionEstimator(TR, SMF);
DE.FitTarget = 'LikelihoodOfJumps';
DE.DiffusionModel = 'Brownian';
DE.NComponents = 2;
DE.FrameLagRange = [1, 5]; % range of frame lags computed in MSD
DE.EstimateSEs = true; % estimate standard errors of fit D values
DE.FitIndividualTrajectories = false; % fit each trajectory MSD
DE.UnitFlag = false;
DE.Verbose = 1;
DE.estimateDiffusionConstant();

success = 1;

end

./MATLAB/+smi_stat/@DiffusionEstimator/fitMSDBrownian.m
function [FitParams, FitParamsSE] = ...
    fitMSDBrownian(FrameLags, MSD, NPoints, FitMethod)
%fitMSDBrownian fits an MSD to a Brownian motion model.
% This method will fit a set of mean squared displacement (MSD) to the
% Brownian motion model (i.e., a line).
%
% INPUTS:
%   FrameLags: The frame lags corresponding to the MSD values in 'MSD'.
%              (NFrameLagsx1 array)
%   MSD: The mean squared displacement data corresponding to the frame lags
%        'FrameLags'. (NFrameLagsx1 array)
%   NPoints: The number of displacements used to compute each of MSD.
%            (NFrameLagsx1 array)(only needed if FitMethod = 'WeightedLS')
%            (Default set s.t. weighted least squares weights are all 1)
%   FitMethod: A string specifying the fit method. (Default = 'WeightedLS')
%
% OUTPUTS:
%   FitParams: Fit parameters for the MSD fit where
%              MSDFit = FitParams(1) + FitParams(2)*FrameLags
%   FitParamsSE: Standard errors for the MSD fit parameters 'FitParams'.

% Created by:
%   David J. Schodt (Lidke lab, 2021)


% Define default parameters if needed.
if (~exist('FitMethod', 'var') || isempty(FitMethod))
    FitMethod = 'WeightedLS';
end
if (~exist('NPoints', 'var') || isempty(NPoints))
    % The weights in the weighted least squares fit will be 
    % NPoints / FrameLags.^2, thus this default makes the weights 1.
    NPoints = FrameLags .^ 2;
end

% Fit the MSD to the model.
switch FitMethod
    case {'LS', 'WeightedLS'}
        % Define the weights to just be 1 (i.e., an unweighted fit) for
        % regular least squares and roughly the inverse of the MSD variance
        % otherwise.
        % NOTE: The weight array is (as I've defined it here)
        %       proportional to the reciprocal of the CRLB of each
        %       point in an MSD plot. The proportionality constant is
        %       dropped because it doesn't affect the weighted fit.
        MSDVariance =  (FrameLags.^2) ./ NPoints;
        Weights = strcmpi(FitMethod, 'LS')*ones(numel(FrameLags), 1) ...
            + strcmpi(FitMethod, 'WeightedLS')./MSDVariance;
        
        % Perform the least squares fit.
        [BetaHat, BetaHatSE] = ...
            smi_stat.leastSquaresFit(FrameLags, MSD, Weights);
        FitParams = BetaHat.';
        FitParamsSE = BetaHatSE.';
    otherwise
        error('Unknown ''FitMethod'' = %s', FitMethod)
end


end
./MATLAB/+smi_stat/@DiffusionEstimator/mleOfJumps.m
function [MLEParams, MLEParamsSE] = ...
    mleOfJumps(MSDStruct, NComponents, DiffusionModel, Verbose)
%mleOfJumps finds the MLE from the likelihood of observed jumps.
% This method will make a maximum likelihood estimate of the diffusion
% constant(s) (and possibly population ratios) based on a model for the
% likelihood of observed jumps.
%
% INPUTS:
%   MSDStruct: A structure array of MSD data as output from computeMSD()
%              (see computeMSD() for more details).
%   DiffusionModel: A string specifying the diffusion model to fit to the
%                   MSD. See options in DiffusionEstimator class property
%                   'DiffusionModel'. (Default = 'Brownian')
%   Verbose: Verbosity level specifying how many temporary outputs should
%            be displayed (e.g., Command Window updates). (Default = 0)
%
% OUTPUTS:
%   MLEParams: MLE for the desired model parameters..  These will vary
%              based on 'FitMethod'. MLEParams(ii, :) will contain the MLEs
%              corresponding to the data in MSDStruct(ii).
%              (numel(MSDStruct)xNParameters array)
%   MLEParamsSE: Standard errors for the MLEs in 'MLEParams'. These will
%                vary based on 'Method'.

% Created by:
%   David J. Schodt (Lidke lab, 2021)


% Define default parameters if needed.
if (~exist('DiffusionModel', 'var') || isempty(DiffusionModel))
    DiffusionModel = 'Brownian';
end
if (~exist('Verbose', 'var') || isempty(Verbose))
    Verbose = 0;
end

% Determine how many fit parameters are used in the desired model.
NFitParams = 2 * NComponents;

% Compute the MLE.
if (Verbose > 1)
    fprintf('mleOfJumps(): computing MLE from observed jumps...\n')
end
NFits = numel(MSDStruct);
MLEParams = NaN(NFits, NFitParams);
MLEParamsSE = NaN(NFits, NFitParams);
for ii = 1:NFits
    % Isolate some arrays needed for the fit.
    SquaredDisplacement = double(MSDStruct(ii).SquaredDisplacement);
    if isempty(SquaredDisplacement)
        % This trajectory was too short and no displacements were measured.
        continue
    end
    FrameLagsAll = double(MSDStruct(ii).FrameLagsAll);
    LocVarianceSum = double(MSDStruct(ii).LocVarianceSum);
    
    % Compute the MLE based on the desired model.
    % NOTE: We're only allowing Brownian motion for now.
    switch lower(DiffusionModel)
        case 'brownian'
            if (nargout > 1)
                [ParamsHat, ParamsHatSE] = ...
                    smi_stat.DiffusionEstimator.mleOfJumpsBrownian(...
                    SquaredDisplacement, FrameLagsAll, LocVarianceSum, ...
                    NComponents);
                MLEParamsSE(ii, :) = ParamsHatSE.';
            else
                ParamsHat = smi_stat.DiffusionEstimator.mleOfJumpsBrownian(...
                    SquaredDisplacement, FrameLagsAll, LocVarianceSum, ...
                    NComponents);
            end
            MLEParams(ii, :) = ParamsHat.';
        otherwise
            error('Unknown ''DiffusionModel'' = %s', DiffusionModel)
    end
end


end
./MATLAB/+smi_stat/@DiffusionEstimator/plotEnsembleMSD.m
function [PlotAxes] = plotEnsembleMSD(PlotAxes, ...
    MSDEnsemble, DiffusionStruct, DiffusionModel, UnitFlag)
%plotEnsembleMSD plots an ensemble MSD and an associated fit.
% This method will plot the MSD data in MSDEnsemble as well as the fit
% information provided in DiffusionStruct.
%
% INPUTS:
%   PlotAxes: Axes in which the plot will be made. (Default = gca())
%   MSDEnsemble: Structure array with ensemble MSD results (see outputs of
%                computeMSD())
%   DiffusionStruct: Structure array containing MSD fit ressults. 
%                    (Default = [], meaning no fit results are plotted).
%   DiffusionModel: A string specifying the diffusion model to fit to the
%                   MSD. See options in DiffusionEstimator class property
%                   'DiffusionModel'. (Default = 'brownian1c')
%   UnitFlag: Flag to specify camera units (0) or physical units (1).
%             (Default = 0)
%
% OUTPUTS:
%   PlotAxes: Axes in which the plot was made.

% Created by:
%   David J. Schodt (Lidke lab, 2021)


% Set defaults if needed.
if (~exist('PlotAxes', 'var') || isempty(PlotAxes))
    PlotAxes = gca();
end
if (~exist('DiffusionStruct', 'var') || isempty(DiffusionStruct))
    DiffusionStruct = [];
end
if (~exist('DiffusionModel', 'var') || isempty(DiffusionModel))
    DiffusionModel = 'brownian1c';
end
if (~exist('UnitFlag', 'var') || isempty(UnitFlag))
    UnitFlag = 0;
end

% Plot the MSD.
FrameRate = DiffusionStruct(2).FrameRate;
PixelSize = DiffusionStruct(2).PixelSize;
FrameConversion = ~UnitFlag + UnitFlag/FrameRate;
JumpConversion = ~UnitFlag + UnitFlag*PixelSize;
FrameLags = MSDEnsemble.FrameLags * FrameConversion;
plot(PlotAxes, FrameLags, MSDEnsemble.MSD*(JumpConversion^2), '.')
hold(PlotAxes, 'on')

% If needed, plot the fit results.
if ~isempty(DiffusionStruct)
    % Define some unit conversion parameters. This is needed because the
    % DiffusionStruct allows for either camera units or physical units
    % (unlike the MSD structures).
    IsCameraUnits = strcmpi(DiffusionStruct(2).Units, ...
        {'pixels'; 'frames'});
    JumpUnitConversion = IsCameraUnits(1)*JumpConversion ...
        + ~IsCameraUnits(1)*(UnitFlag + ~UnitFlag/PixelSize);
    TimeUnitConversion = IsCameraUnits(2)*FrameConversion ...
        + ~IsCameraUnits(2)*(UnitFlag + ~UnitFlag*FrameRate);
    
    % Plot the MSD fit.
    switch lower(DiffusionModel)
        case 'brownian'
            % The Brownian diffusion model suggests the MSD is linear with
            % time.
            FitParams = DiffusionStruct(2).FitParams ...
                * (JumpUnitConversion^2) ./ [1, TimeUnitConversion];
            plot(PlotAxes, ...
                FrameLags, FitParams(2)*FrameLags + FitParams(1))
        otherwise
            warning('Unknown ''DiffusionModel'' = %s', DiffusionModel)
    end
end
TimeUnit = smi_helpers.arrayMUX({'frames', 'seconds'}, UnitFlag);
MSDUnit = smi_helpers.arrayMUX(...
    {'pixels^2', 'micrometers^2'}, UnitFlag);
xlabel(PlotAxes, sprintf('Time lag (%s)', TimeUnit))
ylabel(PlotAxes, sprintf('MSD (%s)', MSDUnit))
legend(PlotAxes, {'MSD', 'Fit'}, 'Location', 'best')


end
./MATLAB/+smi_stat/@DiffusionEstimator/DiffusionEstimator.m
classdef DiffusionEstimator < handle
    %DiffusionEstimator contains methods useful for diffusion estimation.
    % This class contains several methods used to estimate diffusion
    % constants from single-particle tracking data.
    %
    % REQUIRES:
    %   Optimization Toolbox (to use fmincon() for certain models)
    
    % Created by:
    %   David J. Schodt (Lidke lab, 2021)
    
    
    properties
        % ID of the diffusion model to be considered (char array/string)
        % OPTIONS:
        %   'Brownian'
        DiffusionModel{mustBeMember(DiffusionModel, {'Brownian'})} = ...
            'Brownian';
        
        % Number of diffusing components. (Default = 1)
        % This can only be changed for FitTarget = CDFOfJumps or
        % LikelihoodOfJumps.
        NComponents = 1;
        
        % Fit method for fitting data (char array/string)
        FitMethod{mustBeMember(FitMethod, {'WeightedLS', 'LS'})} = ...
            'WeightedLS';
        
        % Target data that will be fit (char array/string)
        FitTarget{mustBeMember(FitTarget, ...
            {'MSD', 'CDFOfJumps', 'LikelihoodOfJumps'})} = 'MSD';

        % Range of frame lags used to estimate D (Default = [1, 5])
        FrameLagRange = [1, 5];
        
        % Number of MSD points to be fit (scalar, integer)(Default = 5)
        NFitPoints = 5;
        
        % Flag to estimate standard errors (Default = true)
        % NOTE: For some of the fit methods/fit targets (e.g., FitTarget =
        %       'CDFOfJumps') we have to use a bootstrap, in which case
        %       estimating SEs can be unreasonably slow.
        EstimateSEs = true;
        
        % Flag to fit individual trajectory MSDs/CDFs (Default = true)
        FitIndividualTrajectories = true;
        
        % Number of spatial dimensions (scalar, integer)(Default = 2)
        NDimensions = 2;
        
        % Directory in which results will be saved by saveResults().
        SaveDir = pwd();
        
        % Base name of saved results. Default defined in obj.saveDir().
        BaseSaveName
        
        % Tracking results structure.
        TR
        
        % Single Molecule Fitting structure, for pixel size and framerate.
        SMF = smi_core.SingleMoleculeFitting;
        
        % Boolean flag to indicate units of outputs (boolean)(Default = 0)
        % 1 (true) will make the outputs of estimateDiffusionConstant()
        %   micrometers and seconds.
        % 0 (false) will make the outputs of estimateDiffusionConstant()
        %   pixels and frames.
        % NOTE: Most methods of this class will use pixels and frames
        %       regardless of obj.UnitFlag. This property will only affect
        %       the "user-facing" wrapper methods, such as
        %       estimateDiffusionConstant() and saveResults()
        UnitFlag = false;
        
        % Verbosity level for estimateDiffusionConstant() (Default = 0)
        %   Verbose 0: no Command Window outputs
        %   Verbose 1: General progress printed to Command Window
        %   Verbose 2: Display some intermediate results
        %   Verbose 3: Debugging mode, extensive outputs
        Verbose = 0;
    end
    
    properties (SetAccess = protected)
        % Structure array containing diffusion estimates.
        DiffusionStruct
        
        % Structure array containing trajectory-wise MSDs.
        MSDSingleTraj
        
        % Structure array containing the ensemble MSD.
        MSDEnsemble
    end
    
    methods
        function [obj, DiffusionStruct] = ...
                DiffusionEstimator(TR, SMF, Verbose, AutoRun)
            %DiffusionEstimator is the class constructor.
            % Several optional inputs can be provided to directly set class
            % properties.  'AutoRun' is a boolean flag which specifies
            % whether or not this constructor should call
            % obj.estimateDiffusionConstant() if all requisite class
            % properties were provided.
            
            % Set defaults if needed.
            if (~exist('AutoRun', 'var') || isempty(AutoRun))
                AutoRun = false;
            end
            
            % Set class properties based on the inputs.
            AllFieldsSet = true;
            if (exist('TR', 'var') && ~isempty(TR))
                obj.TR = TR;
            else
                AllFieldsSet = false;
            end
            if (exist('SMF', 'var') && ~isempty(SMF))
                obj.SMF = SMF;
            end
            if (exist('Verbose', 'var') && ~isempty(Verbose))
                obj.Verbose = Verbose;
            end
            
            % Run obj.estimateDiffusionConstant() if requested.
            if (AutoRun && AllFieldsSet)
                [DiffusionStruct] = obj.estimateDiffusionConstant();
            end
        end
        
        [DiffusionStruct] = estimateDiffusionConstant(obj);
        saveResults(obj, SaveParams)
        
    end
    
    methods (Static)
        [MSDSingleTraj, MSDEnsemble] = ...
            computeMSD(TR, FrameLagRange, Verbose);
        [MSDStruct] = computeCDFOfJumps(MSDStruct, FrameLagRange);
        [FitParams, FitParamsSE] = ...
            fitMSD(MSDStruct, FitMethod, NFitPoints, ...
            DiffusionModel, Verbose);
        [FitParams, FitParamsSE] = fitCDFOfJumps(MSDStruct, ...
            FitMethod, NComponents, DiffusionModel, Verbose);
        [MLEParams, MLEParamsSE] = ...
            mleOfJumps(MSDStruct, NComponents, DiffusionModel, Verbose);
        [PlotAxes] = plotEnsembleMSD(PlotAxes, ...
            MSDEnsemble, DiffusionStruct, DiffusionModel, UnitFlag);
        [PlotAxes] = plotEnsembleCDFOfJumps(PlotAxes, ...
            MSDEnsemble, DiffusionStruct, UnitFlag);
        success = unitTest();
    end
    
    methods (Static, Hidden)
        % These methods are 'Hidden' because they are primarily intended
        % for use within other more user-centric methods (i.e., we don't
        % want to distract the user with these options, but if they need
        % them they are still accessible).
        
        [MSDSingleTraj] = computeSingleTrajMSD(TR, FrameLagRange, Verbose);
        [FitParams, FitParamsSE] = ...
            fitMSDBrownian(FrameLags, MSD, NPoints, FitMethod);
        [FitParams, FitParamsSE] = ...
            fitCDFOfJumpsBrownian(SortedJumps, CDFOfJumps, ...
            FrameLags, NPoints, LocVarianceSum, NComponents, ...
            Weights, FitMethod, FitOptions);
        [CDFOfJumps] = brownianJumpCDF(MotionParams, ...
            SortedSquaredDisp, FrameLags, NPoints, LocVarianceSum);
        [MLEParams, MLEParamsSE] = mleOfJumpsBrownian(...
            SquaredDisplacement, FrameLagsAll, ...
            LocVarianceSum, NComponents, FitOptions);
        [LogLikelihood] = brownianJumpLikelihood(MotionParams, ...
            SquaredDisplacement, FrameLagsAll, LocVarianceSum);
    end
    
    
end

./MATLAB/+smi_stat/@DiffusionEstimator/fitMSD.m
function [FitParams, FitParamsSE] = ...
    fitMSD(MSDStruct, FitMethod, NFitPoints, DiffusionModel, Verbose)
%fitMSD fits mean squared displacement data.
% This method will fit a mean squared displacement plot by the method
% specified by 'FitMethod'.
%
% INPUTS:
%   MSDStruct: A structure array of MSD data as output from computeMSD()
%              (see computeMSD() for more details).
%   FitMethod: A string specifying the fit method. (Default = 'WeightedLS')
%   NFitPoints: Number of points in the MSD to be fit. (Default = 5)
%   DiffusionModel: A string specifying the diffusion model to fit to the
%                   MSD. See options in DiffusionEstimator class property
%                   'DiffusionModel'. (Default = 'Brownian')
%   Verbose: Verbosity level specifying how many temporary outputs should
%            be displayed (e.g., Command Window updates).
%
% OUTPUTS:
%   FitParams: Fit parameters for the MSD fit.  These will vary based on
%              'FitMethod'. FitParams(ii, :) will contain the fit
%              parameters for the fit to MSDStruct(ii). 
%              (numel(MSDStruct)xNParameters array)
%   FitParamsSE: Standard errors for the MSD fit parameters 'FitParams'.
%                These will vary based on 'Method'.

% Created by:
%   David J. Schodt (Lidke lab, 2021)


% Define default parameters if needed.
if (~exist('FitMethod', 'var') || isempty(FitMethod))
    FitMethod = 'WeightedLS';
end
if (~exist('NFitPoints', 'var') || isempty(NFitPoints))
    NFitPoints = 5;
end
if (~exist('DiffusionModel', 'var') || isempty(DiffusionModel))
    DiffusionModel = 'Brownian';
end
if (~exist('Verbose', 'var') || isempty(Verbose))
    Verbose = 0;
end

% Fit the MSD data.
if (Verbose > 1)
    fprintf('fitMSD(): fitting MSD with FitMethod = ''%s''...\n', ...
        FitMethod)
end
NFits = numel(MSDStruct);
FitParams = NaN(NFits, 2);
FitParamsSE = NaN(NFits, 2);
for ii = 1:NFits
    % Make sure the MSD has enough points to make a useful fit.
    FrameLags = double(MSDStruct(ii).FrameLags);
    MaxFitPoints = numel(FrameLags);
    FitPointsIndices = 1:min(NFitPoints, MaxFitPoints);
    FrameLags = FrameLags(FitPointsIndices);
    if (numel(FrameLags) < 2)
        % This trajectory is too short so we won't bother fitting it.
        continue
    end
    
    % Fit the MSD to the desired diffusion model.
    NPoints = double(MSDStruct(ii).NPoints(FitPointsIndices));
    MSD = double(MSDStruct(ii).MSD(FitPointsIndices));
    switch lower(DiffusionModel)
        case 'brownian'
            [FitParams(ii, :), FitParamsSE(ii, :)] = ...
                smi_stat.DiffusionEstimator.fitMSDBrownian(...
                FrameLags, MSD, NPoints, FitMethod);
        otherwise
            error('Unknown ''DiffusionModel'' = %s', DiffusionModel)
    end
end


end
./MATLAB/+smi_stat/@DiffusionEstimator/mleOfJumpsBrownian.m
function [MLEParams, MLEParamsSE] =  mleOfJumpsBrownian(...
    SquaredDisplacement, FrameLagsAll, LocVarianceSum, NComponents, ...
    FitOptions)
%mleOfJumpsBrownian finds the MLE for Brownian motion jumps.
% This method will estimate the MLE for the likelihood of observed squared
% displacements based on a Brownian motion model with either one diffusing
% population (i.e., one diffusion constant) or two diffusing populations
% (two diffusion constants and the population ratio).
%
% INPUTS:
%   SquaredDisplacement: The squared displacements made by the
%                        trajectory(ies). (NDatax1 numeric array)
%   FrameLagsAll: All of the frame lags associated with the jumps in
%                 'SquaredDisplacement'. (NDatax1 array)
%   LocVarianceSum: Sum of the localization variances for the two points
%                   used to compute the jumps. This array should be
%                   averaged over x and y.
%                   (NDatax1 numeric array)
%                   NOTE: I don't know which is better: average the
%                         variances, or average the SEs and square them? My
%                         bet is on averaging variances, but I'm not sure.
%                         This can make a big difference in some cases!
%   NComponents: Number of diffusion coefficients to fit.
%                (scalar, integer)(Default = 2)
%   FitOptions: Fit options sent directly to fminsearch (see doc fminsearch
%               for details)(Default = optimset(@fminsearch)
%               or optimoptions('fmincon') as appropriate)
%
% OUTPUTS:
%   MLEParams: MLE for the desired model parameters..  These will vary
%              based on 'FitMethod'. MLEParams(ii, :) will contain the MLEs
%              corresponding to the data in MSDStruct(ii).
%              (numel(MSDStruct)xNParameters array)
%   MLEParamsSE: Standard errors for the MLEs in 'MLEParams'. These will
%                vary based on 'Method'.
%
% REQUIRES:
%   Optimization Toolbox (for fmincon() when using the N-component models)

% Created by:
%   David J. Schodt (Lidke lab, 2021)


% Define default parameters if needed.
if (~exist('NComponents', 'var') || isempty(NComponents))
    NComponents = 2;
end
if (~exist('FitOptions', 'var') || isempty(FitOptions))
    FitOptions = optimoptions('fmincon');
    FitOptions.Display = 'none';
end

% Find the MLE based on the Brownian motion model using a constrained fit.
% NOTE: This model can be found by taking the prob(r|sigma^2=2Dt+loc.error)
%       (which is a product of Gaussians), converting to polar
%       coordinates, and integrating over theta. For multiple frame lags
%       (which we have), we'll also need to integrate over the frame lags
%       times the proportion of each frame lag observed.
% NOTE: The parameter initial guess below was found to be less susceptible
%       to local minima than a "uniform" (each component equal) initial
%       guess (there tends to be a local minimum at the "uniform" initial
%       guess).
CostFunction = @(Params) ...
    -smi_stat.DiffusionEstimator.brownianJumpLikelihood(Params, ...
    SquaredDisplacement, FrameLagsAll, LocVarianceSum);
NFitComponents = 2 * NComponents;
ParamsLowerBound = ...
    [min(SquaredDisplacement./(4*FrameLagsAll))*ones(NComponents, 1);
    zeros(NComponents, 1)];
ParamsUpperBound = ...
    [max(SquaredDisplacement./(4*FrameLagsAll))*ones(NComponents, 1); ...
    ones(NComponents, 1)];
Quantiles = quantile(SquaredDisplacement./(4*FrameLagsAll), NComponents+2);
DInitGuess = Quantiles(2:(end-1));
AlphaInitGuess = (1/NComponents) * ones(1, NComponents);
ParamsInit = [DInitGuess, AlphaInitGuess].';
Aeq = zeros(NFitComponents);
Aeq(1, (NComponents+1):end) = 1;
beq = zeros(NFitComponents, 1);
beq(1) = 1;
MLEParams = fmincon(CostFunction, ParamsInit, [], [], Aeq, beq, ...
    ParamsLowerBound, ParamsUpperBound, [], FitOptions);

% If requested, estimate the CRLBs of fit parameters.
if (nargout > 1)
    % Compute the CRLB for the variance of the jump distribution.
    r = sqrt(SquaredDisplacement);
    v = 2*FrameLagsAll*MLEParams(1:NComponents).' + mean(LocVarianceSum);
    alpha = MLEParams((NComponents+1):end).';
    Top = alpha .* r .* exp(-0.5*r.^2./v) ...
        .* (0.5*(r.^2)./(v.^3) - (1./v.^2));
    Bottom = sum(alpha .* (r./v) .* exp(-0.5*r.^2./v), 2);
    DTopDV = alpha .* r .* exp(-0.5*r.^2./v) ...
        .* (2./(v.^3) - 2*(r.^2)./(v.^4) + (r.^4)./(4*v.^5));
    DBottomDV = Top;
    DSqDVLogL = sum((Bottom.*DTopDV - Top.*DBottomDV) ./ (Bottom.^2), 1);
    CRLBOfVariance = sqrt(-1 ./ DSqDVLogL);

    % Compute the CRLB for the population ratios.
    DSqDAlphaLogL = sum(-((r./v) .* exp(-0.5*r.^2./v)).^2 ...
        ./ sum(alpha .* (r./v) .* exp(-0.5*r.^2./v), 2).^2, 1);
    CRLBOfAlpha = sqrt(-1 ./ DSqDAlphaLogL);
    MLEParamsSE = [CRLBOfVariance, CRLBOfAlpha].';
end


end
./MATLAB/+smi_stat/@DiffusionEstimator/saveResults.m
function saveResults(obj, SaveParams)
%saveResults saves useful results of diffusion estimation analysis.
% This method can be used to save several pieces of information from the
% diffusion analysis results.
%
% INPUTS:
%   SaveParams: Structure array of various parameters defining what we
%               should save.
%               Fields: MakeFitPlot-Generates and saves a plot of the 
%                                   MSD/CDF fit. (Default = true)

% Created by:
%   David J. Schodt (Lidke Lab, 2021)


% Define the path to the .mat file in which results will be saved.
if isempty(obj.BaseSaveName)
    obj.BaseSaveName = smi_helpers.genTimeString('_');
end
if ~exist(obj.SaveDir, 'dir')
    mkdir(obj.SaveDir);
end

% Check if the SaveParams structure was provided, initializing it to empty
% if it wasn't.
if (~exist('SaveParams', 'var') || isempty(SaveParams))
    SaveParams = struct();
end

% Set default parameter values where needed.
DefaultSaveParams.MakeFitPlot = true;
DefaultParameterNames = fieldnames(DefaultSaveParams);
InputParameterNames = fieldnames(SaveParams);
for ii = 1:numel(DefaultParameterNames)
    if ~any(ismember(DefaultParameterNames{ii}, InputParameterNames))
        % The field DefaultParameterNames{ii} is not present in the
        % SaveParams structure and so the default must be added.
        SaveParams.(DefaultParameterNames{ii}) = ...
            DefaultSaveParams.(DefaultParameterNames{ii});
    end
end

% Save some class properties to a .mat file.
FilePath = fullfile(obj.SaveDir, ...
    ['DiffusionResults_', obj.BaseSaveName, '.mat']);
if (obj.Verbose > 1)
    fprintf('saveResults(): saving diffusion estimates to \n\t%s...\n', ...
        FilePath)
elseif (obj.Verbose > 0)
    fprintf('saveResults(): saving diffusion estimation results...\n')
end
DiffusionStruct = obj.DiffusionStruct;
FitMethod = obj.FitMethod;
NFitPoints = obj.NFitPoints;
MSDEnsemble = obj.MSDEnsemble;
MSDSingleTraj = obj.MSDSingleTraj;
MaxFrameLag = obj.MaxFrameLag;
save(FilePath, 'DiffusionStruct', 'FitMethod', 'NFitPoints', ...
    'MaxFrameLag', 'MSDEnsemble', 'MSDSingleTraj', '-v7.3');

% Generate and save a plot of the fit.
if SaveParams.MakeFitPlot
    VisiblePlot = smi_helpers.arrayMUX({'off', 'on'}, (obj.Verbose > 0));
    PlotFigure = figure('Visible', VisiblePlot);
    PlotAxes = axes(PlotFigure);
    FilePath = fullfile(obj.SaveDir, ...
        [obj.FitTarget, 'EnsembleFit_', obj.BaseSaveName]);
    switch obj.FitTarget
        case 'MSD'
            % Plot the MSD and the associated fit.
            if (obj.Verbose > 1)
                fprintf('saveResults(): saving MSD fit plot to \n\t%s...\n', ...
                    FilePath)
            end
            obj.plotEnsembleMSD(PlotAxes, obj.MSDEnsemble, ...
                obj.DiffusionStruct, obj.DiffusionModel, ...
                obj.UnitFlag);
        case 'CDFOfJumps'
            % Plot the CDF and the associated fit.
            if (obj.Verbose > 1)
                fprintf('saveResults(): saving CDF fit plot to \n\t%s...\n', ...
                    FilePath)
            end
            obj.plotEnsembleCDFOfJumps(PlotAxes, obj.MSDEnsemble, ...
                obj.DiffusionStruct, obj.UnitFlag);
    end
    
    % Save the plot.
    saveas(PlotFigure, FilePath, 'png')
    if (obj.Verbose < 2)
        % For the higher verbosity levels, we'll keep the plot open for the
        % user to view.
        close(PlotFigure)
    end
end


end
./MATLAB/+smi_stat/@DiffusionEstimator/estimateDiffusionConstant.m
function [DiffusionStruct] = estimateDiffusionConstant(obj)
%estimateDiffusionConstant estimates the diffusion constant.
% This method will fit the MSD/CDF/etc. data to estimate the diffusion
% constant(s). This is meant to be the main run method of the
% DiffusionEstimator class.
%
% OUTPUTS:
%   DiffusionStruct: Structure array containing the fit diffusion
%                    constants and their standard errors. The units will be
%                    specified by the property obj.UnitFlag, with 1
%                    specifying physical units (micrometers, seconds) and 0
%                    specifying camera units (pixels, frames).

% Created by:
%   David J. Schodt (Lidke lab, 2021)


% Compute the MSDs.
if (obj.Verbose > 0)
    fprintf('estimateDiffusionConstant(): computing MSDs...\n');
end
[obj.MSDSingleTraj, obj.MSDEnsemble] = ...
    obj.computeMSD(obj.TR, obj.FrameLagRange, obj.Verbose);

% Fit the results and convert units where necessary.
if (obj.Verbose > 1)
    fprintf(['estimateDiffusionConstant(): fitting trajectory-wise ', ...
        'data...\n']);
elseif (obj.Verbose > 0)
    fprintf(['estimateDiffusionConstant(): estimating diffusion ', ...
        'constants...\n']);
end
JumpUnitConversion = ~obj.UnitFlag + obj.UnitFlag*obj.SMF.Data.PixelSize;
FrameUnitConversion = ~obj.UnitFlag + obj.UnitFlag*obj.SMF.Data.FrameRate;
ParamsSingleTraj = NaN;
ParamsSingleTrajSE = NaN;
DiffusionConstantSingleTraj = NaN;
DiffusionConstantSingleTrajSE = NaN;
PopulationRatiosSingleTraj = NaN;
PopulationRatiosSingleTrajSE = NaN;
switch obj.FitTarget
    case 'MSD'
        % Update NComponents to make sure it's 1 (we can't fit multiple
        % components with MSD).
        obj.NComponents = 1;
        
        % Fit the trajectory-wise MSDs.
        % NOTE: fitMSD() is written such that the SEs are only computed
        %       when the second output is requested.
        if obj.FitIndividualTrajectories
            if obj.EstimateSEs
                [ParamsSingleTraj, ParamsSingleTrajSE] = ...
                    obj.fitMSD(obj.MSDSingleTraj, ...
                    obj.FitMethod, obj.NFitPoints, ...
                    obj.DiffusionModel, obj.Verbose);
            else
                ParamsSingleTraj = obj.fitMSD(obj.MSDSingleTraj, ...
                    obj.FitMethod, obj.NFitPoints, ...
                    obj.DiffusionModel, obj.Verbose);
                ParamsSingleTrajSE = NaN(size(ParamsSingleTraj));
            end
            ParamsSingleTraj = ParamsSingleTraj ...
                .* (JumpUnitConversion.^2) .* [1, FrameUnitConversion];
            ParamsSingleTrajSE = ParamsSingleTrajSE ...
                .* (JumpUnitConversion.^2) .* [1, FrameUnitConversion];
            
            % Compute the diffusion constants.
            DiffusionConstantSingleTraj = ...
                ParamsSingleTraj(:, 2) / (2*obj.NDimensions);
            DiffusionConstantSingleTrajSE = ...
                ParamsSingleTrajSE(:, 2) / (2*obj.NDimensions);
            PopulationRatiosSingleTraj = 1;
            PopulationRatiosSingleTrajSE = 0;
        end
        
        % Fit the ensemble MSD.
        if (obj.Verbose > 1)
            fprintf(['estimateDiffusionConstant(): fitting ensemble ', ...
                'MSD...\n']);
        end
        if obj.EstimateSEs
            [ParamsEnsemble, ParamsEnsembleSE] = ...
                obj.fitMSD(obj.MSDEnsemble, ...
                obj.FitMethod, obj.NFitPoints, ...
                obj.DiffusionModel, obj.Verbose);
        else
            ParamsEnsemble = obj.fitMSD(obj.MSDEnsemble, ...
                obj.FitMethod, obj.NFitPoints, ...
                obj.DiffusionModel, obj.Verbose);
            ParamsEnsembleSE = NaN(size(ParamsEnsemble));
        end
        ParamsEnsemble = ParamsEnsemble ...
            .* (JumpUnitConversion.^2) .* [1, FrameUnitConversion];
        ParamsEnsembleSE = ParamsEnsembleSE ...
            .* (JumpUnitConversion.^2) .* [1, FrameUnitConversion];
        
        % Compute the ensemble diffusion constant.
        DiffusionConstantEnsemble = ...
            ParamsEnsemble(:, 2) / (2*obj.NDimensions);
        DiffusionConstantEnsembleSE = ...
            ParamsEnsembleSE(:, 2) / (2*obj.NDimensions);
        PopulationRatiosEnsemble = 1;
        PopulationRatiosEnsembleSE = 0;
    case 'CDFOfJumps'
        % Modify obj.NFitPoints to reflect the fact that we're fitting the
        % entire CDF, no matter what the user has requested!
        obj.NFitPoints = numel(obj.MSDEnsemble.FrameLagsAll);
        
        % Compute the CDF (cumulative distribution function, a.k.a.
        % cumulative probability distribution, CPD) of the trajectory-wise
        % displacements.
        obj.MSDSingleTraj = ...
            obj.computeCDFOfJumps(obj.MSDSingleTraj, obj.FrameLagRange);
        obj.MSDEnsemble = ...
            obj.computeCDFOfJumps(obj.MSDEnsemble, obj.FrameLagRange);
        
        % Fit the trajectory-wise CDFs.
        if obj.FitIndividualTrajectories
            if obj.EstimateSEs
                [ParamsSingleTraj, ParamsSingleTrajSE] = ...
                    obj.fitCDFOfJumps(obj.MSDSingleTraj, ...
                    obj.FitMethod, obj.NComponents, ...
                    obj.DiffusionModel, obj.Verbose);
            else
                ParamsSingleTraj = ...
                    obj.fitCDFOfJumps(obj.MSDSingleTraj, ...
                    obj.FitMethod, obj.NComponents, ...
                    obj.DiffusionModel, obj.Verbose);
                ParamsSingleTrajSE = NaN(size(ParamsSingleTraj));
            end
            ParamsSingleTraj(1:obj.NComponents) = ...
                ParamsSingleTraj(1:obj.NComponents) ...
                .* (JumpUnitConversion.^2) .* FrameUnitConversion;
            ParamsSingleTrajSE(1:obj.NComponents) = ...
                ParamsSingleTrajSE(1:obj.NComponents) ...
                .* (JumpUnitConversion.^2) .* FrameUnitConversion;
            
            % Extract the diffusion constants and population ratios.
            DiffusionConstantSingleTraj = ...
                ParamsSingleTraj(:, 1:obj.NComponents);
            DiffusionConstantSingleTrajSE = ...
                ParamsSingleTrajSE(:, 1:obj.NComponents);
            PopulationRatiosSingleTraj = ...
                ParamsSingleTraj(:, (obj.NComponents+1):end);
            PopulationRatiosSingleTrajSE = ...
                ParamsSingleTrajSE(:, (obj.NComponents+1):end);
        end
        
        % Fit the ensemble CDF of jumps.
        if (obj.Verbose > 1)
            fprintf(['estimateDiffusionConstant(): fitting ensemble ', ...
                'CDF of jumps...\n']);
        end
        if obj.EstimateSEs
            [ParamsEnsemble, ParamsEnsembleSE] = ...
                obj.fitCDFOfJumps(obj.MSDEnsemble, ...
                obj.FitMethod, obj.NComponents, ...
                obj.DiffusionModel, obj.Verbose);
        else
            ParamsEnsemble = ...
                obj.fitCDFOfJumps(obj.MSDEnsemble, ...
                obj.FitMethod, obj.NComponents, ...
                obj.DiffusionModel, obj.Verbose);
            ParamsEnsembleSE = NaN(size(ParamsEnsemble));
        end
        ParamsEnsemble(1:obj.NComponents) = ...
            ParamsEnsemble(1:obj.NComponents).' ...
            .* (JumpUnitConversion.^2) .* FrameUnitConversion;
        ParamsEnsembleSE(1:obj.NComponents) = ...
            ParamsEnsembleSE(1:obj.NComponents).' ...
            .* (JumpUnitConversion.^2) .* FrameUnitConversion;
        
        % Extract the diffusion constants and population ratios.
        DiffusionConstantEnsemble = ...
            ParamsEnsemble(1:obj.NComponents);
        DiffusionConstantEnsembleSE = ...
            ParamsEnsembleSE(1:obj.NComponents);
        PopulationRatiosEnsemble = ...
            ParamsEnsemble((obj.NComponents+1):end);
        PopulationRatiosEnsembleSE = ...
            ParamsEnsembleSE((obj.NComponents+1):end);
    case 'LikelihoodOfJumps'
        % Modify obj.NFitPoints to reflect the fact that we're using all of
        % the data in the MLE.
        obj.NFitPoints = numel(obj.MSDEnsemble.FrameLagsAll);
        
        % Compute the trajectory-wise MLEs.
        % NOTE: This is the same model as the 'CDFOfJumps', but making an
        %       MLE from the PDF instead of fitting the CDF.
        if obj.FitIndividualTrajectories
            if obj.EstimateSEs
                [ParamsSingleTraj, ParamsSingleTrajSE] = ...
                    obj.mleOfJumps(obj.MSDSingleTraj, ...
                    obj.NComponents, obj.DiffusionModel, obj.Verbose);
            else
                ParamsSingleTraj = ...
                    obj.mleOfJumps(obj.MSDSingleTraj, ...
                    obj.NComponents, obj.DiffusionModel, obj.Verbose);
                ParamsSingleTrajSE = NaN(size(ParamsSingleTraj));
            end
            ParamsSingleTraj(1:obj.NComponents) = ...
                ParamsSingleTraj(1:obj.NComponents) ...
                .* (JumpUnitConversion.^2) .* FrameUnitConversion;
            ParamsSingleTrajSE(1:obj.NComponents) = ...
                ParamsSingleTrajSE(1:obj.NComponents) ...
                .* (JumpUnitConversion.^2) .* FrameUnitConversion;
            
            % Extract the diffusion constants and population ratios.
            DiffusionConstantSingleTraj = ...
                ParamsSingleTraj(:, 1:obj.NComponents);
            DiffusionConstantSingleTrajSE = ...
                ParamsSingleTrajSE(:, 1:obj.NComponents);
            PopulationRatiosSingleTraj = ...
                ParamsSingleTraj(:, (obj.NComponents+1):end);
            PopulationRatiosSingleTrajSE = ...
                ParamsSingleTrajSE(:, (obj.NComponents+1):end);
        end
        
        % Compute the ensemble MLEs.
        if (obj.Verbose > 1)
            fprintf(['estimateDiffusionConstant(): ', ...
                'computing MLE of jumps...\n']);
        end
        if obj.EstimateSEs
            [ParamsEnsemble, ParamsEnsembleSE] = obj.mleOfJumps(...
                obj.MSDEnsemble, obj.NComponents, ...
                obj.DiffusionModel, obj.Verbose);
        else
            ParamsEnsemble = obj.mleOfJumps(...
                obj.MSDEnsemble, obj.NComponents, ...
                obj.DiffusionModel, obj.Verbose);
            ParamsEnsembleSE = NaN(size(ParamsEnsemble));
        end
        ParamsEnsemble(1:obj.NComponents) = ...
            ParamsEnsemble(1:obj.NComponents) ...
            .* (JumpUnitConversion.^2) .* FrameUnitConversion;
        ParamsEnsembleSE(1:obj.NComponents) = ...
            ParamsEnsembleSE(1:obj.NComponents) ...
            .* (JumpUnitConversion.^2) .* FrameUnitConversion;
        
        % Extract the diffusion constants and population ratios.
        DiffusionConstantEnsemble = ...
            ParamsEnsemble(1:obj.NComponents);
        DiffusionConstantEnsembleSE = ...
            ParamsEnsembleSE(1:obj.NComponents);
        PopulationRatiosEnsemble = ...
            ParamsEnsemble((obj.NComponents+1):end);
        PopulationRatiosEnsembleSE = ...
            ParamsEnsembleSE((obj.NComponents+1):end);
end

% Store the results in the DiffusionStruct.
DiffusionStruct(1).Name = 'trajectory';
JumpUnit = smi_helpers.arrayMUX({'pixels', 'micrometers'}, obj.UnitFlag);
TimeUnit = smi_helpers.arrayMUX({'frames', 'seconds'}, obj.UnitFlag);
DiffusionStruct(1).Units = {JumpUnit; TimeUnit};
DiffusionStruct(1).FitParams = ParamsSingleTraj;
DiffusionStruct(1).FitParamsSE = ParamsSingleTrajSE;
DiffusionStruct(1).PixelSize = obj.SMF.Data.PixelSize;
DiffusionStruct(1).FrameRate = obj.SMF.Data.FrameRate;
DiffusionStruct(1).DiffusionConstant = DiffusionConstantSingleTraj;
DiffusionStruct(1).DiffusionConstantSE = DiffusionConstantSingleTrajSE;
DiffusionStruct(1).PopulationRatios = PopulationRatiosSingleTraj;
DiffusionStruct(1).PopulationRatiosSE = PopulationRatiosSingleTrajSE;
DiffusionStruct(1).NFitPoints = obj.NFitPoints;
DiffusionStruct(2).Name = 'ensemble';
DiffusionStruct(2).Units = {JumpUnit; TimeUnit};
DiffusionStruct(2).FitParams = ParamsEnsemble;
DiffusionStruct(2).FitParamsSE = ParamsEnsembleSE;
DiffusionStruct(2).PixelSize = obj.SMF.Data.PixelSize;
DiffusionStruct(2).FrameRate = obj.SMF.Data.FrameRate;
DiffusionStruct(2).DiffusionConstant = DiffusionConstantEnsemble;
DiffusionStruct(2).DiffusionConstantSE = DiffusionConstantEnsembleSE;
DiffusionStruct(2).PopulationRatios = PopulationRatiosEnsemble;
DiffusionStruct(2).PopulationRatiosSE = PopulationRatiosEnsembleSE;
DiffusionStruct(2).NFitPoints = obj.NFitPoints;
obj.DiffusionStruct = DiffusionStruct;


end
./MATLAB/+smi_stat/@DiffusionEstimator/brownianJumpLikelihood.m
function [LogLikelihood] = brownianJumpLikelihood(MotionParams, ...
    SquaredDisplacement, FrameLagsAll, LocVarianceSum)
%brownianJumpLikelihood computes the likelihood of given Brownian jumps.
% This method will generate a model of the distribution of the jumps made 
% by a Brownian random walker.
%
% INPUTS:
%   MotionParams: Array of parameters needed for the model. For the one
%                 component model, this is just D. For the two component
%                 model, this is [D_1; D_2; alpha_1, alpha_2]. 
%                 For N-components,
%                 this is [D_1, D_2, ..., D_N, 
%                         alpha_1, alpha_2, ..., alpha_N
%   SquaredDisplacement: The squared displacements made by the
%                        trajectory(ies). (NDatax1 numeric array)
%   FrameLagsAll: All of the frame lags associated with the jumps in
%                 'SquaredDisplacement'. (NDatax1 array)
%   LocVarianceSum: Sum of the localization variances for the two points
%                   used to compute the jumps. This array should be
%                   averaged over x and y. (NJumpsx1 numeric array)
%                   NOTE: I don't know which is better: average the
%                         variances, or average the SEs and square them? My
%                         bet is on averaging variances, but I'm not sure.
%                         This can make a big difference in some cases!
%
% OUTPUTS:
%   LogLikelihood: The log-likelihood of observing the jumps 
%                  'SortedSquaredDisp' assuming they were made by a 
%                   Brownian random walker.

% Created by:
%   David J. Schodt (Lidke lab, 2021)


% Ensure MotionParams is a row vector.
if iscolumn(MotionParams)
    MotionParams = MotionParams.';
end

% Determine which model we're using (1-component, 2-component, ...).
NParams = numel(MotionParams);
NComponents = NParams / 2;

% Compute the likelihood.
% NOTE: I'm taking the mean of the localization variance sums.  That's not
%       ideal, but dealing with those properly becomes too messy/slow
%       (i.e., we get another integral...).
% NOTE: For emphasis, 'LocVarianceSum' is the sum of the localization
%       variances of the two localizations, thus we don't need to
%       multiply it by a factor of 2.
% NOTE: Occasionally, outlier data (i.e., very large jumps due to, e.g.,
%       tracking errors) lead to infinite log-likelihood.  I'm ignoring
%       those outliers using the JumpLikelihood(JumpLikelihood == 0) = 1;
%       below (so that log(JumpLikelihood)=0 for those terms).
Variance = 2*FrameLagsAll*MotionParams(1:NComponents) ...
    + mean(LocVarianceSum);
JumpLikelihood = sum((sqrt(SquaredDisplacement)./Variance) ...
    .* exp(-0.5*SquaredDisplacement./Variance) ...
    .* MotionParams((NComponents+1):end), 2);
JumpLikelihood(JumpLikelihood == 0) = 1;
LogLikelihood = sum(log(JumpLikelihood));


end
./MATLAB/+smi_stat/@DiffusionEstimator/fitCDFOfJumpsBrownian.m
function [FitParams, FitParamsSE] =  fitCDFOfJumpsBrownian(...
    SortedSquaredDisp, CDFOfJumps, SortedFrameLagsAll, NPoints, ...
    LocVarianceSum, NComponents, Weights, FitMethod, FitOptions)
%fitCDFOfJumpsBrownian fits the CDF of jumps to a Brownian motion model.
% This method will fit the CDF of squared displacements to a Brownian
% motion model with either one diffusing population (i.e., one diffusion
% constant) or two diffusing populations (two diffusion constants and the
% population ratio).
%
% INPUTS:
%   SortedSquaredDisp: The sorted (in ascending order) squared jumps used 
%                      to compute 'CDFOfJumps'. (numeric array)
%   CDFOfJumps: CDF of the jumps (displacements). (NDatax1 array)
%   SortedFrameLagsAll: All of the frame lags associated with the jumps in
%                 'SortedSquaredDisp'. (NDatax1 array)
%   NPoints: The number of data points (or jumps) corresponding to each
%            frame lag in 'FrameLags' (NFrameLagsx1 array)
%   LocVarianceSum: Sum of the localization variances for the two points
%                   used to compute the jumps. This array should be
%                   averaged over x and y.
%                   (NDatax1 numeric array)
%                   NOTE: I don't know which is better: average the
%                         variances, or average the SEs and square them? My
%                         bet is on averaging variances, but I'm not sure.
%                         This can make a big difference in some cases!
%   NComponents: Number of diffusion coefficients to fit.
%                (scalar, integer)(Default = 2)
%   Weights: Weights used for weighted least squares. (NDatax1 array)
%            (Default = ones(NFrameLags, 1) i.e. no weighting)
%   FitMethod: A string specifying the fit method. (Default = 'WeightedLS')
%   FitOptions: Fit options sent directly to fminsearch (see doc fminsearch
%               for details)(Default = optimset(@fminsearch)
%               or optimoptions('fmincon') as appropriate)
%
% OUTPUTS:
%   FitParams: Fit parameters for the MSD fit where
%              MSDFit = FitParams(1) + FitParams(2)*FrameLags
%   FitParamsSE: Standard errors for the MSD fit parameters 'FitParams'.
%
% REQUIRES:
%   Optimization Toolbox (for fmincon() when using the N-component models)

% Created by:
%   David J. Schodt (Lidke lab, 2021)


% Define default parameters if needed.
if (~exist('FitMethod', 'var') || isempty(FitMethod))
    FitMethod = 'WeightedLS';
end
NJumps = numel(SortedSquaredDisp);
if (~exist('Weights', 'var') || isempty(Weights))
    Weights = ones(NJumps, 1);
end
if (~exist('NComponents', 'var') || isempty(NComponents))
    NComponents = 2;
end
if (~exist('FitOptions', 'var') || isempty(FitOptions))
    if (NComponents > 1)
        FitOptions = optimoptions('fmincon');
        FitOptions.Display = 'none';
    else
        FitOptions = optimset(@fminsearch);
    end
end

% Fit the CDF of the MSD to the model.
NFitComponents = 2 * NComponents;
switch FitMethod
    case {'LS', 'WeightedLS'}
        % For regular least squares ('LS'), overwrite Weights to just be an
        % array of ones (i.e., no weighting).
        Weights = strcmpi(FitMethod, 'LS')*ones(NJumps, 1) ...
            + strcmpi(FitMethod, 'WeightedLS')*Weights;
        
        % Define lower and upper bounds for the fit parameters (only used
        % for NComponents > 1).
        ParamsLowerBound = ...
            [min(SortedSquaredDisp./(4*SortedFrameLagsAll))*ones(NComponents, 1); ...
            zeros(NComponents, 1)];
        ParamsUpperBound = ...
            [max(SortedSquaredDisp./(4*SortedFrameLagsAll))*ones(NComponents, 1); ...
            ones(NComponents, 1)];
        
        % Define constraints of the form A*x = b (e.g., for now
        % I'm forcing the sum of N population ratios to be == 1).
        Aeq = zeros(NFitComponents);
        Aeq(1, (NComponents+1):end) = 1;
        beq = zeros(NFitComponents, 1);
        beq(1) = 1;
                
        % Fit the CDF of the displacements using least squares. This
        % process is quite slow due to the bootstrap, so I'll only do the
        % bootstrap if the output FitParamsSE was requested.
        % NOTE: This model can be found by taking the
        %       prob(r|sigma^2=2Dt+loc.error) (which is a product of
        %       Gaussians), converting to polar coordinates, integrating
        %       over theta, and then integrating from 0 to r' to get the
        %       CDF. For multiple frame lags (as we have), we'll also need
        %       to integrate over the frame lags times the proportion of
        %       each frame lag observed.
        CostFunction = @(Params, SortedSqJumps, CDFOfJumps) sum(Weights ...
            .* (smi_stat.DiffusionEstimator.brownianJumpCDF(...
            Params, SortedSqJumps, unique(SortedFrameLagsAll), NPoints, ...
            LocVarianceSum) - CDFOfJumps).^2);
        Quantiles = quantile(SortedSquaredDisp./(4*SortedFrameLagsAll), ...
            NComponents+2);
        DInitGuess = Quantiles(2:(end-1));
        AlphaInitGuess = (1/NComponents) * ones(1, NComponents);
        ParamsInit = [DInitGuess, AlphaInitGuess].';
        if (nargout > 1)
            % For the single component fit, we'll just use fminsearch().
            % For the N-component fit, it sometimes seems important to
            % constrain the fit to get a reasonable result.
            if (NComponents > 1)
                % Perform the constrained fit.
                [FitParams, FitParamsSE] = smi_stat.bootstrapFitCon(...
                    SortedSquaredDisp, CDFOfJumps, ParamsInit, CostFunction, ...
                    [], Aeq, beq, [], [], ...
                    ParamsLowerBound, ParamsUpperBound, FitOptions);
            else
                [FitParams, FitParamsSE] = smi_stat.bootstrapFit(...
                    SortedSquaredDisp, CDFOfJumps, ParamsInit, CostFunction, ...
                    [], FitOptions);
            end
        else
            % For the single component fit, we'll just use fminsearch().
            % For the N-component fit, it sometimes seems important to
            % constrain the fit to get a reasonable result.
            if (NComponents > 1)
                % Perform the constrained fit.
                FitParams = fmincon(@(Params) ...
                    CostFunction(Params, SortedSquaredDisp, CDFOfJumps), ...
                    ParamsInit, [], [], Aeq, beq, ...
                    ParamsLowerBound, ParamsUpperBound);
            else
                FitParams = fminsearch(@(Params) ...
                    CostFunction(Params, SortedSquaredDisp, CDFOfJumps), ...
                    ParamsInit, FitOptions);
            end
        end
    otherwise
        error('Unknown ''FitMethod'' = %s', FitMethod)
end


end
./MATLAB/+smi_stat/@DiffusionEstimator/README.md
### +smi_stat/@DiffusionEstimator

DiffusionEstimator contains several methods used to estimate diffusion
constants from single-particle tracking data.

REQUIRES:
- Optimization Toolbox (to use fmincon() for certain models)

For a detailed example, see
[Example_DiffusionEstimator.m](../../examples/Example_DiffusionEstimator.m).

---

```
properties:
   % ID of the diffusion model to be considered (char array/string)
   % OPTIONS:
   %   'Brownian'
   DiffusionModel{mustBeMember(DiffusionModel, {'Brownian'})} = ...
       'Brownian';
   
   % Number of diffusing components. (Default = 1)
   % This can only be changed for FitTarget = CDFOfJumps or
   % LikelihoodOfJumps.
   NComponents = 1;
   
   % Fit method for fitting data (char array/string)
   FitMethod{mustBeMember(FitMethod, {'WeightedLS', 'LS'})} = ...
       'WeightedLS';
   
   % Target data that will be fit (char array/string)
   FitTarget{mustBeMember(FitTarget, ...
       {'MSD', 'CDFOfJumps', 'LikelihoodOfJumps'})} = 'MSD';

   % Range of frame lags used to estimate D (Default = [1, 5])
   FrameLagRange = [1, 5];
   
   % Number of MSD points to be fit (scalar, integer)(Default = 5)
   NFitPoints = 5;
   
   % Flag to estimate standard errors (Default = true)
   % NOTE: For some of the fit methods/fit targets (e.g., FitTarget =
   %       'CDFOfJumps') we have to use a bootstrap, in which case
   %       estimating SEs can be unreasonably slow.
   EstimateSEs = true;
   
   % Flag to fit individual trajectory MSDs/CDFs (Default = true)
   FitIndividualTrajectories = true;
   
   % Number of spatial dimensions (scalar, integer)(Default = 2)
   NDimensions = 2;
   
   % Directory in which results will be saved by saveResults().
   SaveDir = pwd();
   
   % Base name of saved results. Default defined in obj.saveDir().
   BaseSaveName
   
   % Tracking results structure.
   TR
   
   % Single Molecule Fitting structure, for pixel size and framerate.
   SMF = smi_core.SingleMoleculeFitting;
   
   % Boolean flag to indicate units of outputs (boolean)(Default = 0)
   % 1 (true) will make the outputs of estimateDiffusionConstant()
   %   micrometers and seconds.
   % 0 (false) will make the outputs of estimateDiffusionConstant()
   %   pixels and frames.
   % NOTE: Most methods of this class will use pixels and frames
   %       regardless of obj.UnitFlag. This property will only affect
   %       the "user-facing" wrapper methods, such as
   %       estimateDiffusionConstant() and saveResults()
   UnitFlag = false;
        
   % Verbosity level for estimateDiffusionConstant() (Default = 0)
   %   Verbose 0: no Command Window outputs
   %   Verbose 1: General progress printed to Command Window
   %   Verbose 2: Display some intermediate results
   %   Verbose 3: Debugging mode, extensive outputs
   Verbose = 0;
```

---

methods:
- **[brownianJumpCDF](brownianJumpCDF.m)**:
  generates a model of the CDF of Brownian jumps
- **[brownianJumpLikelihood](brownianJumpLikelihood.m)**:
  computes the likelihood of given Brownian jumps
- **[computeCDFOfJumps](computeCDFOfJumps.m)**:
  computes the CDF (CPD) of the jumps in 'MSDStruct'.
- **[computeMSD](computeMSD.m)**:
  computes the mean squared displacement from TR
- **[computeSingleTrajMSD](computeSingleTrajMSD.m)**:
  computes the mean squared displacement from TR
- **[estimateDiffusionConstant](estimateDiffusionConstant.m)**:
  estimates the diffusion constant
- **[fitCDFOfJumps](fitCDFOfJumps.m)**:
  fits the CDF of displacement data (jumps)
- **[fitCDFOfJumpsBrownian](fitCDFOfJumpsBrownian.m)**:
  fits the CDF of jumps to a Brownian motion model
- **[fitMSD](fitMSD.m)**:
  fits mean squared displacement data
- **[fitMSDBrownian](fitMSDBrownian.m)**:
  fits an MSD to a Brownian motion model
- **[mleOfJumps](mleOfJumps.m)**:
  finds the MLE from the likelihood of observed jumps
- **[mleOfJumpsBrownian](mleOfJumpsBrownian.m)**:
  finds the MLE for Brownian motion jumps
- **[plotEnsembleCDFOfJumps](plotEnsembleCDFOfJumps.m)**:
  plots the CDF of jumps and an associated fit
- **[plotEnsembleMSD](plotEnsembleMSD.m)**:
  plots an ensemble MSD and an associated fit
- **[saveResults](saveResults.m)**:
  saves useful results of diffusion estimation analysis
- **[unitTest](unitTest.m)**:
  test calling smi_stat.DiffusionEstimator routines

./MATLAB/+smi_stat/@DiffusionEstimator/computeCDFOfJumps.m
function [MSDStruct] = computeCDFOfJumps(MSDStruct, FrameLagRange)
%computeCDFOfMSD computes the CDF (CPD) of the jumps in 'MSDStruct'.
% This method will compute the empirical cumulative distribution function
% of the displacements provided in 'MSDStruct'.
%
% INPUTS:
%   MSDStruct: A structure array of MSD data as output from computeMSD()
%              (see computeMSD() outputs for more details).
%   FrameLagRange: Range of frame lags included in the CDF computation. 
%                  (2 element array, [min. frame lag, max. frame lag])
%                  (Default = [2, 2], so only jumps across 2 frames are 
%                  included)
%
% OUTPUTS:
%   MSDStruct: A structure array of MSD data as output from computeMSD()
%              (see computeMSD() for more details), with a new field(s)
%              added containing the CDF of the MSD.

% Created by:
%   David J. Schodt (Lidke lab, 2021)


% Set defaults/revise inputs if needed.
if (~exist('FrameLagRange', 'var') || isempty(FrameLagRange))
    FrameLagRange = [2, 2];
else
    FrameLagRange = sort(FrameLagRange);
end

% Loop through the provided MSDStruct and compute the CDF.
for ii = 1:numel(MSDStruct)
    if ~isempty(MSDStruct(ii).MSD)
        % Sort arrays as needed.
        [MSDStruct(ii).SortedSquaredDisp, SortIndices] = ...
            sort(MSDStruct(ii).SquaredDisplacement);
        MSDStruct(ii).FrameLagsAll = ...
            MSDStruct(ii).FrameLagsAll(SortIndices);
        
        % Isolate the data corresponding to frame lags in 'FrameLagRange'.
        KeepBool = ((MSDStruct(ii).FrameLagsAll>=FrameLagRange(1)) ...
            & (MSDStruct(ii).FrameLagsAll<=FrameLagRange(2)));
        MSDStruct(ii).SortedSquaredDisp = ...
            MSDStruct(ii).SortedSquaredDisp(KeepBool);
        MSDStruct(ii).FrameLagsAll = ...
            MSDStruct(ii).FrameLagsAll(KeepBool);
        
        % Compute the CDF of the jumps.
        NJumps = numel(MSDStruct(ii).SortedSquaredDisp);
        MSDStruct(ii).CDFOfJumps = cumsum(ones(NJumps, 1)) / NJumps;
    end
end


end
./MATLAB/+smi_stat/@DiffusionEstimator/fitCDFOfJumps.m
function [FitParams, FitParamsSE] = fitCDFOfJumps(MSDStruct, FitMethod, ...
    NComponents, DiffusionModel, Verbose)
%fitCDFOfJumps fits the CDF of displacement data (jumps).
% This method will fit a model to the CDF (CPD) of trajectory
% displacements.
%
% INPUTS:
%   MSDStruct: A structure array of MSD data as output from computeMSD()
%              (see computeMSD() for more details). The MSDStruct must
%              already be populated with SortedJumps and CDFOfJumps (see
%              computeCDFOfMSD()).
%   FitMethod: A string specifying the fit method. (Default = 'WeightedLS')
%   NComponents: Number of diffusive components used in fit. (Default = 1)
%   DiffusionModel: A string specifying the diffusion model to fit to the
%                   MSD. See options in DiffusionEstimator class property
%                   'DiffusionModel'. (Default = 'Brownian')
%   Verbose: Verbosity level specifying how many temporary outputs should
%            be displayed (e.g., Command Window updates).
%
% OUTPUTS:
%   FitParams: Fit parameters for the CDF fit.  These will vary based on
%              'FitMethod'. FitParams(ii, :) will contain the fit
%              parameters for the fit to MSDStruct(ii).
%              (numel(MSDStruct)xNParameters array)
%   FitParamsSE: Standard errors for the CDF fit parameters 'FitParams'.
%                These will vary based on 'Method'.

% Created by:
%   David J. Schodt (Lidke lab, 2021)


% Define default parameters if needed.
if (~exist('FitMethod', 'var') || isempty(FitMethod))
    FitMethod = 'WeightedLS';
end
if (~exist('NComponents', 'var') || isempty(NComponents))
    NComponents = 1;
end
if (~exist('DiffusionModel', 'var') || isempty(DiffusionModel))
    DiffusionModel = 'Brownian';
end
if (~exist('Verbose', 'var') || isempty(Verbose))
    Verbose = 0;
end

% Determine how many fit parameters are needed in the desired model.
NFitParams = 2 * NComponents;

% Fit the CDF data.
if (Verbose > 1)
    fprintf(['fitCDFOfJumps(): fitting CDF of jumps with FitMethod = ', ...
        '''%s''...\n'], FitMethod)
end
NFits = numel(MSDStruct);
FitParams = NaN(NFits, NFitParams);
FitParamsSE = NaN(NFits, NFitParams);
for ii = 1:NFits
    % Isolate some arrays needed for the fit.
    CDFOfJumps = double(MSDStruct(ii).CDFOfJumps);
    if isempty(CDFOfJumps)
        % This trajectory was too short so we can't make the fit.
        continue
    end
    FrameLagsAll = double(MSDStruct(ii).FrameLagsAll);
    NPoints = double(MSDStruct(ii).NPoints);
    LocVarianceSum = double(MSDStruct(ii).LocVarianceSum);
    SortedSquaredDisp = double(MSDStruct(ii).SortedSquaredDisp);
    
    % Fit the CDF of the jumps to the desired diffusion model.
    % NOTE: We're only allowing Brownian motion for now.
    switch lower(DiffusionModel)
        case 'brownian'
            if (nargout > 1)
                [ParamsHat, ParamsHatSE] = ...
                    smi_stat.DiffusionEstimator.fitCDFOfJumpsBrownian(...
                    SortedSquaredDisp, CDFOfJumps, ...
                    FrameLagsAll, NPoints, LocVarianceSum, NComponents, ...
                    [], FitMethod);
                FitParamsSE(ii, :) = ParamsHatSE.';
            else
                ParamsHat = ...
                    smi_stat.DiffusionEstimator.fitCDFOfJumpsBrownian(...
                    SortedSquaredDisp, CDFOfJumps, ...
                    FrameLagsAll, NPoints, LocVarianceSum, NComponents, ...
                    [], FitMethod);
            end
            FitParams(ii, :) = ParamsHat.';
        otherwise
            error('Unknown ''DiffusionModel'' = %s', DiffusionModel)
    end
end


end
./MATLAB/+smi_stat/@DiffusionEstimator/computeMSD.m
function [MSDSingleTraj, MSDEnsemble] = ...
    computeMSD(TR, FrameLagRange, Verbose)
%computeMSD computes the mean squared displacement from TR.
% This method computes the trajectory-wise and ensemble mean squared
% displacements of the trajectories given in 'TR'.
%
% INPUTS:
%   TR: Tracking results structure.
%   FrameLagRange: Range of frame differences between localizations for
%                  which MSD is computed. (Default is from 1 to 1/4 of the 
%                  max possible frame lag for the ensemble
%                  calculation)([min., max.])
%   Verbose: Verbosity level specifying how many temporary outputs should
%            be displayed (e.g., Command Window updates).
%
% OUTPUTS:
%   MSDSingleTraj: A structure array containing the trajectory-wise MSD
%                  results.  All units are in camera units (pixels, frames)
%   MSDEnsemble: A structure array containing the ensemble MSD results.
%                All units are in camera units (pixels, frames)

% Created by:
%   David J. Schodt (Lidke lab, 2021)
%       based on msdAnalysis.m by Hanieh Mazloom-Farsibaf (Lidke lab, 2018)


% Set defaults/validate parameters if needed.
if (~exist('Verbose', 'var') || isempty(Verbose))
    Verbose = 0;
end
MaxFrameDiff = ...
    max(cell2mat(cellfun(@(X) X(end) - X(1), {TR.FrameNum}, ...
    'UniformOutput', false).'));
DefaultMaxFrameLag = ceil(MaxFrameDiff / 4);
if (~exist('FrameLagRange', 'var') || isempty(FrameLagRange))
    FrameLagRange = [1, DefaultMaxFrameLag];
elseif (FrameLagRange(2) > MaxFrameDiff)
    if (Verbose > 2)
        % For the highest verbosity levels, we should share more info. than
        % just the warning.
        fprintf(['computeMSD(): Input max(FrameLagRange)=%i but the\n', ...
            '\tmaximum possible frame lag is %i frames. FrameLagRange\n', ...
            '\twill be set to a default value of [1, %i]\n'], ...
            FrameLagRange(2), MaxFrameDiff, DefaultMaxFrameLag)
    elseif (Verbose > 0)
        warning(['computeMSD(): Input max(FrameLagRange)=%i is too large. ', ...
            'Using default of %i.'], ...
            FrameLagRange(2), DefaultMaxFrameLag)
    end
    FrameLagRange = [1, DefaultMaxFrameLag];
end

% Loop through all trajectories in TR and compute the trajectory-wise and
% ensemble MSDs.
NTraj = numel(TR);
if (Verbose > 1)
    fprintf(['computeMSD(): computing trajectory-wise MSDs for %i ', ...
        'localizations.\n'], NTraj)
end
MSDSingleTraj = struct([]);
MSDMatrix = zeros(NTraj, FrameLagRange(2));
NPointsMatrix = MSDMatrix;
SquaredDisplacement = [];
LocVarianceSum = [];
FrameLagsAll = [];
for ii = 1:NTraj
    % Compute the MSD for this trajectory.
    if (Verbose > 2)
        fprintf(['computeMSD(): computing MSD for ', ...
            'trajectory TR(%i)...\n'], ii)
    end
    MSDCurrent = smi_stat.DiffusionEstimator.computeSingleTrajMSD(...
        TR(ii), FrameLagRange, Verbose);
    MSDSingleTraj = [MSDSingleTraj; MSDCurrent];
    
    % Store the single trajectory MSD in a matrix with all of the
    % trajectory MSDs.
    CurrentLags = MSDCurrent.FrameLags;
    MSDMatrix(ii, CurrentLags) = MSDCurrent.MSD;
    NPointsMatrix(ii, CurrentLags) = MSDCurrent.NPoints;
    SquaredDisplacement = [SquaredDisplacement; ...
        MSDCurrent.SquaredDisplacement];
    LocVarianceSum = [LocVarianceSum; MSDCurrent.LocVarianceSum];
    FrameLagsAll = [FrameLagsAll; MSDCurrent.FrameLagsAll];
end
if (Verbose > 1)
    fprintf('computeMSD(): computing ensemble MSD...\n')
end
FrameLags = (FrameLagRange(1):FrameLagRange(2)).';
MSDMatrix = MSDMatrix(:, FrameLags);
NPointsMatrix = NPointsMatrix(:, FrameLags);
NPoints = sum(NPointsMatrix, 1).';
MSD = sum(MSDMatrix.*NPointsMatrix, 1).' ./ NPoints;
KeepBool = ~isnan(MSD);
MSDEnsemble.MSD = MSD(KeepBool);
MSDEnsemble.FrameLags = FrameLags(KeepBool);
MSDEnsemble.NPoints = NPoints(KeepBool);
MSDEnsemble.SquaredDisplacement = SquaredDisplacement;
MSDEnsemble.LocVarianceSum = LocVarianceSum;
MSDEnsemble.FrameLagsAll = FrameLagsAll;


end
./MATLAB/+smi_stat/@DiffusionEstimator/brownianJumpCDF.m
function [CDFOfJumps] = brownianJumpCDF(MotionParams, ...
    SortedSquaredDisp, FrameLags, NPoints, LocVarianceSum)
%brownianJumpCDF generates a model of the CDF of Brownian jumps.
% This method will generate a model of the CDF (CPD) of the jumps made by a
% Brownian random walker.
%
% INPUTS:
%   MotionParams: Array of parameters needed for the model. For the one
%                 component model, this is just D. For the two component
%                 model, this is [D_1; D_2; alpha_1; alpha_2].
%                 For N-components, this is [D_1, D_2, ..., D_N, 
%                         alpha_1, alpha_2, ..., alpha_N
%   SortedSquaredDisp: The sorted (in ascending order) squared jumps used 
%                      to compute 'CDFOfJumps'. (numeric array)
%   FrameLags: All of the unique frame lags associated with the jumps in
%              'SortedSquaredDisp'. Note that this isn't necessarily the 
%              same size as 'SortedSquaredDisp', since 'SortedSquaredDisp'
%              can contain multiple jumps for each frame lag. 
%              (NFrameLagsx1 array)
%   NPoints: The number of data points (or jumps) corresponding to each
%            frame lag in 'FrameLags' (NFrameLagsx1 array)
%   LocVarianceSum: Sum of the localization variances for the two points
%                   used to compute the jumps. This array should be
%                   averaged over x and y.
%                   (NJumpsx1 numeric array)
%                   NOTE: I don't know which is better: average the
%                         variances, or average the SEs and square them? My
%                         bet is on averaging variances, but I'm not sure.
%                         This can make a big difference in some cases!
%
% OUTPUTS:
%   CDFOfJumps: The CDF (cumulative distribution function, cumulative
%               probability distribution, etc.) of the jump sizes made by a
%               Brownian random walker.

% Created by:
%   David J. Schodt (Lidke lab, 2021)


% Ensure MotionParams is a column vector.
if isrow(MotionParams)
    MotionParams = MotionParams.';
end

% Determine which model we're using (1-component, 2-component, ...).
NParams = numel(MotionParams);
NComponents = NParams / 2;

% Compute the probability of each frame lag (i.e., the proportion of data
% corresponding to each frame lag).
FrameLagProb = NPoints / sum(NPoints);

% Compute the CDF model.
% NOTE: I'm taking the mean of the localization variance sums.  That's not
%       ideal, but dealing with those properly becomes too messy/slow
%       (i.e., we get another integral...).
NFrameLags = numel(FrameLags);
ZerosArray = zeros(numel(SortedSquaredDisp), 1);
CDFOfJumps = ZerosArray;
for nn = 1:NComponents
    % Define the variance term for this component.
    % NOTE: For emphasis, 'LocVarianceSum' is the sum of the localization
    %       variances of the two localizations, thus we don't need to
    %       multiply it by a factor of 2.
    Variance = 2*FrameLags*MotionParams(nn) + mean(LocVarianceSum);
    
    % Sum over frame lags.
    CDFOfJumpsNN = ZerosArray;
    for ff = 1:NFrameLags
        CDFOfJumpsNN = CDFOfJumpsNN ...
            + (FrameLagProb(ff) ...
            * (1-exp(-0.5*SortedSquaredDisp/Variance(ff))));
    end
    CDFOfJumps = CDFOfJumps + MotionParams(nn+NComponents)*CDFOfJumpsNN;
end


end
./MATLAB/+smi_stat/@DiffusionEstimator/computeSingleTrajMSD.m
function [MSDSingleTraj] = computeSingleTrajMSD(TR, FrameLagRange, Verbose)
%computeSingleTrajMSD computes the mean squared displacement from TR.
% This method computes the mean squared displacement between localizations
% in the single trajectory provided in TR.
%
% NOTE: This method isn't very memory efficient, as I'm creating two pretty
%       big arrays of zeros (see 'SquaredDisplacement' below) which are
%       usually very sparse. I tried using the sparse matrix built-ins in
%       MATLAB but that made this method too slow.
%
% INPUTS:
%   TR: Tracking results structure containing only one trajectory.  To be
%       sure, only TR(1) will be used in the analysis.
%   FrameLagRange: Range of frame differences between localizations for
%                  which MSD is computed. (Default is from 1 to 1/4 of the 
%                  max possible frame lag for this trajectory)
%                  ([min., max.])
%   Verbose: Verbosity level specifying how many temporary outputs should
%            be displayed (e.g., Command Window updates).
%
% OUTPUTS:
%   MSDSingleTraj: A structure array with the following fields:
%       TrajectoryID: The trajectory ID from TR(1).TrajectoryID.
%       MSD: The mean squared displacement between localizations in TR(1)
%            (pixel^2)
%       NPoints: The number of displacements used in computing MSD at each
%                point (i.e., MSD(ii) was the mean of NPoints(ii) squared
%                displacements).
%       FrameLags: Number of frames between displacements used to compute 
%                  each MSD point (i.e., MSD(ii) is the mean squared
%                  displacement for localizations separated by FrameLag(ii)
%                  frames).
%       SquaredDisplacement: The squared displacements used to compute MSD,
%                            returned as a convenience since it was already
%                            computed internally (i.e., we might as well 
%                            output this if requested).  Each row
%                            corresponds to a single localization, and each
%                            column to a frame lag. (pixel^2)

% Created by:
%   David J. Schodt (Lidke lab, 2021) 
%       based on msdAnalysis.m by Hanieh Mazloom-Farsibaf with
%       modifications to improve speed.


% Set defaults if needed.
if (~exist('Verbose', 'var') || isempty(Verbose))
    Verbose = 0;
end
FrameNum = TR(1).FrameNum;
NLocalizations = numel(FrameNum);
if (~exist('FrameLagRange', 'var') || isempty(FrameLagRange))
    FrameLagRange = [1, FrameNum(NLocalizations) - FrameNum(1)];
end

% Loop through localizations and compute the displacement to later
% localizations.
if (Verbose > 2)
    fprintf(['computeSingleTrajMSD(): computing single trajectory\n', ...
        'displacements between %i localizations\n'], NLocalizations)
end
Coordinates = [TR(1).X, TR(1).Y];
MeanVariance = mean([TR(1).X_SE.^2, TR(1).Y_SE.^2], 2);
FrameLags = (FrameLagRange(1):FrameLagRange(2)).';
NFrameLags = numel(FrameLags);
SquaredDisplacement = zeros(NLocalizations-1, NFrameLags);
SquaredDisplacementMask = zeros(NLocalizations-1, NFrameLags, 'logical');
LocVarianceSum = SquaredDisplacement;
for ff = 1:NFrameLags
    % Start with the first localization and find the distance to the
    % localization ff frames away.
    Index1 = 1;
    Index2 = 2;
    while (Index2 <= NLocalizations)
        % Check if the current frame gap is that desired.
        FrameDiff = FrameNum(Index2) - FrameNum(Index1);
        if (FrameDiff > FrameLags(ff))
            % This frame gap is too large, so we need a new Index1.
            Index1 = Index1 + 1;
            Index2 = Index1 + 1;
        elseif (FrameDiff == FrameLags(ff))
            % Compute the displacement.
            SquaredDisplacement(Index1, ff) = ...
                (Coordinates(Index1, 1)-Coordinates(Index2, 1))^2 ...
                + (Coordinates(Index1, 2)-Coordinates(Index2, 2))^2;
            SquaredDisplacementMask(Index1, ff) = true;
            
            % Store the sum of the localization variances.
            LocVarianceSum(Index1, ff) = ...
                MeanVariance(Index1) + MeanVariance(Index2);
            
            % Update the indices, ensuring the gaps don't overlap.
            Index1 = Index2;
            Index2 = Index1 + 1;
        else
            % This frame gap isn't the one desired.
            Index2 = Index2 + 1;
        end
    end
end

% Compute the MSD.
NPoints = sum(logical(SquaredDisplacement), 1).';
KeepBool = logical(NPoints);
if (Verbose > 2)
    fprintf(['computeSingleTrajMSD(): computing single trajectory\n', ...
        'MSD, %i valid frame gaps found\n'], sum(KeepBool))
end
MSD = sum(SquaredDisplacement, 1).' ./ NPoints;
NPoints = NPoints(KeepBool);
MSD = MSD(KeepBool);
FrameLagsAll = FrameLags.' .* SquaredDisplacementMask;
FrameLags = FrameLags(KeepBool);
MSDSingleTraj.ConnectID = TR(1).ConnectID;
MSDSingleTraj.MSD = MSD;
MSDSingleTraj.FrameLags = FrameLags;
MSDSingleTraj.FrameLagsAll = FrameLagsAll(SquaredDisplacementMask);
MSDSingleTraj.NPoints = NPoints;
MSDSingleTraj.SquaredDisplacement = ...
    SquaredDisplacement(SquaredDisplacementMask);
MSDSingleTraj.LocVarianceSum = LocVarianceSum(SquaredDisplacementMask);


end
./MATLAB/+smi_stat/@DiffusionEstimator/plotEnsembleCDFOfJumps.m
function [PlotAxes] = plotEnsembleCDFOfJumps(PlotAxes, ...
    MSDEnsemble, DiffusionStruct, UnitFlag)
%plotEnsembleCDFOfJumps plots the CDF of jumps and an associated fit.
% This method will plot the CDF of jumps data provided in MSDEnsemble as
% well as the associated fit provided in DiffusionStruct.
%
% INPUTS:
%   PlotAxes: Axes in which the plot will be made. (Default = gca())
%   MSDEnsemble: Structure array with ensemble MSD results (see outputs of
%                computeMSD())
%   DiffusionStruct: Structure array containing MSD fit ressults.
%                    (Default = [], meaning no fit results are plotted).
%   UnitFlag: Flag to specify camera units (0) or physical units (1).
%             (Default = 0)
%
% OUTPUTS:
%   PlotAxes: Axes in which the plot was made.

% Created by:
%   David J. Schodt (Lidke lab, 2021)


% Set defaults if needed.
if (~exist('PlotAxes', 'var') || isempty(PlotAxes))
    PlotAxes = gca();
end
if (~exist('DiffusionStruct', 'var') || isempty(DiffusionStruct))
    DiffusionStruct = [];
end
if (~exist('UnitFlag', 'var') || isempty(UnitFlag))
    UnitFlag = 0;
end

% Plot the CDF of jumps.
FrameRate = DiffusionStruct(2).FrameRate;
PixelSize = DiffusionStruct(2).PixelSize;
FrameConversion = ~UnitFlag + UnitFlag/FrameRate;
SquaredJumpsConversion = UnitFlag*(PixelSize^2) + ~UnitFlag;
SquaredJumps = MSDEnsemble.SortedSquaredDisp * SquaredJumpsConversion;
stairs(PlotAxes, SquaredJumps, MSDEnsemble.CDFOfJumps)

% If needed, plot the fit results.
NComponents = numel(DiffusionStruct(2).DiffusionConstant);
if ~isempty(DiffusionStruct)  
    % Define some unit conversion parameters. This is needed because the
    % DiffusionStruct allows for either camera units or physical units
    % (unlike the MSD structures).
    IsCameraUnits = strcmpi(DiffusionStruct(2).Units, ...
        {'pixels'; 'frames'});
    SqJumpUnitConversion = IsCameraUnits(1)*SquaredJumpsConversion ...
        + ~IsCameraUnits(1)*(UnitFlag + ~UnitFlag/(PixelSize^2));
    TimeUnitConversion = IsCameraUnits(2)*FrameConversion ...
        + ~IsCameraUnits(2)*(UnitFlag + ~UnitFlag*FrameRate);
    
    % Plot the CDF fit.
    hold(PlotAxes, 'on')
    FitParams = DiffusionStruct(2).FitParams;
    FitParams(1:NComponents) = FitParams(1:NComponents) ...
        * SqJumpUnitConversion / TimeUnitConversion;
    ModelCDF = smi_stat.DiffusionEstimator.brownianJumpCDF(...
        FitParams, SquaredJumps, ...
        MSDEnsemble.FrameLags * FrameConversion, ...
        MSDEnsemble.NPoints, ...
        MSDEnsemble.LocVarianceSum * SquaredJumpsConversion);
    plot(PlotAxes, SquaredJumps, ModelCDF)
end
SquaredJumpsUnit = smi_helpers.arrayMUX({'pixels^2', 'micrometers^2'}, ...
    UnitFlag);
xlabel(PlotAxes, sprintf('Squared jumps (%s)', SquaredJumpsUnit))
ylabel(PlotAxes, 'CDF of jumps')
legend(PlotAxes, {'CDF of jumps', 'Fit'}, 'Location', 'best')


end
./MATLAB/+smi_stat/@HMM/unitTest.m
% Test calling smi_stat,HMM routines.
function success = unitTest()

% This script demonstrates the basic usage of smi_stat.HMM.  We start by
% simulating some raw tracking data, reloading the raw data and tracking,
% and finally running the tracking results through the HMM analysis
% pipeline to search for dimers.  Simulated data and results will be saved
% in freshly generated directories under smite/MATLAB/examples/spt/

success = 0;

%% Simulate and save some SPT data in the format expected for real data.
% Simulate some diffusing blobs and save simulated raw data.
rng(12)
DataParams.NDatasets = 10;
SimParams.FrameSize = [64, 64];
SimParams.NFrames = 1000;
SimParams.ParticleDensity = 0.01; % particles / px^2, make 2X target since we split into 2 channels
SimParams.D = 0.1; % px^2 / frame
SimParams.KOffToOn = 0.95;
SimParams.KOnToOff = 0.05;
SimParams.KOnToBleach = 1e-3;
SimParams.Intensity = 1000;
SimParams.KDisconnect = 0.05;
SimParams.InteractionDistance = 0.5; % pixels
SimParams.InteractionProb = 0.5;
SaveDir = fullfile(tempdir, 'smite', 'unitTest', 'HMM');
if ~isfolder(SaveDir)
   mkdir(fullfile(tempdir, 'smite'));
   mkdir(fullfile(tempdir, 'smite', 'unitTest'));
   mkdir(fullfile(tempdir, 'smite', 'unitTest', 'HMM'));
end
DataDir = fullfile(SaveDir, ...
    'example_data', 'spt', smi_helpers.genTimeString());
if ~isfolder(DataDir)
    mkdir(DataDir)
end
[~, SimParams, DataParams] = smi_sim.SimSPT.makeExampleSim(...
    SimParams, DataParams, DataDir); % SimParams and DataParams padded w/ defaults

%% Prepare an SMF structure for each channel.
% NOTE: Channel 1 will not be transformed (it is the reference channel), so
%       we should ensure SMFChannel1.Data.RegistrationFilePath is empty!
PixelSize = 0.1; % must be set to true data values
FrameRate = 20;
SMFChannel1 = smi_core.SingleMoleculeFitting;
SMFChannel1.Data.AnalysisID = 'Channel1';
SMFChannel1.Data.FileDir = DataDir;
SMFChannel1.Data.DataROI = [1, 1, ...
    SimParams.FrameSize(1), SimParams.FrameSize(2)]; % left half of data [YStart, XStart, YEnd, XEnd]
SMFChannel1.Data.RegistrationFilePath = '';
SMFChannel1.Data.PixelSize = PixelSize;
SMFChannel1.Data.FrameRate = FrameRate;
SMFChannel1.Fitting.PSFSigma = SimParams.PSFSigma;
SMFChannel1.Tracking.MaxFrameGap = 20;
SMFChannel2 = copy(SMFChannel1);
SMFChannel2.Data.AnalysisID = 'Channel2';
SMFChannel2.Data.DataROI = [1, 1 + SimParams.FrameSize(2), ...
    SimParams.FrameSize(1), 2*SimParams.FrameSize(2)]; % right half of data
SMFChannel2.Data.RegistrationFilePath = '';

%% Prepare an SPT class object for each channel and then track.
SPTChannel1 = smi.SPT(SMFChannel1, false);
SPTChannel1.GenerateMovies = false;
SPTChannel1.GeneratePlots = false;
SPTChannel2 = smi.SPT(SMFChannel2, false);
SPTChannel2.GenerateMovies = false;
SPTChannel2.GeneratePlots = false;

%% Loop through our data files and track one at a time.
FileList = dir(fullfile(DataDir, 'Data_*.mat'));
FileList = FileList(~[FileList.isdir]); % exclude directories
NFiles = numel(FileList);
for nn = 1:NFiles
    % Update the file name in each of the SPT objects.
    SPTChannel1.SMF.Data.FileName = FileList(nn).name;
    SPTChannel2.SMF.Data.FileName = FileList(nn).name;
    
    % Perform the tracking.
    SPTChannel1.performFullAnalysis()
    SPTChannel2.performFullAnalysis()
end

%% Reload the tracked results and search for dimer candidates.
% NOTE: 'FileDir' is a directory containing both channel 1 and channel 2
%        results files.  findDimerCandidatesFromFiles() will search this
%        directory for files matching FilePatterns{1} and treat those files
%        as channel 1 results.  It will then do the same for
%        FilePatterns{2} (channel 2 results) and then attempt to match the
%        channel 1 and channel 2 files based on their file names (e.g.,
%        Data01_Channel1_Results.mat would be paired to
%        Data01_Channel2_Results.mat).
ResultsDir = fullfile(DataDir, 'Results');
FilePatterns = {'*Channel1_Results.mat'; '*Channel2_Results.mat'};
MaxDimerSeparation = 2; % pixels
MaxSeparation = 5; % pixels
[TRArray, ~, FileList] = smi_stat.HMM.findDimerCandidatesFromFiles(...
    ResultsDir, FilePatterns, MaxDimerSeparation, MaxSeparation);

% Add diffusion coefficients to the TRArray.
% NOTE: You can also do this on a per-trajectory basis if needed.
[TRArray.DiffusionCoefficient] = deal(SimParams.D);

%% Prepare the HMM class and run the analysis.
SMF = smi_core.SingleMoleculeFitting;
SMF.Data.FrameRate = FrameRate; % fps, specific to the loaded TRs above
SMF.Data.PixelSize = PixelSize; % micrometers, specific to the loaded TRs above
HMM = smi_stat.HMM(TRArray, SMF);
HMM.MaxSeparation = MaxSeparation;
HMM.DimerSeparation = SimParams.InteractionDistance; % pixels, TRUE physical separation between dimers
HMM.SaveDir = fullfile(ResultsDir, 'HMM_Results');
HMM.GeneratePlots = [true; true]; % [basic plots; summary plots]
HMM.UnitFlag = false;
HMM.performFullAnalysis()

success = 1;

end

./MATLAB/+smi_stat/@HMM/computeDimerDurations.m
function [DimerDurations] = ...
    computeDimerDurations(StateSequence, FrameNum, DimerState)
%computeDimerDurations computes the length of dimer events in StateSequence
% This method will look for changes in the values of StateSequence to
% determine when and for how long DimerState was present.  
% NOTE: If StateSequence(end) == DimerState, DimerDurations will treat that
%       as the end of a dimerization event.
%
% INPUTS:
%   StateSequence: An estimated sequence of states, e.g. [2, 1, 1, 2],
%                  which would correspond to an event length of 2.
%   FrameNum: Frame number corresponding to the observations in
%             StateSequence.
%   DimerState: Numeric value corresponding to the dimer state in
%               StateSequence.  If StateSequence = [1, 1, 1, 2, 2, 1, 2],
%               DimerState == 2 leads to DimerDurations = 2, and for
%               DimerState == 1 leads to DimerDurations = [3; 1].
%               (default = 1)
% 
% OUTPUTS:
%   DimerDurations: An array containing the observed durations of each
%                   dimerization event in StateSequence.

% Created by:
%   David J. Schodt (Lidke Lab, 2020)


% Set default parameters if needed.
if (~exist('DimerState', 'var') || isempty(DimerState))
    DimerState = 1;
end

% Ensure StateSequence is a column vector.
if (size(StateSequence, 1) < size(StateSequence, 2))
    StateSequence = StateSequence.';
end

% Create a boolean array to indicate which elements in StateSequence are
% equal to DimerState.
DimerEventBool = (StateSequence == DimerState);

% Find the starting/ending indices of each dimer event in StateSequence.
EventChanges = [DimerEventBool(1); diff(DimerEventBool)];
StartIndices = find(EventChanges == 1);
EndIndices = find(EventChanges == -1) - 1;

% If the start and end indices don't match in size, the last dimer event
% continued until the last observation.
if (numel(StartIndices) ~= numel(EndIndices))
    EndIndices = [EndIndices; numel(StateSequence)];
end

% Compute the duration of each event.
% NOTE: The +1 and the -1 above cancel each other out, but I like leaving
%       them because it helps clarify what the code is doing 
%       (at least for me)
DimerDurations = FrameNum(EndIndices) - FrameNum(StartIndices) + 1;


end
./MATLAB/+smi_stat/@HMM/findDimerCandidatesFromFiles.m
function [TRArray, SMFArray, FileList] = findDimerCandidatesFromFiles(...
    FileDir, FilePatterns, ...
    MaxDimerSeparation, MaxSeparation, MinValidPoints, MinMedianPhotons, ...
    BorderPadding, Verbose)
%findDimerCandidatesFromFiles creates a TRArray from the provided files.
% This method is a wrapper around findDimerCandidates() which will load
% Tracking Results (TR) structures from the provided files and construct
% the TRArray.
%
% INPUTS:
%   FileDir: Directory containing the tracking results files.
%   FilePatterns: Patterns to match to find and pair tracking results in
%                 FileDir. The pattern can contain a wildcard '*' but
%                 is otherwise a normal string.
%                 (Default = {'*Channel1_Results.mat';
%                             '*Channel2_Results.mat'})
%   MaxDimerSeparation: Maximum value of the minimum trajectory separation
%                       for a pair to be considered a dimer candidate.
%                       (pixels)(Default = 1)
%   MaxSeparation: Maximum distance between candidate trajectories that
%                  will be saved in the output TRArray.  For example, if
%                  two trajectories were separated by
%                  [10, 5, 3, 1, 1, 4, 12], and the MaxSeparation is 4, the
%                  output TRArray will contain the segments of these
%                  trajectories corresponding to the separations
%                  [3, 1, 1, 4].
%                  (pixels)(Default = 10 * MaxDimerDistance).
%   MinValidPoints: Minimum number of points during which the candidates
%                   must be within MaxSeparation of each other.
%                   (frames)(Default = 0)
%   MinPhotons: Minimum value for the median photons a trajectory must have
%               to be considered a candidate. (photons)(Default = 0)
%   BorderPadding: Minimum number of pixels from the border the
%                  trajectories must be during their candidate duration.
%                  (pixels)(Default = 0)
%   Verbose: Verbosity level of warning messages. (Default = 1)
%
% OUTPUTS:
%   TRArray: A structure array of TR structures, where the constituent TR
%            structures correspond to dimer candidate trajectories.  The
%            first index corresponds to the "channel" of the trajectory and
%            the second index corresponds to the pair number.  For example,
%            TRArray(j, 1) will contain information about a trajectory from
%            TR1 that was observed within MaxDimerDistance of
%            TRArray(j, 2), a trajectory in TR2.
%            NOTE: The entirety of the two trajectories will be saved in
%                  the TRArray, and a new field DimerCandidateBool will be
%                  added to describe which datapoints correspond to the
%                  trajectories being close to each other (e.g.,
%                  TRArray(j, 1).FrameNum(TRArray(j, 1).DimerCandidateBool)
%                  will give the frames during which the trajectories were
%                  close).  Another field, ObservationStatus is defined as
%                  followed: ObservationStatus(1) is a boolean indicating
%                  whether or not the "off" to "on" transition
%                  (>MaxDimerSeparation to <=MaxDimerSeparation) was
%                  observed. ObservationStatus(2) is a boolean indicating
%                  whether or not the "on" to "off" transition was
%                  observed.
%   SMFArray: Array of SMFs loaded alongside the TRArrays.
%   FileList: List of files sharing the same size as TRArray, such that
%             TRArray(ii, jj) is a trajectory present in FileList{ii, jj}.

% Created by:
%   David J. Schodt (Lidke Lab, 2020)


% Set default parameters if needed.
if (~exist('FilePatterns', 'var') || isempty(FilePatterns))
    FilePatterns = {'*Channel1_Results.mat'; '*Channel2_Results.mat'};
end
if (~exist('MaxDimerSeparation', 'var') || isempty(MaxDimerSeparation))
    MaxDimerSeparation = 1;
end
if (~exist('MaxSeparation', 'var') || isempty(MaxSeparation))
    MaxSeparation = 10 * MaxDimerSeparation;
end
if (~exist('MinValidPoints', 'var') || isempty(MinValidPoints))
    MinValidPoints = 0;
end
if (~exist('MinMedianPhotons', 'var') || isempty(MinMedianPhotons))
    MinMedianPhotons = 0;
end
if (~exist('BorderPadding', 'var') || isempty(BorderPadding))
    BorderPadding = 0;
end
if (~exist('Verbose', 'var') || isempty(Verbose))
    Verbose = 0;
end

% Search for files in the 'FileDir' and pair them together.
FilesCh1 = dir(fullfile(FileDir, FilePatterns{1}));
FilesCh1 = {FilesCh1.name}.';
FilesCh2 = dir(fullfile(FileDir, FilePatterns{2}));
FilesCh2 = {FilesCh2.name}.';
[FileList1, FileList2] = smi_helpers.pairText(FilesCh1, FilesCh2, ...
    erase(FilePatterns, '*'));
FileList1 = fullfile(FileDir, FileList1);
FileList2 = fullfile(FileDir, FileList2);

% Loop through the provided files, load them, and construct the TRArray.
FileList = {};
TRArray = struct([]);
SMFArray = struct([]);
for ff = 1:numel(FileList1)
    % Load the TR structures and add the filename.
    try
        load(FileList1{ff}, 'TR', 'SMF')
        TR1 = TR;
        [TR1.FileDir] = deal(FileDir);
        [TR1.FileName] = deal(FilesCh1{ff});
        [TR1.RawDataPath] = ...
            deal(fullfile(SMF.Data.FileDir, SMF.Data.FileName{1}));
        SMF1 = SMF;
        if isobject(SMF1)
            % If the 'SMF' was saved as an instance of the class, we should
            % convert it to a struct to save space.
            SMF1 = SMF1.packageSMF();
        end
    catch
        if Verbose
            warning(['findDimerCandidatesFromFiles(): ''TR'' structure ', ...
                'not found in file %s', FileList1{ff}])
        end
        continue
    end
    try
        load(FileList2{ff}, 'TR', 'SMF')
        TR2 = TR;
        [TR2.FileDir] = deal(FileDir);
        [TR2.FileName] = deal(FilesCh2{ff});
        [TR2.RawDataPath] = ...
            deal(fullfile(SMF.Data.FileDir, SMF.Data.FileName{1}));
        SMF2 = SMF;
        if isobject(SMF2)
            % If the 'SMF' was saved as an instance of the class, we should
            % convert it to a struct to save space.
            SMF2 = SMF2.packageSMF();
        end
    catch
        if Verbose
            warning(['findDimerCandidatesFromFiles(): ''TR'' structure ', ...
                'not found in file %s', FileList2{ff}])
        end
        continue
    end

    % Find dimer candidates between 'TR1' and 'TR2'.
    TRArrayCurrent = smi_stat.HMM.findDimerCandidates(TR1, TR2, ...
        MaxDimerSeparation, MaxSeparation, ...
        MinValidPoints, MinMedianPhotons, BorderPadding);
    TRArray = smi_core.TrackingResults.catTR(TRArray, TRArrayCurrent, false);
    FileList = [FileList; ...
        repmat([FileList1(ff), FileList2(ff)], size(TRArrayCurrent, 1), 1)];
    SMFArray = [SMFArray;
        repmat([SMF1, SMF2], size(TRArrayCurrent, 1), 1)];
end


end
./MATLAB/+smi_stat/@HMM/createAllMovies.m
function [MovieParams] = createAllMovies(TRArray, SMFArray, ...
    MovieParams, SaveDir)
%createAllMovies creates dimer movies for all pairs in TRArray.

% INPUTS:
%   TRArray: TRArray with fields 'RawDataPath', 'DimerCandidateBool', and...
%            'StateSequence' populated.
%   SMFArray: Array of SMF structures corresponding to each trajectory pair
%             in TRArray.
%   MovieParams: Structure of movie parameters (see
%                smi_vis.GenerateMovies.prepDefaults()).
%                (Default = smi_vis.GenerateMovies.prepDefaults() with a
%                few updated settings)
%   SaveDir: Save directory for the movies. (Default = pwd())

% Created by:
%   David J. Schodt (Lidke Lab, 2022)


% Set defaults.
if (~exist('SMFArray', 'var') || isempty(SMFArray))
    DefaultSMF = smi_core.SingleMoleculeFitting;
    SMFArray = repmat(DefaultSMF, size(TRArray, 1), 2);
end
if (~exist('MovieParams', 'var') || isempty(MovieParams))
    MovieParams = smi_vis.GenerateMovies.prepDefaults();
end
DefaultParams = smi_vis.GenerateMovies.prepDefaults();
DefaultParams.AutoCrop = true;
DefaultParams.IndicateDimer = true;
DefaultParams.IndicateDimerCandidate = true;
DefaultParams.TrajColors = [0, 1, 0; 1, 0, 1];
MovieParams = smi_helpers.padStruct(MovieParams, DefaultParams);
if (~exist('SaveDir', 'var') || isempty(SaveDir))
    SaveDir = pwd();
end
if ~exist(SaveDir, 'dir')
    mkdir(SaveDir);
end

% Loop through dimer pairs and prepare the movies.
for nn = 1:size(TRArray, 1)
    % Load the raw data for this dimer pair, if possible.
    FullFile1 = fullfile(SMFArray(nn, 1).Data.FileDir, ...
        SMFArray(nn, 1).Data.FileName{1});
    if isfile(FullFile1)
        LD = smi_core.LoadData;
        [~, RawData1] = LD.loadRawData(SMFArray(nn, 1), 1, ...
            SMFArray(nn, 1).Data.DataVariable);
    else
        RawData1 = ones(TRArray(nn, 1).YSize, ...
            TRArray(nn, 1).XSize);
    end
    FullFile2 = fullfile(SMFArray(nn, 2).Data.FileDir, ...
        SMFArray(nn, 2).Data.FileName{1});
    if isfile(FullFile2)
        LD = smi_core.LoadData;
        [~, RawData2] = LD.loadRawData(SMFArray(nn, 2), 1, ...
            SMFArray(nn, 2).Data.DataVariable);
    else
        RawData2 = ones(TRArray(nn, 2).YSize, ...
            TRArray(nn, 2).XSize);
    end

    % Load the registration transform, if available (we'll use this to
    % transform the raw data so that it aligns nicely for the movie).
    if isfile(SMFArray(nn, 2).Data.RegistrationFilePath)
        % We'll always assume channel 2 is the registered channel!
        load(SMFArray(nn, 2).Data.RegistrationFilePath, ...
            'RegistrationTransform')
        RawData2 = smi_core.ChannelRegistration.transformImages(...
            RegistrationTransform{2}, RawData2);
    end

    % Rescale the raw data and create the false color overlay.
    RawData1 = smi_vis.contrastStretch(RawData1, [], ...
        MovieParams.PercentileCeiling, ...
        MovieParams.PercentileFloor, ...
        MovieParams.MinScaleIntensity);
    RawData2 = smi_vis.contrastStretch(RawData2, [], ...
        MovieParams.PercentileCeiling, ...
        MovieParams.PercentileFloor, ...
        MovieParams.MinScaleIntensity);
    RawDataRGB = ones([size(RawData1, 1:2), 3, size(RawData1, 3)]);
    for cc = 1:3
        RawDataRGB(:, :, cc, :) = ...
            RawData1*MovieParams.RawDataColors(1, cc) ...
            + RawData2*MovieParams.RawDataColors(2, cc);
    end

    % Prepare and save the movie.
    MovieMaker = smi_vis.GenerateMovies(MovieParams);
    MovieMaker.RawData = RawDataRGB;
    MovieMaker.TR = TRArray(nn, :);
    MovieSavePath = fullfile(SaveDir, ...
        sprintf('DimerPair%i_movie.mp4', nn));
    MovieMaker.saveMovie(MovieSavePath)
end


end
./MATLAB/+smi_stat/@HMM/performFullAnalysis.m
function [RateParameters, RateParametersSE, LogLikelihood] = ...
    performFullAnalysis(obj)
%performFullAnalysis performs all analyses on the data in obj.TRArray.
% This method performs all analyses possible on the data.  This is intended
% to be a main "run" method to this class, meaning that the user can
% create an instance of this class, set all class properties as needed, and
% then run this method to perform a complete analysis of the data.
% NOTE: Outputs from this method are added for convenience:
%       they should all also be saved/updated in the class instance.

% Created by:
%   David J. Schodt (Lidke Lab, 2020)


% Add a message to the Command Window to indicate the status.
if (obj.Verbose > 0)
    fprintf('HMM.performFullAnalysis(): beginning analysis...\n')
end

% If needed, prepare a set of emission PDFs based on the requested model.
% NOTE: I've added this in an attempt to generalize the
%       performFullAnalysis() method.  While not yet complete, the goal is
%       that the user may set custom handles for obj.PDFHandles if desired
%       and still run performFullAnalysis() in a meaningful way.
if isempty(obj.PDFHandles)
    obj.PDFHandles = obj.generateEmissionPDFs(obj.ModelSpecifier);
end

% Make local copies of various arrays and define misc. parameters.
TRArray = obj.TRArray;
NStates = numel(obj.PDFHandles);
if ~NStates
    error('You must set smi_stat.HMM.PDFHandles before proceeding')
end
StateSpace = (1:NStates).';

% Isolate the dimer candidates that we wish to send through the HMM
% analysis and add some new fields that we'll need.
TRArrayTrunc = obj.isolateCandidateTRArray(TRArray);

% Ensure that diffusion coefficients are available for each trajectory.
NCandidates = size(TRArrayTrunc, 1);
if isfield(TRArrayTrunc, 'DiffusionCoefficient')
    % Make sure the length of each DiffusionCoefficient array matches the
    % number of frames (in case we ever have time-resolved Ds).  If the
    % sizes don't match, we'll pad with median(D) for all values.
    for nn = 1:NCandidates
        PadSize = numel(TRArrayTrunc(nn, 1).FrameNum) ...
            - numel(TRArrayTrunc(nn, 1).DiffusionCoefficient);
        TRArrayTrunc(nn, 1).DiffusionCoefficient = ...
            padarray(TRArrayTrunc(nn, 1).DiffusionCoefficient, ...
            PadSize, ...
            median(TRArrayTrunc(nn, 1).DiffusionCoefficient), ...
            'post');
        PadSize = numel(TRArrayTrunc(nn, 2).FrameNum) ...
            - numel(TRArrayTrunc(nn, 2).DiffusionCoefficient);
        TRArrayTrunc(nn, 2).DiffusionCoefficient = ...
            padarray(TRArrayTrunc(nn, 2).DiffusionCoefficient, ...
            PadSize, ...
            median(TRArrayTrunc(nn, 2).DiffusionCoefficient), ...
            'post');
    end
else
    % If TRArrayTrunc doesn't have the DiffusionCoefficient field, we'll
    % use the median of the value stored in obj.SMF.Tracking.D for all
    % trajectories.
    D = median(obj.SMF.Tracking.D);
    for nn = 1:NCandidates
        TRArrayTrunc(nn, 1).DiffusionCoefficient = ...
            D * ones(size(TRArrayTrunc(nn, 1).FrameNum));
        TRArrayTrunc(nn, 2).DiffusionCoefficient = ...
            D * ones(size(TRArrayTrunc(nn, 2).FrameNum));
    end
end

% Ensure that the registration error is available for each trajectory.
if (isfield(TRArrayTrunc, 'RegError') && ~isempty(TRArrayTrunc(1).RegError))
    % Make sure the length of each RegError array matches the number of
    % frames.  If the sizes don't match, we'll pad with median(RegError) 
    % for all values.
    for nn = 1:NCandidates
        NFrames = numel(TRArrayTrunc(nn, 1).FrameNum);
        TRArrayTrunc(nn, 1).RegError = ...
            padarray(TRArrayTrunc(nn, 1).RegError, ...
            NFrames - numel(TRArrayTrunc(nn, 1).RegError), ...
            median(TRArrayTrunc(nn, 1).RegError), ...
            'post');
        NFrames = numel(TRArrayTrunc(nn, 2).FrameNum);
        TRArrayTrunc(nn, 2).RegError = ...
            padarray(TRArrayTrunc(nn, 2).RegError, ...
            NFrames - numel(TRArrayTrunc(nn, 2).RegError), ...
            median(TRArrayTrunc(nn, 2).RegError), ...
            'post');
    end
else
    % If no registration error was provided, we'll assume it's 0.
    for nn = 1:NCandidates
        TRArray(nn, 1).RegError = ...
            zeros(size(TRArray(nn, 1).FrameNum));
        TRArray(nn, 2).RegError = ...
            zeros(size(TRArray(nn, 2).FrameNum));
        TRArrayTrunc(nn, 1).RegError = ...
            zeros(size(TRArrayTrunc(nn, 1).FrameNum));
        TRArrayTrunc(nn, 2).RegError = ...
            zeros(size(TRArrayTrunc(nn, 2).FrameNum));
    end
end

% Compute the emission pdf's for the HMM states for all of the trajectory
% pairs.
if (obj.Verbose > 1)
    fprintf('HMM.performFullAnalysis(): preparing emission matrix...\n')
end
EmissionPDFCell = cell(NCandidates, 1);
EmissionPDFInputs = cell(8, 1);
EmissionPDFInputs{5} = obj.DimerSeparation;
EmissionPDFInputs{7} = obj.MaxSeparation;
EmissionPDFInputs{8} = obj.DomainSeparation;
DeltaT = EmissionPDFCell;
for ii = 1:NCandidates
    % Update the EmissionPDFInputs for this candidate.
    % NOTE: In general, TRArrayTrunc(ii, 2).RegError is the useful
    %       registration error!
    EmissionPDFInputs{1} = TRArrayTrunc(ii, 1).Separation;
    EmissionPDFInputs{2} = [TRArrayTrunc(ii, 1).AverageSE, ...
        TRArrayTrunc(ii, 2).AverageSE];
    EmissionPDFInputs{3} = double(diff(TRArrayTrunc(ii, 1).FrameNum));
    EmissionPDFInputs{4} = TRArrayTrunc(ii, 2).RegError + obj.RegErrorInflation;
    EmissionPDFInputs{6} = [TRArrayTrunc(ii, 1).DiffusionCoefficient, ...
        TRArrayTrunc(ii, 2).DiffusionCoefficient];
    DeltaT{ii} = EmissionPDFInputs{3};
    
    % Compute the emission pdf's and store them in the TRArray.
    EmissionPDFCell{ii} = ...
        obj.generateEmissionMatrix(obj.PDFHandles, EmissionPDFInputs);
    TRArrayTrunc(ii, 1).EmissionProbabilities = EmissionPDFCell{ii};
    TRArrayTrunc(ii, 2).EmissionProbabilities = EmissionPDFCell{ii};
end

% Estimate the rate parameters from the data and convert to a matrix for
% later use.
if (obj.Verbose > 1)
    fprintf('HMM.performFullAnalysis: estimating rate parameters...\n')
end
[RateParameters, RateParametersSE, LogLikelihood] = ...
    obj.estimateRateParameters(EmissionPDFCell, DeltaT, ...
    obj.RateParametersGuess);
TransitionRates = zeros(NStates);
DiagonalBool = logical(eye(NStates));
TransitionRates(~DiagonalBool) = RateParameters;

% Estimate the state sequence for each pair of trajectories, storing the
% result in TRArray.
if (obj.Verbose > 1)
    fprintf('HMM.performFullAnalysis: computing state sequence...\n')
end
for ii = 1:NCandidates
    % Generate the transition matrices for these trajectories.
    TransitionMatrixSeries = obj.generateTransitionMatrix(...
        TransitionRates, diff(TRArrayTrunc(ii, 1).FrameNum));
    
    % Estimate the state sequence that resulted in these observations.
    EmissionProbabilitySeries = EmissionPDFCell{ii}.';
    [StateSequence] = obj.computeViterbiPath(StateSpace, ...
        EmissionProbabilitySeries(:, 1), TransitionMatrixSeries, ...
        EmissionProbabilitySeries);
    
    % Find the apparent durations of each dimer event (as found by the
    % Viterbi algorithm in obj.computeViterbiPath() above).
    DimerDurations = obj.computeDimerDurations(...
        StateSequence, TRArrayTrunc(ii, 1).FrameNum);
    
    % Store interesting arrays in the TRArrayTrunc.
    TRArrayTrunc(ii, 1).StateSequence = StateSequence;
    TRArrayTrunc(ii, 1).DimerDurations = DimerDurations;
    TRArrayTrunc(ii, 2).StateSequence = StateSequence;
    TRArrayTrunc(ii, 2).DimerDurations = DimerDurations;
    
    % Store interesting arrays in the "full sized" TRArray (useful for
    % some plots/movies we might wish to make).
    DimerCandidateBool1 = TRArray(ii, 1).DimerCandidateBool;
    DimerCandidateBool2 = TRArray(ii, 2).DimerCandidateBool;
    Separation1Padded = NaN(numel(DimerCandidateBool1), 1);
    Separation2Padded = NaN(numel(DimerCandidateBool2), 1);
    Separation1Padded(DimerCandidateBool1) = ...
        TRArrayTrunc(ii, 1).Separation;
    Separation2Padded(DimerCandidateBool2) = ...
        TRArrayTrunc(ii, 2).Separation;
    StateSequence1Padded = NaN(numel(DimerCandidateBool1), 1);
    StateSequence2Padded = NaN(numel(DimerCandidateBool2), 1);
    StateSequence1Padded(DimerCandidateBool1) = StateSequence;
    StateSequence2Padded(DimerCandidateBool2) = StateSequence;
    EmissionProb1Padded = NaN(numel(DimerCandidateBool1), NStates);
    EmissionProb2Padded = NaN(numel(DimerCandidateBool2), NStates);
    EmissionProb1Padded(DimerCandidateBool1, :) = ...
        TRArrayTrunc(ii, 1).EmissionProbabilities;
    EmissionProb2Padded(DimerCandidateBool2, :) = ...
        TRArrayTrunc(ii, 2).EmissionProbabilities;
    TRArray(ii, 1).Separation = Separation1Padded;
    TRArray(ii, 1).StateSequence = StateSequence1Padded;
    TRArray(ii, 1).DimerDurations = DimerDurations;
    TRArray(ii, 1).EmissionProbabilities = EmissionProb1Padded;
    TRArray(ii, 2).Separation = Separation2Padded;
    TRArray(ii, 2).StateSequence = StateSequence2Padded;
    TRArray(ii, 2).DimerDurations = DimerDurations;
    TRArray(ii, 2).EmissionProbabilities = EmissionProb2Padded;
end

% Determine if the DimerDurations and the found dimer off-rate are in
% agreement.
DimerDurations = cell2mat({TRArrayTrunc(:, 1).DimerDurations}.');
ViterbiOffRate = -log(1 - 1/mean(DimerDurations));
switch NStates
    case 2
        HMMOffRate = RateParameters(2);
    case 3
        HMMOffRate = RateParameters(3) + RateParameters(5);
    otherwise
        error('Update HMM.performFullAnalysis() for new state model!!!');
end
RelativeDiff = (abs(ViterbiOffRate-HMMOffRate) ...
    / abs(ViterbiOffRate+HMMOffRate));
if ((RelativeDiff>obj.DiscrepancyTol) && (obj.Verbose>0))
    warning(['Off-rate estimates differ by %0.2g%%, ', ...
        '%0.2g%% tolerance not met'], ...
        100*RelativeDiff, 100*obj.DiscrepancyTol);
end

% Save misc. local arrays back into the class instance.
obj.RateParameters = RateParameters;
obj.RateParametersSE = RateParametersSE;
obj.TRArray = TRArray;
obj.TRArrayTrunc = TRArrayTrunc;

% Save the analysis results.
if obj.SaveResults
    if (obj.Verbose > 1)
        fprintf('HMM.performFullAnalysis: saving results...\n')
    end
    obj.saveResults();
end

% Add an update message to the Command Window.
if (obj.Verbose > 0)
    fprintf('HMM.performFullAnalysis(): analysis complete!\n')
end


end
./MATLAB/+smi_stat/@HMM/findDimerCandidates.m
function [TRArray] = findDimerCandidates(TR1, TR2, ...
    MaxDimerSeparation, MaxSeparation, MinValidPoints, MinMedianPhotons, ...
    BorderPadding)
%findDimerCandidates finds dimer candidate pairs between TR1 and TR2.
% This method will search through all combinations of trajectories between
% TR1 and TR2 (one combination contains one trajectory from TR1, one from
% TR2) to find dimer candidates, i.e., trajectories that were observed
% within MaxDimerSeparation of each other at some point in time.
%
% INPUTS:
%   TR1: Tracking results structure (see smi_core.TrackingResults)
%   TR2: Tracking results structure (see smi_core.TrackingResults)
%   MaxDimerSeparation: Maximum value of the minimum trajectory separation
%                       for a pair to be considered a dimer candidate.
%                       (pixels)(Default = 1)
%   MaxSeparation: Maximum distance between candidate trajectories that
%                  will be saved in the output TRArray.  For example, if
%                  two trajectories were separated by 
%                  [10, 5, 3, 1, 1, 4, 12], and the MaxSeparation is 4, the
%                  output TRArray will contain the segments of these
%                  trajectories corresponding to the separations 
%                  [3, 1, 1, 4]. 
%                  (pixels)(Default = 10 * MaxDimerDistance).
%   MinValidPoints: Minimum number of points during which the candidates
%                   must be within MaxSeparation of each other.
%                   (frames)(Default = 0)
%   MinPhotons: Minimum value for the median photons a trajectory must have
%               to be considered a candidate. (photons)(Default = 0)
%   BorderPadding: Minimum number of pixels from the border the
%                  trajectories must be during their candidate duration.
%                  (pixels)(Default = 0)
%
% OUTPUTS:
%   TRArray: A structure array of TR structures, where the constituent TR
%            structures correspond to dimer candidate trajectories.  The 
%            first index corresponds to the "channel" of the trajectory and 
%            the second index corresponds to the pair number.  For example,
%            TRArray(j, 1) will contain information about a trajectory from 
%            TR1 that was observed within MaxDimerDistance of
%            TRArray(j, 2), a trajectory in TR2.
%            NOTE: The entirety of the two trajectories will be saved in
%                  the TRArray, and a new field DimerCandidateBool will be
%                  added to describe which datapoints correspond to the
%                  trajectories being close to each other (e.g., 
%                  TRArray(j, 1).FrameNum(TRArray(j, 1).DimerCandidateBool)
%                  will give the frames during which the trajectories were
%                  close).  Another field, ObservationStatus is defined as
%                  followed: ObservationStatus(1) is a boolean indicating
%                  whether or not the "off" to "on" transition
%                  (>MaxDimerSeparation to <=MaxDimerSeparation) was
%                  observed. ObservationStatus(2) is a boolean indicating
%                  whether or not the "on" to "off" transition was
%                  observed.

% Created by:
%   David J. Schodt (Lidke Lab, 2020)


% Set default parameters if needed.
if (~exist('MaxDimerSeparation', 'var') || isempty(MaxDimerSeparation))
    MaxDimerSeparation = 1;
end
if (~exist('MaxSeparation', 'var') || isempty(MaxSeparation))
    MaxSeparation = 10 * MaxDimerSeparation;
end
if (~exist('MinValidPoints', 'var') || isempty(MinValidPoints))
    MinValidPoints = 0;
end
if (~exist('MinMedianPhotons', 'var') || isempty(MinMedianPhotons))
    MinMedianPhotons = 0;
end
if (~exist('BorderPadding', 'var') || isempty(BorderPadding))
    BorderPadding = 0;
end

% Make sure TR1 and TR2 share the same fields (this is a nice check which
% may allow inter-compability between old/new TR structures).
TR1 = smi_core.TrackingResults.padTR(TR1, TR2);
TR2 = smi_core.TrackingResults.padTR(TR2, TR1);

% Loop through TR1 and search for dimer candidates in TR2.
if BorderPadding
    % For certain simulations, it's easiest for us to not define these and
    % to just set BorderPadding = 0.
    XSize = TR1(1).XSize;
    YSize = TR1(1).YSize;
    UpperBorderX = XSize - BorderPadding;
    UpperBorderY = YSize - BorderPadding;
end
[TR1.DimerCandidateBool] = deal([]);
[TR1.ObservationStatus] = deal([]);
[TR1.Separation] = deal([]);
[TR1.AverageSE] = deal([]);
[TR2.DimerCandidateBool] = deal([]);
[TR2.ObservationStatus] = deal([]);
[TR2.Separation] = deal([]);
[TR2.AverageSE] = deal([]);
TRArray = struct([]);
for ii = 1:numel(TR1)
    % Isolate relevant fields from TR1 for the current channel 1 trajectory
    % and create other arrays as needed.
    XChannel1 = double(TR1(ii).X);
    YChannel1 = double(TR1(ii).Y);
    AverageSEChannel1 = mean(double([TR1(ii).X_SE, TR1(ii).Y_SE]), 2);
    FrameNumChannel1 = TR1(ii).FrameNum;
    NaNChannel1 = NaN(numel(XChannel1), 1);
    for jj = 1:numel(TR2)
        % Isolate relevant fields from TR2 for the current channel 2 
        % trajectory and create other arrays as needed.
        XChannel2 = double(TR2(jj).X);
        YChannel2 = double(TR2(jj).Y);
        AverageSEChannel2 = mean(double([TR2(jj).X_SE, TR2(jj).Y_SE]), 2);
        FrameNumChannel2 = TR2(jj).FrameNum;
        NaNChannel2 = NaN(numel(XChannel2), 1);
        
        % Determine which frames (if any) these two trajectories were
        % both observed in.
        OverlapBoolChannel1 = ismember(FrameNumChannel1, FrameNumChannel2);
        if (sum(OverlapBoolChannel1) < MinValidPoints)
            % If these trajectories didn't overlap in time for sufficiently
            % many frames, we can skip to the next iteration of the loop
            % now. 
            % NOTE: We'll still need to compare to MinValidPoints later
            %       on, but continuing here can speed up the code since we
            %       already know they don't overlap for very long.
            continue
        end
        OverlapBoolChannel2 = ismember(FrameNumChannel2, FrameNumChannel1);
        
        % Determine if these trajectories were ever sufficiently close to
        % be considered an interaction candidate.
        XChannel1Overlap = XChannel1(OverlapBoolChannel1);
        YChannel1Overlap = YChannel1(OverlapBoolChannel1);
        FrameNumChannel1Overlap = FrameNumChannel1(OverlapBoolChannel1);
        XChannel2Overlap = XChannel2(OverlapBoolChannel2);
        YChannel2Overlap = YChannel2(OverlapBoolChannel2);
        FrameNumChannel2Overlap = FrameNumChannel2(OverlapBoolChannel2);
        CenterToCenterSeparation = sqrt(...
            (XChannel1Overlap-XChannel2Overlap).^2 ...
            + (YChannel1Overlap-YChannel2Overlap).^2);
        WithinMaxSeparation = (CenterToCenterSeparation <= MaxSeparation);
        WithinMaxDimerDist = (CenterToCenterSeparation ...
            <= MaxDimerSeparation);
        if ~(any(WithinMaxSeparation) && any(WithinMaxDimerDist))
            % These trajectories were never sufficiently close to each
            % other so we can just skip the rest of the thresholding steps.
            continue
        end
                
        % Find the starting/ending indices of each interaction candidate 
        % for the current trajectory pair.
        % NOTE: It's easier to understand how these are found by
        %       testing them on an example.  I used
        %       WithinMaxSeparation = ...
        %           [1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1].';
        StartIndices = find([WithinMaxSeparation(1); ...
            diff(WithinMaxSeparation)] == 1);
        EndIndices = find([0; diff(WithinMaxSeparation)] == -1) - 1;
        
        % If there is not an EndIndices element corresponding to every 
        % StartIndices element, that means there was an interaction that 
        % was not fully captured (WithinMaxSeparation(end) == 1).  We 
        % still want to keep that interaction so we should add the missing
        % EndIndices value.
        if (numel(StartIndices) ~= numel(EndIndices))
            EndIndices = [EndIndices; numel(WithinMaxSeparation)];
        end
                
        % Remove start/end indices that are the same, i.e. events with only
        % a single point captured within the MaxSeparation
        % NOTE: Just to be clear, it's okay to have a single point within
        %       MaxDimerSeparation, but if it's just one point within
        %       MaxSeparation then that data won't be very interpretable
        %       (if anything, this condition being met might mean that
        %       MaxSeparation is set too low!)
        SinglePointBool = (StartIndices == EndIndices);
        StartIndices = StartIndices(~SinglePointBool);
        EndIndices = EndIndices(~SinglePointBool);
        
        % Loop through each interaction that we've identified.
        NObservations = numel(FrameNumChannel1Overlap);
        for kk = 1:numel(StartIndices)
            % Define our indexing array for the current set of start/end 
            % indices.
            IndexArray = max(StartIndices(kk), 1) ...
                : min(EndIndices(kk), NObservations);
                        
            % Ensure that these trajectories were within MaxDimerDistance 
            % of each other during this portion of time.
            % NOTE: The thresholding on MaxDimerDistance above is just a
            %       preliminary threshold over the full trajectory, this 
            %       threshold is now thresholding over an isolated portion
            %       of the trajectory.
            if ~any(WithinMaxDimerDist(IndexArray))
                continue
            end
            
            % Map the start/end indices we've found back into the TR 
            % structures.
            % NOTE: This is a bit redudant for some TR fields, e.g.
            %       XChannel1Overlap(IndexArray) and
            %       XChannel1(DimerCandidateBoolChannel1) should give the
            %       same result.  I'm doing this so that we can easily 
            %       access other fields of the TR that we don't have an
            %       "overlap" version of.
            DimerCandidateBoolChannel1 = ismember(...
                FrameNumChannel1, ...
                FrameNumChannel1Overlap(IndexArray));
            DimerCandidateBoolChannel2 = ismember(...
                FrameNumChannel2, ...
                FrameNumChannel2Overlap(IndexArray));
            
            % Enforce the MinValidPoints threshold on this pair segment.
            if (sum(DimerCandidateBoolChannel1) < MinValidPoints)
                continue
            end
            
            % Enforce the border padding.
            CandidateXChannel1 = XChannel1(DimerCandidateBoolChannel1);
            CandidateYChannel1 = YChannel1(DimerCandidateBoolChannel1);
            CandidateXChannel2 = XChannel2(DimerCandidateBoolChannel2);
            CandidateYChannel2 = YChannel2(DimerCandidateBoolChannel2);
            if (BorderPadding ...
                    && (any(CandidateXChannel1 < BorderPadding) ...
                    || any(CandidateYChannel1 < BorderPadding) ...
                    || any(CandidateXChannel2 < BorderPadding) ...
                    || any(CandidateYChannel2 < BorderPadding) ...
                    || any(CandidateXChannel1 > UpperBorderX) ...
                    || any(CandidateYChannel1 > UpperBorderY) ...
                    || any(CandidateXChannel2 > UpperBorderX) ...
                    || any(CandidateYChannel2 > UpperBorderY)))
                % One of these trajectories got too close to the edge of
                % the field of view, so we'll discard these candidates.
                continue
            end
            
            % Enforce the min. photons.
            MedianPhotonsCh1 = ...
                median(TR1(ii).Photons(DimerCandidateBoolChannel1));
            MedianPhotonsCh2 = ...
                median(TR2(jj).Photons(DimerCandidateBoolChannel2));
            if ~((MedianPhotonsCh1>=MinMedianPhotons) ...
                    && (MedianPhotonsCh2>=MinMedianPhotons))
                continue
            end
            
            % Store the dimer candidate segments in the TRArray.
            TRArrayCurrent(1, 1) = TR1(ii);
            TRArrayCurrent(1).DimerCandidateBool = ...
                DimerCandidateBoolChannel1;
            SeparationChannel1 = NaNChannel1;
            SeparationChannel1(OverlapBoolChannel1) = ...
                CenterToCenterSeparation;
            CandidateSeparation = ...
                SeparationChannel1(DimerCandidateBoolChannel1);
            ObservationStatus = ...
                [(CandidateSeparation(1) > MaxDimerSeparation); 
                (CandidateSeparation(end) > MaxDimerSeparation)];
            TRArrayCurrent(1).ObservationStatus = ObservationStatus;
            TRArrayCurrent(1).Separation = SeparationChannel1;
            TRArrayCurrent(1).AverageSE = AverageSEChannel1;
            TRArrayCurrent(1, 2) = TR2(jj);
            TRArrayCurrent(2).DimerCandidateBool = ...
                DimerCandidateBoolChannel2;
            TRArrayCurrent(2).ObservationStatus = ObservationStatus;
            SeparationChannel2 = NaNChannel2;
            SeparationChannel2(OverlapBoolChannel2) = ...
                CenterToCenterSeparation;
            TRArrayCurrent(2).Separation = SeparationChannel2;
            TRArrayCurrent(2).AverageSE = AverageSEChannel2;
            TRArray = [TRArray; TRArrayCurrent];
            
            % Construct the ObservationStatus struct.
            CandidateSeparation = ...
                SeparationChannel1(DimerCandidateBoolChannel1);
            ObservationStatusCurrent.OffOnObserved = ...
                (CandidateSeparation(1) > MaxDimerSeparation);
            ObservationStatusCurrent.OnOffObserved = ...
                (CandidateSeparation(end) > MaxDimerSeparation);
        end
    end
end


end
./MATLAB/+smi_stat/@HMM/generateEmissionPDFs.m
function [PDFHandles] = generateEmissionPDFs(ModelSpecifier)
%generateEmissionPDFs creates array of emission density fxn. handles.
% This method will generate an array of function handles corresponding to 
% the model specified by ModelSpecifier.  These function handles can be
% used to generate the emisssion probability densities for
% each state given observations (as is done in 
% smi_stat.HMM.generateEmissionMatrix()).
%
% NOTE: These function handles are designed to take a single input X, which
%       is a cell array containing all parameters/data needed to
%       compute values for the probability densities.
%       X{1}: Separation in current frame (pixels)
%       X{2}: Standard error in current frame, [particle 1, particle 2]
%             (pixels)(NObservations x 2)
%       X{3}: Frames elapsed since previous observation (DeltaT)
%       X{4}: Sigma overlay, i.e., channel registration error (pixels)
%       X{5}: Dimer separation (pixels)
%       X{6}: Diffusion constant for each trajectory (organized as
%             [D trajectory 1, D trajectory 2]). (pixel^2 / frame)
%       X{7}: Maximum separation between two trajectories (used in
%             computing initial probability density of free state)(pixels)
%       X{8:end}: Additional parameters/data, case dependent, e.g.,
%                 X{8} is the domain separation if ModelSpecifier = 'DDF'
%
% INPUTS:
%   ModelSpecifier: An array specifying the HMM model being used.  The
%                   first character will always be the number of states in
%                   the model.
%                   'DF': two-state dimer/free model
%                   'DDF': three-state dimer/domain/free model
%                   (char array)
%
% OUTPUTS:
%   PDFHandles: A cell array of function handles, with each index
%               corresponding to a state in the model 'ModelSpecifier'.
%               ModelSpecifier 'DF':
%                   FunctionHandles{1} gives the probability density of
%                       observing a separation between two particles in
%                       a dimer.
%                   FunctionHandles{2} gives the probability density of
%                       observing a separation between two particles
%                       that are freely diffusing.
%               ModelSpecifier 'DDF':
%                   FunctionHandles{1} gives the probability density of
%                       observing a separation between two particles in
%                       a dimer.
%                   FunctionHandles{2} gives the probability density of
%                       observing a separation between two particles
%                       that are co-confined (in a "domain").
%                   FunctionHandles{3} gives the probability density of
%                       observing a separation between two particles
%                       that are freely diffusing.

% Created by:
%   David J. Schodt (Lidke Lab, 2020)


% Populate the output array based on the ModelSpecifier.
switch ModelSpecifier
    case 'DF'
        % Generate the function handle for the dimer state.
        PDFHandles{1, 1} = @(X) generateDimerPDF(X);
        
        % Generate the function handle for the free state.
        PDFHandles{2, 1} = @(X) generateFreePDF(X);
    case 'DDF'
        % Generate the function handle for the dimer state.
        PDFHandles{1, 1} = @(X) generateDimerPDF(X);
        
        % Generate the function handle for the domain state.
        PDFHandles{2, 1} = @(X) generateDomainPDF(X);
        
        % Generate the function handle for the free state.
        PDFHandles{3, 1} = @(X) generateFreePDF(X);
end

    function [DimerPDF] = generateDimerPDF(X)
        % This function generates the dimer state probability density.
        
        % Extract some arrays from X to make the code more readable.
        Separation = X{1};
        PositionSE = X{2};
        SigmaOverlay = X{4};
        SeparationDimer = X{5};
        
        % Define the dimer state pdf.
        VarianceDimer = sum(PositionSE.^2, 2) + SigmaOverlay.^2;
        DimerPDF = (Separation./VarianceDimer) ...
            .* exp(-0.5*(Separation.^2+SeparationDimer^2)./VarianceDimer) ...
            .* besseli(0, Separation*SeparationDimer./VarianceDimer);
        IsInvalid = (isinf(DimerPDF) | isnan(DimerPDF));
        if any(IsInvalid)
            % The Bessel function is unstable for large arguments, so we
            % sometimes need to compute the integral numerically at certain
            % points.
            InvalidIndices = find(IsInvalid);
            Theta = linspace(0, 2*pi, 1e3);
            DimerPDFInt = zeros(sum(IsInvalid), 1);
            for ii = 1:sum(IsInvalid)
                Index = InvalidIndices(ii);
                ProbIntegrand = ...
                    exp(-0.5 * (Separation(Index)^2+SeparationDimer^2 ...
                    - 2*Separation(Index)*SeparationDimer...
                    *cos(Theta))/VarianceDimer(Index));
                DimerPDFInt(ii) = ...
                    (Separation(Index)/(2*pi*VarianceDimer(Index))) ...
                    * trapz(Theta, ProbIntegrand);
            end
            DimerPDF(IsInvalid) = DimerPDFInt;
        end
    end

    function [DomainPDF] = generateDomainPDF(X)
        % This function generates the domain state probability density.
        
        % Extract some arrays from X to make the code more readable.
        Separation = X{1};
        PositionSE = X{2};
        SigmaOverlay = X{4};
        SeparationDomain = X{8};
        
        % Define the domain state pdf.
        VarianceDomain = sum(PositionSE.^2, 2) + SigmaOverlay.^2;
        DomainPDF = (Separation./VarianceDomain) ...
            .* exp(-0.5*(Separation.^2+SeparationDomain^2)./VarianceDomain) ...
            .* besseli(0, Separation*SeparationDomain./VarianceDomain);
        IsInvalid = (isinf(DomainPDF) | isnan(DomainPDF));
        if any(IsInvalid)
            % The Bessel function is unstable for large arguments, so we
            % sometimes need to compute the integral numerically for some
            % observations.
            InvalidIndices = find(IsInvalid);
            Theta = linspace(0, 2*pi, 1e3);
            DomainPDFInt = zeros(sum(IsInvalid), 1);
            for ii = 1:sum(IsInvalid)
                Index = InvalidIndices(ii);
                ProbIntegrand = ...
                    exp(-0.5 * (Separation(Index)^2+SeparationDomain^2 ...
                    - 2*Separation(Index)*SeparationDomain...
                    *cos(Theta))/VarianceDomain(Index));
                DomainPDFInt(ii) = ...
                    (Separation(Index)/(2*pi*VarianceDomain(Index))) ...
                    * trapz(Theta, ProbIntegrand);
            end
            DomainPDF(IsInvalid) = DomainPDFInt;
        end
    end

    function [FreePDF] = generateFreePDF(X)
        % This function generates the free state probability density.
        
        % Define useful indexing arrays.
        NObservations = numel(X{1});
        if (NObservations == 1)
            IndexArrayCurrent = 1;
            IndexArrayPrevious = 1;
        else
            IndexArrayCurrent = 2:NObservations;
            IndexArrayPrevious = 1:(NObservations-1);
        end
        
        % Extract some arrays from X to make the code more readable.
        InitialSeparation = X{1}(1);
        Separation = X{1}(IndexArrayCurrent);
        SeparationPrevious = X{1}(IndexArrayPrevious);
        PositionSE = X{2}(IndexArrayCurrent, :);
        PositionSEPrevious = X{2}(IndexArrayPrevious, :);
        DeltaT = X{3};
        DiffusionCoefficients = X{6}(IndexArrayPrevious, :);
        
        % Define the free state pdf.
        VarianceFree = sum(PositionSE.^2, 2) ...
            + sum(PositionSEPrevious.^2, 2) ...
            + 2*sum(DiffusionCoefficients, 2).*DeltaT;
        VarianceFreeInitial = 2*sum(PositionSEPrevious(1, :).^2, 2) ...
            + 2*sum(DiffusionCoefficients(1, :), 2);
        FreePDF = (Separation./VarianceFree) ...
            .* exp(-0.5*(Separation.^2+SeparationPrevious.^2)./VarianceFree) ...
            .* besseli(0, Separation.*SeparationPrevious./VarianceFree);
        FreePDFInitial = (InitialSeparation./VarianceFreeInitial) ...
            .* exp(-InitialSeparation^2./VarianceFreeInitial) ...
            * besseli(0, InitialSeparation^2./VarianceFreeInitial);
        IsInvalid = (isnan(FreePDF) | isinf(FreePDF));
        IsInvalidInitial = (isnan(FreePDFInitial) ...
            || isinf(FreePDFInitial));
        if any(IsInvalid)
            % The Bessel function is unstable for large arguments, so we
            % sometimes need to compute the integral numerically at certain
            % points.
            InvalidIndices = find(IsInvalid);
            Theta = linspace(0, 2*pi, 1e3);
            FreePDFInt = zeros(sum(IsInvalid), 1);
            for ii = 1:sum(IsInvalid)
                Index = InvalidIndices(ii);
                ProbIntegrand = exp(-0.5...
                    *(Separation(Index)^2+SeparationPrevious(Index)^2 ...
                    - 2*Separation(Index)*SeparationPrevious(Index)...
                    *cos(Theta))/VarianceFree(Index));
                FreePDFInt(ii) = ...
                    (Separation(Index)/(2*pi*VarianceFree(Index))) ...
                    * trapz(Theta, ProbIntegrand);
            end
            FreePDF(IsInvalid) = FreePDFInt;
        end
        if any(IsInvalidInitial)
            % The Bessel function is unstable for large arguments, so we
            % sometimes need to compute the integral numerically at certain
            % points.
            Theta = linspace(0, 2*pi, 1e3);
            ProbIntegrand = ...
                exp(-(InitialSeparation^2) * (1-cos(Theta)) ...
                ./ VarianceFreeInitial);
            FreePDFInitial = ...
                (InitialSeparation ./ (2*pi*VarianceFreeInitial)) ...
                * trapz(Theta, ProbIntegrand);
        end
        FreePDF = [FreePDFInitial; FreePDF];
    end


end
./MATLAB/+smi_stat/@HMM/createSummaryPlot.m
function [FigureHandle, DisplayParams] = ...
    createSummaryPlot(FigureHandle, TRArray, SMF, DisplayParams, UnitFlag)
%createSummaryPlot creates a multi-panel summary plot of the HMM analysis.
% This method creates a multi-panel plot with several sub-plots
% corresponding to a single dimer event identified by the HMM.  The
% purpose of this multi-panel plot is to contain as much useful information
% related to the HMM analysis results as possible, so that the user can
% look at the resulting figure and quickly determine if the dimer event was
% correctly identified/worth saving.
%
% INPUTS:
%   FigureHandle: Figure in which we should plot stuff.
%                 (Default = figure())
%   TRArray: A structure array of TR structures, where the constituent TR
%            structures correspond to the relevant segments of dimer
%            trajectories.  TRArray(1) will contain information about a
%            trajectory from TR1 that was found to have dimerized with
%            TRArray(2).
%   SMF: Single Molecule Fitting structure (for now, only
%        SMF.Data.PixelSize and SMF.Data.FrameRate are  used).
%        (Default = smi_core.SingleMoleculeFitting)
%   DisplayParams: A structure of display parameters for the movie.
%                  ChannelNames: Name labels for each channel.
%                                (Default = {'Channel 1'; 'Channel 2'})
%                  FileNames: List of filenames corresponding to
%                             trajectories in TRArray (e.g.,
%                             FileNames{2} is the filename corresponding to
%                             TRArray(2)). (Default = {''; ''})
%                  RegFileName: Registration filename applied to the
%                               "moving" channel of TRArray. (Default = '')
%                  MaxYDisplaySep: Maximum of y axis for any plots of
%                                  separation vs time (pixels)(Default =
%                                  max(cell2mat({TRArray.Separation}))
%                  MaxYDisplayState: Maximum of y axis for plots of the
%                                    state (i.e., states 1, 2, 3).
%                                    (Default = 1.1 * MaxStateNumber)
%                  MinXYRange: Minimum XY display range of the movie
%                              (pixels)(Default = 10)
%                  PairNumber: The pair number identifying the dimer pair
%                              being plotted. (Default = 1)
%                  StateNames: see SMA_HMM.m
%                              (Default = {'Dimer'; 'Free'})
%                  StateColormap: A colormap corresponding to the states
%                                 given in ModelSpecifier/StateNames
%                                 (NStates x 3 array)
%                                 (Default = colormap(lines(NStates)))
%   UnitFlag: Flag indicating we should use physical units. 
%             (Default = false)
%
% OUTPUTS:
%   FigureHandle: Figure in which we plotted stuff.
%   DisplayParams: Set of parameters used to produce plots, including the
%                  defaults set internally.
%
% CITATION:

% Created by:
%   David J. Schodt (Lidke Lab, 2020)


% Prepare some defaults if needed.
if (~exist('FigureHandle', 'var') || isempty(FigureHandle) ...
        || ~isvalid(FigureHandle))
    % Generate the figure.
    FigureHandle = figure('Units', 'inches', ...
        'Position', [0, 0, 8.5, 11], ...
        'PaperSize', [8.5, 11]);
end
if (~exist('SMF', 'var') || isempty(SMF))
    SMF = smi_core.SingleMoleculeFitting;
end
if (~exist('DisplayParams', 'var') || isempty(DisplayParams))
    DisplayParams = struct();
end
if (~exist('UnitFlag', 'var') || isempty(UnitFlag))
    UnitFlag = false;
end

% Set default parameter values where needed.
StateSequence = cell2mat({TRArray.StateSequence}.');
NStates = max([numel(unique(StateSequence(~isnan(StateSequence)))), ...
    size(TRArray(1, 1).EmissionProbabilities, 2), ...
    max(StateSequence)]);
DefaultDisplayParams.ChannelNames = {'Channel 1'; 'Channel 2'};
DefaultDisplayParams.FileNames = {''; ''};
DefaultDisplayParams.RegFileName = '';
DefaultDisplayParams.MaxYDisplaySep = ...
    max(cell2mat({TRArray.Separation}.'));
DefaultDisplayParams.MaxYDisplayState = ...
    1.1 * numel(unique(StateSequence(~isnan(StateSequence))));
DefaultDisplayParams.MinXYRange = 10;
DefaultDisplayParams.PairNumber = 1;
DefaultDisplayParams.StateNames = {'Dimer'; 'Free'};
DefaultDisplayParams.StateColormap = lines(NStates);
DisplayParams = smi_helpers.padStruct(DisplayParams, DefaultDisplayParams);

% Define some more parameters.
LengthUnitString = ...
    smi_helpers.arrayMUX({'pixel', '$\mu m$'}, UnitFlag);
TimeDimensionString = ...
    smi_helpers.arrayMUX({'Frame number', 'Time'}, UnitFlag);
TimeUnitString = ...
    smi_helpers.arrayMUX({'frames', 'seconds'}, UnitFlag);

% Add a title to the summary plot.
TrajectoryID1 = TRArray(1).ConnectID;
TrajectoryID2 = TRArray(2).ConnectID;
TitleString = sprintf('Dimer pair %i, %s ID: %i, %s ID: %i\n', ...
    DisplayParams.PairNumber, ...
    DisplayParams.ChannelNames{1}, TrajectoryID1, ...
    DisplayParams.ChannelNames{2}, TrajectoryID2);
if isfield(TRArray, 'FileName')
    % A filename stored in TRArray will override filenames added in
    % DisplayParams.
    TitleString = [TitleString, ...
        sprintf('%s file: %s\n%s file: %s\n', ...
        DisplayParams.ChannelNames{1}, TRArray(1).FileName, ...
        DisplayParams.ChannelNames{2}, TRArray(2).FileName)];
elseif ~(isempty(DisplayParams.FileNames{1}) ...
        ||isempty(DisplayParams.FileNames{2}))
    TitleString = [TitleString, ...
        sprintf('%s file: %s\n%s file: %s\n', ...
        DisplayParams.ChannelNames{1}, DisplayParams.FileNames{1}, ...
        DisplayParams.ChannelNames{2}, DisplayParams.FileNames{2})];
end
if (((~isempty(TRArray(2).IsTransformed)&&TRArray(2).IsTransformed) ...
        || (~isempty(TRArray(1).IsTransformed)&&TRArray(1).IsTransformed)) ...
        && ~isempty(DisplayParams.RegFileName))
    TitleString = [TitleString, ...
        sprintf('registration file: %s\n', DisplayParams.RegFileName)];
end
sgtitle(FigureHandle, TitleString, 'FontSize', 8, 'Interpreter', 'none');

% Determine how many rows of subplots we want (this should be updated as
% new plots are added!).
if (isfield(TRArray, 'XRegCorrection') ...
        && isfield(TRArray, 'YRegCorrection'))
    % If thesse fields are present, we'll make an additional plot and thus
    % need another row!
    NPlotRows = 5;
else
    NPlotRows = 4;
end

% Generate the state sequence + separation plot.
PlotAxes = subplot(NPlotRows, 2, 1:2, 'Parent', FigureHandle);
hold(PlotAxes, 'on')
smi_stat.HMM.plotDimerPairInfo(PlotAxes, ...
    'ViterbiSequence', TRArray, SMF, DisplayParams, UnitFlag);
xlabel(PlotAxes, ...
    sprintf('%s (%s)', TimeDimensionString, TimeUnitString), ...
    'Interpreter', 'Latex')
yyaxis(PlotAxes, 'left')
ylabel(PlotAxes, sprintf('Separation (%s)', LengthUnitString), ...
    'Interpreter', 'Latex')
yyaxis(PlotAxes, 'right')
ylabel(PlotAxes, 'State', 'Interpreter', 'Latex')

% Plot the emission probabilities and the state sequence.
PlotAxes = subplot(NPlotRows, 2, 3:4, 'Parent', FigureHandle);
hold(PlotAxes, 'on');
smi_stat.HMM.plotDimerPairInfo(PlotAxes, ...
    'EmissionProbability', TRArray, SMF, DisplayParams, UnitFlag);
xlabel(PlotAxes, ...
    sprintf('%s (%s)', TimeDimensionString, TimeUnitString), ...
    'Interpreter', 'Latex')
yyaxis(PlotAxes, 'left')
ylabel(PlotAxes, 'Emission probability density', ...
    'Interpreter', 'Latex')
yyaxis(PlotAxes, 'right')
ylabel(PlotAxes, 'State', 'Interpreter', 'Latex')
legend(PlotAxes, ...
    {DisplayParams.StateNames{1}, DisplayParams.StateNames{2}, ...
    'State Sequence'}, 'Location', 'best')

% Plot the entire track, color coding the dimer state.
PlotAxes = subplot(NPlotRows, 2, 5, 'Parent', FigureHandle);
hold(PlotAxes, 'on');
smi_stat.HMM.plotDimerPairInfo(PlotAxes, ...
    'TrajectoryPlot3D', TRArray, SMF, DisplayParams, UnitFlag);
xlabel(PlotAxes, sprintf('X (%s)', LengthUnitString), ...
    'Interpreter', 'Latex')
ylabel(PlotAxes, sprintf('Y (%s)', LengthUnitString), ...
    'Interpreter', 'Latex')
zlabel(PlotAxes, ...
    sprintf('%s (%s)', TimeDimensionString, TimeUnitString), ...
    'Interpreter', 'Latex')
legend(PlotAxes, ...
    {DisplayParams.ChannelNames{1}, DisplayParams.ChannelNames{2}, ...
    'Dimer State'}, 'Location', 'best');

% Plot the entire track in 2D to help identify edge effects.
PlotAxes = subplot(NPlotRows, 2, 6, 'Parent', FigureHandle);
hold(PlotAxes, 'on');
smi_stat.HMM.plotDimerPairInfo(PlotAxes, ...
    'TrajectoryPlot2D', TRArray, SMF, DisplayParams, UnitFlag);
xlabel(PlotAxes, sprintf('X (%s)', LengthUnitString), ...
    'Interpreter', 'Latex')
ylabel(PlotAxes, sprintf('Y (%s)', LengthUnitString), ...
    'Interpreter', 'Latex')
legend(PlotAxes, ...
    {DisplayParams.ChannelNames{1}, DisplayParams.ChannelNames{2}, ...
    'Dimer State'}, 'Location', 'best');

% Plot the x and y separations in a scatterplot.
PlotAxes = subplot(NPlotRows, 2, 7, 'Parent', FigureHandle);
hold(PlotAxes, 'on');
smi_stat.HMM.plotDimerPairInfo(PlotAxes, ...
    'XYSeparationPlot', TRArray, SMF, DisplayParams, UnitFlag);
xlabel(PlotAxes, sprintf('X Separation (%s)', LengthUnitString), ...
    'Interpreter', 'Latex')
ylabel(PlotAxes, sprintf('Y Separation (%s)', LengthUnitString), ...
    'Interpreter', 'Latex')

% Plot the photons over time.
PlotAxes = subplot(NPlotRows, 2, 8, 'Parent', FigureHandle);
hold(PlotAxes, 'on');
plot(PlotAxes, TRArray(1).FrameNum(TRArray(1).DimerCandidateBool), ...
    TRArray(1).Photons(TRArray(1).DimerCandidateBool), 'gx')
plot(PlotAxes, TRArray(2).FrameNum(TRArray(2).DimerCandidateBool), ...
    TRArray(2).Photons(TRArray(2).DimerCandidateBool), 'mo')
xlabel(PlotAxes, ...
    sprintf('%s (%s)', TimeDimensionString, TimeUnitString), ...
    'Interpreter', 'Latex')
ylabel(PlotAxes, 'Photons', 'Interpreter', 'Latex')
legend(PlotAxes, {'Channel 1', 'Channel 2'}, 'Location', 'best')

% Plot the registration corrections over time.
if (isfield(TRArray, 'XRegCorrection') ...
        && isfield(TRArray, 'YRegCorrection'))
    PlotAxes = subplot(NPlotRows, 2, 9, 'Parent', FigureHandle);
    hold(PlotAxes, 'on');
    smi_stat.HMM.plotDimerPairInfo(PlotAxes, ...
        'RegistrationPlot', TRArray, SMF, DisplayParams, UnitFlag);
    xlabel(PlotAxes, ...
        sprintf('%s (%s)', TimeDimensionString, TimeUnitString), ...
        'Interpreter', 'Latex')
    ylabel(PlotAxes, sprintf('Reg. Correction (%s)', LengthUnitString), ...
        'Interpreter', 'Latex')
    zlabel(PlotAxes, ...
        sprintf('%s (%s)', TimeDimensionString, TimeUnitString), ...
        'Interpreter', 'Latex')
    legend(PlotAxes, {'X Correction', 'YCorrection'}, 'Location', 'best');
end


end
./MATLAB/+smi_stat/@HMM/saveResults.m
function saveResults(obj)
%saveResults saves useful results of the Hidden Markov model analysis.
% This method contains a collection of various plot generation codes and
% result saving codes that can be used after smi.HMM.performFullAnalysis
% has been run.

% Created by:
%   David J. Schodt (Lidke Lab, 2020)


% Make sure that the top level save directory (obj.SaveDir) exists.
if isempty(obj.SaveDir)
    if  ~isempty(obj.SMF(1).Data.ResultsDir)
        obj.SaveDir = obj.SMF(1).Data.ResultsDir;
    else
        obj.SaveDir = pwd();
    end
end
if ~exist(obj.SaveDir, 'dir')
    mkdir(obj.SaveDir);
end

% Extract misc. parameters from obj (to clean up the code) and define other
% useful parameters.
FrameRate = obj.SMF(1).Data.FrameRate;
UnitFlag = obj.UnitFlag;
NStates = numel(obj.PDFHandles);
TimeUnitString = smi_helpers.arrayMUX({'frame', 'second'}, UnitFlag);

% Create a list of directories in the top level save directory.  We will
% check if there are directories named "Condition" followed by a number,
% e.g. "Condition1", and then create the next directory following that
% pattern, e.g. "Condition2".  If the user provided a condition label,
% we won't do that.
% NOTE: We'll always just add 1 to the highest number used, so if a
%       directory named "Condition3" exists, but 1 and 2 don't, we'll still
%       just create our new directory as "Condition4".  If "Condition" is
%       followed by a string, it shouldn't affect what we're doing here...
if isempty(obj.ConditionLabel)
    % Isolate items that follow the "Condition*" naming pattern in the
    % current directory, removing items that aren't directories just to be
    % safe.
    ConditionDirs = dir(fullfile(obj.SaveDir, 'Condition*'));
    ConditionDirNames = {ConditionDirs(...
        cell2mat({ConditionDirs.isdir})).name};

    % Create a suffix for our new "Condition*" directory.
    if isempty(ConditionDirNames)
        obj.ConditionLabel = 'Condition1';
    else
        % Find the maximum number is in the existing "Condition*"
        % directories.
        MaxNumber = 0; % max number found in the directory names
        for ii = 1:numel(ConditionDirNames)
            CurrentNumberString = erase(ConditionDirNames(ii), ...
                'Condition');
            MaxNumber = max(MaxNumber, str2double(CurrentNumberString{1}));
        end
        obj.ConditionLabel = sprintf('Condition%s', num2str(MaxNumber+1));
    end
end
ResultsDir = fullfile(obj.SaveDir, obj.ConditionLabel);
if ~exist(ResultsDir, 'dir')
    mkdir(ResultsDir);
end

% Isolate all pairs from the TRArray that were found to have dimerized.
TRArrayTemp = obj.TRArray;
DimerPairBool = zeros(size(TRArrayTemp, 2), 1, 'logical');
for ii = 1:size(TRArrayTemp, 1)
    % Search for pairs that had a 1 in their StateSequence (state 1 is the
    % dimer state).
    StateSequenceCurrent = TRArrayTemp(ii, 1).StateSequence;
    DimerPairBool(ii) = any(StateSequenceCurrent == 1);
end
TRArrayDimer = TRArrayTemp(logical(DimerPairBool), :);
TRArrayNotDimer = TRArrayTemp(~logical(DimerPairBool), :);
DimerDurations = cell2mat({TRArrayDimer(:, 1).DimerDurations}.');
DimerDurations = DimerDurations * (UnitFlag/FrameRate + ~UnitFlag);

% Save a .txt summary file containing the dimer->* off rates for easy
% access.
if (NStates == 3)
    KOff = obj.RateParameters(3) + obj.RateParameters(5);
    KOffSE = sqrt(obj.RateParametersSE(3)^2 + obj.RateParametersSE(5)^2);
    RateParameterKey = {'RateParameters(1): Domain -> Dimer'; ...
        'RateParameters(2): Free -> Dimer'; ...
        'RateParameters(3): Dimer -> Domain';
        'RateParameters(4): Free -> Domain';
        'RateParameters(5): Dimer -> Free';
        'RateParameters(6): Domain -> Free';
        sprintf('Rate parameter units: 1/%s', TimeUnitString)};
else
    KOff = obj.RateParameters(2);
    KOffSE = obj.RateParametersSE(2);
    RateParameterKey = {'RateParameters(1): Free -> Dimer'; ...
        'RateParameters(2): Dimer -> Free'; ...
        sprintf('Rate parameter units: 1/%s', TimeUnitString)};
end
KOff = KOff * (UnitFlag*FrameRate + ~UnitFlag); % convert to desired units
KOffSE = KOffSE * (UnitFlag*FrameRate + ~UnitFlag);
FileID = fopen(fullfile(obj.SaveDir, 'OffRateSummary.txt'), 'a');
fprintf(FileID, '%s: k_off = (%0.4f+-%0.4f) / %s, %i dimer events\n', ...
    obj.ConditionLabel, KOff, KOffSE, TimeUnitString, ...
    numel(DimerDurations));
fclose(FileID);

% Save the rate parameters in the top level directory, appending the
% filename and variable names with the specified condition label.
RateParameterNameString = sprintf('RateParameters%s', ...
    obj.ConditionLabel);
RateParametersTemp = obj.RateParameters ...
    * (UnitFlag*FrameRate + ~UnitFlag); % convert to desired units
eval(sprintf('%s = RateParametersTemp;', ...
    RateParameterNameString)); % create local var. with descriptive name
RateParameterSENameString = sprintf('RateParametersSE%s', ...
    obj.ConditionLabel);
RateParametersSETemp = obj.RateParametersSE ...
    * (UnitFlag*FrameRate + ~UnitFlag); % convert to desired units
eval(sprintf('%s = RateParametersSETemp;', ...
    RateParameterSENameString)); % create local var. with descriptive name
save(fullfile(obj.SaveDir, [RateParameterNameString, '.mat']), ...
    RateParameterNameString, RateParameterSENameString, ...
    'RateParameterKey');

% Save a copy of this class instance in the ResultsDir.
HMMNameString = 'HMM';
eval(sprintf('%s = obj;', HMMNameString)); % create local variable
save(fullfile(ResultsDir, ...
    sprintf('%s%s.mat', HMMNameString, obj.ConditionLabel)), ...
    HMMNameString, '-v7.3');

% Save these sub-TRArrays in the appropriate directories (for easy user
% access).
DimerDir = fullfile(ResultsDir, 'Dimers');
if ~exist(DimerDir, 'dir')
    mkdir(DimerDir);
end
NotDimerDir = fullfile(ResultsDir, 'Other');
if ~exist(NotDimerDir, 'dir')
    mkdir(NotDimerDir);
end
save(fullfile(DimerDir, 'TRArrayDimer.mat'), 'TRArrayDimer', '-v7.3');
save(fullfile(NotDimerDir, 'TRArrayNotDimer.mat'), 'TRArrayNotDimer', ...
    '-v7.3');

% Exit now if no dimers were identified.
if isempty(TRArrayDimer)
    return
end

% Generate some interesting plots (if desired).
FiguresVisible = smi_helpers.arrayMUX({'off', 'on'}, (obj.Verbose > 1));
if obj.GeneratePlots(1)
    % Create a histogram of the event durations found from the Viterbi
    % algorithm, with the exponential distribution found in HMM plotted on
    % top.
    FigureHandle = figure('Visible', FiguresVisible);
    PlotAxes = axes(FigureHandle);
    hold(PlotAxes, 'on');
    BinWidth = max(1, round(mean(DimerDurations)));
    [~, BinEdges] = histcounts(DimerDurations, 'BinWidth', BinWidth);
    histogram(PlotAxes, DimerDurations, 'BinWidth', BinWidth, ...
        'Normalization', 'pdf')
    DurationRange = linspace(BinEdges(1), BinEdges(end), 1e3);
    ExpFit = KOff * exp(-KOff*DurationRange);
    plot(PlotAxes, DurationRange, ExpFit);
    legend(PlotAxes, {'Observed durations', ...
        sprintf('k_{off} = %0.4f / %s', KOff, TimeUnitString)}, ...
        'Location', 'best');
    title(PlotAxes, sprintf('%s, %i dimer events', ...
        obj.ConditionLabel, numel(DimerDurations)), 'Interpreter', 'none')
    xlabel(PlotAxes, sprintf('Dimer duration (%ss)', TimeUnitString), ...
        'Interpreter', 'Latex')
    ylabel(PlotAxes, 'PDF', 'Interpreter', 'Latex')
    FileName = fullfile(DimerDir, 'DimerDurationsHistogram');
    saveas(FigureHandle, FileName, 'png');
    close(FigureHandle);

    % Create a histogram of the distribution of dimer separations.
    FigureHandle = figure('Visible', FiguresVisible);
    PDFInputs{5} = obj.DimerSeparation;
    DisplayParams.TitleString = 'Observed dimers';
    TRArrayDimerTemp = TRArrayDimer;
    for ii = 1:size(TRArrayDimer, 1)
        TRArrayDimerTemp(ii, 2).RegError = TRArrayDimerTemp(ii, 2).RegError ...
            + obj.RegErrorInflation;
    end
    obj.plotSepDistribs(FigureHandle, ...
        TRArrayDimerTemp, obj.PDFHandles, PDFInputs, DisplayParams);
    FileName = fullfile(DimerDir, 'DimerSeparationsHistogram');
    saveas(FigureHandle, FileName, 'png');
    close(FigureHandle);
end

% Create a single plot with several interesting subplots that can be
% viewed quickly as a summary.
if obj.GeneratePlots(2)
    FigureHandle = figure('Units', 'inches', ...
        'Position', [0, 0, 8.5, 11], ...
        'PaperSize', [8.5, 11], ...
        'Visible', FiguresVisible);
    obj.PlotParams.MaxYDisplaySep = obj.MaxSeparation;
    StateSequenceAll = cell2mat({TRArrayDimer.StateSequence}.');
    DimerCandAll = cell2mat({TRArrayDimer.DimerCandidateBool}.');
    obj.PlotParams.MaxYDisplayState = ...
        1.1 * max(StateSequenceAll(DimerCandAll));
    for ii = 1:size(TRArrayDimer, 1)
        % Generate the plot.
        obj.PlotParams.PairNumber = ii;
        [~, obj.PlotParams] = obj.createSummaryPlot(FigureHandle, ...
            TRArrayDimer(ii, :), obj.SMF(1), ...
            obj.PlotParams, obj.UnitFlag);

        % Save the plot.
        FileName = fullfile(DimerDir, sprintf('DimerPair%i', ii));
        saveas(FigureHandle, FileName, 'fig');
        saveas(FigureHandle, FileName, 'png');
        clf(FigureHandle);
    end
    close(FigureHandle);
end

% Generate dimer movies (if requested).
if obj.GenerateMovies
    % Reshape obj.SMF to match the size of TRArrayDimer (needed for
    % createAllMovies()).
    if all(size(obj.SMF) >= size(TRArrayDimer))
        SMFDimer = obj.SMF(DimerPairBool, :);
    else
        % obj.SMF may have been provided as either a single SMF or two SMFs
        % (one for each channel).
        SMFPair1 = smi_core.SingleMoleculeFitting.reloadSMF(obj.SMF(1, :));
        SMFDimer = repmat(SMFPair1, ...
            size(TRArrayDimer, 1:2) - size(SMFPair1, 1:2) + 1);
    end
    obj.MovieParams.UnitFlag = true;
    obj.MovieParams = obj.createAllMovies(TRArrayDimer, SMFDimer, ...
        obj.MovieParams, DimerDir);
end


end
./MATLAB/+smi_stat/@HMM/computePairSeparation.m
function [TRArray] = computePairSeparation(TRArray)
%computePairSeparation computes separation between traj. pairs in TRArray.
% This method will loop over the trajectory pairs in TRArray, compute the
% center-to-center distance between those trajectories, and then store the
% result in the output TRArray.  This method also computes the x,y averaged
% standard errors (this is a bit out of place based on this methods name,
% but it seemed to make sense to stick it in here since the x,y averaged
% standard errors are almost always something we'll need when we look at
% the separation between two trajectories).
%
% NOTE: This method assumes that the pairs in TRArray are already matched
%       in frame number, i.e. 
%       all(TRArray(1, ii).FrameNum == TRArray(2, ii).FrameNum) == 1
%
% INPUTS:
%   TRArray: A structure array of TR structures containing dimer candidates 
%            (see HMM.findDimerCandidates()) which have been "matched"
%            using HMM.isolateCandidateTRArray().
%
% OUTPUTS:
%   TRArray: Input TRArray but with additional fields Separation
%            (separation between the two trajectories in a column of
%            TRArray) and AverageSE (the averaged x,y averaged standard
%            error for a given trajectory).
%           

% Created by:
%   David J. Schodt (Lidke Lab, 2020)


% Loop through the TRArray and update it to contain the Separation and
% AverageSE fields.
for ii = 1:size(TRArray, 1)
    XTraj1 = double(TRArray(ii, 1).X);
    XSETraj1 = double(TRArray(ii, 1).X_SE);
    YTraj1 = double(TRArray(ii, 1).Y);
    YSETraj1 = double(TRArray(ii, 1).Y_SE);
    XTraj2 = double(TRArray(ii, 2).X);
    XSETraj2 = double(TRArray(ii, 2).X_SE);
    YTraj2 = double(TRArray(ii, 2).Y);
    YSETraj2 = double(TRArray(ii, 2).Y_SE);
    Separation = sqrt((XTraj1-XTraj2).^2 + (YTraj1-YTraj2).^2);
    AverageSETraj1 = mean([XSETraj1, YSETraj1], 2);
    AverageSETraj2 = mean([XSETraj2, YSETraj2], 2);
    TRArray(1, ii).Separation = Separation;
    TRArray(1, ii).AverageSE = AverageSETraj1;
    TRArray(2, ii).Separation = Separation;
    TRArray(2, ii).AverageSE = AverageSETraj2;
end


end
./MATLAB/+smi_stat/@HMM/createDimerMovie.m
function [MovieParams] = createDimerMovie(MovieAxes, ...
    TRArray, RawDataChannel1, RawDataChannel2, MovieParams, SMF, VideoObject)
%createDimerMovie creates a movie of trajectories superimposed on raw data.
% This method will create a movie of a dimer event contained in TRArray
% superimposed on the images present in RawData.
%
% NOTE: This movie generator can create some weird looking overlaps between
%       the normal trajectory and the dimer portion of the trajectory.  The
%       usage inside of obj.createAllMovies() might result in a better
%       movie!
%
% INPUTS:
%   MovieAxes: Axes object in which we've plotted stuff.
%              (Default = axes(figure()))
%   TRArray: A structure array of two TR structures, with each TR structure
%            consisting of one trajectory.
%   RawDataChannel1: 3D matrix containing the raw data of the first
%                    channel corresponding to the trajectory TRArray(1).
%   RawDataChannel2: 3D matrix containing the raw data of the second
%                    channel corresponding to the trajectory TRArray(2).
%   MovieParams: A structure of display parameters for the movie. See
%                smi_vis.GenerateMovies.prepDefaults() for options. Note
%                that some of the defaults are changed to be better suited
%                for dimer movies. Some additional fields relevant to dimer
%                data are also added to this structure:
%                CreateGrayscaleMovie: 0 to create color overlay movie.
%                                      1 to create side-by-side movie
%                                      (Default = 0)
%                ColorMap: ColorMap used to display trajectories.
%                          (Default = [0, 1, 0; 1, 0, 1], i.e., green
%                          channel 1 and magenta channel 2)
%                ChannelNames: name labels for each channel.
%                              (Default = {'Channel 1', 'Channel 2'})
%                IndicateDimer: When true, indicate dimer events with a
%                               special marking. (Default = true)
%                IndicateDimerCandidate: When true, indicate which the data
%                                        which was considered to be a dimer
%                                        candidate in pre-processsing.
%                                        (Default = true)
%   SMF: Single Molecule Fitting structure (used for Data.PixelSize and
%        Data.FrameRate).
%   VideoObject: Video writer object defining the movie that will be saved
%                while preparing this movie (see MATLAB VideoWriter
%                object).  This object should be opened and closed outside
%                of this method for proper usage.
%                (Default = [] and the movie isn't saved)
%
% OUTPUTS:
%   DisplayParams: The same structure as the input structure, but with the
%                  default parameters added in.
%
% CITATION:

% Created by:
%   David J. Schodt (Lidke Lab, 2021)


% Set default parameter values where needed.
if (~exist('MovieParams', 'var') || isempty(MovieParams))
    MovieParams = struct();
end
if (~exist('MovieAxes', 'var') || isempty(MovieAxes))
    MovieAxes = axes(figure());
end
if (~exist('SMD', 'var') || isempty(SMD))
    SMD = smi_core.SingleMoleculeData.createSMD();
end
if (~exist('VideoObject', 'var') || isempty(VideoObject))
    VideoObject = [];
end
DefaultParams = smi_vis.GenerateMovies.prepDefaults();
DefaultParams.CreateGrayscaleMovie = false;
DefaultParams.ChannelNames = {'Channel 1', 'Channel 2'};
DefaultParams.ColorMap = [0, 1, 0; 1, 0, 1];
DefaultParams.TrajColor = [0, 1, 0; 1, 0, 1];
DefaultParams.IndicateDimerCandidate = true;
DefaultParams.IndicateDimer = true;
DefaultParams.AutoClip = true;
MovieParams = smi_helpers.padStruct(MovieParams, DefaultParams);
MovieParams.ColorMap = smi_vis.contrastStretch(MovieParams.ColorMap);

% Prepare the raw data.
DataSize = size(RawDataChannel1);
ScaledDataCh1 = reshape(smi_vis.contrastStretch(RawDataChannel1), ...
    [DataSize(1:2), 1 ,DataSize(3)]);
ScaledDataCh2 = reshape(smi_vis.contrastStretch(RawDataChannel2), ...
    [DataSize(1:2), 1 ,DataSize(3)]);
if DefaultParams.CreateGrayscaleMovie
    % For grayscale movies, we'll concatenate the data side-by-side into
    % one large set of grayscale images.
    ScaledData = [ScaledDataCh1, ScaledDataCh2];
    ScaledData = repmat(ScaledData, 1, 1, 3, 1);
else
    ScaledDataCh1Color = cat(3, ...
        ScaledDataCh1 * MovieParams.ColorMap(1, 1), ...
        ScaledDataCh1 * MovieParams.ColorMap(1, 2), ...
        ScaledDataCh1 * MovieParams.ColorMap(1, 3));
    ScaledDataCh2Color = cat(3, ...
        ScaledDataCh2 * MovieParams.ColorMap(2, 1), ...
        ScaledDataCh2 * MovieParams.ColorMap(2, 2), ...
        ScaledDataCh2 * MovieParams.ColorMap(2, 3));
    ScaledData = ScaledDataCh1Color + ScaledDataCh2Color;
end

% Prepare the movie generator.
MovieGenerator = smi_vis.GenerateMovies;
TRDimerCand = smi_stat.HMM.isolateCandidateTRArray(TRArray);
MovieGenerator.TR = TRDimerCand;
MovieGenerator.Params = MovieParams;
MovieGenerator.RawData = ScaledData;
MovieGenerator.prepRawData()
MovieGenerator.prepAxes(MovieAxes)

% Define a few other parameters that'll be used in this method.
% NOTE: XRange and YRange are defined to resolve some coordinate
%       differences between raw data plots and the real data.
IsRotating = (size(MovieParams.LineOfSite, 1) > 1);
ResolutionString = sprintf('-r%i', MovieParams.Resolution);

% If the VideoObject is non-empty, open it.
if ~isempty(VideoObject)
    open(VideoObject)
end

% Define some parameters used in the display of dimer data.
DimerParams = MovieGenerator.Params;
DimerParams.TrajColor = [0, 0, 1; 0, 0, 1];
TRDimerCh1 = smi_core.SingleMoleculeData.isolateSubSMD(TRArray(1), ...
    TRArray(1).StateSequence == 1);
TRDimerCh2 = smi_core.SingleMoleculeData.isolateSubSMD(TRArray(2), ...
    TRArray(2).StateSequence == 1);
TRDimer = smi_core.TrackingResults.catTR(TRDimerCh1, TRDimerCh2);
DimerCandParams = MovieGenerator.Params;
DimerCandParams.LineStyle = '-';
RemainderParams = MovieGenerator.Params;
RemainderParams.LineStyle = ':';
TRRemainderCh1 = smi_core.SingleMoleculeData.isolateSubSMD(TRArray(1), ...
    ~(TRArray(1).DimerCandidateBool | (TRArray(1).StateSequence==1)));
TRRemainderCh2 = smi_core.SingleMoleculeData.isolateSubSMD(TRArray(2), ...
    ~(TRArray(2).DimerCandidateBool | (TRArray(2).StateSequence==1)));
TRRemainder = smi_core.TrackingResults.catTR(TRRemainderCh1, TRRemainderCh2);

% Loop through the frames of raw data and prepare the movie.
ScaledData = MovieGenerator.ScaledData;
MovieFigure = ancestor(MovieAxes, 'figure');
for ff = MovieGenerator.Params.ZFrames(1):MovieGenerator.Params.ZFrames(2)
    % Make the current frame of the movie.
    smi_vis.GenerateMovies.makeFrame(MovieAxes, ...
        [], ScaledData(:, :, :, ff), MovieGenerator.Params, SMF, SMD, ff);
    smi_vis.GenerateMovies.plotTrajectories(MovieAxes, ...
        TRRemainder, [ff-RemainderParams.MaxTrajLength, ff], ...
        RemainderParams.TrajColor, 'LineStyle', RemainderParams.LineStyle);
    smi_vis.GenerateMovies.plotTrajectories(MovieAxes, ...
        TRDimerCand, [ff-DimerCandParams.MaxTrajLength, ff], ...
        DimerCandParams.MaxTrajLength, ...
        DimerCandParams.TrajColor, 'LineStyle', DimerCandParams.LineStyle);
    smi_vis.GenerateMovies.plotTrajectories(MovieAxes, ...
        TRDimer, [ff-DimerParams.MaxTrajLength, ff], ...
        DimerParams.TrajColor, 'Marker', DimerParams.PlotMarker);
    
    % Update the line of site if needed.
    if IsRotating
        view(MovieAxes, MovieGenerator.Params.LineOfSite(ff, :))
    end
    
    % Update the axes to ensure all new objects and changes are present.
    drawnow()
    
    % If needed, write this movie frame.
    if isempty(VideoObject)
        % This movie isn't being saved: add a pause so the movie doesn't go
        % too fast.
        pause(1 / MovieGenerator.Params.FrameRate);
    else
        FrameData = print(MovieFigure, ...
            '-RGBImage', '-opengl', ResolutionString);
        VideoObject.writeVideo(FrameData);
    end
end

% Close the VideoObject.
if ~isempty(VideoObject)
    close(VideoObject)
end


end
./MATLAB/+smi_stat/@HMM/HMM.m
classdef HMM < handle
    %HMM contains methods for hidden Markov model analysis.
    % This class contains methods related to/useful for hidden Markov model
    % (HMM) of single-particle tracking (SPT).  In particular, this class
    % is designed to perform HMM and related analyses on the output
    % Tracking Results (TR) structures produced by smi.SPT.
    %
    % NOTE: This class ALWAYS uses camera units (pixels, frames)
    %       throughout the analysis.  When UnitFlag = 1, units are not
    %       converted to physical units (micrometers, seconds) until the
    %       very end when outputs/plots are being produced.
    %
    % See reference
    % Nitta, C. F., Green, E. W., Jhamba, E. D., Keth, J. M.,
    % Ortiz-Caraveo, I., Grattan, R. M., Schodt, D. J., Gibson, A. C.,
    % Rajput, A., Lidke, K. A., Steinkamp, M. P., Wilson, B. S.,
    % & Lidke, D. S. (2021). EGFR transactivates RON to drive oncogenic
    % crosstalk. eLife
    % https://doi.org/10.7554/eLife.63678
    %
    % REQUIRES:
    %   Optimization Toolbox
    %   Image Processing Toolbox
    %   Statistics and Machine Learning Toolbox
    
    % Created by:
    %   David J. Schodt (Lidke Lab, 2021)
    
    
    properties
        % Separation between fluorophores on a dimer (pixels)
        DimerSeparation(1, 1) {mustBeFloat(DimerSeparation)} = 0.5;
        
        % Typical domain size for the free, dimer, domain model (pixels)
        DomainSeparation(1, 1) {mustBeFloat(DomainSeparation)} = 2;
        
        % Max. separation for dimer candidates (pre-processing) (pixels)
        MaxSeparation(1, 1) {mustBeFloat(MaxSeparation)} = 5;

        % Registration error inflation (pixels)
        RegErrorInflation(1, 1) {mustBeFloat(RegErrorInflation)} = 0.0;
        
        % Identifier for one of the pre-built models. (Default = 'DF')
        % OPTIONS:
        %   'DF': dimer or free
        %   'DDF': dimer, domain, or free
        ModelSpecifier {mustBeText(ModelSpecifier)} = 'DF';
        
        % Handles to the state PDFs used in the HMM (cell array)
        PDFHandles(:, 1) cell
        
        % Initial guess of rate parameters (NRatesx1 float)
        RateParametersGuess(:, 1) {mustBeFloat(RateParametersGuess)} = ...
            0.01 * [1; 1];
        
        % Array of TR structures corresponding to dimer candidates. (Nx2)
        % This is organized as a NCandidatex2 structure, with each column
        % being a dimer candidate.
        TRArray(:, 2) struct
        
        % Data channel names added to certain outputs. (cell array of char)
        ChannelNames cell = {'Channel 1'; 'Channel 2'};
        
        % Model state names added to certain outputs. (cell array of char)
        StateNames cell = {'Dimer'; 'Free'};
        
        % Label for save directory to indicate a condition. (char/string)
        ConditionLabel {mustBeText(ConditionLabel)} = '';
        
        % Indicate results should be saved. (Default = true)
        % NOTE: This is used when running obj.performFullAnalysis().
        SaveResults logical = true;
        
        % Indicate outputs should be in physical units. (Default = false)
        UnitFlag logical = false;
        
        % Indicate movies should be generated and saved. (Default = false)
        % NOTE: This is used when running obj.performFullAnalysis().
        GenerateMovies logical = false;
        
        % Set of movie parameters (see GenerateMovies)
        MovieParams struct = smi_vis.GenerateMovies.prepDefaults();
        
        % Set of plot parameters (see DisplayParams in plotDimerPairInfo())
        PlotParams struct = struct();
        
        % Indicate plots should be generated and saved. (Default = true)
        % GeneratePlots(1) indicates the histogram of dimer durations
        %   should be generated.
        % GeneratePlots(2) indicates the summaray plots should be
        %   generated.
        % NOTE: This is used when running obj.performFullAnalysis() inside
        %       of obj.saveResults().
        GeneratePlots = [true; true];

        % Structure of parameters (see smi_core.SingleMoleculeFitting)
        % NOTE: This can be passed as an array of two SMFs, one for each
        %       channel, which can be used when information about each
        %       channel is needed (e.g., in obj.createAllMovies()).
        %       Alternatively, this can be passed as an array of SMFs
        %       matching the size of obj.TRArray, allowing for things like
        %       loading raw data for each pair in TRArraay.
        SMF = smi_core.SingleMoleculeFitting;
        
        % Top level directory for saving results.
        % NOTE: If left empty, obj.saveResults() will try to use
        %       obj.SMF.Data.ResultsDir.  If that is also empty, a default
        %       will be set to pwd().
        SaveDir {mustBeText(SaveDir)} = '';
        
        % Verbosity level of obj.performFullAnalysis(). (Default = 1)
        Verbose {mustBeInteger(Verbose)} = 1;
    end
    
    properties (SetAccess = 'protected')
        % Rate parameters found by HMM analysis. (float array)
        RateParameters(:, 1) {mustBeFloat(RateParameters)}
        
        % Standard error estimates of rate parameters. (float array)
        RateParametersSE(:, 1) {mustBeFloat(RateParametersSE)}
        
        % Pre-processed obj.TRArray as seen by the HMM analysis. (Nx2)
        TRArrayTrunc(:, 2) struct
    end
    
    properties (Hidden)
        % Tolerance used in a check in obj.performFullAnalysis().
        DiscrepancyTol(1, 1) {mustBeFloat(DiscrepancyTol)} = 0.1;
        
        % Filenames corresponding to dimer candidates in TRArray.
        FileNames(:, 2) cell
        
        % Registration files corresponding to dimer candidates in TRArray.
        RegFileNames(:, 1) cell
    end
    
    methods
        function obj = HMM(TRArray, SMF)
            % Class constructor which allows option inputs.
            if exist('TRArray', 'var')
                obj.TRArray = TRArray;
            end
            if exist('SMF', 'var')
                obj.SMF = SMF;
            end

            % Revise some default movie parameters.
            obj.MovieParams.AutoCrop = true;
            obj.MovieParams.IndicateDimer = true;
            obj.MovieParams.IndicateDimerCandidate = true;
            obj.MovieParams.CropToDimerCandidates = true;
            obj.MovieParams.TrajColor = [0, 1, 0; 1, 0, 1];
        end
        
        function set.ConditionLabel(obj, InputValue)
            % This set method ensures that the user defined ConditionLabel
            % doesn't contain any spaces (spaces can cause issues in some
            % parts of the code, but are a common choice by users, so I've
            % found it easiest to just replace them quietly).
            obj.ConditionLabel = replace(InputValue, ' ', '_');
        end
        
        [RateParameters, RateParametersSE, LogLikelihood] = ...
            performFullAnalysis(obj);
        saveResults(obj);
        
    end
    
    methods (Static)
        [TransitionMatrix] = ...
            generateTransitionMatrix(TransitionRates, DeltaT);
        [EmissionMatrix] = ...
            generateEmissionMatrix(PDFHandles, DataCell);
        [PDFHandles] = generateEmissionPDFs(ModelSpecifier);
        [LogLikelihood] = computeLogLikelihood(TransitionMatrixSeries, ...
            EmissionProbabilitySeries);
        [RateParameters, RateParametersSE, LogLikelihood] = ...
            estimateRateParameters(EmissionPDFCell, DeltaT, ...
            RateParametersGuess, SearchOptions, Verbose);
        [TRArray] = findDimerCandidates(TR1, TR2, ...
            MaxDimerSeparation, MaxSeparation, MinValidPoints, ...
            MinPhotons, BorderPadding);
        [TRArray, SMFArray, FileList] = ...
            findDimerCandidatesFromFiles(FileDir, FilePatterns, ...
            MaxDimerSeparation, MaxSeparation, MinValidPoints, ...
            MinPhotons, BorderPadding, Verbose);
        [TRArray] = computePairSeparation(TRArray);
        [TRArrayTrunc] = isolateCandidateTRArray(TRArray);
        [StateSequence] = computeViterbiPath(...
            StateSpace, InitialProbability, ...
            TransitionMatrix, EmissionMatrix);
        [DimerDurations] = computeDimerDurations(...
            StateSequence, FrameNum, DimerState);
        [PlotAxes] = plotOffRateBarGraph(OffRates, OffRatesSE, ...
            XBarLocations, ConditionColorMap, ConditionNames, UnitFlag, ...
            PlotAxes);
        [PlotAxes] = plotDimerDurationCDF(DimerDurations, PlotAxes);
        [MovieParams] = createDimerMovie(MovieAxes, ...
            TRArray, RawDataChannel1, RawDataChannel2, ...
            FilePath, MovieParams, SMF, VideoObject)
        [MovieParams] = createAllMovies(TRArray, SMFArray, ...
            MovieParams, SaveDir);
        [FigureHandle, DisplayParams] = createSummaryPlot(FigureHandle, ...
            TRArray, SMF, DisplayParams, UnitFlag);
        success = unitTest();
    end
    
    methods (Static, Hidden)
        % These methods should still be accesible to the user, but it's
        % probably best that we don't overwhelm the user with too many
        % visible methods that they aren't likely to use!
        
        [PlotFigure, DisplayParams] = plotSepDistribs(PlotFigure, ...
            TRArray, PDFHandles, PDFInputs, DisplayParams);
        [PlotAxes, DisplayParams] = plotDimerPairInfo(PlotAxes, ...
            PlotType, TRArray, SMF, DisplayParams, UnitFlag);
        %         plotViterbiPath
        %         plotEmissionProbabilities
        %         plotDimerTraj2D
        %         plotDimerTraj3D
        %         plotRegistration
        %         plotXYSeparation
    end
    
    
end

./MATLAB/+smi_stat/@HMM/computeViterbiPath.m
function [StateSequence] = computeViterbiPath(...
    StateSpace, InitialProbability, TransitionMatrix, EmissionMatrix)
%computeViterbiPath estimates state sequence for a HMM using Viterbi alg.
% This method uses the Viterbi algorithm to estimate the most likely state
% sequence of hidden states in a hidden Markov model (HMM) given a set of
% observations.  In this method, the observations are intrinsically 
% accounted for in the EmissionMatrix.
% 
% NOTE: The observation space is assumed to be infinite, e.g., as it would
%       be if the observation space is the set of all possible distances 
%       between two trajectories.  In this case, the columns of the
%       emission matrix MUST correspond directly to an observation given in
%       Observation, i.e., the emission probabilities for Obervation(ii)
%       are given in the column EmissionMatrix(:, ii).
% 
% INPUTS:
%   StateSpace: The set of states in the HMM (e.g., [1; 2; 3] for a three
%               state model). (Kx1)
%   InitialProbability: Probabality of being in a state in StateSpace
%                       (e.g., [0.4; 0.3; 0.3] for a three state model).
%                       (Kx1)
%   TransitionMatrix: The matrix containing the transition probabilities
%                     from one state to another in a single time step 
%                     (e.g., TransitionMatrix(i, j) = 0.2 means that the
%                     probability of transition from state i to j during a
%                     given time step is 0.2).
%                     Alternatively, TransitionMatrix can have a third
%                     dimension corresponding to the second dimension of
%                     the EmissionMatrix, i.e. the TransitionMatrix is
%                     different for each observation (as might be the case
%                     if the observations were not uniformly sampled in
%                     time).  Note that in this case there will not be a
%                     transition matrix for the first observation.
%                     (numel(StateSpace) x numel(StateSpace), OR
%                      numel(StateSpace) x numel(StateSpace) 
%                          x numel(Observations)-1)
%   EmissionMatrix: The probability density of being in a given state in 
%                   StateSpace given Observation.
%                   (numel(StateSpace) x numel(Observations)).
% 
% OUTPUTS:
%   StateSequence: The estimated state sequence of hidden states given the
%                  input Observations. 

% Created by:
%   David J. Schodt (Lidke Lab, 2020)


% Ensure inputs are given as column vectors.
if (size(StateSpace, 2) > size(StateSpace, 1))
    StateSpace = StateSpace.';
end
if (size(InitialProbability, 2) > size(InitialProbability, 1))
    InitialProbability = InitialProbability.';
end

% Initialize/pre-allocate variables as needed.
MStates = numel(StateSpace);
NObservations = size(EmissionMatrix, 2);
StateSequence = zeros(NObservations, 1, 'uint8');
StateIndices = StateSequence;
LogPathProbability = zeros(MStates, NObservations);
PathHistory = LogPathProbability;

% Add a third dimension to the TransitionMatrix (if needed) so that code
% doesn't have to be modified with if/else conditions further down.
if (size(TransitionMatrix, 3) == 1)
    TransitionMatrix = repmat(TransitionMatrix, [1, 1, NObservations-1]);
end

% Initialize the log probability table.
LogPathProbability(:, 1) = log(InitialProbability .* EmissionMatrix(:, 1));

% Loop through each observation in Observation and construct the
% log probability table and the path history table.
for jj = 2:NObservations
    for ii = 1:MStates
        [LogPathProbability(ii, jj), PathHistory(ii, jj)] = ...
            max(LogPathProbability(:, jj-1) ...
            + log(TransitionMatrix(:, ii, jj-1)) ...
            + log(EmissionMatrix(ii, jj)));
    end
end

% Construct the state sequence.
[~, StateIndices(NObservations)] = ...
    max(LogPathProbability(:, NObservations));
StateSequence(NObservations) = StateSpace(StateIndices(NObservations));
for ii = NObservations:-1:2
    StateIndices(ii-1) = PathHistory(StateIndices(ii), ii);
    StateSequence(ii-1) = StateSpace(StateIndices(ii-1));
end


end
./MATLAB/+smi_stat/@HMM/estimateRateParameters.m
function [RateParameters, RateParametersSE, LogLikelihood] = ...
    estimateRateParameters(EmissionPDFCell, DeltaT, ...
    RateParametersGuess, SearchOptions, Verbose)
%estimateRateParameters estimates rate parameters from dimer candidates.
% This method will perform a Hidden Markov Model (HMM) analysis on all
% trajectory pairs contained in TRArray, using the model given by the 
% emission probability densities EmissionPDFCell.
% 
% INPUTS:
%   EmissionPDFCell: A cell array containing the emission PDF's for each
%                    state for every candidate in TRArray.  For example,
%                    EmissionPDFCell{10} will be equal to
%                    TRArray(1, 10).EmissionProbabilities(...
%                       TRArray(1, 10).DimerCandidateBool)
%   DeltaT: Cell array with each element corresponding to the time since
%           last observation, corresponding to the observations used to 
%           generate EmissionPDFCell (e.g., DeltaT{n} = diff(TRArray(1,
%           n).FrameNum(TRArray(1, n).DimerCandidateBool)).
%           (NCandidates x 1 cell array)
%   MaxSeparation: Maximum separation that may exist between trajectories
%                  in TRArray.
%   RateParametersGuess: An initial guess of the rate parameters. 
%                        (default = 0.1 * ones(NRateParameters, 1))
%                        (NRateParameters x 1 array, where 
%                         NRateParameters = NStates * (NStates-1))
%   SearchOptions: MATLAB optimoptions structure sent directly to
%                  fmincon(). (Default = optimoptions('fmincon'))
%   Verbose: Verbosity level requested. (Default = 1)
%
% OUTPUTS:
%   RateParameters: An array containing the rate parameters estimated for
%                   the HMM (see the nested function 
%                   computeLogLikelihoodWrapper below for parameter
%                   descriptions).
%                   (1 / frames)
%   RateParametersSE: The estimated standard errors in the reported 
%                     RateParameters. (1 / frames)
%   LogLikelihood: The log-likelihood computed at the returned value of
%                  RateParameters. 
%
% REQUIRES: Optimization Toolbox to use fmincon()

% Created by:
%   David J. Schodt (Lidke Lab, 2020)


% Define misc. parameters/set defaults.
if (~exist('Verbose', 'var') || isempty(Verbose))
    Verbose = 1;
end
if (~exist('SearchOptions', 'var') || isempty(SearchOptions))
    SearchOptions = optimoptions('fmincon');
    SearchOptions.Display = ...
        smi_helpers.arrayMUX({'none', 'final', 'iter'}, Verbose);
end
NStates = size(EmissionPDFCell{1}, 2);
NRateParams = NStates * (NStates-1);

% Set defaults if needed.
if ~exist('RateParametersGuess', 'var') || isempty(RateParametersGuess)
    RateParametersGuess = 0.01 * ones(NRateParams, 1);
end

% Estimate the rate parameters by minimizing the negative of the
% log-likelihood.
NegLogLikelihood = @(X) -computeLogLikelihoodWrapper(X, DeltaT, ...
    EmissionPDFCell, NStates);
RateParameters = fmincon(NegLogLikelihood, RateParametersGuess, ...
    [], [], [], [], zeros(NRateParams, 1), inf(NRateParams, 1), ...
    [], SearchOptions);
LogLikelihood = -NegLogLikelihood(RateParameters);

% Estimate the errors in the found model parameters.
[HessianMatrix] = smi_stat.computeHessian(NegLogLikelihood, RateParameters);
RateParametersSE = sqrt(diag(inv(HessianMatrix)));


    function [LogLikelihood] = computeLogLikelihoodWrapper(...
            SearchParameters, DeltaT, EmissionPDFCell, NStates)
        % This is a wrapper for the class method computeLogLikelihood.  In
        % computeLogLikelihood, the rate parameters are given as a matrix,
        % but to estimate the rate parameters with fminsearch we need to
        % have a function with a vector input.  This function also acts to
        % loop over all trajectory pairs to compute the overall likelihood
        % of a given model parametrized by RateParameters.
        % 
        % INPUTS: 
        %   SearchParameters: A vector containing the transition rate
        %                     parameters between the HMM states as well as
        %                     the domain size parameter.
        %                     ModelSpecifier = 'DF': 
        %                       SearchParameters(1) = rate parameter from
        %                           state 2 to state 1 (Free to Dimer)
        %                       SearchParameters(2) = rate parameter from
        %                           state 1 to state 2 (Dimer to Free)
        %                     ModelSpecifier = 'DDF':
        %                       SearchParameters(1) = rate parameter from
        %                           state 2 to state 1 (Domain to Dimer)
        %                       SearchParameters(2) = rate parameter from
        %                           state 3 to state 1 (Free to Dimer)
        %                       SearchParameters(3) = rate parameter from
        %                           state 1 to state 2 (Dimer to Domain)
        %                       SearchParameters(4) = rate parameter from
        %                           state 3 to state 2 (Free to Domain)
        %                       SearchParameters(5) = rate parameter from
        %                           state 1 to state 3 (Dimer to Free)
        %                       SearchParameters(6) = rate parameter from
        %                           state 2 to state 3 (Domain to Free)
        %                   NOTE: The ordering of rate parameters is based
        %                         on MATLABs column based behavior, so to 
        %                         convert from matrix to array we scan down 
        %                         each column and read off the elements.
        %   EmissionPDFCell: A cell array containing the emission PDF's for
        %                    each state for all trajectory pairs in TRArray
        %   NStates: Number of states in the model.
        %   
        % OUTPUTS:
        %   LogLikelihood: The log-likelihood of the sequence as computed
        %                  by smi_stat.HMM.computeLogLikelihood()
                
        % Convert the SearchParameters array to a rate parameter matrix for
        % use in smi_stat.HMM.computeLogLikelihood(). 
        RateParameterMatrix = zeros(NStates);
        DiagonalBool = logical(eye(NStates));
        RateParameterMatrix(~DiagonalBool) = SearchParameters;
                
        % Loop through all dimer candidate pairs in TRArray to compute the
        % log-likelihood.
        LogLikelihood = 0;
        for nn = 1:numel(DeltaT)
            % Compute the transition matrices for all observations of the 
            % current trajectory pair.
            TransitionMatrixSeries = smi_stat.HMM.generateTransitionMatrix(...
                RateParameterMatrix, DeltaT{nn});
                        
            % Compute the log-likelihood.
            LogLikelihood = LogLikelihood ...
                + smi_stat.HMM.computeLogLikelihood(...
                TransitionMatrixSeries, EmissionPDFCell{nn});
        end
    end


end
./MATLAB/+smi_stat/@HMM/README.md
### +smi_stat/@HMM

@HMM contains methods related to/useful for hidden Markov model
(HMM) of single-particle tracking (SPT).  In particular, this class
is designed to perform HMM and related analyses on the output
Tracking Results (TR) structures produced by smi.SPT.

NOTE: This class ALWAYS uses camera units (pixels, frames)
throughout the analysis.  When UnitFlag = 1, units are not
converted to physical units (micrometers, seconds) until the
very end when outputs/plots are being produced.

See reference:
Nitta, C. F., Green, E. W., Jhamba, E. D., Keth, J. M.,
Ortiz-Caraveo, I., Grattan, R. M., Schodt, D. J., Gibson, A. C.,
Rajput, A., Lidke, K. A., Steinkamp, M. P., Wilson, B. S.,
& Lidke, D. S. (2021). EGFR transactivates RON to drive oncogenic
crosstalk. eLife
https://doi.org/10.7554/eLife.63678

REQUIRES:
- Optimization Toolbox
- Image Processing Toolbox
- Statistics and Machine Learning Toolbox

For a detailed example, see
[Example_HMM.m](../../examples/Example_HMM.m).

---
    
```
properties:
   % Separation between fluorophores on a dimer (pixels)
   DimerSeparation(1, 1) {mustBeFloat(DimerSeparation)} = 0.5;
   
   % Typical domain size for the free, dimer, domain model (pixels)
   DomainSeparation(1, 1) {mustBeFloat(DomainSeparation)} = 2;
   
   % Max. separation for dimer candidates (pre-processing) (pixels)
   MaxSeparation(1, 1) {mustBeFloat(MaxSeparation)} = 5;

   % Registration error inflation (pixels)
   RegErrorInflation(1, 1) {mustBeFloat(RegErrorInflation)} = 0.0;
   
   % Identifier for one of the pre-built models. (Default = 'DF')
   % OPTIONS:
   %   'DF': dimer or free
   %   'DDF': dimer, domain, or free
   ModelSpecifier {mustBeText(ModelSpecifier)} = 'DF';
   
   % Handles to the state PDFs used in the HMM (cell array)
   PDFHandles(:, 1) cell
   
   % Initial guess of rate parameters (NRatesx1 float)
   RateParametersGuess(:, 1) {mustBeFloat(RateParametersGuess)} = ...
       0.01 * [1; 1];
   
   % Array of TR structures corresponding to dimer candidates. (Nx2)
   % This is organized as a NCandidatex2 structure, with each column
   % being a dimer candidate.
   TRArray(:, 2) struct
   
   % Data channel names added to certain outputs. (cell array of char)
   ChannelNames cell = {'Channel 1'; 'Channel 2'};
   
   % Model state names added to certain outputs. (cell array of char)
   StateNames cell = {'Dimer'; 'Free'};
   
   % Label for save directory to indicate a condition. (char/string)
   ConditionLabel {mustBeText(ConditionLabel)} = '';
   
   % Indicate results should be saved. (Default = true)
   % NOTE: This is used when running obj.performFullAnalysis().
   SaveResults logical = true;
   
   % Indicate outputs should be in physical units. (Default = false)
   UnitFlag logical = false;
   
   % Indicate movies should be generated and saved. (Default = false)
   % NOTE: This is used when running obj.performFullAnalysis().
   GenerateMovies logical = false;
   
   % Set of movie parameters (see GenerateMovies)
   MovieParams struct = smi_vis.GenerateMovies.prepDefaults();
   
   % Set of plot parameters (see DisplayParams in plotDimerPairInfo())
   PlotParams struct = struct();
   
   % Indicate plots should be generated and saved. (Default = true)
   % GeneratePlots(1) indicates the histogram of dimer durations
   %   should be generated.
   % GeneratePlots(2) indicates the summaray plots should be
   %   generated.
   % NOTE: This is used when running obj.performFullAnalysis() inside
   %       of obj.saveResults().
   GeneratePlots = [true; true];

   % Structure of parameters (see smi_core.SingleMoleculeFitting)
   % NOTE: This can be passed as an array of two SMFs, one for each
   %       channel, which can be used when information about each
   %       channel is needed (e.g., in obj.createAllMovies()).
   %       Alternatively, this can be passed as an array of SMFs
   %       matching the size of obj.TRArray, allowing for things like
   %       loading raw data for each pair in TRArraay.
   SMF = smi_core.SingleMoleculeFitting;
   
   % Top level directory for saving results.
   % NOTE: If left empty, obj.saveResults() will try to use
   %       obj.SMF.Data.ResultsDir.  If that is also empty, a default
   %       will be set to pwd().
   SaveDir {mustBeText(SaveDir)} = '';
   
   % Verbosity level of obj.performFullAnalysis(). (Default = 1)
   Verbose {mustBeInteger(Verbose)} = 1;
```

---

methods:
- **[computeDimerDurations](computeDimerDurations.m)**:
  computes the length of dimer events in StateSequence
- **[computeLogLikelihood](computeLogLikelihood.m)**:
  computes the LogLikelihood of a sequence in the HMM
- **[computePairSeparation](computePairSeparation.m)**:
  computes separation between traj. pairs in TRArray
- **[computeViterbiPath](computeViterbiPath.m)**:
  estimates state sequence for a HMM using Viterbi alg
- **[createAllMovies](createAllMovies.m)**:
  creates dimer movies for all pairs in TRArray
- **[createDimerMovie](createDimerMovie.m)**:
  creates a movie of trajectories superimposed on raw data
- **[createSummaryPlot](createSummaryPlot.m)**:
  creates a multi-panel summary plot of the HMM analysis
- **[estimateRateParameters](estimateRateParameters.m)**:
  estimates rate parameters from dimer candidates
- **[findDimerCandidates](findDimerCandidates.m)**:
  finds dimer candidate pairs between TR1 and TR2
- **[findDimerCandidatesFromFiles](findDimerCandidatesFromFiles.m)**:
  creates a TRArray from the provided files
- **[generateEmissionMatrix](generateEmissionMatrix.m)**:
  computes emission matrix for an observed separation
- **[generateEmissionPDFs](generateEmissionPDFs.m)**:
  creates array of emission density function handles
- **[generateTransitionMatrix](generateTransitionMatrix.m)**:
  generates the transition matrix of a Markov model
- **[isolateCandidateTRArray](isolateCandidateTRArray.m)**:
  isolates dimer candidate pairs in TRArray
- **[performFullAnalysis](performFullAnalysis.m)**:
  performs all analyses on the data in obj.TRArray
- **[plotDimerPairInfo](plotDimerPairInfo.m)**:
  creates various plots related to dimer pair trajectories
- **[plotSepDistribs](plotSepDistribs.m)**:
  makes histograms of the distributions of separations
- **[saveResults](saveResults.m)**:
  saves useful results of the Hidden Markov model analysis.
- **[unitTest](unitTest.m)**:
  test calling smi_stat.HMM routines

./MATLAB/+smi_stat/@HMM/plotDimerPairInfo.m
function [PlotAxes, DisplayParams] = ...
    plotDimerPairInfo(PlotAxes, PlotType, TRArray, ...
    SMF, DisplayParams, UnitFlag)
%plotDimerPairInfo creates various plots related to dimer pair trajectories
% This method organizes several plotting codes meant to plot information
% related to a pair of dimer trajectories.
%
% NOTE: We should split this up into a few simpler methods.  Specifically,
%       each "case" of the switch/case below should be a simpler call to a
%       different method.  For now, we'll leave this as is.
% 
% INPUTS:
%   PlotAxes: Axes in which we should plot stuff. (Default = gca())
%   PlotType: Type of plot that will be created. 
%             ViterbiSequence: Plot of the separation vs. time with state
%                              as identified by Viterbi algorithm overlain.
%             EmissionProbability: Plot of the emission probability vs.
%                                  time with the state sequence overlain.
%             TrajectoryPlot3D: 3D plot of the two trajectories over time,
%                               with the state specified by StateToIndicate
%                               being marked in some way.
%             TrajectoryPlot2D: 2D plot of the two trajectories over time,
%                               with the state specified by StateToIndicate
%                               being marked in some way.  The frame will
%                               be forced to the full frame size in this
%                               plot (the goal of this plot is to help
%                               identify edge effects, so we want to see
%                               how close to the ROI edge the trajectories
%                               were).
%             RegistrationPlot: Plot of the registration corrections made
%                               over time.
%             XYSeparationPlot: Plot the separation between the two
%                               trajectories separately in x, y as a
%                               scatterplot.
%             (Default = 'ViterbiSequence')
%   TRArray: A structure array of TR structures, where the constituent TR
%            structures correspond to the relevant segments of dimer
%            trajectories.  TRArray(1) will contain information about a 
%            trajectory from TR1 that was found to have dimerized with
%            TRArray(2).  TRArray can additionally contain a "PairIDs" 
%            cell array, which contains the trajectory ID's of trajectories
%            which were part of an oligomer in each frame (this information
%            will be plotted when PlotType = 'ViterbiSequence') as might be 
%            known for a simulated TRArray.  For example, if
%            TRArray(1).PairIDs(23) = [5; 8], this means that the
%            trajectory TRArray(1) was part of an oligomer with
%            trajectories 5 and 8 in frame 23.
%   SMF: Single Molecule Fitting structure (for now, only
%        SMF.Data.PixelSize and SMF.Data.FrameRate are  used).
%        (Default = smi_core.SingleMoleculeFitting)
%   DisplayParams: A structure of display parameters for the plots.
%                  StateColormap: A colormap corresponding to the states
%                                 given in ModelSpecifier/StateNames
%                                 (NStates x 3 array)
%                                 (Default = colormap(lines(NStates)))
%                  MinXYRange: Minimum XY display range of the movie
%                              (pixels)(Default = 10) 
%                  MaxYDisplaySep: Maximum of y axis for any plots of
%                                  separation vs time (pixels)(Default =
%                                  max(cell2mat({TRArray.Separation}))
%                  MaxYDisplayState: Maximum of y axis for state plots.
%                                    (Default = 1.1*NStates)
%                  PairNumber: The pair number identifying the dimer pair 
%                              being plotted. (Default = 1)
%                  StateNames: see smi_stat.HMM 
%                              (Default = {'Dimer'; 'Free'})
%                  StateToMark: Numeric value corresponding to a specific 
%                               state that should be marked when
%                               PlotType = 'TrajectoryPlot'
%                               (Default = 1)
%   UnitFlag: Flag indicating we should use physical units. 
%             (Default = false)
% 
% OUTPUTS:
%   PlotAxes: Axes object in which we've plotted stuff.
%   DisplayParams: The same structure as the input structure, but with the
%                  default parameters added in.

% Created by:
%   David J. Schodt (Lidke Lab, 2020)

% Set default values if needed.
if (~exist('PlotAxes', 'var') || isempty(PlotAxes))
    PlotAxes = gca();
end
if (~exist('PlotType', 'var') || isempty(PlotType))
    PlotType = 'ViterbiSequence';
end
if (~exist('SMF', 'var') || isempty(SMF))
    SMF = smi_core.SingleMoleculeFitting;
end
if (~exist('UnitFlag', 'var') || isempty(UnitFlag))
    UnitFlag = false;
end

% Define some parameters that we'll need for setting some defaults.
DimerCandidateBool1 = TRArray(1).DimerCandidateBool;
DimerCandidateBool2 = TRArray(2).DimerCandidateBool;
StateSequence = TRArray(1).StateSequence(DimerCandidateBool1);
EmissionProbabilities = TRArray(1).EmissionProbabilities(...
    DimerCandidateBool1, :);
NStates = max([numel(unique(StateSequence)), ...
    size(EmissionProbabilities, 2), ...
    max(StateSequence)]);

% Set default display parameters where needed.
if (~exist('DisplayParams', 'var') || isempty(DisplayParams))
    DisplayParams = struct();
end
DefaultDisplayParams.StateNames = {'Dimer'; 'Free'};
DefaultDisplayParams.StateColormap = lines(NStates);
DefaultDisplayParams.MinXYRange = 10;
DefaultDisplayParams.MaxYDisplaySep = ...
    max(cell2mat({TRArray.Separation}.'));
DefaultDisplayParams.MaxYDisplayState = ...
    1.1 * numel(unique(StateSequence(~isnan(StateSequence))));
DefaultDisplayParams.PairNumber = 1;
DefaultDisplayParams.StateToMark = 1;
DefaultParameterNames = fieldnames(DefaultDisplayParams);
InputParameterNames = fieldnames(DisplayParams);
for ii = 1:numel(DefaultParameterNames)
    if ~any(ismember(DefaultParameterNames{ii}, InputParameterNames))
        % The field DefaultParameterNames{ii} is not present in the
        % DisplayParams structure and so the default must be added.
        DisplayParams.(DefaultParameterNames{ii}) = ...
            DefaultDisplayParams.(DefaultParameterNames{ii});
    end
end

% Convert misc. arrays to the desired units, isolate segments of
% interest of certain arrays, and define misc. parameters.
% NOTE: Some of the default parameters are dependent on these so I do this
%       first.
FrameRate = SMF.Data.FrameRate;
PixelSize = SMF.Data.PixelSize;
MaxYDisplaySepConverted = DisplayParams.MaxYDisplaySep ...
    * (UnitFlag*PixelSize + ~UnitFlag);
FrameNum = TRArray(1).FrameNum(DimerCandidateBool1) ...
    * (UnitFlag/FrameRate + ~UnitFlag);
Separation = TRArray(1).Separation(DimerCandidateBool1) ...
    * (UnitFlag*PixelSize + ~UnitFlag);
if isfield(TRArray(1), 'PairIDs')
    PairIDs = TRArray(1).PairIDs(DimerCandidateBool1);
    IsDimerGroundTruth = cellfun(...
        @(X) any(TRArray(2).TrajectoryID == X), PairIDs);
else
    IsDimerGroundTruth = zeros(sum(DimerCandidateBool1), 1);
end

% Prepare the figure/axes for the plots.
axes(PlotAxes);
hold(PlotAxes, 'on');

% Proceed to plot the user selected plot.
switch PlotType
    case 'ViterbiSequence'
        % Prepare the figure/axes for the Viterbi plot.
        axis(PlotAxes, 'tight');
        yyaxis(PlotAxes, 'left');
        
        % Define misc. parameters for later use and define parameter
        % dependent defaults.
        NObservations = numel(StateSequence);
        StatePlotValues = 1:NStates;
        MinYValue = 0;
        
        % Create an RGBA color from our selected RGB color (if we just add
        % a 4-th element to the color for the alpha value, .fig file isn't
        % saving that correctly as of R2020a).  I found this conversion
        %  here: http://marcodiiga.github.io/rgba-to-rgb-conversion
        AlphaValue = 0.5;
        StateColormap = (1-AlphaValue) * repmat(PlotAxes.Color, ...
            [size(DisplayParams.StateColormap, 1), 1]) ...
            + AlphaValue*DisplayParams.StateColormap(:, 1:3);

        % Plot the state color code rectangle for the first observation.
        CurrentStateColor = StateColormap(...
            StatePlotValues == StateSequence(1), :);
        RectangleStartFrame = zeros(NObservations, 1);
        RectangleStartFrame(1) = FrameNum(1);
        if (NObservations > 1)
            RectangleXWidth = ((FrameNum(1)+FrameNum(2))/2) ...
                - RectangleStartFrame(1);
        else
            RectangleXWidth = FrameNum(1) - RectangleStartFrame(1) + 0.5;
        end
        rectangle(PlotAxes, 'Position',  ...
            [RectangleStartFrame(1), MinYValue, RectangleXWidth, ...
            MaxYDisplaySepConverted], ...
            'FaceColor', CurrentStateColor, 'EdgeColor', 'none');
        if IsDimerGroundTruth(1)
            rectangle(PlotAxes, 'Position',  ...
                [RectangleStartFrame(1), ...
                MinYValue+MaxYDisplaySepConverted/2, ...
                RectangleXWidth, MaxYDisplaySepConverted/2], ...
                'FaceColor', CurrentStateColor, 'EdgeColor', 'none');
        end
        
        % Plot the state color code rectangles for the remaining
        % observations.
        for ii = 2:(NObservations-1)
            % Plot a rectangle as a background color behind each state.
            CurrentStateColor = StateColormap(...
                StatePlotValues == StateSequence(ii), :);
            RectangleStartFrame(ii) = (FrameNum(ii-1) + FrameNum(ii)) / 2;
            RectangleXWidth = (FrameNum(ii+1)+FrameNum(ii))/2 ...
                - RectangleStartFrame(ii);
            rectangle(PlotAxes, 'Position',  ...
                [RectangleStartFrame(ii), MinYValue, ...
                RectangleXWidth, MaxYDisplaySepConverted], ...
                'FaceColor', CurrentStateColor, 'EdgeColor', 'none');
            if IsDimerGroundTruth(ii)
                rectangle(PlotAxes, 'Position',  ...
                    [RectangleStartFrame(ii), ...
                    MinYValue+MaxYDisplaySepConverted/2, ...
                    RectangleXWidth, MaxYDisplaySepConverted/2], ...
                    'FaceColor', CurrentStateColor, 'EdgeColor', 'none');
            end
        end
        CurrentStateColor = StateColormap(...
            StatePlotValues == StateSequence(NObservations), :);
        if (NObservations > 1)
            RectangleStartFrame(NObservations) = ...
                (FrameNum(NObservations-1) + FrameNum(NObservations)) / 2;
        else
            RectangleStartFrame(1) = FrameNum(1) - (1/2);
        end
        RectangleXWidth = FrameNum(NObservations) ...
            - RectangleStartFrame(NObservations);
        rectangle(PlotAxes, 'Position',  ...
            [RectangleStartFrame(NObservations), MinYValue, ...
            RectangleXWidth, MaxYDisplaySepConverted], ...
            'FaceColor', CurrentStateColor, 'EdgeColor', 'none');
        if IsDimerGroundTruth(NObservations)
            rectangle(PlotAxes, 'Position',  ...
                [RectangleStartFrame(NObservations), ...
                MinYValue + MaxYDisplaySepConverted/2, ...
                RectangleXWidth, MaxYDisplaySepConverted/2], ...
                'FaceColor', CurrentStateColor, 'EdgeColor', 'none');
        end
        line(PlotAxes, FrameNum, Separation, 'Color', 'k', ...
            'LineWidth', 1, 'LineStyle', '-')
        PlotAxes.YColor = [0, 0, 0];
        PlotAxes.YLim = [MinYValue, MaxYDisplaySepConverted];
        yyaxis(PlotAxes, 'right');
        stairs(PlotAxes, ...
            [RectangleStartFrame; ...
            RectangleStartFrame(end) + RectangleXWidth], ...
            [StateSequence; StateSequence(end)], ...
            'Color', 'k', 'LineWidth', 2, 'LineStyle', ':')
        PlotAxes.YColor = [0, 0, 0];
        PlotAxes.YLim = [0, DisplayParams.MaxYDisplayState];
        PlotAxes.YTick = min(StateSequence):max(StateSequence);
        PlotAxes.YTickLabel = DisplayParams.StateNames;
        PlotAxes.YColor = [0, 0, 0];
    case 'EmissionProbability'
        % Generate the emission probability vs. time plot with the Viterbi
        % state sequence shown on top.
        yyaxis(PlotAxes, 'left')
        for jj = 1:NStates
            plot(PlotAxes, FrameNum, ...
                EmissionProbabilities(:, jj), ...
                'Color', DisplayParams.StateColormap(jj, :), ...
                'LineWidth', 1.5, 'LineStyle', '-');
        end
        yyaxis(PlotAxes, 'right')
        stairs(PlotAxes, [FrameNum(1); ...
            (FrameNum(1:(end-1))+FrameNum(2:end))/2; ...
            FrameNum(end)], ...
            [StateSequence; StateSequence(end)], ...
            'k:', 'LineWidth', 2)
        PlotAxes.XLim = [min(FrameNum), max(FrameNum)];
        PlotAxes.YLim = [0, DisplayParams.MaxYDisplayState];
        PlotAxes.YTick = min(StateSequence):max(StateSequence);
        PlotAxes.YTickLabel = DisplayParams.StateNames;
        PlotAxes.YColor = [0, 0, 0];
    case 'TrajectoryPlot3D'
        % Plot the two trajectories over time in 3D.
        view(PlotAxes, -45, 5) % force corner view
        axis(PlotAxes, 'tight'); % will be overridden in x, y below
        XCurrent1 = TRArray(1).X(DimerCandidateBool1) ...
            * (UnitFlag*PixelSize + ~UnitFlag);
        YCurrent1 = TRArray(1).Y(DimerCandidateBool1) ...
            * (UnitFlag*PixelSize + ~UnitFlag);
        XCurrent2 = TRArray(2).X(DimerCandidateBool2) ...
            * (UnitFlag*PixelSize + ~UnitFlag);
        YCurrent2 = TRArray(2).Y(DimerCandidateBool2) ...
            * (UnitFlag*PixelSize + ~UnitFlag);
        line(PlotAxes, XCurrent1, YCurrent1, FrameNum, ...
            'Color', [0, 0, 0], 'LineWidth', 1.5, 'LineStyle', '--');
        line(PlotAxes, XCurrent2, YCurrent2, FrameNum, ...
            'Color', [0, 0, 0], 'LineWidth', 1.5, 'LineStyle', ':');
        
        % Mark the appropriate state (if requested) in the plot.
        MarkedStateBool = (StateSequence == DisplayParams.StateToMark);
        EventChanges = [MarkedStateBool(1); diff(MarkedStateBool)];
        StartIndices = find(EventChanges == 1);
        EndIndices = find(EventChanges == -1) - 1;
        if (numel(EndIndices) ~= numel(StartIndices))
            EndIndices = [EndIndices; numel(MarkedStateBool)];
        end
        for kk = 1:numel(StartIndices)
            % Loop through all instances of the jj-th state event and
            % plot them (this is done to make the lines continuous, not
            % jumping all over when switching to another state).
            EventIndices = StartIndices(kk):EndIndices(kk);
            line(PlotAxes, ...
                XCurrent1(EventIndices), ...
                YCurrent1(EventIndices), ...
                FrameNum(EventIndices), ...
                'Color', [DisplayParams.StateColormap(1, :), 0.5], ...
                'LineWidth', 2, 'LineStyle', '-');
            line(PlotAxes, ...
                XCurrent2(EventIndices), ...
                YCurrent2(EventIndices), ...
                FrameNum(EventIndices), ...
                'Color', [DisplayParams.StateColormap(1, :), 0.5], ...
                'LineWidth', 2, 'LineStyle', '-');
        end
        
        % Modify the x, y plot limits to improve appearance.
        XRange = [min(min(XCurrent1), min(XCurrent2)), ...
            max(max(XCurrent1), max(XCurrent2))]; % x range of data
        XWidth = max(XRange(2) - XRange(1), DisplayParams.MinXYRange ...
            * (UnitFlag*PixelSize + ~UnitFlag));
        YRange = [min(min(YCurrent1), min(YCurrent2)), ...
            max(max(YCurrent1), max(YCurrent2))];
        YWidth = max(YRange(2)-YRange(1), DisplayParams.MinXYRange ...
            * (UnitFlag*PixelSize + ~UnitFlag));
        PlotAxes.XLim = mean(XRange) + [-XWidth, XWidth]/2;
        PlotAxes.YLim = mean(YRange) + [-YWidth, YWidth]/2;
    case 'TrajectoryPlot2D'
        % Plot the two trajectories in 2D
        view(PlotAxes, 2)
        axis(PlotAxes, 'equal')
        XCurrent1 = TRArray(1).X(DimerCandidateBool1) ...
            * (UnitFlag*PixelSize + ~UnitFlag);
        YCurrent1 = TRArray(1).Y(DimerCandidateBool1) ...
            * (UnitFlag*PixelSize + ~UnitFlag);
        XCurrent2 = TRArray(2).X(DimerCandidateBool2) ...
            * (UnitFlag*PixelSize + ~UnitFlag);
        YCurrent2 = TRArray(2).Y(DimerCandidateBool2) ...
            * (UnitFlag*PixelSize + ~UnitFlag);
        line(PlotAxes, XCurrent1, YCurrent1, ...
            'Color', [0, 0, 0], 'LineWidth', 1.5, 'LineStyle', '--');
        line(PlotAxes, XCurrent2, YCurrent2, ...
            'Color', [0, 0, 0], 'LineWidth', 1.5, 'LineStyle', ':');
        
        % Mark the appropriate state (if requested) in the plot.
        MarkedStateBool = (StateSequence == DisplayParams.StateToMark);
        EventChanges = [MarkedStateBool(1); diff(MarkedStateBool)];
        StartIndices = find(EventChanges == 1);
        EndIndices = find(EventChanges == -1) - 1;
        if (numel(EndIndices) ~= numel(StartIndices))
            EndIndices = [EndIndices; numel(MarkedStateBool)];
        end
        for kk = 1:numel(StartIndices)
            % Loop through all instances of the jj-th state event and
            % plot them (this is done to make the lines continuous, not
            % jumping all over when switching to another state).
            EventIndices = StartIndices(kk):EndIndices(kk);
            line(PlotAxes, ...
                XCurrent1(EventIndices), ...
                YCurrent1(EventIndices), ...
                'Color', [DisplayParams.StateColormap(1, :), 0.5], ...
                'LineWidth', 2, 'LineStyle', '-');
            line(PlotAxes, ...
                XCurrent2(EventIndices), ...
                YCurrent2(EventIndices), ...
                'Color', [DisplayParams.StateColormap(1, :), 0.5], ...
                'LineWidth', 2, 'LineStyle', '-');
        end
        
        % Modify the x, y plot limits to improve appearance.
        PlotAxes.XLim = [0, TRArray(1).XSize] ...
            * (UnitFlag*PixelSize + ~UnitFlag);
        PlotAxes.YLim = [0, TRArray(1).YSize] ...
            * (UnitFlag*PixelSize + ~UnitFlag);
    case 'RegistrationPlot'
        XRegCorrection = zeros(sum(DimerCandidateBool1), 1);
        for ii = 1:numel(TRArray)
            % Check if XRegCorrection is present and non-empty, adding it
            % if possible.  (This is a workaround for some older data in
            % which I left the field empty instead of set to zeros).
            if ~isempty(TRArray(ii).XRegCorrection)
                XRegCorrection = XRegCorrection ...
                    + cell2mat({TRArray(ii).XRegCorrection(...
                    TRArray(ii).DimerCandidateBool)});
            end
        end
        XRegCorrection = XRegCorrection * (UnitFlag*PixelSize + ~UnitFlag);
        YRegCorrection = zeros(sum(DimerCandidateBool1), 1);
        for ii = 1:numel(TRArray)
            % Check if YRegCorrection is present and non-empty, adding it
            % if possible.  (This is a workaround for some older data in
            % which I left the field empty instead of set to zeros).
            if ~isempty(TRArray(ii).YRegCorrection)
                YRegCorrection = YRegCorrection ...
                    + cell2mat({TRArray(ii).YRegCorrection(...
                    TRArray(ii).DimerCandidateBool)});
            end
        end
        YRegCorrection = YRegCorrection * (UnitFlag*PixelSize + ~UnitFlag);
        plot(PlotAxes, FrameNum, XRegCorrection, 'kx')
        plot(PlotAxes, FrameNum, YRegCorrection, 'ko')
    case 'XYSeparationPlot'
        % Plot the separations in x and y over time.
        XSeparation = cell2mat({TRArray(2).X(DimerCandidateBool2)}.') ...
            - cell2mat({TRArray(1).X(DimerCandidateBool1)}.');
        XSeparation = XSeparation * (UnitFlag*PixelSize + ~UnitFlag);
        YSeparation = cell2mat({TRArray(2).Y(DimerCandidateBool2)}.') ...
            - cell2mat({TRArray(1).Y(DimerCandidateBool1)}.');
        YSeparation = YSeparation * (UnitFlag*PixelSize + ~UnitFlag);
        plot(PlotAxes, XSeparation, YSeparation, 'k-')
        
        % Mark the appropriate state (if requested) in the plot.
        MarkedStateBool = (StateSequence == DisplayParams.StateToMark);
        EventChanges = [MarkedStateBool(1); diff(MarkedStateBool)];
        StartIndices = find(EventChanges == 1);
        EndIndices = find(EventChanges == -1) - 1;
        if (numel(EndIndices) ~= numel(StartIndices))
            EndIndices = [EndIndices; numel(MarkedStateBool)];
        end
        for kk = 1:numel(StartIndices)
            % Loop through all instances of the jj-th state event and
            % plot them (this is done to make the lines continuous, not
            % jumping all over when switching to another state).
            EventIndices = StartIndices(kk):EndIndices(kk);
            line(PlotAxes, ...
                XSeparation(EventIndices), ...
                YSeparation(EventIndices), ...
                FrameNum(EventIndices), ...
                'Color', [DisplayParams.StateColormap(1, :), 0.5], ...
                'LineWidth', 2, 'LineStyle', '-');
        end
        
        % Modify the x and y limits to improve plot appearance.
        XRange = [min(XSeparation), max(XSeparation)];
        XWidth = max(2*max(abs(XRange)), DisplayParams.MinXYRange ...
            * (UnitFlag*PixelSize + ~UnitFlag));
        YRange = [min(YSeparation), max(YSeparation)];
        YWidth = max(2*max(abs(YRange)), DisplayParams.MinXYRange ...
            * (UnitFlag*PixelSize + ~UnitFlag));
        PlotAxes.XLim = [-XWidth, XWidth] / 2;
        PlotAxes.YLim = [-YWidth, YWidth] / 2;
        plot(PlotAxes, [0, 0], PlotAxes.YLim, 'm:')
        plot(PlotAxes, PlotAxes.XLim, [0, 0], 'm:')
end


end
./MATLAB/+smi_stat/@HMM/generateTransitionMatrix.m
function [TransitionMatrix] = ...
    generateTransitionMatrix(TransitionRates, DeltaT)
%generateTransitionMatrix generates the transition matrix of a Markov model
% This method will generate a transition matrix for a Markov model given
% the input TransitionRates.

% INPUTS:
%   TransitionRates: Array containing the transition rate constants
%                    between the states of the Markov model.  The element
%                    TransitionRates(i, j) is the transition rate from
%                    state i to state j.  TransitionRates(i, i) is not
%                    used for any value of i.
%                    (NxN, N = number of states)(1 / frames)
%   DeltaT: Time step(s) between observations.
%           (1x1 or NObservations-1 x 1 array)(frames)
%
% OUTPUTS:
%   TransitionMatrix: Matrix containing the transition probabilities
%                     between the N states of the Markov model.
%                     TransitionMatrix(i, j, k) gives the probability of
%                     transition from state i to state j during DeltaT(k).
%                     Note that sum(TransitionMatrix, 2, ii) = ones(N, 1)
%                     (NStates x NStates x numel(DeltaT))

% Created by:
%   David J. Schodt (Lidke Lab, 2020)


% Force the inputs to be double precision floats (just in case).
TransitionRates = double(TransitionRates);
DeltaT = double(DeltaT);

% Ensure diagonal terms of the input TransitionRates matrix are 0.
NStates = size(TransitionRates, 1);
NObservations = numel(DeltaT);
DiagonalBool = logical(eye(NStates));
TransitionRates(DiagonalBool) = zeros(NStates, 1);

% Loop through each element in DeltaT and compute the corresponding
% transition matrix.
LeavingProbability = repmat(sum(TransitionRates, 2), ...
    [1, NStates]);
TransitionMatrix = zeros(NStates, NStates, NObservations);
for ii = 1:NObservations
    % Populate the off-diagonal terms of the transition matrix.  These
    % terms correspond to transitions to other states.
    ArrivalProbability = 1 - exp(-LeavingProbability*DeltaT(ii));
    TransitionMatrixCurrent = TransitionRates .* ArrivalProbability ...
        ./ LeavingProbability;
    
    % Populate the diagonal elements of the transition matrix.  These terms
    % correspond to remaining in the same state.
    % NOTE: The diagonal elements are computed to satisfy
    %       sum(TransitionMatrix, 2) = ones(NStates, 1)
    TransitionMatrixCurrent(DiagonalBool) = ...
        1 - sum(TransitionMatrixCurrent, 2);
    
    % Add the current TransitionMatrix to the full TransitionMatrix array.
    TransitionMatrix(:, :, ii) = TransitionMatrixCurrent;
end


end
./MATLAB/+smi_stat/@HMM/computeLogLikelihood.m
function [LogLikelihood] = ...
    computeLogLikelihood(TransitionMatrixSeries, EmissionProbabilitySeries)
%computeLogLikelihood computes the LogLikelihood of a sequence in the HMM.
% This method will compute the log likelihood of observing a pair of
% trajectories given a specified Hidden Markov Model (HMM).

% INPUTS:
%   TransitionMatrixSeries: An array containing transition matrices for
%                           each observation in the sequence. 
%                           (NStates x NStates x NObservations-1 double)
%   EmissionProbabilitySeries: An array containing the emission
%                              probabilities for each state at each
%                              observation. 
%                              (NStates x NObservations double)
%
% OUTPUTS:
%   LogLikelihood: The natural logarithm of the likelikhood of observing
%                  the input data given the specified HMM.

% Created by:
%   David J. Schodt (Lidke Lab, 2020)


% Loop through the observations and compute the log-likelihood.
NObservations = size(EmissionProbabilitySeries, 1);
LikelihoodArray = EmissionProbabilitySeries(1, :);
LikelihoodScaling = zeros(NObservations, 1);
LikelihoodScaling(1) = sum(LikelihoodArray);
for ii = 2:NObservations
    % Update the likelihood matrix.
    % NOTE: You might see the emission probabilities forced into a diagonal
    %       matrix in some literature, but we don't need to do that.  It's
    %       in an array form as EmissionProbabilitySeries(ii, :) so I just
    %       use element-wise multiplication to get the same effect with
    %       fewer computations needed.
    LikelihoodArray = LikelihoodArray ...
        * TransitionMatrixSeries(:, :, ii-1) ...
        .* EmissionProbabilitySeries(ii, :);
    LikelihoodScaling(ii) = sum(LikelihoodArray);
    LikelihoodArray = LikelihoodArray ./ LikelihoodScaling(ii);
end
LogLikelihood = sum(log(LikelihoodScaling));


end
./MATLAB/+smi_stat/@HMM/isolateCandidateTRArray.m
function [TRArrayTrunc] = isolateCandidateTRArray(TRArray)
%isolateCandidateTRArray isolates dimer candidate pairs in TRArray.
% This method will loop through each trajectory in TRArray and isolate the
% portions of the trajectory considered candidates for dimer events.
% Specifically, the input TRArray should have a field DimerCandidateBool,
% and this method will simply loop through all fields and apply the
% DimerCandidateBool mask to the data.
%
% INPUTS:
%   TRArray: A structure array of TR structures, where the constituent TR
%            structures correspond to dimer candidate trajectories.  The 
%            first index corresponds to the "channel" of the trajectory and 
%            the second index corresponds to the pair number.  For example,
%            TRArray(j, 1) will contain information about a trajectory from 
%            TR1 that was observed within MaxDimerDistance of
%            TRArray(j, 2), a trajectory in TR2.
%
% OUTPUTS:
%   TRArrayTrunc: The input structure TRArray with all fields truncated to
%                 only show the portions of the trajectories that were
%                 marked as dimer candidates.

% Created by:
%   David J. Schodt (Lidke Lab, 2020)


% Generate a list of fieldnames in the TRArray.
TRArrayFields = fieldnames(TRArray);

% Loop through all fields and apply the DimerCandidateBool mask where
% relevant.
TRArrayTrunc = TRArray;
for ii = 1:size(TRArray, 1)
    DimerCandidateBool1 = logical(TRArray(ii, 1).DimerCandidateBool);
    DimerCandidateBool2 = logical(TRArray(ii, 2).DimerCandidateBool);
    for jj = 1:numel(TRArrayFields)
        % Determine how many datapoints exist in each of the two
        % trajectories in this pairing.
        NDataPoints1 = numel(TRArray(ii, 1).FrameNum);
        NDataPoints2 = numel(TRArray(ii, 2).FrameNum);
        
        % Apply the DimerCandidateBool mask to relevant fields.
        if (numel(TRArray(ii, 1).(TRArrayFields{jj})) == NDataPoints1)
            TRArrayTrunc(ii, 1).(TRArrayFields{jj}) = ...
                TRArray(ii, 1).(TRArrayFields{jj})(DimerCandidateBool1);
        end
        if (numel(TRArray(ii, 2).(TRArrayFields{jj})) == NDataPoints2)
            TRArrayTrunc(ii, 2).(TRArrayFields{jj}) = ...
                TRArray(ii, 2).(TRArrayFields{jj})(DimerCandidateBool2);
        end
    end
end


end
./MATLAB/+smi_stat/@HMM/generateEmissionMatrix.m
function [EmissionMatrix] = ...
    generateEmissionMatrix(PDFHandles, DataCell)
%generateEmissionMatrix computes emission matrix for an observed separation
% This method will compute the emission probability densities of observing
% a separation given a state model (e.g. Dimer, Domain, Free, ...), where
% all model parameters and required data are contained in the DataCell cell
% array.
%
% INPUTS:
%   DataCell: A cell array containing all data/parameters need to compute
%             the emission probabilities for each state.
%             DataCell{1}: Separation in current frame (pixels)
%             DataCell{2}: Standard error in current frame (pixels)
%             DataCell{3}: Frames elapsed since previous observation
%             DataCell{4}: Sigma overlay, i.e., registration error (pixels)
%             DataCell{5}: Dimer separation (pixels)
%             DataCell{6}: Diffusion coefficient for each trajectory.
%                          (pixel^2 / frame)
%             DataCell{7}: Maximum separation between two trajectories
%                          (used in computing initial probability density
%                          of free state)(pixels)
%             DataCell{8:end}: Additional parameters/data, case dependent,
%                              e.g., DataCell{8} is sigma domain for the
%                              dimer, domain, free model
%   PDFHandles: A cell array of function handles, with each handle defining
%               the probability density of the observed separation for a
%               given model state.
%
% OUTPUTS:
%   EmissionMatrix: The probability densities of observing the input
%                   Seperation given a state model specified by the inputs.
%                   This is column vector, with row ii corresponding to the
%                   probability density of observing the input Separation
%                   given that the underlying state is state ii.
%                   (N x numel(PDFHandles) double)

% Created by:
%   David J. Schodt (Lidke Lab, 2020)


% Compute the emission probability densities based on the specified state
% model, storing each of the densities as elements in a column vector in
% EmissionMatrix.
NObservations = numel(DataCell{1});
NStates = numel(PDFHandles);
EmissionMatrix = zeros(NObservations, NStates, 'double');
for ii = 1:NStates
    EmissionMatrix(:, ii) = PDFHandles{ii}(DataCell);
end
EmissionMatrix(:, 1) = PDFHandles{1}(DataCell);


end
./MATLAB/+smi_stat/@HMM/plotSepDistribs.m
function [PlotFigure, DisplayParams] = plotSepDistribs(PlotFigure, ...
    TRArray, PDFHandles, PDFInputs, DisplayParams)
%plotSepDistribs makes histograms of the distributions of separations.
% This function makes histograms of the separation distributions for each
% state of the HMM.  This should be run after the Viterbi sequences have
% been stored in TRArray.  A model of the expected separation distributions
% is overlain on the observed histograms.
%
% WARNING: For now, this is somewhat of a "skeleton" in that I'm only
%          plotting the distribution for the dimer state.  DJS 22/1/20
%
% INPUTS:
%   PlotFigure: Figure in which we'll make the plots.
%   TRArray: Array of tracking results pairs that have there state sequence
%            field population.
%   PDFHandles: Array of handles to the state emission PDFs (see
%               smi_stat.HMM.generateEmissionPDFs())
%   PDFInputs: Cell array of inputs needed for PDFHandles. Indices should
%              match the ordering defined in
%              smi_stat.HMM.generateEmissionPDFs().  Note that some of
%              these will be populated internally based on values in
%              TRArray.
%   DisplayParams: A structure of display parameters for the plots.
%
% OUTPUTS:
%   PlotFigure: Figure containing the plots.
%   DisplayParams: A structure of display parameters for the plots.

% Created by:
%   David J. Schodt (Lidke Lab, 2022)


% Isolate the separations for each state.
% NStates = numel(PDFHandles);
NStates = 1; % only focus on dimer state, see WARNING above
NPairs = size(TRArray, 1);
Separation = cell(NStates, 1);
for nn = 1:NStates
    for ii = 1:NPairs
        Separation{nn} = [Separation{nn};
            TRArray(ii, 1).Separation(TRArray(ii, 1).StateSequence == nn)];
    end
end

% Define the model for the expected distribution of separations.
Model = cell(NStates, 1);
for nn = 1:NStates
    % Loop over each trajectory pair and add it's contribution to the model
    % distribution.
    SepModel = linspace(min(Separation{nn}), max(Separation{nn}), ...
        numel(Separation{nn})).';
    PDFInputs{1} = SepModel;
    Model{nn} = zeros(size(SepModel));
    for ii = 1:NPairs
        % Isolate some needed arrays from TRArray.
        % NOTE: We typically want TRArray(ii, 2).RegError because channel 1
        %       is used as the reference channel.
        KeepBool1 = (TRArray(ii, 1).StateSequence == nn);
        KeepBool2 = (TRArray(ii, 2).StateSequence == nn);
        AverageSE = [TRArray(ii, 1).AverageSE(KeepBool1), ...
            TRArray(ii, 2).AverageSE(TRArray(ii, 2).StateSequence == nn)];
%         DeltaT = double(diff(sort(TRArray(ii, 1).FrameNum(KeepBool1))));
        RegError = TRArray(ii, 2).RegError(KeepBool2);
%         D = [TRArray(ii, 1).DiffusionCoefficient(KeepBool1), ...
%             TRArray(ii, 2).DiffusionCoefficient(KeepBool2)];

        % Loop over each observation and add its contribution.
        for jj = 1:numel(RegError)
            PDFInputs{2} = AverageSE(jj, :);
%             PDFInputs{3} = DeltaT(jj); % not used, see WARNING above
            PDFInputs{4} = RegError(jj);
%             PDFInputs{6} = D(jj, :); % not used, see WARNING above
            Model{nn} = Model{nn} ...
                + PDFHandles{nn}(PDFInputs)/numel(RegError);
        end
    end
    Model{nn} = Model{nn} / NPairs;

    % Plot the model over a histogram of the observations.
    PlotAxes = subplot(NStates, 1, nn, 'Parent', PlotFigure);
    histogram(PlotAxes, Separation{nn}, 'Normalization', 'pdf')
    hold(PlotAxes, 'on')
    plot(PlotAxes, SepModel, Model{nn})
    xlabel(PlotAxes, 'Separation (pixels)')
    ylabel(PlotAxes, 'PDF(Separation)')
    legend(PlotAxes, {'Observed', 'Model'}, 'Location', 'best')
    title(PlotAxes, DisplayParams.TitleString)
end


end
./MATLAB/+smi_stat/findCoordAffine.m
function [AffineTransform] = findCoordAffine(Coords1, Coords2, MaxDist)
%findCoordAffine finds an affine transform to transform Coords2 to Coords1.
% This method will compute an affine transform which can transform Coords2
% coordinates into alignment with Coords1 coordinates. The cost function for
% the affine transform computation is given as the sum of the thresholded
% nearest-neighbor distances, thresholded to MaxDist.
%
% INPUTS:
%   Coords1: [X, Y] coordinates. (Nx2 numeric array)
%   Coords2: [X, Y] coordinates that are to be aligned to Coords1 via the 
%            output AffineTransform. (Nx2 numeric array)
%   MaxDist: Nearest-neighbor distance threshold between Coords1 and 
%            Coords2 localizations. (Default = 1 pixel)
%
% OUTPUTS:
%   AffineTransform: An affine transform that can be used to transform
%                    Coords1 coordinates into alignment with Coords2
%                    localizations.

% Created by:
%   David J. Schodt (Lidke Lab, 2021)


% Set defaults if needed.
if (~exist('MaxDist', 'var') || isempty(MaxDist))
    MaxDist = 1;
end

% Convert input coordinates to type double.
Coords1 = double(Coords1);
Coords2 = double(Coords2);

% Determine the center of mass shift between the coordinates (will be used
% as an initial guess for the affine transform).
COMShift = mean(Coords1, 1) - mean(Coords2, 1);
XInitial = [1, 0, 0, 1, COMShift];

% Perform an unconstrained fit to estimate the affine transform values.
CostFunction = @(X) nndSum(Coords1, Coords2, affine2d(...
    [X(1), X(2), 0; ...
    X(3), X(4), 0; ...
    X(5), X(6), 1]));
XHat = fminsearch(CostFunction, XInitial);
AffineTransform = affine2d(...
    [XHat(1), XHat(2), 0; ...
    XHat(3), XHat(4), 0; ...
    XHat(5), XHat(6), 1]);


    function Cost = nndSum(Coords1, Coords2, AffineTransform)
        % Transform Coords2 with the affine transform.
        Coords2Transformed = ...
            smi_core.ChannelRegistration.transformCoords(...
            AffineTransform, Coords2);
        
        % Compute the nearest-neighbor distances between Coords1 and the
        % transformed Coords2.
        [~, NNDistances] = knnsearch(Coords2Transformed, Coords1);
        
        % Compute the thresholded sum of the nearest-neighbor distances.
        NNDistances(NNDistances > MaxDist) = MaxDist;
        Cost = sum(NNDistances);
    end


end
./MATLAB/ExpectedResults/unitTest/HMM/README.md
Removed due to size: (example_data/spt/2023_05_12_12_08_08)

- 1.5M : Data\_002\_2023\_05\_12\_12\_08\_13.mat
- 2.0M : Data\_003\_2023\_05\_12\_12\_08\_15.mat
- 1.8M : Data\_004\_2023\_05\_12\_12\_08\_18.mat
- 1.5M : Data\_005\_2023\_05\_12\_12\_08\_20.mat
- 1.6M : Data\_006\_2023\_05\_12\_12\_08\_23.mat
- 1.7M : Data\_007\_2023\_05\_12\_12\_08\_25.mat
- 1.9M : Data\_008\_2023\_05\_12\_12\_08\_28.mat
- 1.2M : Data\_009\_2023\_05\_12\_12\_08\_30.mat

Also (example_data/spt/2023_05_12_12_08_08/Results)

- 1.6M : Data\_002\_2023\_05\_12\_12\_08\_13\_Channel1\_Results.mat
- 1.6M : Data\_002\_2023\_05\_12\_12\_08\_13\_Channel2\_Results.mat
- 2.3M : Data\_003\_2023\_05\_12\_12\_08\_15\_Channel1\_Results.mat
- 2.6M : Data\_003\_2023\_05\_12\_12\_08\_15\_Channel2\_Results.mat
- 2.7M : Data\_004\_2023\_05\_12\_12\_08\_18\_Channel1\_Results.mat
- 3.5M : Data\_004\_2023\_05\_12\_12\_08\_18\_Channel2\_Results.mat
- 4.2M : Data\_005\_2023\_05\_12\_12\_08\_20\_Channel1\_Results.mat
- 5.3M : Data\_005\_2023\_05\_12\_12\_08\_20\_Channel2\_Results.mat
- 9.0M : Data\_006\_2023\_05\_12\_12\_08\_23\_Channel1\_Results.mat
- 9.6M : Data\_006\_2023\_05\_12\_12\_08\_23\_Channel2\_Results.mat
- 24M  : Data\_007\_2023\_05\_12\_12\_08\_25\_Channel1\_Results.mat
- 27M  : Data\_007\_2023\_05\_12\_12\_08\_25\_Channel2\_Results.mat
- 46M  : Data\_008\_2023\_05\_12\_12\_08\_28\_Channel1\_Results.mat
- 75M  : Data\_008\_2023\_05\_12\_12\_08\_28\_Channel2\_Results.mat
- 134M : Data\_009\_2023\_05\_12\_12\_08\_30\_Channel1\_Results.mat
- 148M : Data\_009\_2023\_05\_12\_12\_08\_30\_Channel2\_Results.mat
- 401M : Data\_010\_2023\_05\_12\_12\_08\_33\_Channel1\_Results.mat
- 294M : Data\_010\_2023\_05\_12\_12\_08\_33\_Channel2\_Results.mat

Also (example_data/spt/2023_05_12_12_08_08/Results/HMM_Results)

- 30M  : HMMCondition1.mat

Also (example_data/spt/2023_05_12_12_08_08/Results/HMM_Results/Condition1/Dimers)

- 164K : DimerPair2.fig
- 144K : DimerPair3.fig
- 140K : DimerPair4.fig
- 152K : DimerPair5.fig
- 140K : DimerPair6.fig
- 136K : DimerPair7.fig
- 136K : DimerPair8.fig
- 136K : DimerPair9.fig
- 148K : DimerPair10.fig
- 140K : DimerPair11.fig
- 144K : DimerPair12.fig
- 144K : DimerPair13.fig
- 140K : DimerPair14.fig
- 140K : DimerPair15.fig
- 140K : DimerPair16.fig
- 140K : DimerPair17.fig
- 140K : DimerPair18.fig
- 160K : DimerPair19.fig
- 156K : DimerPair20.fig
- 140K : DimerPair21.fig
- 144K : DimerPair22.fig
- 144K : DimerPair23.fig
- 140K : DimerPair24.fig
- 160K : DimerPair25.fig
- 140K : DimerPair26.fig
- 136K : DimerPair27.fig
- 148K : DimerPair28.fig
- 140K : DimerPair29.fig
- 156K : DimerPair30.fig
- 164K : DimerPair31.fig
- 140K : DimerPair32.fig
- 160K : DimerPair33.fig

Also (example_data/spt/2023_05_12_12_08_08/Results/HMM_Results/Condition1/Other)

- 17M  : TRArrayNotDimer.mat

./MATLAB/ExpectedResults/unitTest/SMLM/README.md
SMLM_testData.h5 removed as it consumed ~1 Gb (1048579048 bytes).

./MATLAB/ExpectedResults/README.md
### Expected Results of [run_tests.m](../run_tests.m)

Note that some outputs have been removed due to size considerations as
noted in the following READMEs:
- [HMM](unitTest/HMM/README.md)
- [SMLM](unitTest/SMLM/README.md)

These tests were performed on a Linux system running Ubuntu 20.04 using
x86_64 processors running MATLAB R2021a.

The tests are frequently stochastic in nature, so outputs from run to
run will not necessarily be identical, even on the same system, but
the `ExpectedResults` will provide a flavor of what to expect.

./MATLAB/+smi_vis/contrastStretch.m
function [Image] = contrastStretch(Image, MinMax, ...
    PercentileCeiling, PercentileFloor, MinScaleIntensity)
%contrastStretch scales images to the range MinMax.
% This method performs a full scale histogram stretch of 'Image' such that
% the stretched pixel values lie in the range [MinMax(1), MinMax(2)].
%
% INPUTS:
%   Image: Array of pixel values that will be stretched. (float array)
%   MinMax: Array containing the minimum and maximum pixel value after
%           scaling. (Default = [0, 1])
%   MinScaleIntensity: Minimum scaling intensity (useful for noisy data,
%                      so that the scaling doesn't just brighten the noise)
%                      (Default = 1)
%   PercentileCeiling: Percentile ceiling of pixel values in the raw data
%                      above which values are clipped. (Default = 100)
%   PercentileFloor: Percentile floor of pixel values in the raw data below
%                    which values are clipped. (Default = 0)
%
% OUTPUTS:
%   Image: Input array 'Image' scaled to the range 'MinMax'.

% Created by:
%   David J. Schodt (Lidke Lab, 2021)


% Set defaults and check some inputs.
if (~exist('MinMax', 'var') || isempty(MinMax))
    MinMax = [0; 1];
end
MinMax = sort(MinMax);
if (~exist('MinScaleIntensity', 'var') || isempty(MinScaleIntensity))
    MinScaleIntensity = 1;
end
if (~exist('PercentileCeiling', 'var') || isempty(PercentileCeiling))
    PercentileCeiling = 100;
end
if (~exist('PercentileFloor', 'var') || isempty(PercentileFloor))
    PercentileFloor = 0;
end

% If the image is identically zero or scalar, return.
if ~any(Image(:))
    Image = Image + MinMax(1);
    return
elseif isscalar(Image)
    return
end

% Scale the 'Image' array.
if (PercentileCeiling ~= 100)
    MaxIntensity = ...
        max(prctile(Image(:), PercentileCeiling), MinScaleIntensity);
    Image(Image > MaxIntensity) = MaxIntensity;
end
if (PercentileFloor ~= 0)
    MinIntensity = prctile(Image(:), PercentileFloor);
    Image(Image < MinIntensity) = MinIntensity;
end
Image = (Image-min(Image(:))) ...
    * (MinMax(2)-MinMax(1))/(max(Image(:))-min(Image(:))) ...
    + MinMax(1);


end
./MATLAB/+smi_vis/@InspectResults/gui.m
function gui(obj)
%gui prepares an SR inspection GUI for the InspectResults class.

% Created by:
%   David J. Schodt (Lidke lab, 2021)


% Create a figure handle for the GUI.
if (isempty(obj.GUIFigure) || ~isvalid(obj.GUIFigure))
    DefaultFigurePosition = get(0, 'defaultFigurePosition');
    obj.GUIFigure = figure('MenuBar', 'none', 'NumberTitle', 'off', ...
        'Name', 'Inspect Results', 'Tag', 'MovieGUI', ...
        'Units', 'pixels', ...
        'Position', [DefaultFigurePosition(1:2), 1000, 500]);
end

% Prepare a panel for data controls.
ControlPanelPos = [0, 0, 0.25, 1];
ControlPanel = uipanel(obj.GUIFigure, ...
    'Title', 'Control Panel', ...
    'FontWeight', 'bold', 'Units', 'normalized', ...
    'Position', ControlPanelPos);
ButtonSize = [0, 0, 0.5, 0.1];
LoadImagePos = [0, ControlPanelPos(4)-ButtonSize(4), ButtonSize(3:4)];
uicontrol('Parent', ControlPanel, ...
    'Style', 'pushbutton', 'String', 'Load Image', ...
    'Units', 'normalized', 'Position', LoadImagePos, ...
    'Callback', @loadImage);
LoadSMDPos = LoadImagePos + [ButtonSize(3), 0, 0, 0];
uicontrol('Parent', ControlPanel, ...
    'Style', 'pushbutton', 'String', 'Load SMD', ...
    'Units', 'normalized', 'Position', LoadSMDPos, ...
    'Callback', @loadSMD);
ExportButtonPos = LoadSMDPos + [0, -ButtonSize(4), 0, 0];
uicontrol('Parent', ControlPanel, ...
    'Style', 'pushbutton', 'String', 'Export SMD', ...
    'Units', 'normalized', 'Position', ExportButtonPos, ...
    'Callback', @exportSMD);
RefreshGUIPos = ButtonSize + [0, 0, 0, 0];
uicontrol('Parent', ControlPanel, ...
    'Style', 'pushbutton', 'String', 'Refresh GUI', ...
    'Units', 'normalized', 'Position', RefreshGUIPos, ...
    'Callback', @refreshGUI);

% Prepare axes for the image.
ImagePanelPos = [sum(ControlPanelPos([1, 3])), 0, 0.5, 1];
ImagePanel = uipanel(obj.GUIFigure, ...
    'Units', 'normalized', 'Position', ImagePanelPos);
obj.ImageAxes = axes(ImagePanel);
obj.ImageAxes.PositionConstraint = 'innerposition';
makeToolbar(obj.ImageAxes)

% Add a panel to contain information about selected ROI.
InfoPanelPos = [sum(ImagePanelPos([1, 3])), 0, 1-ImagePanelPos(3), 1];
InfoPanel = uipanel(obj.GUIFigure, ...
    'Title', 'ROI Information', ...
    'FontWeight', 'bold', 'Units', 'normalized', ...
    'Position', InfoPanelPos);
TextBoxSize = [0, 0, 1, 0.05];
ROITextPos = [0, InfoPanelPos(4)-TextBoxSize(4), TextBoxSize(3:4)];
ROIText = uicontrol('Parent', InfoPanel, 'Style', 'text', ...
    'String', 'ROI: []', ...
    'Units', 'normalized', ...
    'Position', ROITextPos, ...
    'HorizontalAlignment', 'left');
ROIDescriptionPos = ROITextPos + [0, -TextBoxSize(4), 0, 0];
uicontrol('Parent', InfoPanel, 'Style', 'text', ...
    'String', '        [YStart, XStart, YEnd, XEnd]', ...
    'Units', 'normalized', ...
    'Position', ROIDescriptionPos, ...
    'HorizontalAlignment', 'left');
NLocTextPos = ROIDescriptionPos + [0, -TextBoxSize(4), 0, 0];
NLocText = uicontrol('Parent', InfoPanel, 'Style', 'text', ...
    'String', '0 localizations selected', ...
    'Units', 'normalized', ...
    'Position', NLocTextPos, ...
    'HorizontalAlignment', 'left');
DatasetTextPos = NLocTextPos + [0, -TextBoxSize(4), 0, 0];
DatasetRangeText = uicontrol('Parent', InfoPanel, 'Style', 'text', ...
    'String', 'Dataset range:', ...
    'Units', 'normalized', ...
    'Position', DatasetTextPos, ...
    'HorizontalAlignment', 'left');
FrameTextPos = DatasetTextPos + [0, -TextBoxSize(4), 0, 0];
FrameRangeText = uicontrol('Parent', InfoPanel, 'Style', 'text', ...
    'String', 'Frame range:', ...
    'Units', 'normalized', ...
    'Position', FrameTextPos, ...
    'HorizontalAlignment', 'left');
DensityTextPos = FrameTextPos + [0, -TextBoxSize(4), 0, 0];
DensityText = uicontrol('Parent', InfoPanel, 'Style', 'text', ...
    'String', 'Density:', ...
    'Tooltip', 'Units of SMD pixels, not SR pixels!', ...
    'Units', 'normalized', ...
    'Position', DensityTextPos, ...
    'HorizontalAlignment', 'left');
PlotButtonPos = ButtonSize + [0, DensityTextPos(2)-ButtonSize(4), 0, 0];
uicontrol('Parent', InfoPanel, 'Style', 'pushbutton', ...
    'String', 'Display Plots', ...
    'Units', 'normalized', 'Position', PlotButtonPos, ...
    'Callback', @displayPlots);


    function updateROIInfo()
        %updateROIInfo updates the GUI to reflect changes to the ROI.
        ROIString = sprintf('%.1f, ', obj.ROI);
        ROIText.String = sprintf('ROI: [%s]', ROIString(1:(end-2)));
        if (isempty(obj.SMDIsolated) || isempty(obj.ROI))
            return
        end
        NLoc = numel(obj.SMDIsolated.FrameNum);
        NLocText.String = sprintf('%i localizations selected', NLoc);
        DatasetRangeText.String = sprintf('Dataset range: %i-%i', ...
            min(obj.SMDIsolated.DatasetNum), max(obj.SMDIsolated.DatasetNum));
        FrameRangeText.String = sprintf('Frame range: %i-%i', ...
            min(obj.SMDIsolated.FrameNum), max(obj.SMDIsolated.FrameNum));
        DensityText.String = ...
            sprintf('Density: %.4f localizations/pixel^2', ...
            NLoc / prod(obj.ROI(3:4)-obj.ROI(1:2)));
        updateAxes(obj.ImageAxes)
    end

    function displayPlots(~, ~)
        % This is a callback function to respond to clicks of the Display
        % Plots button.  Clicking that button will open a small GUI with a
        % dropdown menu to allow for display of various plots related to
        % the currently selected localizations.
        
        % Create the figure for the small GUI.
        DisplayGUI = figure('NumberTitle', 'off', 'Resize', 'off', ...
            'Units', 'pixels', 'MenuBar', 'none', ...
            'ToolBar', 'none', 'Position', [500, 500, 200, 150]);
        
        % Add text to the GUI to guide user control.
        uicontrol('Parent', DisplayGUI, 'Style', 'text', ...
            'String', 'Select Plot:', 'Position', [70, 125, 60, 15]);
        
        % Add a drop-down menu to the GUI figure.
        DropdownMenu = uicontrol('Parent', DisplayGUI, ...
            'Style', 'popupmenu', 'String', obj.DispPlotsOptions, ...
            'Position', [50, 95, 100, 25]);
        
        % Add a display button to the GUI figure.
        uicontrol('Parent', DisplayGUI, 'Style', 'pushbutton', ...
            'String', 'Display Plot', 'Position', [65, 45, 70, 25], ...
            'Callback', {@displayPlotPushed, DropdownMenu});
    end

    function displayPlotPushed(~, ~, DropdownMenu)
        % This is a callback for the Display Plot button within the display
        % plot GUI, which will plot the information about selected
        % localizations.
        
        % Create a new figure and plot the trajectory information as
        % selected by the drop down menu in the display plot GUI.
        DisplayPlotsFigure = findobj('Tag', 'DisplayPlotsFigure');
        if isempty(DisplayPlotsFigure)
            DisplayPlotsFigure = figure('Tag', 'DisplayPlotsFigure');
        end
        figure(DisplayPlotsFigure)
        PlotAxes = axes(DisplayPlotsFigure);
        hold(PlotAxes, 'on');
        
        % Plot the requested field from the SMD, plotting each ConnectID as
        % a different color (this might be nice for, e.g., pre-frame
        % connected data).
        DropdownString = DropdownMenu.String;
        DropdownValue = DropdownMenu.Value;
        DesiredPlotString = DropdownString{DropdownValue};
        DesiredField = obj.SMDIsolated.(DesiredPlotString);
        FrameNum = obj.SMDIsolated.FrameNum;
        DatasetNum = obj.SMDIsolated.DatasetNum;
        assert(numel(FrameNum) == numel(DesiredField), ...
            ['The selected field is not the same length as ', ...
            'SMD.FrameNum and cannot be plotted'])
        UniqueIDs = unique(obj.SMDIsolated.ConnectID);
        IDColors = lines(numel(UniqueIDs));
        for ii = 1:numel(UniqueIDs)
            CurrentBool = (obj.SMDIsolated.ConnectID == UniqueIDs(ii));
            plot(PlotAxes, FrameNum(CurrentBool) ...
                + (DatasetNum(CurrentBool)-1)*obj.SMDIsolated.NFrames, ...
                DesiredField(CurrentBool), 'x', 'Color', IDColors(ii, :))
        end
        xlabel(PlotAxes, 'Frame + (Dataset-1)*NFrames')
        ylabel(PlotAxes, DesiredPlotString)
    end

    function refreshGUI(~, ~)
        % Update the GUI to display obj.SRImage as well as any other useful
        % updates.
        cla(obj.ImageAxes)
        ImSize = size(obj.SRImage);
        imshow(obj.SRImage, [0, 1], 'Parent', obj.ImageAxes, ...
            'XData', [0.5, ImSize(2)-0.5], 'YData', [0.5, ImSize(1)-0.5])
        updateAxes(obj.ImageAxes)
        updateROIInfo()
    end

    function loadImage(Source, ~)
        %loadImage loads an SR image.

        % Load and display an image.
        try
            % Ask the user to select an image.
            Source.Enable = 'off';
            [File, Path] = uigetfile({'*.png'; '*.jpeg'}, ...
                'Select an SR reconstruction image');

            % Load the image into obj.SRImage and rescale.
            if ~isequal(File, 0)
                obj.SRImage = double(imread(fullfile(Path, File)));
                obj.SRImage = smi_vis.contrastStretch(obj.SRImage, [0, 1]);
            else
                Source.Enable = 'on';
                return
            end

            % Update the GUI.
            refreshGUI()
            Source.Enable = 'on';
        catch MException
            Source.Enable = 'on';
            rethrow(MException)
        end
    end

    function loadSMD(Source, ~)
        %loadSMD loads an SMD from a .mat file.

        % Load the SMD.
        try
            % Ask the user to select an results file.
            Source.Enable = 'off';
            [File, Path] = uigetfile('*.mat', 'Select a Results file');

            % Load the data into obj.SMD.
            if ~isequal(File, 0)
                load(fullfile(Path, File), 'SMD', 'SMF')
                obj.SMD = SMD;
                if exist('SMF', 'var')
                    % Added for back compatability with older results.
                    obj.SMF = SMF;
                end
            else
                Source.Enable = 'on';
                return
            end
        catch MException
            Source.Enable = 'on';
            rethrow(MException)
        end
        Source.Enable = 'on';
    end

    function exportSMD(~, ~)
        %exportSMD allows the user to export obj.SMDIsolated to a .mat file
        [File, Path] = uiputfile('*.mat', 'Save current ROI to a file.');
        if ~isequal(File, 0)
            SMD = obj.SMDIsolated;
            SMF = obj.SMF;
            save(fullfile(Path, File), 'SMD', 'SMF')
        end
    end

    function getROI(~, ~)
        %getROI allows selection of a rectangular ROI in the image axes.

        % Use the drawrectangle() prompt to allow user selection of the
        % ROI.
        delete(obj.ROIHandle)
        ImSize = size(obj.SRImage);
        obj.ROIHandle = drawrectangle(obj.ImageAxes, 'DrawingArea', ...
            [0, 0, ImSize(2), ImSize(1)]);

        % Define the ROI in terms of the data size (if obj.SMD is present)
        % or the image size.
        ROI = [obj.ROIHandle.Position([2, 1]), ...
            obj.ROIHandle.Position([2, 1])+obj.ROIHandle.Position([4, 3])];
        if isempty(obj.SMD)
            % In this case, only the image was provided, so we'll define
            % the ROI in image coordinates.
            obj.ROI = ROI;
        else
            ROI = ROI ./ [ImSize(1), ImSize(2), ImSize(1), ImSize(2)];
            obj.ROI = ROI .* [obj.SMD.YSize, obj.SMD.XSize, ...
                obj.SMD.YSize, obj.SMD.XSize];
        end

        % Update the ROI information panel.
        updateROIInfo()
    end

    function makeToolbar(ImageAxes)
        %makeToolbar makes a custom toolbar for the given axes.

        % Prepare a default toolbar.
        Toolbar = axtoolbar(ImageAxes, 'default');
        
        % Add a custom localization selection button.
        Icon = ones(23, 23);
        Icon(11:13, :) = 0;
        Icon(:, 11:13) = 0;
        Icon = repmat(Icon, [1, 1, 3]);
        axtoolbarbtn(Toolbar, 'push', 'Icon', Icon, ...
            'Tooltip', 'Select ROI', 'ButtonPushedFcn', @getROI);
    end

    function updateAxes(ImageAxes)
        %updateAxes updates the axes in which the SR image is displayed.

        % Ensure the toolbar is present/update it.
        makeToolbar(ImageAxes)

        % Update the axes tick labels based on obj.SMD, and if that's not
        % present, based on the size of the SR image.
        xtickformat(obj.ImageAxes, '%g')
        ytickformat(obj.ImageAxes, '%g')
        ImSize = size(obj.SRImage);
        NTicksX = numel(obj.ImageAxes.XTick);
        NTicksY = numel(obj.ImageAxes.YTick);
        obj.ImageAxes.XTick = linspace(0, ImSize(2), NTicksX);
        obj.ImageAxes.YTick = linspace(0, ImSize(1), NTicksY);
        if ~(isempty(obj.SMD) ...
                || isempty(obj.SMD.XSize) || isempty(obj.SMD.YSize))
            % In this case, we want the axes to reflect the coordinates of
            % SMD.
            XTicks = linspace(0, obj.SMD.XSize+0.5, NTicksX).';
            obj.ImageAxes.XTickLabel = num2str(XTicks, '%g');
            YTicks = linspace(0, obj.SMD.YSize+0.5, NTicksY).';
            obj.ImageAxes.YTickLabel = num2str(YTicks, '%g');
        else
            % If no SMD is present, we'll just use the image coordinates.
            obj.ImageAxes.XTickLabel = num2str(obj.ImageAxes.XTick.', '%g');
            obj.ImageAxes.YTickLabel = num2str(obj.ImageAxes.YTick.', '%g');
        end
    end


end
./MATLAB/+smi_vis/@InspectResults/InspectResults.m
classdef InspectResults < handle
    %InspectResults contains methods useful for inspecting SR data.
    % This class provides an interface for inspecting super-resolution
    % results.  The primary intention is that this class can be used to
    % associate localizations from a reconstruction image (e.g., a Gaussian
    % SR image) and the entries of a Single Molecule Data structure
    % (see smi_core.SingleMoleculeData).
    %
    % The suggested usage of this class is through the GUI, which will be
    % opened by default when creating an instance of this class:
    %   Inspect = smi_vis.InspectResults();
    % From the GUI, you should load a super-resolution image reconstruction
    % (saved as, e.g., a .png) as well as a *_Results.mat file containing
    % the SMD structure (see usage of smi.SMLM, which generates a 
    % *_Results.mat file).  Once the image is loaded, it'll be displayed in
    % the GUI figure.  Hovering over the GUI figure will reveal a toolbar
    % with a '+' icon which can be used to highlight a ROI and display
    % info. about localizations from the ROI.
    %
    % REQUIRES:
    %   Image Processing Toolbox
    %   Statistics and Machine Learning Toolbox

    % Created by:
    %   David J. Schodt (Lidke lab, 2021)
    
    properties
        % Single Molecule Data structure. (see smi_core.SingleMoleculeData)
        SMD

        % Super-resolution reconstruction image. (YxXx3 float)
        SRImage

        % Figure containing the interactive GUI.
        GUIFigure

        % Axes containing the SR image.
        ImageAxes

        % ROI in SMD coordinates. ([YStart, XStart, YEnd, XEnd])
        ROI
    end

    properties (Dependent)
        % Isolated SMD within the ROI defined by ROIHandle.
        SMDIsolated
    end


    properties (Hidden, SetAccess = 'protected')
        % ROI handle selected in the GUI.
        ROIHandle
    end

    properties (Hidden)
        % List of fields that can be plotted from the GUI.
        DispPlotsOptions = {'DatasetNum', 'FrameNum', 'X', 'Y', 'Z', ...
            'X_SE', 'Y_SE', 'Z_SE', ...
            'Photons', 'Photons_SE', 'Bg', 'Bg_SE', ...
            'PSFSigma', 'PSFSigmaX', 'PSFSigmaY', ...
            'PSFSigma_SE', 'PSFSigmaX_SE', 'PSFSigmaY_SE', ...
            'PValue', 'LogLikelihood', 'ThreshFlag', ...
            'ConnectID', 'NCombined'}

        % Single Molecule Fitting structure loaded along with SMD.
        % NOTE: This is only kept as an aid to exporting, so that both SMD
        %       and SMF can be exported to a file.
        SMF
    end
    
    methods
        function obj = InspectResults(StartGUI)
            if (~exist('StartGUI', 'var') || isempty(StartGUI))
                StartGUI = true;
            end
            if StartGUI
                obj.gui()
            end
        end

        function SMDIsolated = get.SMDIsolated(obj)
            % get method for obj.SMDIsolated.
            if isempty(obj.SMD)
                SMDIsolated = smi_core.SingleMoleculeData.createSMD();
                return
            end
            if isempty(obj.ROI)
                SMDIsolated = obj.SMD;
                if ~isempty(SMDIsolated)
                    obj.ROI = [1, 1, SMDIsolated.YSize, SMDIsolated.XSize];
                end
            else
                SMDIsolated = smi_core.SingleMoleculeData.isolateSubROI(...
                    obj.SMD, obj.ROI);
            end
        end
        
        [] = gui(obj)
    end


end
./MATLAB/+smi_vis/@InspectResults/README.md
### +smi_vis/@InspectResults

InspectResults contains methods useful for inspecting SR data.
This class provides an interface for inspecting super-resolution
results.  The primary intention is that this class can be used to
associate localizations from a reconstruction image (e.g., a Gaussian
SR image) and the entries of a Single Molecule Data structure
(see smi_core.SingleMoleculeData).

The suggested usage of this class is through the GUI, which will be
opened by default when creating an instance of this class:
```
   Inspect = smi_vis.InspectResults();``
```
From the GUI, you should load a super-resolution image reconstruction
(saved as, e.g., a .png) as well as a *_Results.mat file containing
the SMD structure (see usage of smi.SMLM, which generates a 
*_Results.mat file).  Once the image is loaded, it'll be displayed in
the GUI figure.  Hovering over the GUI figure will reveal a toolbar
with a '+' icon which can be used to highlight a ROI and display
info about localizations from the ROI.

REQUIRES:
- Image Processing Toolbox
- Statistics and Machine Learning Toolbox

---

properties:
```
   % Single Molecule Data structure. (see smi_core.SingleMoleculeData)
   SMD

   % Super-resolution reconstruction image. (YxXx3 float)
   SRImage

   % Figure containing the interactive GUI.
   GUIFigure

   % Axes containing the SR image.
   ImageAxes

   % ROI in SMD coordinates. ([YStart, XStart, YEnd, XEnd])
   ROI
```

./MATLAB/+smi_vis/plotImageStack.m
function [PlotAxes] = plotImageStack(PlotAxes, ...
    ImageStack, StackSpacing, ColorMap, ViewLOS, ImageScaling)
%plotImageStack plots a stack of images.
% This method will plot a stack of images contained in a 3D array. The
% intention is that these plots will be used for qualitative purposes 
% (e.g., displaying an example of a dataset).
%
% INPUTS:
%   PlotAxes: Axes in which the image stack will be plotted.
%             (Default = gca())
%   ImageStack: A 3d array containing the images. 
%               (MxNx3xNImages numeric array)
%   StackSpacing: Spacing between the NImages in ImageStack.
%                 (pixels)(Default = 5)
%   ColorMap: Color map used to display the images. Note that this is not
%             defined/used the same way as colormaps are sometimes used in
%             MATLAB, and instead defines a splitting ratio between the RGB
%             channels. The use of a fourth element will allow for setting
%             the 'FaceAlpha' property of the surface() call used below.
%             (1x3(4) or NImagesx3(4) numeric array)(Default = [1, 1, 1])
%   ViewLOS: Line of site for viewing the stack. This will be passed
%            directly to the MATLAB method view(). (Default = [-45, 10])
%   ImageScaling: Scaling mode of the images.
%                 'global': Each image is rescaled with respect to the
%                           entire stack.
%                 'local': Each image is independently rescaled to [0, 1].
%                 (char array)(Default = 'global')
%
% OUTPUTS:
%   PlotAxes: Axes in which the image stack was plotted.

% Created by:
%   David J. Schodt (Lidke lab, 2021)


% Set defaults if needed.
if (~exist('PlotAxes', 'var') || isempty(PlotAxes) || ~isvalid(PlotAxes))
    PlotAxes = gca();
end
if (~exist('StackSpacing', 'var') || isempty(StackSpacing))
    StackSpacing = 5;
end
if (~exist('ColorMap', 'var') || isempty(ColorMap))
    ColorMap = [1, 1, 1];
end
if (~exist('ViewLOS', 'var') || isempty(ViewLOS))
    ViewLOS = [-45, 10];
end
if (~exist('ImageScaling', 'var') || isempty(ImageScaling))
    ImageScaling = 'global';
end

% Reshape input stack if needed.
StackSize = size(ImageStack, 1:4);
if (StackSize(3) ~= 3)
    if (StackSize(3) ~= 1)
        % Assume images are arranged as YxXxNImages.
        ImageStack = reshape(ImageStack, ...
            [StackSize(1), StackSize(2), 1, StackSize(3)]);
    end
    ImageStack = repmat(ImageStack, [1, 1, 3]);
end
NImages = size(ImageStack, 4);

% Reshape 'ColorMap' if needed.
if (size(ColorMap, 1) ~= NImages)
    ColorMap = repmat(ColorMap(1, 1:size(ColorMap, 2)), NImages, 1);
end
FaceAlpha = ones(NImages, 1);
if (size(ColorMap, 2) > 3)
    FaceAlpha = ColorMap(:, 4);
end

% Prepare the plot axes.
XRange = [1, StackSize(2)];
YRange = [1, StackSize(1)];
ZRange = [1, NImages * StackSpacing];
axis(PlotAxes, [XRange, YRange, ZRange])
view(PlotAxes, ViewLOS)
axis(PlotAxes, 'off')
axis(PlotAxes, 'equal')

% Rescale the image stack.
ImageStack = (ImageStack-min(ImageStack(:))) ...
    ./ max(ImageStack(:)-min(ImageStack(:)));
if strcmpi(ImageScaling, 'local')
    for nn = 1:NImages
        ImageStack(:, :, :, nn) = ...
            smi_vis.contrastStretch(ImageStack(:, :, :, nn));
    end
end

% Loop through the image stack and plot each image.
for nn = 1:NImages
    ZSurfVal = repmat(nn * StackSpacing, [2, 2]);
    surface(PlotAxes, XRange, YRange, ZSurfVal, ...
        ImageStack(:, :, :, nn).*reshape(ColorMap(nn, 1:3), 1, 1, 3), ...
        'facecolor', 'texturemap', 'FaceAlpha', FaceAlpha(nn));
end


end
./MATLAB/+smi_vis/README.md
### +smi_vis

+smi_vis is the namespace for the visualization functions and classes of
***smite***:
- [@GenerateImages](@GenerateImages/README.md):
  general visualization of super-resolution data
- [@GenerateMovies](@GenerateMovies/README.md):
  generate movies
- [@InspectResults](@InspectResults/README.md):
  inspect super-resolution data

---

functions:
- **[contrastStretch](contrastStretch.m)**:
  scales images to the range MinMax
- **[plotCDFs](plotCDFs.m)**:
  plots multiple CDFs on the same plot.
- **[plotImageStack](plotImageStack.m)**:
  plots a stack of images contained in a 3D array

./MATLAB/+smi_vis/@GenerateMovies/gui.m
function gui(obj)
%gui prepares a movie generation GUI for the GenerateMovies class.

% Created by:
%   David J. Schodt (Lidke lab, 2021)


% Create a figure handle for the GUI.
DefaultFigurePosition = get(0, 'defaultFigurePosition');
obj.GUIFigure = figure('MenuBar', 'none', 'NumberTitle', 'off', ...
    'Name', 'Movie maker', 'Tag', 'MovieGUI', ...
    'Units', 'pixels', ...
    'Position', [DefaultFigurePosition(1:2), 1000, 500]);

% Add a panel for loading existing data.
LoadPanelPos = [0, 0.8, 0.25, 0.2];
LoadPanel = uipanel(obj.GUIFigure, ...
    'Title', 'Load Data', ...
    'FontWeight', 'bold', 'Units', 'normalized', ...
    'Position', LoadPanelPos);
ButtonSize = [0, 0, 1, 1];
LoadResultsPos = [0, 0, ButtonSize(3:4)];
uicontrol('Parent', LoadPanel, ...
    'Style', 'pushbutton', 'String', 'Load Results', ...
    'Units', 'normalized', 'Position', LoadResultsPos, ...
    'Callback', @loadResults);

% Add a panel for display options.
ParamsPanelPos = [0, 0, LoadPanelPos(3), 1-LoadPanelPos(4)];
ParamsPanel = uipanel(obj.GUIFigure, ...
    'Title', 'Parameters', ...
    'FontWeight', 'bold', 'Units', 'normalized', ...
    'Position', ParamsPanelPos);
smi_helpers.addBasicGUI(ParamsPanel, obj.Params, @updateParams);

% Add some controls for the movie.
ControlPanelPos = [ParamsPanelPos(3)-ParamsPanelPos(1), 0, 0.5, 0.1];
ControlPanel = uipanel(obj.GUIFigure, 'Title', 'Movie Controls', ...
    'FontWeight', 'bold', 'Units', 'normalized', ...
    'Position', ControlPanelPos);
FrameSliderPos = [0.1, 0.5, 0.89, 0.5];
if isempty(obj.TRInternal)
    SliderMaxVal = 1;
    SliderStep = [1, 1];
else
    SliderMaxVal = obj.TRInternal(1).NFrames;
    SliderStep = [1, 1] / SliderMaxVal;
end
FrameSlider = uicontrol('Parent', ControlPanel, ...
    'Style', 'slider', ...
    'Units', 'normalized', 'Position', FrameSliderPos, ...
    'HorizontalAlignment', 'left', ...
    'Min', 1, 'Max', SliderMaxVal, ...
    'SliderStep', SliderStep, ...
    'Value', 1, ...
    'Callback', @frameSlider);
FrameNumDisplayPos = [FrameSliderPos(1), 0, ...
    FrameSliderPos(3), 1 - FrameSliderPos(4)];
FrameNumDisplay = uicontrol('Parent', ControlPanel, ...
    'Style', 'text', ...
    'String', sprintf('Frame %i of %i', FrameSlider.Min, FrameSlider.Max), ...
    'Units', 'normalized', 'Position', FrameNumDisplayPos, ...
    'HorizontalAlignment', 'left');
PlayButtonPos = [0, FrameSliderPos(2), ...
    0.9 * (1-FrameSliderPos(3)), FrameSliderPos(4)];
uicontrol('Parent', ControlPanel, ...
    'Style', 'pushbutton', 'String', 'PLAY', ...
    'Units', 'normalized', 'Position', PlayButtonPos, ...
    'Callback', @playMovieCallback);

% Prepare axes for the movie.
MoviePanelPos = ControlPanelPos ...
    + [0, ControlPanelPos(4), 0, 1-2*ControlPanelPos(4)];
MoviePanel = uipanel(obj.GUIFigure, ...
    'Units', 'normalized', 'Position', MoviePanelPos);
obj.MovieAxes = axes(MoviePanel);
obj.MovieAxes.ActivePositionProperty = 'position';
axtoolbar(obj.MovieAxes, 'default');
set(zoom(obj.MovieAxes), 'ActionPostCallback', @postZoomCallback);

% Add controls to allow for saving a movie.
SaveMoviePanelPos = [MoviePanelPos(1)+MoviePanelPos(3), 0, ...
    1-ParamsPanelPos(3)-MoviePanelPos(3), ControlPanelPos(4)];
SaveMoviePanel = uipanel(obj.GUIFigure, 'Title', 'Save Movie', ...
    'FontWeight', 'bold', 'Units', 'normalized', ...
    'Position', SaveMoviePanelPos);
uicontrol('Parent', SaveMoviePanel, 'Style', 'pushbutton', ...
    'String', 'Save Movie', ...
    'Units', 'normalized', 'Position', [0, 0, 1, 1], ...
    'Callback', @saveMovieButtonClicked);

% Add a panel to contain trajectory information about clicked trajectories.
CurrentTrajIndex = 1;
TrajInfoPanelPos = ...
    [SaveMoviePanelPos(1), sum(SaveMoviePanelPos([2, 4])), ...
    SaveMoviePanelPos(3), MoviePanelPos(4)];
TrajInfoPanel = uipanel(obj.GUIFigure, ...
    'Title', 'Trajectory Information', ...
    'FontWeight', 'bold', 'Units', 'normalized', ...
    'Position', TrajInfoPanelPos);
TrajInfoTitlePos = [0, 0.9, 1, 0.1];
uicontrol('Parent', TrajInfoPanel, 'Style', 'text', ...
    'Units', 'normalized', 'Position', TrajInfoTitlePos, ...
    'String', ...
    sprintf('(click a trajectory to display trajectory information)'));
TrajInfoTextPos = [0, TrajInfoTitlePos(2)-TrajInfoTitlePos(4), 0.5, 0.05];
uicontrol('Parent', TrajInfoPanel, 'Style', 'text', ...
    'String', 'Connect ID: ', ...
    'Units', 'normalized', ...
    'Position', TrajInfoTextPos, ...
    'HorizontalAlignment', 'left');
TrajIDDisplay = uicontrol('Parent', TrajInfoPanel, 'Style', 'edit', ...
    'Units', 'normalized', ...
    'Position', TrajInfoTextPos + [TrajInfoTextPos(3), 0, 0, 0], ...
    'HorizontalAlignment', 'left', ...
    'Callback', @trajectorySelectedEdit);
StartFrameDisplay = uicontrol('Parent', TrajInfoPanel, 'Style', 'text', ...
    'String', sprintf('Start %s (%s):', ...
    obj.TimeDimensionString, obj.TimeUnitString), ...
    'Units', 'normalized', ...
    'Position', TrajInfoTextPos ...
    + [0, -TrajInfoTextPos(4), (1-TrajInfoTextPos(3)), 0], ...
    'HorizontalAlignment', 'left');
EndFrameDisplay = uicontrol('Parent', TrajInfoPanel, 'Style', 'text', ...
    'String', sprintf('End %s (%s):', ...
    obj.TimeDimensionString, obj.TimeUnitString), ...
    'Units', 'normalized', 'Position', TrajInfoTextPos ...
    + [0, -2*TrajInfoTextPos(4), (1-TrajInfoTextPos(3)), 0], ...
    'HorizontalAlignment', 'left');
TrajFidelityDisplay = uicontrol('Parent', TrajInfoPanel, 'Style', 'text', ...
    'String', 'Trajectory Fidelity: ', ...
    'Tooltip', 'Number of points in trajectory divided by total duration.', ...
    'Units', 'normalized', 'Position', TrajInfoTextPos ...
    + [0, -3*TrajInfoTextPos(4), (1-TrajInfoTextPos(3)), 0], ...
    'HorizontalAlignment', 'left');
uicontrol('Parent', TrajInfoPanel, 'Style', 'pushbutton', ...
    'String', 'Display Plots', ...
    'Units', 'normalized', 'Position', [0, 0, 1, 0.2], ...
    'Callback', @displayPlots);

% If raw data is available, display the first frame.
if ~isempty(obj.RawData)
    obj.prepRawData()
    obj.prepAxes()
    obj.makeFrame(obj.MovieAxes, ...
        obj.TRInternal, obj.ScaledData(:, :, :, end), ...
        obj.Params, obj.SMF, obj.SMD, obj.Params.ZFrames(1));
end


    function updateParams(Source, ~)
        % Callback for obj.Params updates.
        
        % Update the appropriate field of obj.Params based on the
        % uicontrol.
        CurrentField = obj.Params.(Source.Tag);
        if islogical(CurrentField)
            obj.Params.(Source.Tag) = logical(Source.Value);
        elseif (ischar(CurrentField) || isstring(CurrentField))
            obj.Params.(Source.Tag) = Source.String;
        elseif isnumeric(CurrentField)
            % NOTE: We want to use str2num() instead of, e.g., str2double()
            %       because str2num() works nicely for vectors.
            obj.Params.(Source.Tag) = str2num(Source.String);
        end
        
        % Update the frame slider to reflect changes to 'ZFrames'.
        if ~isempty(obj.Params.ZFrames)
            FrameSlider.Value = obj.Params.ZFrames(1);
            FrameSlider.Min = obj.Params.ZFrames(1);
            FrameSlider.Max = obj.Params.ZFrames(2);
        end
    end

    function playMovieCallback(Source, ~)
        % This is a callback function for the PLAY button, which will call
        % the function playMovie to replay the movie without needing to use
        % the slidebar.
        
        try
            % Disable the PLAY button so it can't be clicked multiple times
            Source.Enable = 'off';
            
            % Play the movie.
            obj.generateMovie();
            
            % Remake the last frame of the movie showing the entirety of
            % the trajectories.
            TempParams = obj.Params;
            TempParams.MaxTrajLength = inf;
            obj.LineHandles = obj.makeFrame(obj.MovieAxes, ...
                obj.TRInternal, obj.ScaledData(:, :, :, end), TempParams, ...
                obj.SMF, obj.SMD, TempParams.ZFrames(2));
            
            % Set the callback function for the line handles.
            setLineCallbacks()
        catch MException
            % Re-enable the Play button before throwing the error.
            Source.Enable = 'on';
            rethrow(MException)
        end
    end

    function frameSlider(Source, ~)
        % This is a callback function for the event that the user has slid
        % the FrameSlider slidebar.  This method will determine the
        % location of the slidebar, convert this to a frame within the
        % movie, and then plot the trajectories of the movie as they exists
        % up through that frame.
        
        % Get the location of the slide bar, as well as the min and max
        % values possible for the slider.
        SliderValue = round(get(Source, 'Value'));
        SliderMax = get(Source, 'Max');
        
        % Update the scaled data based on the current obj.Params.
        obj.prepRawData()
        
        % Make sure the axes are prepared based on the settings in
        % obj.Params (this can be a bit slow since each movement of the
        % slider calls this, but I haven't found a better way to deal with
        % this since updates in obj.setVitalParams() can affect the changes
        % needed to the axes).
        obj.prepAxes()
        
        % Display the selected movie frame.  If the selected frame is the
        % last frame, display the entire trajectory.
        if (SliderValue == SliderMax)
            TempParams = obj.Params;
            TempParams.MaxTrajLength = inf;
            obj.LineHandles = obj.makeFrame(obj.MovieAxes, obj.TRInternal, ...
                obj.ScaledData(:, :, :, SliderValue), ...
                TempParams, obj.SMF, obj.SMD, SliderValue);
        else
            obj.LineHandles = obj.makeFrame(obj.MovieAxes, obj.TRInternal, ...
                obj.ScaledData(:, :, :, SliderValue), ...
                obj.Params, obj.SMF, obj.SMD, SliderValue);
        end
        
        % Set the callback function for the line handles.
        setLineCallbacks()
        
        % Update the frame number display within the GUI to show the
        % currently selected frame of the movie.
        FrameNumDisplay.String = sprintf(...
            'Frame %i of %i', SliderValue, SliderMax);
    end

    function setLineCallbacks()
        % Loop through the line handles and set their 'Callback' property
        % so that they can be clicked.
        for nn = 1:numel(obj.LineHandles)
            % Specify the ButtonDownFcn.
            if isgraphics(obj.LineHandles(nn)) ...
                    && obj.LineHandles(nn).isvalid
                % If the nn-th line handle has been deleted/is not
                % valid, we can't set the ButtonDownFcn property.
                obj.LineHandles(nn).ButtonDownFcn = ...
                    {@trajectoryClicked, nn};
            end
        end
    end

    function trajectoryClicked(~, ~, TRIndex)
        % This is a callback function for the event that the user has
        % clicked on a trajectory (with TR index 'TRIndex') within
        % the movie.
        
        % Remove previous indicator(s) that a trajectory had been selected
        % prior to this event, ensuring that the line is still valid before
        % attempting to modify it.
        [obj.LineHandles(obj.LineHandles.isvalid ...
            & isgraphics(obj.LineHandles)).LineWidth] = deal(0.5);
        
        % Add indicators to the selected trajectory to emphasize which one
        % was selected.
        if (CurrentTrajIndex == TRIndex)
            % If the same trajectory was clicked again, we'll assume the
            % user was trying to "unclick" it.
            CurrentTrajIndex = [];
            return
        end
        [obj.LineHandles(TRIndex).LineWidth] = 3;
        
        % Update 'CurrentlySelectedTrajectory' so that other callbacks can
        % access this information.
        CurrentTrajIndex = TRIndex;
        
        % Grab useful information about the trajectory to be displayed,
        % ensuring the units are consistent with the movie.
        FrameNum = obj.TRInternal(TRIndex).FrameNum;
        Time = (FrameNum-1)*obj.Params.UnitFlag/obj.SMF.Data.FrameRate ...
            + FrameNum*(~obj.Params.UnitFlag);
        
        % Modify text panels within the display panel to provide
        % information about the selected trajectory.
        TrajIDDisplay.String = num2str(obj.TRInternal(TRIndex).ConnectID);
        StartFrameDisplay.String = sprintf('Start %s (%s): %i', ...
            obj.TimeDimensionString, ...
            obj.TimeUnitString, min(Time));
        EndFrameDisplay.String = sprintf('End %s (%s): %i', ...
            obj.TimeDimensionString, ...
            obj.TimeUnitString, max(Time));
        TrajFidelity = ...
            smi_core.TrackingResults.computeTrajLengths(obj.TRInternal(TRIndex)) ...
            / smi_core.TrackingResults.computeTrajDurations(obj.TRInternal(TRIndex));
        TrajFidelityDisplay.String = ...
            sprintf('Trajectory Fidelity: %.4f', TrajFidelity);
    end

    function trajectorySelectedEdit(Source, ~)
        % This is a callback function for the event that a user has
        % manually entered a trajectory ID that they wish to highlight/get
        % information for.
        
        % Ensure that the entered value isn't empty.
        if isempty(Source.String)
            return
        end
        
        % Determine the trajectory ID and check if a line handle exists for
        % it.
        ConnectID = str2double(Source.String);
        if ~ismember(ConnectID, [obj.TRInternal.ConnectID])
            warning('Trajectory %i does not exist in the movie', ...
                ConnectID);
            return
        end
        
        % Call the trajectorySelected function, passing along the user
        % input trajectory ID.
        trajectoryClicked([], [], find([obj.TRInternal.ConnectID] == ConnectID))
    end

    function saveMovieButtonClicked(~, ~)
        % This is a callback function to respond to clicks of the save
        % movie button.
        obj.DataIsPrepped = false;
        obj.AxesPrepped = false;
        obj.saveMovie()
    end


    function displayPlots(~, ~)
        % This is a callback function to respond to clicks of the Display
        % Plots button.  Clicking that button will open a small GUI with a
        % dropdown menu to allow for display of various plots related to
        % the currently clicked trajectory.
        
        % Create the figure for the small GUI.
        DisplayGUI = figure('NumberTitle', 'off', 'Resize', 'off', ...
            'Units', 'pixels', 'MenuBar', 'none', ...
            'ToolBar', 'none', 'Position', [500, 500, 200, 150]);
        
        % Add text to the GUI to guide user control.
        uicontrol('Parent', DisplayGUI, 'Style', 'text', ...
            'String', 'Select Plot:', 'Position', [70, 125, 60, 15]);
        
        % Add a drop-down menu to the GUI figure.
        DropdownMenu = uicontrol('Parent', DisplayGUI, ...
            'Style', 'popupmenu', 'String', obj.DispPlotsOptions, ...
            'Position', [50, 95, 100, 25]);
        
        % Add a display button to the GUI figure.
        uicontrol('Parent', DisplayGUI, 'Style', 'pushbutton', ...
            'String', 'Display Plot', 'Position', [65, 45, 70, 25], ...
            'Callback', {@displayPlotPushed, DropdownMenu});
    end


    function displayPlotPushed(~, ~, DropdownMenu)
        % This is a callback for the Display Plot button within the display
        % plot GUI, which will plot the information about a clicked
        % trajectory from the drop down menu.
        
        % Create a new figure and plot the trajectory information as
        % selected by the drop down menu in the display plot GUI.
        DisplayPlotsFigure = findobj('Tag', 'DisplayPlotsFigure');
        if isempty(DisplayPlotsFigure)
            DisplayPlotsFigure = figure('Tag', 'DisplayPlotsFigure');
        end
        figure(DisplayPlotsFigure)
        PlotAxes = axes(DisplayPlotsFigure);
        hold(PlotAxes, 'on');
        
        % Extract the desired field from the TR structure.
        DropdownString = DropdownMenu.String;
        DropdownValue = DropdownMenu.Value;
        DesiredPlotString = DropdownString{DropdownValue};
        DesiredField = obj.TRInternal(CurrentTrajIndex).(DesiredPlotString);
        FrameNum = obj.TRInternal(CurrentTrajIndex).FrameNum;
        assert(numel(FrameNum) == numel(DesiredField), ...
            ['The selected field is not the same length as ', ...
            'TR.FrameNum and cannot be plotted'])
        plot(PlotAxes, FrameNum, DesiredField, 'x')
        xlabel(PlotAxes, 'Frame number (frames)')
    end

    function loadResults(Source, ~)
        %loadResults loads tracking results from a .mat file.
        % This function loads the selected .mat file and additionally
        % attempts to load the raw data used to generate the results.
        
        % Wrap everything in a try/catch so we can re-enable the load
        % button if there's an error.
        Source.Enable = 'off';
        try
            % Ask the user to select an results file.
            [File, Path] = uigetfile('*.mat', 'Select a *Results.mat file');
            
            % Load the results and attempt to load the raw data.
            if ~isequal(File, 0)
                % Load results.
                load(fullfile(Path, File), 'TR', 'SMD', 'SMF')
                obj.TR = TR;
                obj.SMD = SMD;
                if exist('SMF', 'var')
                    % If the SMF exists, store it and attempt to load the
                    % designated raw data.
                    obj.SMF = SMF;
                    LD = smi_core.LoadData;
                    [~, obj.RawData] = LD.loadRawData(obj.SMF, 1, ...
                        obj.SMF.Data.DataVariable);
                    obj.prepRawData()
                    obj.prepAxes()
                    obj.makeFrame(obj.MovieAxes, ...
                        obj.TRInternal, obj.ScaledData(:, :, :, end), ...
                        obj.Params, obj.SMF, obj.SMD, obj.Params.ZFrames(1));
                end
                
                % Update the frame slider.
                FrameSlider.Value = 1;
                FrameSlider.Min = 1;
                FrameSlider.Max = obj.TRInternal(1).NFrames;
                FrameSlider.SliderStep = [1, 1] / FrameSlider.Max;
                Source.Enable = 'on';
            else
                Source.Enable = 'on';
                return
            end
        catch MException
            Source.Enable = 'on';
            rethrow(MException)
        end
    end

    function postZoomCallback(~, ~)
        % Custom post-zooming callback for movie axes.
        obj.addAxesTicks(obj.MovieAxes)
    end


end
./MATLAB/+smi_vis/@GenerateMovies/plotTrajectories.m
function [LineHandles] = plotTrajectories(PlotAxes, ...
    Params, TR, FrameRange, Color, varargin)
%plotTrajectories plots trajectories in the specified axes.
% This method plots trajectories in 'TR'.  This method is intended to
% remain "lightweight" for speed purposes, so minimal input checks/default
% settings should be implemented here.
%
% INPUTS:
%   PlotAxes: Axes in which the trajectories will be plotted.
%   Params: Structure of parameters (see usage below and settings in
%           obj.prepOligoDefaults())
%   TR: Tracking Results structure (see smi_core.TrackingResults).
%   FrameRange: Range of frames over which trajectories should be plotted.
%   Color: Color of the trajectory lines. (NTrajectoriesx3(4) float array)
%   varargin: Additional inputs that can be provided as keyword arguments
%             for the MATLAB line() method (see Line Properties from line()
%             documentation for options).  For example, you can change
%             the Marker property to 'x' as plotTrajectories(PlotAxes, TR,
%             FrameRange, MaxTrajLength, Color, 'Marker', 'x')
%
% OUTPUTS:
%   LineHandles: Array of line handles corresponding to the trajectories
%                in 'TR'.

% Created by:
%   David J. Schodt (Lidke Lab, 2021)


% Loop through trajectories present in 'TR' and plot them, enforcing the
% requested 'FrameRange' and 'MaxTrajLength'.
NTraj = numel(TR);
LineHandles = gobjects(NTraj, 1);
IndicateDimer = Params.IndicateDimer;
IndicateDimerCandidate = Params.IndicateDimerCandidate;
AddDimerDecorations = ...
    ((IndicateDimerCandidate&&isfield(TR, 'DimerCandidateBool')) ...
    || (IndicateDimer&&isfield(TR, 'StateSequence')));
for nn = 1:NTraj
    % Determine which datapoints we should plot.
    KeepBool = ((TR(nn).FrameNum>=FrameRange(1)) ...
        & (TR(nn).FrameNum<=FrameRange(2)));
    if ~any(KeepBool)
        continue
    end
    X = TR(nn).X(KeepBool);
    Y = TR(nn).Y(KeepBool);
    FrameNum = TR(nn).FrameNum(KeepBool);

    % Plot the trajectories, adding extra decorations for dimerization if
    % needed.
    if AddDimerDecorations
        % Add a dotted line for the entire trajectory (this should get
        % covered up by the other lines where relevant, otherwise it'll
        % stay as a dotted line to indicate parts that weren't dimer
        % candidates).
        line(PlotAxes, X, Y, FrameNum, ...
            'Color', Color(nn, :), 'LineStyle', ':');

        % Indicate dimer candidate frames, making sure to not have overlaps
        % (e.g., if there's a frame gap between candidate frames, don't
        % connect a line across the frame gap!).
        if isfield(TR, 'DimerCandidateBool')
            DimerCandidateBool = TR(nn).DimerCandidateBool(KeepBool);
            if any(DimerCandidateBool)
                % Find and plot each segment of dimer candidates.
                [CandidateStartInd, CandidateEndInd] = ...
                    smi_helpers.findStartEndInds(DimerCandidateBool);
                for ii = 1:numel(CandidateStartInd)
                    line(PlotAxes, ...
                        X(CandidateStartInd(ii):CandidateEndInd(ii)), ...
                        Y(CandidateStartInd(ii):CandidateEndInd(ii)), ...
                        FrameNum(CandidateStartInd(ii):CandidateEndInd(ii)), ...
                        'Color', Color(nn, :), ...
                        'LineStyle', '-', 'LineWidth', 2)
                end
            end
        else
            DimerCandidateBool = zeros(size(FrameNum), 'logical');
        end

        % Indicate dimer frames.
        if isfield(TR, 'StateSequence')
            DimerBool = (TR(nn).StateSequence(KeepBool) == 1);
            if any(DimerBool)
                % Find and plot each segment of dimer candidates.
                [DimerStartInd, DimerEndInd] = ...
                    smi_helpers.findStartEndInds(DimerBool);
                for ii = 1:numel(DimerStartInd)
                    line(PlotAxes, ...
                        X(DimerStartInd(ii):DimerEndInd(ii)), ...
                        Y(DimerStartInd(ii):DimerEndInd(ii)), ...
                        FrameNum(DimerStartInd(ii):DimerEndInd(ii)), ...
                        'Color', [0, 0, 1], ...
                        'LineStyle', '-', 'LineWidth', 2)
                end
            end
        else
            DimerBool = zeros(size(FrameNum), 'logical');
        end

        % Plot an invisible line over the whole trajectory for use as the
        % linehandle (which will allow us to click the trajectory in a
        % GUI).
        LineHandles(nn) = line(PlotAxes, ...
            X, Y, FrameNum, ...
            'Color', [0, 0, 0, 0], 'LineWidth', 2, ...
            'PickableParts', 'all');
    else
        % Plot the full trajectory as usual.
        LineHandles(nn) = line(PlotAxes, ...
            X, Y, FrameNum, ...
            'Color', Color(nn, :), varargin{:});
    end
end


end
./MATLAB/+smi_vis/@GenerateMovies/generateMovie.m
function [] = generateMovie(obj)
%generateMovie generates a movie of 2D trajectories over time.
% This method is intended to be a wrapper around playMovie() which will
% do a couple of useful things before playing the movie.

% Created by:
%   David J. Schodt (Lidke Lab, 2021)


% Rescale/crop the raw data to improve the display.
obj.prepRawData()

% Prepare the axes based on settings in obj.Params.
obj.prepAxes()

% Play the movie.
obj.playMovie(obj.MovieAxes, obj.TRInternal, obj.ScaledData, ...
    obj.Params, obj.SMF, obj.SMD, obj.VideoObject)


end
./MATLAB/+smi_vis/@GenerateMovies/prepDefaults.m
function [Params] = prepDefaults()
%prepDefaults prepares a default 'Params' structure.
% This method prepares a 'Params' structure with all fields present with
% default values.
%
% OUTPUTS:
%   Params: Structure of parameters that will be applied to movies.
%           UnitFlag: Boolean flag to specify the units of the movie                            false for camera units (pixels, frames)
%                     true for physical units (micrometers, seconds)
%                     (boolean)(Default = false)
%           MaxTrajLength: Maximum number of points of a given
%                          trajectory that will be plotted.
%                          (frames)(Default = inf)
%           XPixels: Range of X values shown in movie.
%                    ([MinPixel, MaxPixel])(pixels)(Default = [])
%                    NOTE: XPixels, YPixels, and ZFrames are kept as
%                          separate parameters (i.e., instead of lumping
%                          into one ROI parameter) to allow one to be set
%                          without having to set the others.
%           YPixels: Range of Y values shown in movie.
%                    ([MinPixel, MaxPixel])(pixels)
%                    (Default = [])
%           ZFrames: Range of frames shown in movie.
%                    ([MinFrame, MaxFrame])(frames)
%                    (Default = [])
%           MinScaleIntensity: Minimum value that we will use to scale the 
%                              raw data. If the raw data ranges from 
%                              [0, MaxIntensity], we scale as
%                              RawData / MaxIntensity, but if raw data is 
%                              too noisy this just brightens noise, so we
%                              set MaxIntensity = max(MaxIntensity,
%                              MinScaleIntensity).
%                              (numeric scalar)(Default = 1)
%           PercentileCeiling: Percentile ceiling of pixel values in the 
%                              raw data above which values are clipped.
%                               (percentage)(Default = 100)
%           PercentileFloor: Percentile floor of pixel values in the raw
%                            data below which values are clipped.
%                            (percentage)(Default = 0)
%           PlotMarker: Marker to be placed on top of each localization. 
%                       Options: MATLAB markers, e.g., 'x' (see Line 
%                       Properties in MATLAB documentation) or 'none'.
%                        (char. array)(Default = 'none')
%           SMDMarker: Marker to be placed on top of each
%                      localization in SMD. (Default = 'none')
%           SMDColor: Color of the SMD markers. (Default = [1, 0, 0])
%           LineOfSite: Line of site vector for view() (rotates
%                       "camera" orientation for 3D movie.  When
%                       Is2D = 0, LineOfSite can be given as an
%                       NFramex2 array and the movie will rotate as
%                       prescribed by these angles.
%                       (1x2 array or NFramesx2 array)(degrees)
%                       (Default = [0, 90])
%           Resolution: Resolution of the movie that gets saved to
%                       FilePath.
%                       (scalar)(dpi)(Default = 0, which sets to screen
%                       resolution)
%           FrameRate: Approximate playback framerate used when not saving
%                      a movie (i.e., if the movie is being displayed but
%                      not saved, an additional pause(1/FrameRate) is added
%                      between each frame). (Default = 10 fps)
%           AutoCrop: Flag to request cropping to data present in TR.  This
%                     is enforced in GenerateMovies.prepRawData() and 
%                     nowhere else as of this writing. (Default = false)
%           MinXYRange: Minimum XY range allowed when AutoClip = true,
%                       otherwise this is not used. (pixels)(Default = 20)
%           NPadPixels: Number of padding pixels added to edges of XY data
%                       when AutoClip = true, otherwise this is not used.
%                       (pixels)(Default = 5)
%           NPadFrames: Number of padding frames added around frames of
%                       trajectories in TR when AutoClip = true, otherwise
%                       this is not used. (pixels)(Default = 10)
%           AddTimeStamp: Add a frame/time stamp in a corner of the movie.
%                         (Default = false)
%           ChannelNames: Label names for each channel. 
%                         (Default = {'Channel 1'; 'Channel 2'})
%           RawDataColors: Color of raw data in each channel.
%                          (NChannelsx3 numeric array, [RGB])
%                          (Default = [0, 1, 0; 1, 0, 1])
%           TrajColor: Color of each trajectory in TR.
%                      (NTrajx3 numeric array)
%                      (Default = [], values set automatically elsewhere)
%           CropToDimerCandidates: 0 for normal behavior.
%                                  1 if 'AutoCrop' should apply temporally
%                                  to only those frames in which the
%                                  trajectory was a dimer candidate.
%                                  (Default = 0)
%           IndicateDimer: 0 if you don't want special dimer marker
%                          1 if you want to indicate dimer events
%                          If the field TR.StateSequence doesn't exist/is
%                          empty, this property doesn't do anything.
%                          (Default = 0)
%           IndicateDimerCandidate: 0 if you don't want to indicate the 
%                                       section of data considered as a
%                                       dimer candidate.
%                                   1 if you want to indicate the section
%                                     of data considered as a dimer
%                                     candidate.
%                                   If the field TR.DimerCandidateBool 
%                                   doesn't exist/is empty, this property 
%                                   doesn't do anything.
%                                   (Default = 0)

% Created by:
%   David J. Schodt (Lidke Lab, 2022)


% Set some default parameters.
Params.UnitFlag = false;
Params.MaxTrajLength = inf;
Params.ZFrames = [];
Params.XPixels = [];
Params.YPixels = [];
Params.MinScaleIntensity = 1;
Params.PercentileCeiling = 100;
Params.PercentileFloor = 0;
Params.PlotMarker = 'none';
Params.SMDMarker = 'none';
Params.SMDColor = [1, 0, 0];
Params.LineOfSite = [0, 90];
Params.Resolution = 0;
Params.FrameRate = 10;
Params.AutoCrop = false;
Params.MinXYRange = 20;
Params.NPadPixels = 5;
Params.NPadFrames = 10;
Params.AddTimeStamp = false;
Params.RawDataColors = [0, 1, 0; 1, 0, 1];
Params.TrajColor = [];
Params.ChannelNames = {'Channel 1'; 'Channel 2'};
Params.CropToDimerCandidates = false;
Params.IndicateDimer = false;
Params.IndicateDimerCandidate = false;


end
./MATLAB/+smi_vis/@GenerateMovies/playMovie.m
function [] = playMovie(PlotAxes, TR, ScaledData, ...
    Params, SMF, SMD, VideoObject)
%playMovie prepares a movie of the trajectories in TR.
% This method prepares a movie of single-particle tracking trajectories for
% 2D tracking.
%
% INPUTS:
%   PlotAxes: Axes in which the trajectories will be plotted.
%             (Default = gca())
%   TR: Tracking Results structure (see smi_core.TrackingResults).
%   ScaledData: Data corresponding to the trajectories in 'TR'.  The fourth
%               dimension is assumed to correspond directly with the frame
%               number.
%   Params: Structure of display parameters that will be applied to
%           the movie (see smi_vis.GenerateMovies.prepDefaults()).
%   SMF: Single Molecule Fitting structure (used for Data.PixelSize and
%        Data.FrameRate).
%   SMD: Single Molecule Data structure containing additional localizations
%        that we want to show in the movie (e.g., this might be the results
%        from a box finding algorithm, where the localizations aren't
%        associated as trajectories yet). (Default is an empty SMD)
%   VideoObject: Video writer object defining the movie that will be saved
%                while preparing this movie (see MATLAB VideoWriter
%                object).
%                (Default = [] and the movie isn't saved)

% Created by:
%   David J. Schodt (Lidke Lab, 2021)


% Set default parameter values where needed.
if (~exist('Params', 'var') || isempty(Params))
    Params = struct();
end
if (~exist('PlotAxes', 'var') || isempty(PlotAxes))
    PlotAxes = gca();
end
if (~exist('SMD', 'var') || isempty(SMD))
    SMD = smi_core.SingleMoleculeData.createSMD();
end
if (~exist('VideoObject', 'var') || isempty(VideoObject))
    VideoObject = [];
end
DefaultParams = smi_vis.GenerateMovies.prepDefaults();
Params = smi_helpers.padStruct(Params, DefaultParams);

% Define a few other parameters that'll be used in this method.
% NOTE: XRange and YRange are defined to resolve some coordinate
%       differences between raw data plots and the real data.
IsRotating = (size(Params.LineOfSite, 1) > 1);
ResolutionString = sprintf('-r%i', Params.Resolution);

% If the VideoObject is non-empty, open it.
if ~isempty(VideoObject)
    open(VideoObject)
end

% Loop through the frames of raw data and prepare the movie.
PlotFigure = ancestor(PlotAxes, 'figure');
for ff = Params.ZFrames(1):Params.ZFrames(2)           
    % Make the current frame of the movie.
    smi_vis.GenerateMovies.makeFrame(PlotAxes, ...
        TR, ScaledData(:, :, :, ff), Params, SMF, SMD, ff);
        
    % Update the line of site if needed.
    if IsRotating
        view(PlotAxes, Params.LineOfSite(ff, :))
    end
    
    % Update the axes to ensure all new objects and changes are present.
    drawnow()
    
    % If needed, write this movie frame.
    if isempty(VideoObject)
        % This movie isn't being saved: add a pause so the movie doesn't go
        % too fast.
        pause(1 / Params.FrameRate);
    else
        FrameData = print(PlotFigure, ...
            '-RGBImage', '-opengl', ResolutionString);
        VideoObject.writeVideo(FrameData);
    end
end

% Close the VideoObject.
if ~isempty(VideoObject)
    close(VideoObject)
end


end
./MATLAB/+smi_vis/@GenerateMovies/prepAxes.m
function [] = prepAxes(obj, PlotAxes)
%prepAxes prepares some features of the movie axes.
% This method does a few things to the axes 'PlotAxes' based on fields 
% in obj.Params (e.g., setting the axis limits).
%
% INPUTS:
%   PlotAxes: Axes that will be modified. (Default = obj.MovieAxes)

% Created by:
%   David J. Schodt (Lidke Lab, 2021)


% Before proceeding, check if the axes are in need of an update.
if obj.AxesPrepped
    return
end

% Set defaults if needed.
if (~exist('PlotAxes', 'var') || isempty(PlotAxes) || ~isvalid(PlotAxes))
    PlotAxes = obj.MovieAxes;
end

% Revise several properties of the axes.
hold(PlotAxes, 'on')
PlotAxes.ActivePositionProperty = 'position';
PlotAxes.DataAspectRatio = [1, 1, ...
    max(obj.Params.ZFrames)/max([obj.Params.XPixels, obj.Params.YPixels])];
PlotAxes.YDir = 'reverse';
PlotAxes.XLimMode = 'manual';
PlotAxes.YLimMode = 'manual';
PlotAxes.ZLimMode = 'manual';
PlotAxes.XLim = obj.Params.XPixels + [0, 1];
PlotAxes.YLim = obj.Params.YPixels + [0, 1];
PlotAxes.ZLim = obj.Params.ZFrames;
view(PlotAxes, obj.Params.LineOfSite(1, :));
colormap(PlotAxes, 'gray')

% Revise axes ticks based on the unit flag.
obj.addAxesTicks(PlotAxes, 5, '%.1f')

% Add some decorations to the movie axes.
xlabel(PlotAxes, sprintf('X (%s)', obj.LengthUnitString), ...
    'Interpreter', 'Latex')
ylabel(PlotAxes, sprintf('Y (%s)', obj.LengthUnitString), ...
    'Interpreter', 'Latex')
zlabel(PlotAxes, ...
    sprintf('%s (%s)', obj.TimeDimensionString, obj.TimeUnitString), ...
    'Interpreter', 'Latex')

% Update the flag indicating the axes have been prepped.
obj.AxesPrepped = true;


end
./MATLAB/+smi_vis/@GenerateMovies/GenerateMovies.m
classdef GenerateMovies < handle
    %GenerateMovies contains methods for generating movies.
    % This class consists of methods useful for generating movies,
    % particularly for single-particle tracking data.
    % 
    % REQUIRES:
    %   Image Processing Toolbox
    %   Statistics and Machine Learning Toolbox
    
    % Created by:
    %   David J. Schodt (Lidke Lab, 2021)
    
    
    properties
        % Structure of parameters enforced in the generated movie.
        % See prepDefaults() for a description of the parameter options and
        % playMovie() for usage.
        Params struct = struct([])
        
        % Raw data displayed under trajectories. (YSizexXSizex3xNFrames)
        RawData
        
        % Single Molecule Fitting structure with pixel size and framerate.
        SMF = smi_core.SingleMoleculeFitting;
        
        % Optional SMD containing points to mark in the movie.
        SMD = smi_core.SingleMoleculeData.createSMD();
        
        % Tracking Results structure for the trajectories.
        TR = smi_core.TrackingResults.createTR();
    end
    
    properties (SetAccess = 'protected')
        % Graphics handles to trajectory lines displayed in movie frames.
        % NOTE: This is index the same way as obj.TR, i.e., obj.TR(n)
        %       corresponds to obj.LineHandles(n).
        LineHandles
        
        % Figure containing the GUI.
        GUIFigure
        
        % Axes in which the movie is prepared if using obj.gui().
        MovieAxes
        
        % Rescaled/cropped version of property RawData (see rescaleData())
        % NOTE: I've made this a protected property so that we can ensure
        %       some of obj.Params are updated when this is written to
        %       (which I only do in obj.rescaleData())
        ScaledData
        
        % Flag indicating 'ScaledData' is ready to use.
        DataIsPrepped = false
        
        % Flag indicating 'MovieAxes' is ready to use (e.g., labeled).
        AxesPrepped = false;
        
        % MATLAB VideoWriter object used to write a movie to a file.
        VideoObject
    end
    
    properties (Hidden)
        DispPlotsOptions = {'DatasetNum', 'FrameNum', 'X', 'Y', 'Z', ...
            'X_SE', 'Y_SE', 'Z_SE', ...
            'Photons', 'Photons_SE', 'Bg', 'Bg_SE', ...
            'PSFSigma', 'PSFSigmaX', 'PSFSigmaY', ...
            'PSFSigma_SE', 'PSFSigmaX_SE', 'PSFSigmaY_SE', ...
            'PValue', 'LogLikelihood', 'ThreshFlag', 'ConnectID'}
        LengthUnitOptions = {'pixels', '$\mu m$'};
        TimeDimensionOptions = {'Frame', 'Time'};
        TimeUnitOptions = {'frames', 's'};
    end
    
    properties (Hidden, Dependent)
        LengthUnitString
        TimeDimensionString
        TimeUnitString
    end
    
    properties (Hidden, GetAccess = 'protected')
        % Internally modified version of the user set field 'TR'.
        TRInternal = smi_core.TrackingResults.createTR();
    end
    
    methods
        function obj = GenerateMovies(MovieParams)
            %GenerateMovies is the class constructor.
            if exist('MovieParams', 'var')
                obj.Params = MovieParams;
            else
                obj.Params = obj.prepDefaults();
            end
        end
        
        function set.Params(obj, ParamsInput)
            % Ensure that the class property 'Params' is complete (i.e.,
            % that it has all necessary fields set) and that they are typed
            % correctly (e.g., logical, char, ...).
            DefaultParams = obj.prepDefaults();
            obj.Params = smi_helpers.padStruct(ParamsInput, DefaultParams);
            
            % Anytime obj.Params is set, we should re-prep. the data and
            % axes (since scaling and axes labels might change based on the
            % parameters).
            obj.DataIsPrepped = false;
            obj.AxesPrepped = false;
        end
        
        function set.RawData(obj, RawDataInput)
            obj.RawData = RawDataInput;
            obj.DataIsPrepped = false;
        end
        
        function set.TR(obj, TRInput)
            % Update TRMod whenever the user resets the TR.
            obj.TR = TRInput;
            obj.TRInternal = TRInput;
        end
        
        function [LengthUnitString] = get.LengthUnitString(obj)
            LengthUnitString = smi_helpers.arrayMUX(...
                obj.LengthUnitOptions, obj.Params.UnitFlag);
        end
        
        function [TimeDimensionString] = get.TimeDimensionString(obj)
            TimeDimensionString = smi_helpers.arrayMUX(...
                obj.TimeDimensionOptions, obj.Params.UnitFlag);
        end
        
        function [TimeUnitString] = get.TimeUnitString(obj)
            TimeUnitString = smi_helpers.arrayMUX(...
                obj.TimeUnitOptions, obj.Params.UnitFlag);
        end
        
        prepRawData(obj)
        saveMovie(obj, SavePath)
        generateMovie(obj)
        gui(obj)
        
    end
    
    methods (Hidden)
        % These methods are Hidden because I don't expect the user to
        % access these directly, however there's no harm in leaving them
        % unrestricted.
        setVitalParams(obj)
        prepAxes(obj, PlotAxes)
        addAxesTicks(obj, PlotAxes, NTicks, FormatSpec)
    end
    
    methods (Static)
        playMovie(PlotAxes, TR, ScaledData, Params, SMF, SMD, VideoObject)
        [Params] = prepDefaults();
        saveRawDataMovie(RawData, FilePath, Params, FrameRate)
    end
    
    methods (Static, Hidden)
        % These methods are Hidden because I don't expect the user to
        % access these directly, however there's no harm in leaving them
        % unrestricted.
        [LineHandles] = plotTrajectories(PlotAxes, ...
            Params, TR, FrameRange, Color, varargin);
        [LineHandles] = makeFrame(PlotAxes, TR, ScaledData, ...
            Params, SMF, SMD, Frame);
        [Params] = defineCropROI(TR, Params);
        [RawData] = cropRawData(RawData, Params);
        addTimeStamp(PlotAxes, Frame, FrameRate, Params)
    end
    
    
end
./MATLAB/+smi_vis/@GenerateMovies/addTimeStamp.m
function [] = addTimeStamp(PlotAxes, Frame, FrameRate, Params)
%addTimeStamp places a time stamp in a corner of the PlotAxes.
%
% INPUTS:
%   PlotAxes: Axes in which the timestamp is added.
%   Frame: Current frame of the movie.
%   FrameRate: FrameRate used to convert Frame to units of seconds.
%   Params: Structure of several parameters (see
%           smi_vis.GenerateMovies.prepDefaults())

% Created by:
%   David J. Schodt (Lidke Lab, 2021)


% Add the timestamp, changing units/appearance based on the unit flag.
Time = smi_helpers.arrayMUX({Frame, (Frame-1) / FrameRate}, ...
    Params.UnitFlag);
TimeUnitString = smi_helpers.arrayMUX({'frame', 's'}, Params.UnitFlag);
Timestamp = smi_helpers.arrayMUX(...
    {sprintf('%s %i', TimeUnitString, Time), ...
    sprintf('%.2f %s', Time, TimeUnitString)}, Params.UnitFlag);
text(PlotAxes, double(Params.XPixels(1)), double(Params.YPixels(1)), ...
    double(Params.ZFrames(2)), ...
    Timestamp, 'Color', [1, 1, 1], ...
    'VerticalAlignment', 'top', ...
    'FontSize', 12*(Params.XPixels(2)-Params.XPixels(1))/128)


end
./MATLAB/+smi_vis/@GenerateMovies/setVitalParams.m
function [] = setVitalParams(obj)
%setVitalParams ensures vital parameters in obj.Params are set.
% This method will check obj.Params and ensure that the "vital" parameters
% are given useful values (i.e., values that'll let the user create a movie
% without crashing the code).

% Created by:
%   David J. Schodt (Lidke Lab, 2021)


% Set default values for the vital parameters.
DataProvided = ~isempty(obj.RawData);
TrajProvided = ~isempty(cell2mat({obj.TR.FrameNum}.'));
assert(DataProvided || TrajProvided, ...
    ['You must set GenerateMovies.RawData or ', ...
    'GenerateMovies.TR before calling this method.'])
DataSize = size(obj.RawData, 1:4);
if isempty(obj.Params.ZFrames)
    NFramesData = (DataSize(4)>1)*DataSize(4) ...
        + (DataSize(4)==1)*DataSize(3);
    if (TrajProvided && DataProvided)
        obj.Params.ZFrames = ...
            [1, max(obj.TR(1).NFrames, NFramesData)];
    elseif TrajProvided
        obj.Params.ZFrames = [1, obj.TR(1).NFrames];
    elseif DataProvided
        obj.Params.ZFrames = [1, NFramesData];
    end
end
if isempty(obj.Params.XPixels)
    if (TrajProvided && DataProvided)
        obj.Params.XPixels = ...
            [1, max(obj.TR(1).XSize, DataSize(2))];
    elseif TrajProvided
        obj.Params.XPixels = [1, obj.TR(1).XSize];
    elseif DataProvided
        obj.Params.XPixels = [1, DataSize(2)];
    end
end
if isempty(obj.Params.YPixels)
    if (TrajProvided && DataProvided)
        obj.Params.YPixels = ...
            [1, max(obj.TR(1).YSize, DataSize(1))];
    elseif TrajProvided
        obj.Params.YPixels = [1, obj.TR(1).YSize];
    elseif DataProvided
        obj.Params.YPixels = [1, DataSize(1)];
    end
end
if isempty(obj.Params.TrajColor)
    obj.Params.TrajColor = lines(numel(obj.TR));
else
    % Make sure TrajColor has as many rows as the number of trajectories in
    % obj.TR.
    NTraj = numel(obj.TR);
    NColors = size(obj.Params.TrajColor, 1);
    obj.Params.TrajColor = cat(1, obj.Params.TrajColor, ...
        repmat(obj.Params.TrajColor(end, :), ...
        [max(NTraj-NColors, 1), 1, 1])); 
end
if isempty(obj.Params.SMDColor)
    obj.Params.SMDColor = lines(numel(obj.SMD.FrameNum));
else
    % Make sure SMDColor has as many rows as the number of datapoints in
    % obj.SMD
    NData = numel(obj.SMD);
    NColors = size(obj.Params.SMDColor, 1);
    obj.Params.SMDColor = cat(1, obj.Params.SMDColor, ...
        repmat(obj.Params.SMDColor(end, :), ...
        [max(NData-NColors, 1), 1, 1])); 
end


end
./MATLAB/+smi_vis/@GenerateMovies/saveRawDataMovie.m
function [] = saveRawDataMovie(RawData, FilePath, Params, FrameRate)
%saveRawDataMovie generates and saves a movie of raw data.
% This method generates and saves a movie of the raw data provided in
% 'RawData', with some parameters from 'Params' applied to scale the data.
%
% INPUTS:
%   RawData: Stack of raw data used to generate the movie.
%            (YxXx1xFrames or YxXx3xFrames, see MATLAB's writeVideo() input
%            'img' for more details)
%   FilePath: Path to the file in which the movie will be saved. The file
%             can have either the .mp4 extension or the .avi extension.
%             (Default saved into current directory as .mp4).
%   Params: Structure of parameters that may be used to scale the data.
%           (see GenerateMovies.prepDefaults() for the full set of
%           parameters, though aren't used in this method).
%   FrameRate: Physical frame-rate that should be passed along if
%              Params.UnitFlag is true. (Default = 1)(frames per second)

% Created by:
%   David J. Schodt (Lidke Lab, 2022)


% Set defaults.
if (~exist('FilePath', 'var') || isempty(FilePath))
    FilePath = fullfile(pwd(), [smi_helpers.genTimeString(), '_movie.mp4']);
end
if (~exist('Params', 'var') || isempty(Params))
    Params = smi_vis.GenerateMovies.prepDefaults();
else
    Params = smi_helpers.padStruct(Params, smi_vis.GenerateMovies.prepDefaults());
end
if (~exist('FrameRate', 'var') || isempty(FrameRate))
    FrameRate = 1;
end

% Prepare the raw data.
assert(ismember(size(RawData, 3), [1; 3]), ...
    'Raw data must be provided as a YxXx1xFrames or YxXx3xFrames array.')
RawData = smi_vis.contrastStretch(single(RawData), [0; 1], ...
    Params.PercentileCeiling, Params.PercentileFloor, ...
    Params.MinScaleIntensity);

% Create the video writer.
[Path, File, FileExtension] = fileparts(FilePath);
switch FileExtension
    case '.mp4'
        VideoObject = ...
            VideoWriter(fullfile(Path, File), 'MPEG-4');
        VideoObject.Quality = 100;
    case '.avi'
        VideoObject = ...
            VideoWriter(fullfile(Path, File), 'Uncompressed AVI');
end
VideoObject.FrameRate = Params.FrameRate;

% Generate the movie.
open(VideoObject)
PlotFigure = figure('Resize', 'off');
PlotAxes = axes(PlotFigure);
PlotAxes.YDir = 'reverse';
ResolutionString = sprintf('-r%i', Params.Resolution);
Params.XPixels = [1, size(RawData, 2)];
Params.YPixels = [1, size(RawData, 1)];
Params.ZFrames = [1, size(RawData, 4)];
for ff = 1:size(RawData, 4)
    imshow(RawData(:, :, :, ff), [0, 1], ...
        'Parent', PlotAxes, 'Border', 'tight')
    if Params.AddTimeStamp
        smi_vis.GenerateMovies.addTimeStamp(PlotAxes, ff, FrameRate, Params)
    end
    PlotAxes.Visible = 'off'; % must be w/in loop as of R2021b
    FrameData = print(PlotFigure, '-RGBImage', '-opengl', ResolutionString);
    VideoObject.writeVideo(FrameData);
end
close(VideoObject)
close(PlotFigure)


end
./MATLAB/+smi_vis/@GenerateMovies/prepRawData.m
function [] = prepRawData(obj)
%prepRawData crops and rescales the movie data for display purposes.
% This method crops and rescales obj.RawData based on parameters in
% obj.Params.  Furthermore, this method will also revise some fields of
% obj.Params to ensure obj.Params.AutoClip is being enforced.
%
% REQUIRES:
%   Image Processing Toolbox (to use padarray())

% Created by:
%   David J. Schodt (Lidke Lab, 2021)


% Check if the flag obj.DataIsScaled is set.  If it is, we can exit early.
if obj.DataIsPrepped
    return
end

% If needed, reshape the raw data.
DataSize = size(obj.RawData, 1:4);
if ((DataSize(4)==1) && (DataSize(3)~=3))
    obj.RawData = reshape(obj.RawData, [DataSize(1:2), 1, DataSize(3)]);
    obj.RawData = repmat(obj.RawData, [1, 1, 3, 1]);
    DataSize = size(obj.RawData);
end
if isempty(obj.RawData)
    obj.setVitalParams()
    obj.RawData = zeros(obj.Params.YPixels(2), ...
        obj.Params.XPixels(2), ...
        3, ...
        obj.Params.ZFrames(2));
    obj.ScaledData = zeros(obj.Params.YPixels(2), ...
        obj.Params.XPixels(2), ...
        3, ...
        obj.Params.ZFrames(2));
    return
end

% Grab some parameters from 'TRInternal' which may be empty.  If they are 
% empty, we'll need to come up with reasonable guesses for these values.
NFrames = obj.TRInternal(1).NFrames;
XSize = obj.TRInternal(1).XSize;
YSize = obj.TRInternal(1).YSize;
if isempty(NFrames)
    NFrames = DataSize(4);
end
if isempty(XSize)
    XSize = DataSize(2);
end
if isempty(YSize)
    YSize = DataSize(1);
end
[obj.TRInternal.NFrames] = deal(NFrames);
[obj.TRInternal.XSize] = deal(XSize);
[obj.TRInternal.YSize] = deal(YSize);

% Make sure other vital parameters are set in obj.Params.
obj.setVitalParams()

% Enforce obj.Params.AutoCrop if needed.
if obj.Params.AutoCrop
    obj.Params = obj.defineCropROI(obj.TRInternal, obj.Params);
end

% Pad the raw data to ensure the cropping region is valid.
RawData = single(padarray(obj.RawData, ...
    double([max(0, YSize-DataSize(1)), ...
    max(0, XSize-DataSize(2)), ...
    0, ...
    max(0, NFrames-DataSize(4))]), 'post'));

% Crop the raw data to the specified ROI.
RawData = obj.cropRawData(RawData, obj.Params);

% Rescale the cropped data, treating each color channel independently.
NColorChannels = 3;
obj.ScaledData = zeros(size(RawData));
for cc = 1:NColorChannels
    obj.ScaledData(:, :, cc, :) = ...
        smi_vis.contrastStretch(RawData(:, :, cc, :), [0; 1], ...
        obj.Params.PercentileCeiling, obj.Params.PercentileFloor, ...
        obj.Params.MinScaleIntensity);
end
obj.DataIsPrepped = true;


end
./MATLAB/+smi_vis/@GenerateMovies/cropRawData.m
function [RawData] = cropRawData(RawData, Params)
%cropRawData crops the input data to the region specified in Params.
% This method takes the input 'RawData' and crops it to the size specified
% by the parameters in 'Params'.
%
% INPUTS:
%   RawData: Raw data to be cropped. (YSizexXSizexNFrames or
%            YSizexXSizex3xNFrames numeric array)
%   Params: Structure of movie parameters (see
%           smi_vis.GenerateMovies.prepDefaults())
%
% OUTPUTS:
%   RawData: Cropped input 'RawData'.

% Created by:
%   David J. Schodt (Lidke Lab, 2021)


% Crop the data.
if ~(isempty(Params.XPixels) && isempty(Params.YPixels) ...
        && isempty(Params.ZFrames))
    DataSize = size(RawData, 1:2);
    Params.XPixels = [max(1, round(Params.XPixels(1))), ...
        min(DataSize(2), round(Params.XPixels(2)))];
    Params.YPixels = [max(1, round(Params.YPixels(1))), ...
        min(DataSize(1), round(Params.YPixels(2)))];
    RawData = RawData(Params.YPixels(1):Params.YPixels(2), ...
        Params.XPixels(1):Params.XPixels(2), :, :);
end


end
./MATLAB/+smi_vis/@GenerateMovies/makeFrame.m
function [LineHandles] = makeFrame(PlotAxes, ...
    TR, ScaledData, Params, SMF, SMD, Frame)
%makeFrame plots a single frame for the trajectory movie.
% This method plots a single frame of the movie being prepared.
%
% INPUTS:
%   PlotAxes: Axes in which the trajectories will be plotted.
%   TR: Tracking Results structure (see smi_core.TrackingResults).
%   ScaledData: Individual image corresponding to the trajectories in
%               'TR' for frame 'Frame'.
%   Params: Structure of display parameters that will be applied to
%           the movie (see smi_vis.GenerateMovies.prepDefaults()).
%   SMF: Single Molecule Fitting structure (used for Data.PixelSize and
%        Data.FrameRate).
%   SMD: Single Molecule Data structure containing additional localizations
%        that we want to show in the movie (e.g., this might be the results
%        from a box finding algorithm, where the localizations aren't
%        associated as trajectories yet).
%   Frame: Frame of the movie that will be plotted.
%
% OUTPUTS:
%   LineHandles: Array of line handles corresponding to the trajectories
%                in 'TR'.

% Created by:
%   David J. Schodt (Lidke Lab, 2021)


% Clear the axes to make sure deleted objects aren't accumulating (which 
% can slow things down when trying to capture the frame by, e.g.,
% getframe()).
cla(PlotAxes)

% Display the raw data in the axes.
surface(PlotAxes, Params.XPixels + [0, 1], Params.YPixels + [0, 1], ...
    repmat(min(Params.ZFrames), [2, 2]), ...
    ScaledData, 'facecolor', 'texturemap')

% Plot the trajectories.
[LineHandles] = smi_vis.GenerateMovies.plotTrajectories(PlotAxes, ...
    Params, TR, [Frame-Params.MaxTrajLength, Frame], ...
    Params.TrajColor, 'Marker', Params.PlotMarker);

% Plot the points in the optional input 'SMD'.
smi_vis.GenerateMovies.plotTrajectories(PlotAxes, ...
    Params, SMD, [Frame-Params.MaxTrajLength, Frame], ...
    Params.SMDColor, 'Marker', Params.SMDMarker, 'LineStyle', 'none');

% Add a timestamp.
if Params.AddTimeStamp
    smi_vis.GenerateMovies.addTimeStamp(PlotAxes, Frame, ...
        SMF.Data.FrameRate, Params);
end


end
./MATLAB/+smi_vis/@GenerateMovies/README.md
### +smi_vis/@GenerateMovies

GenerateMovies contains methods useful for generating movies,
particularly for single-particle tracking data.

REQUIRES:
- Image Processing Toolbox
- Statistics and Machine Learning Toolbox

---
    
```
properties:
   % Structure of parameters enforced in the generated movie.
   % See prepDefaults() for a description of the parameter options and
   % playMovie() for usage.
   Params struct = struct([])

   % Raw data displayed under trajectories. (YSizexXSizex3xNFrames)
   RawData

   % Single Molecule Fitting structure with pixel size and framerate.
   SMF = smi_core.SingleMoleculeFitting;

   % Optional SMD containing points to mark in the movie.
   SMD = smi_core.SingleMoleculeData.createSMD();

   % Tracking Results structure for the trajectories.
   TR = smi_core.TrackingResults.createTR();
```

---

methods:
- **[addAxesTicks](addAxesTicks.m)**:
  prepares/displays tick labels on the axes.
- **[addTimeStamp](addTimeStamp.m)**:
  places a time stamp in a corner of the PlotAxes
- **[cropRawData](cropRawData.m)**:
  crops the input data to the region specified in Params
- **[defineCropROI](defineCropROI.m)**:
  defines the ROI surrounding the data for an auto-cropping
- **[generateMovie](generateMovie.m)**:
  generates a movie of 2D trajectories over time
- **[gui](gui.m)**:
  prepares a movie generation GUI for the GenerateMovies class
- **[makeFrame](makeFrame.m)**:
  plots a single frame for the trajectory movie
- **[playMovie](playMovie.m)**:
  prepares a movie of the trajectories in TR
- **[plotTrajectories](plotTrajectories.m)**:
  plots trajectories in the specified axes
- **[prepAxes](prepAxes.m)**:
  prepAxes prepares some features (e.g., axis limits) of the movie axes.
- **[prepDefaults](prepDefaults.m)**:
  prepares a default 'Params' structure
- **[prepRawData](prepRawData.m)**:
  crops and rescales the movie data for display purposes.
- **[saveMovie](saveMovie.m)**:
  generates and saves a movie of 2D trajectories
- **[saveRawDataMovie](saveRawDataMovie.m)**:
  generates and saves a movie of raw data
- **[setVitalParams](setVitalParams.m)**:
  ensures vital parameters in obj.Params are set (i.e.,
  values that'll let the user create a movie without crashing the code)

./MATLAB/+smi_vis/@GenerateMovies/addAxesTicks.m
function [] = addAxesTicks(obj, PlotAxes, NTicks, FormatSpec)
%addAxesTicks prepares/displays tick labels on the axes.
% This method attempts to make nice choices for the ticks/tick labels on
% the provided axes.
%
% INPUTS:
%   PlotAxes: Axes that will be modified. (Default = obj.MovieAxes)
%   NTicks: Number of ticks to be displayed in the visible axes. 
%           (Default = 5)
%   FormatSpec: Tick number formatting specifiers (see usage of sprintf()
%               below when obj.UnitFlag is true)(Default = '%.1f')

% Created by:
%   David J. Schodt (Lidke Lab, 2022)


% Set defaults if needed.
if (~exist('PlotAxes', 'var') || isempty(PlotAxes) || ~isvalid(PlotAxes))
    PlotAxes = obj.MovieAxes;
end
if (~exist('NTicks', 'var') || isempty(NTicks))
    NTicks = 5;
end
if (~exist('FormatSpec', 'var') || isempty(FormatSpec))
    FormatSpec = '%.1f';
end

% Revise axes ticks based on the unit flag.
PlotAxes.XTickMode = 'manual';
PlotAxes.YTickMode = 'manual';
PlotAxes.ZTickMode = 'manual';
PlotAxes.XTick = linspace(PlotAxes.XLim(1), PlotAxes.XLim(2), NTicks);
PlotAxes.YTick = linspace(PlotAxes.YLim(1), PlotAxes.YLim(2), NTicks);
PlotAxes.ZTick = linspace(PlotAxes.ZLim(1), PlotAxes.ZLim(2), NTicks);
if obj.Params.UnitFlag
    PlotAxes.XTickLabelMode = 'manual';
    PlotAxes.YTickLabelMode = 'manual';
    PlotAxes.ZTickLabelMode = 'manual';
    xtickformat(PlotAxes, FormatSpec)
    ytickformat(PlotAxes, FormatSpec)
    ztickformat(PlotAxes, FormatSpec)
    XTicks = (PlotAxes.XTick-1) * obj.SMF.Data.PixelSize;
    YTicks = (PlotAxes.YTick-1) * obj.SMF.Data.PixelSize;
    ZTicks = (PlotAxes.ZTick-1) / obj.SMF.Data.FrameRate;
    PlotAxes.XTickLabel = num2str(XTicks.', FormatSpec);
    PlotAxes.YTickLabel = num2str(YTicks.', FormatSpec);
    PlotAxes.ZTickLabel = num2str(ZTicks.', FormatSpec);
else
    xtickformat(PlotAxes, '%i')
    ytickformat(PlotAxes, '%i')
    ztickformat(PlotAxes, '%i')
end


end
./MATLAB/+smi_vis/@GenerateMovies/defineCropROI.m
function [Params] = defineCropROI(TR, Params)
%defineCropOI defines the ROI surrounding the data for an auto-cropping.
% This method defines a ROI encompassing the data in TR based on some of
% the parameters in Params (e.g., enforcing a minimum ROI size, boundary
% padding, etc.).
%
% INPUTS:
%   TR: Tracking Results structure containing trajectories.
%   Params: Structure of movie parameters (see
%           smi_vis.GenerateMovies.prepDefaults())
%
% OUTPUTS:
%   Params: Input 'Params' with XPixels, YPixels, and ZFrames (possibly)
%           being updated to define an auto-cropping ROI around the data in
%           'TR'.

% Created by:
%   David J. Schodt (Lidke Lab, 2021)


% Enforce the temporal cropping and padding.
AllFrames = cell2mat({TR.FrameNum}.');
if Params.CropToDimerCandidates
    DimerCandidateBool = cell2mat({TR.DimerCandidateBool}.');
    AllFrames = AllFrames(DimerCandidateBool);
else
    DimerCandidateBool = ones(size(AllFrames), 'logical');
end
MinFrame = smi_helpers.arrayMUX({min(AllFrames), 1}, isempty(AllFrames));
MaxFrame = smi_helpers.arrayMUX({max(AllFrames), TR(1).NFrames}, ...
    isempty(AllFrames));
Params.ZFrames = [max(1, MinFrame-Params.NPadFrames), ...
    min(TR(1).NFrames, MaxFrame+Params.NPadFrames)];

% Enforce the min. XY range and the XY padding.
IsDisplayed = ...
    ismember(AllFrames, Params.ZFrames(1):Params.ZFrames(2));
AllX = cell2mat({TR.X}.');
AllX = AllX(DimerCandidateBool);
MinX = smi_helpers.arrayMUX({min(AllX(IsDisplayed)), 1}, isempty(AllX));
MaxX = smi_helpers.arrayMUX({max(AllX(IsDisplayed)), TR(1).XSize}, ...
    isempty(AllX));
XPixels = [max(1, MinX-Params.NPadPixels), ...
    min(TR(1).XSize, MaxX+Params.NPadPixels)];
XWidth = max(diff(XPixels), Params.MinXYRange);
XCenterIdeal = mean(XPixels);
XStart = max(1, floor(min(XCenterIdeal-XWidth/2, TR(1).XSize-XWidth)));
XEnd = min(TR(1).XSize, ceil(XStart+XWidth));
Params.XPixels = [XStart, XEnd];
AllY = cell2mat({TR.Y}.');
AllY = AllY(DimerCandidateBool);
MinY = smi_helpers.arrayMUX({min(AllY(IsDisplayed)), 1}, isempty(AllY));
MaxY = smi_helpers.arrayMUX({max(AllY(IsDisplayed)), TR(1).YSize}, ...
    isempty(AllY));
YPixels = [max(1, MinY-Params.NPadPixels), ...
    min(TR(1).YSize, MaxY+Params.NPadPixels)];
YWidth = max(diff(YPixels), Params.MinXYRange);
YCenterIdeal = mean(YPixels);
YStart = max(1, floor(min(YCenterIdeal-YWidth/2, TR(1).YSize-YWidth)));
YEnd = min(TR(1).YSize, ceil(YStart+YWidth));
Params.YPixels = [YStart, YEnd];


end
./MATLAB/+smi_vis/@GenerateMovies/saveMovie.m
function [] = saveMovie(obj, SavePath)
%saveMovie generates and saves a movie of 2D trajectories.
%
% INPUTS:
%   SavePath: Complete path to the movie file in which the movie will be
%             saved (Default is a file selection prompt).
%   Profile: Movie profile option sent to the video writer. See input
%            'profile' to MATLAB built in VideoWriter.
%            (Default = 'Motion JPEG AVI')

% Created by:
%   David J. Schodt (Lidke Lab, 2021)


% Set defaults if needed.
if (~exist('SavePath', 'var') || isempty(SavePath))
    [File, Path] = uiputfile({'*.mp4', 'MPEG-4 (*.mp4)'; ...
        '*.avi', 'Uncompressed AVI (*.avi)'});
    SavePath = fullfile(Path, File);
end

% Create the video writer.
[Path, File, FileExtension] = fileparts(SavePath);
switch FileExtension
    case '.mp4'
        obj.VideoObject = ...
            VideoWriter(fullfile(Path, File), 'MPEG-4');
        obj.VideoObject.Quality = 100;
    case '.avi'
        obj.VideoObject = ...
            VideoWriter(fullfile(Path, File), 'Uncompressed AVI');
end
obj.VideoObject.FrameRate = obj.Params.FrameRate;

% Create a fresh figure in which we'll prepare the movie for saving (this
% is done due to the usage of print() in obj.playMovie(), which will print
% the whole figure, and thus GUI elements if we prepare the movie within
% the GUI).
PlotFigure = figure();
OriginalAxes = obj.MovieAxes;
obj.MovieAxes = axes(PlotFigure);
obj.MovieAxes.Toolbar.Visible = 'off';

% Generate and save the movie.
obj.generateMovie()
close(PlotFigure)
obj.MovieAxes = OriginalAxes;


end
./MATLAB/+smi_vis/plotCDFs.m
function [varargout] = plotCDFs(PlotAxes, XData, CDFs, Color)
%plotCDFs plots multiple CDFs on the same plot.
% This method plots the CDFs in the cell array 'CDFs' in the same axes,
% ensuring that they both span the same range of x values (this improves
% appearance versus, e.g., having one CDF reach 1 very quickly and then not
% be present from the far right of the plot). 
%
% INPUTS:
%   PlotAxes: Axes in which CDFs will be added. (Default = gca())
%   XData: Cell array of x data corresponding to entries of CDFs.
%          (Nx1 cell array of vectors)
%   CDFs: Cell array of CDFs. (Nx1 cell array of vectors)
%   Color: Matrix defining the colors of each CDF. 
%          (Nx3 matrix of RGB triplets)(Default sampled from lines() 
%           colormap)
%
% OUTPUTS:
%   varargout{1}: Set of linehandles corresponding to the plotted CDFs.
%   varargout{2}: Axes in which the plot was made.

% Created by:
%   David J. Schodt (Lidke Lab, 2021)


% Set defaults and validate inputs.
if (~exist('PlotAxes', 'var') || isempty(PlotAxes) || ~isvalid(PlotAxes))
    PlotAxes = gca();
end
NCDFs = numel(CDFs);
if (~exist('Color', 'var') || isempty(Color))
    Color = lines(NCDFs);
end
assert(size(Color, 2) >= 3, 'Input ''Color'' must be a 3 column matrix!')
assert(size(Color, 1) >= NCDFs, ...
    'Input ''Color'' must have at least as many rows as the number of CDFs!')

% Pad the CDFs so that the far right tails all span the full x range
% (unless the last entry of a CDFs is < 1, in which case we'll allow it to
% stop early).  Also, make sure the data are given as column vectors.
MaxX = max(cellfun(@(X) max(X), XData));
for ii = 1:NCDFs
    % Ensure data are column vectors.
    if isrow(XData{ii})
        XData{ii} = XData{ii}.';
    end
    if isrow(CDFs{ii})
        CDFs{ii} = CDFs{ii}.';
    end
    
    % Pad the arrays.
    if ((CDFs{ii}(end)==1) && (XData{ii}(end)~=MaxX))
        XData{ii} = [XData{ii}; MaxX];
        CDFs{ii} = [CDFs{ii}; 1];
    end
end

% Plot the CDFs.
hold(PlotAxes, 'on')
LineHandles = gobjects(NCDFs, 1);
for ii = 1:NCDFs
    LineHandles(ii) = stairs(PlotAxes, XData{ii}, CDFs{ii}, ...
        'Color', Color(ii, :));
end

% Prepare outputs.
if (nargout() > 0)
    varargout{1} = LineHandles;
end
if (nargout() > 1)
    varargout{2} = PlotAxes;
end


end
./MATLAB/+smi_vis/@GenerateImages/driftImage.m
function [DriftIm, DriftImRGB] = driftImage(SMR, SRImageZoom)
%driftImage generates 2D histogram image from SR data
%
%   INPUT
%      SMR - structure containing at least fields 'X', 'Y', 'XSize', 'YSize',
%            'FileNum', and 'FrameNum' having the x and y coordinates, rawdata
%            x and y sizes, file number and frame number of localizations to be
%            plotted
%      SRImageZoom - zoom factor for drift image 
%
%   OUTPUT
%      If no output args are given drift image will be displayed
%      DriftIm    - gray value drift image
%      DriftImRGB - RBG drift image
%
%   REQUIRES
%      Matlab 2014b or higher

% Created by:
%    Marjolein Meddens, Lidke Lab 2017

% check input
if nargin <1
    error('smi_vis:GenerateImages:driftImage: Not enough input arguments. Please input atleast SMR');
end

if nargin<2
    disp('No input on SRImageZoom, default value of 10 assigned');
    SRImageZoom=10;
end


RawDataSize=[SMR.YSize SMR.XSize];

% calculate size of drift image
xsize=(RawDataSize(2)*SRImageZoom);
ysize=(RawDataSize(1)*SRImageZoom);
% transform coordinates to match image size
x=single(SMR.X*SRImageZoom);
y=single(SMR.Y*SRImageZoom);
% create time stamp of each localization
NperFrame=single(max(SMR.FrameNum)+1);
t=single(SMR.FrameNum)+NperFrame*single(SMR.DatasetNum-1);
t=single(t);
% create drift image
DriftIm = c_HistImTime(ysize,xsize,y,x,t);
% create output
cm=jet(256);
cm(1,:)=[0 0 0];
if nargout==0
    imshow(DriftIm,cm);
    %colormap(cm);
elseif nargout == 2
    [DriftImRGB]=smi_vis.GenerateImages.colorImage(DriftIm,cm);
end

end

./MATLAB/+smi_vis/@GenerateImages/driftImage_unitTest.m
function success = driftImage_unitTest()
%driftImage_unitTest tests all functionality of driftImage.

success = 0;
fprintf('\nTesting smi_vis.GenerateImages.driftImage...\n');

SaveDir = smi_helpers.mkSMITETmpDir('unitTest', 'driftImage');

% create random input
fprintf('Creating data...\n');
rng('default')
pointsPerPoint = 400;
X = 1 + 37*rand(pointsPerPoint,1);
Y = 1 + 27*rand(pointsPerPoint,1);
% simulate drift
SMR.X = zeros(10*pointsPerPoint,1);
SMR.Y = zeros(10*pointsPerPoint,1);
SMR.XSize = 40;
SMR.YSize = 30;
SMR.DatasetNum = zeros(10*pointsPerPoint,1);
SMR.FrameNum = zeros(size(SMR.X));
for ii = 1 : 10
    SMR.X(((ii-1)*pointsPerPoint)+1 : ii*pointsPerPoint) = X + (ii-1)/10;
    SMR.Y(((ii-1)*pointsPerPoint)+1 : ii*pointsPerPoint) = Y + (ii-1)/10;
    SMR.DatasetNum(((ii-1)*pointsPerPoint)+1 : ii*pointsPerPoint) = ii;
    SMR.FrameNum(((ii-1)*pointsPerPoint)+1 : ii*pointsPerPoint) = 1:1:pointsPerPoint;
end
% input parameters
SRImageZoom = 4;

% test with no output
fprintf('Testing with no output...\n');
smi_vis.GenerateImages.driftImage(SMR,SRImageZoom);
%diptruesize(gcf,200);
saveas(gcf, fullfile(SaveDir, 'dI1.png'));
pause(3);
close gcf
% test with single output variable
fprintf('Testing with single output variable...\n');
[driftIm] = smi_vis.GenerateImages.driftImage(SMR,SRImageZoom);
h = figure; imshow(driftIm);
%diptruesize(h,200);
saveas(gcf, fullfile(SaveDir, 'dI2.png'));
pause(3)
close(h)
% test with 2 output variables
fprintf('Testing with two output variables...\n');
[driftIm,driftImRGB] = smi_vis.GenerateImages.driftImage(SMR,SRImageZoom);
h1 = figure; imshow(driftIm);
saveas(gcf, fullfile(SaveDir, 'dI3.png'));
%diptruesize(h1,200);
h2 = figure; imshow(driftImRGB);
saveas(gcf, fullfile(SaveDir, 'dI4.png'));
%diptruesize(h2,200);
%pos = h2.Position;
%pos(2) = pos(2)-300;
%h2.Position = pos;
pause(3)
close(h1,h2)

% finish
fprintf('Done, test successful!\n\n');
success = 1;
end

./MATLAB/+smi_vis/@GenerateImages/blobColorOverlay_unitTest.m
function success = blobColorOverlay_unitTest()
%blobColorOverlay_unitTest tests all functionality of blobColorOverlay.

success = 0;
fprintf('\nTesting smi_vis.GenerateImages.blobColorOverlay...\n');

SaveDir = smi_helpers.mkSMITETmpDir('unitTest', 'blobColorOverlay');

% create sequence and SMD
SZ=256;
NFrames = 100;
NBlobs = 10000;
Background = 5;

SMD.X = (SZ-1)*rand(NBlobs,1);
SMD.Y = (SZ-1)*rand(NBlobs,1);
SMD.Z = [];
SMD.Photons=1000+100*randn(NBlobs,1);
SMD.Photons(SMD.Photons<=0) = 0;
SMD.Background=zeros(NBlobs,1); % no background for individual emitters
SMD.PSFSigma=1.3+0.1*randn(NBlobs,1);
SMD.FrameNum = 1+round((NFrames-1)*rand(NBlobs,1));
SMD.Bg=5*ones(NBlobs,1); % now add background to SMD for overlay
SMD.XSize = SZ;
SMD.YSize = SZ;
SMD.NFrames = NFrames;
[~,Sequence] = smi_sim.GaussBlobs.gaussBlobImage(SMD);

Sequence = Sequence+Background; % add background to the whole sequence
% remove particles from SMD to simulate not all getting fit
SMD.X = SMD.X(1:NBlobs/2);
SMD.Y = SMD.Y(1:NBlobs/2);
SMD.Photons=SMD.Photons(1:NBlobs/2);
SMD.PSFSigma=SMD.PSFSigma(1:NBlobs/2);
SMD.FrameNum = SMD.FrameNum(1:NBlobs/2);
SMD.Bg=5*ones(NBlobs/2,1); % now add background to SMD for overlay

% test with no output
%fprintf('Testing with no output...\n');
%smi_vis.GenerateImages.blobColorOverlay(Sequence,SMD);
%fprintf('Check sequence if you like, it will close in 20 sec...\n');
%pause(20)
%close all

% test with output
fprintf('Testing with output...\n');
[BlobImage] = smi_vis.GenerateImages.blobColorOverlay(Sequence,SMD);
fprintf('Check sequence if you like, it will close in 20 sec...\n');
sliceViewer(BlobImage);
saveas(gcf, fullfile(SaveDir, 'BlobImage.png'));
pause(20)
close all

% finish
fprintf('Done, test successful!\n\n');
success = 1;
end

./MATLAB/+smi_vis/@GenerateImages/dispIm.m
function dispIm()
%dispIm produces a flexible GUI for multiple images.
%
%When called a gui pops up and multiple images can be uploaded using 
%"Choose Image" bottom. The "Backward" and "Forward" bottoms allow going
%back and forth between the loaded images. Tools from the menu bar, such as
%zoom in and zoom out can be used to adjust the dispalyed images. The
%adjustments do not go back to default when moving back and forth between
%the images

% Created by:
%    Mohamadreza Fazel 2019, Lidke Lab

Im={};
map={};
Num = 1;
guiFig = figure('Visible','on','Position',[250,100,710,800],'Name',...
    'Image display','NumberTitle','off','Interruptible','off');

%HAxis1 = axes('Units','Pixel','YTick',[],'XTick',[],'Position',[10,10,690,720]);
HAxis1 = axes('Units','normalize','YTick',[],'XTick',[],'Position',[.05,0.02,0.9,0.88]);

fileButton1 = uicontrol('Style', 'pushbutton','String','Choose Image',...
    'Unit','normalize','Enable','on','Position', [0.1 0.92 0.15 0.06],'Callback',@getFileList1);

 ForwardButton = uicontrol('Style', 'pushbutton','String','Forward',...
    'Unit','normalize','Enable','on','Position', [0.5 0.92 0.15 0.06],'Callback',@forward);
 BackwardButton = uicontrol('Style', 'pushbutton','String','Backward',...
    'Unit','normalize','Enable','on','Position', [0.75 0.92 0.15 0.06],'Callback',@backward);

function getFileList1(~,~) % Choose data file(s) and list them in the File List box
[filename, pathname]=uigetfile('Y:\*.png;*.tif','MultiSelect','on');
Im = cell(1,length(filename));
map = Im;
for ii = 1:length(filename)
[ImT,MapT] = imread(fullfile(pathname,filename{ii}));
Im{ii}=ImT;
map{ii}=MapT;
end
axes(HAxis1);imshow(Im{1},map{1});
end

function forward(~,~)
Num = Num+1;
if Num > length(Im)
    Num = 1; 
end
HAxis1.Children.CData = Im{Num};
end

function backward(~,~)
        Num = Num-1;
if Num == 0
    Num = length(Im);
end
HAxis1.Children.CData = Im{Num};
end
end

./MATLAB/+smi_vis/@GenerateImages/overlayNImages.m
function [OverlayImage, ColorOrderTag] = overlayNImages(ImageStack)
%overlayNImages will fuse N images together into a single overlay image.
% This method will take a stack of N images (an mxnxN array) and overlay
% these images (each being a different color channel) into an output mxn
% image OverlayImage.  N must be between 2 and 4.
%
% NOTE from DJS 9/1/2020: I seem to remember there being a bug with the
%                         color combination math that just happens to not
%                         show up with the colors chosen below, but I can't
%                         remember how it came up/how to fix it at this
%                         time.
%
% INPUTS:
%   ImageStack: (mxnxN) Array of N mxn images which are to be overlain.
%
% OUTPUTS:
%   OverlayImage: (mxnx3) Three color RGB array of the N images from
%                 ImageStack overlain in different color channels.
%   ColorOrderTag: A character array to specify the ordering of the colors.
%                  For example, if ImageStack is mxnx2, OverlayImage will
%                  be a green and magenta overlay of these two images.  The
%                  image ImageStack(:, :, 1) will correspond to green and
%                  ImageStack(:, :, 2) will correspond to magenta, and thus
%                  ColorOrderTag = 'GM'.
%
% Created by:
%   David J. Schodt (Lidke Lab, 2018)


% Ensure that more than one image exists in the stack.  If not, set
% OverlayImage to the input and do not proceed.
if (size(ImageStack, 3) < 2)
    OverlayImage = ImageStack;
    return
end

% Ensure that there aren't more than 4 images in the stack (this code isn't
% written to handle that many).
if (size(ImageStack, 3) > 4)
    error('Input ImageStack cannot contain more than 4 images.');
end

% Generate our color overlay images (3 channel images).
if isfloat(ImageStack)
    % If the input stack was a float, make the output OverlayImage a
    % single.
    OverlayImage = zeros([size(ImageStack, 1), size(ImageStack, 2), 3], ...
        'single');
else
    % If the input stack wasn't a float, make the output OverlayImage a
    % uint8.
    OverlayImage = zeros([size(ImageStack, 1), size(ImageStack, 2), 3], ...
        'uint8');
end
NImages = size(ImageStack, 3); % number of images to overlay
if (NImages == 2)
    % Produce a green (G) and magenta (R+B) color overlay for the two
    % image, with the first image being green.
    
    % Seperate our images to improve code readability.
    Image1 = ImageStack(:, :, 1);
    Image2 = ImageStack(:, :, 2);
    
    % Define the red channel of the overlay image.
    OverlayImage(:, :, 1) = Image2;
    
    % Define the green channel of the overlay image.
    OverlayImage(:, :, 2) = Image1;
    
    % Define the blue channel of the overlay image.
    OverlayImage(:, :, 3) = Image2;
    
    % Scale the color channels individually to [0, 1].
    OverlayImage(:, :, 1) = OverlayImage(:, :, 1) ...
        ./ max(max(OverlayImage(:, :, 1)));
    OverlayImage(:, :, 2) = OverlayImage(:, :, 2) ...
        ./ max(max(OverlayImage(:, :, 2)));
    OverlayImage(:, :, 3) = OverlayImage(:, :, 3) ...
        ./ max(max(OverlayImage(:, :, 3)));
    
    % Save a filename tag to specify the color order for the images
    % (first character -> color for image 1,
    % second character -> color for image 2, ...).
    ColorOrderTag = 'GM';
end

if (NImages == 3)
    % Produce a green (G), magenta (R+B), and cyan (G+B) color overlay for
    % the three images, with the first images being green, second image
    % magenta, and third image cyan.
    
    % Seperate our images to improve code readability.
    Image1 = ImageStack(:, :, 1);
    Image2 = ImageStack(:, :, 2);
    Image3 = ImageStack(:, :, 3);
    
    % Define the red channel of the overlay image.
    OverlayImage(:, :, 1) = Image2;
    
    % Define the green channel of the overlay image.
    OverlayImage(:, :, 2) = Image1 + Image3;
    
    % Define the blue channel of the overlay image.
    OverlayImage(:, :, 3) = Image2 + Image3;
    
    % Scale the color channels individually to [0, 1].
    OverlayImage(:, :, 1) = OverlayImage(:, :, 1) ...
        ./ max(max(OverlayImage(:, :, 1)));
    OverlayImage(:, :, 2) = OverlayImage(:, :, 2) ...
        ./ max(max(OverlayImage(:, :, 2)));
    OverlayImage(:, :, 3) = OverlayImage(:, :, 3) ...
        ./ max(max(OverlayImage(:, :, 3)));
    
    % Save a filename tag to specify the color order for the
    % images (first character -> color for image 1, second
    % character -> color for image 2, ...).
    ColorOrderTag = 'GMC';
end

if (NImages == 4)
    % Produce a green (G), magenta (R+B), cyan (G+B), and yellow (R+G)
    % color overlay for the three images, with the first image being green,
    % second image magenta, third image cyan, and fourth image yellow.
    
    % Seperate our images to improve code readability.
    Image1 = ImageStack(:, :, 1);
    Image2 = ImageStack(:, :, 2);
    Image3 = ImageStack(:, :, 3);
    Image4 = ImageStack(:, :, 4);
    
    % Define the red channel of the overlay image.
    OverlayImage(:, :, 1) = Image2 + Image4;
    
    % Define the green channel of the overlay image.
    OverlayImage(:, :, 2) = Image1 + Image3 + Image4;
    
    % Define the blue channel of the overlay image.
    OverlayImage(:, :, 3) = Image2 + Image3;
    
    % Scale the color channels individually to [0, 1].
    OverlayImage(:, :, 1) = OverlayImage(:, :, 1) ...
        ./ max(max(OverlayImage(:, :, 1)));
    OverlayImage(:, :, 2) = OverlayImage(:, :, 2) ...
        ./ max(max(OverlayImage(:, :, 2)));
    OverlayImage(:, :, 3) = OverlayImage(:, :, 3) ...
        ./ max(max(OverlayImage(:, :, 3)));
    
    % Save a filename tag to specify the color order for the
    % images (first character -> color for image 1,
    % second character -> color for image 2, ...).
    ColorOrderTag = 'GMCY';
end

% For non-float images, we need to rescale the pixel values.
if ~isfloat(OverlayImage)
    OverlayImage = OverlayImage * 255;
end


end
./MATLAB/+smi_vis/@GenerateImages/colorImage_unitTest.m
function success = colorImage_unitTest()
%colorImage_unitTest tests all functionality of colorImage.

success = 0;
fprintf('\nTesting smi_vis.GenerateImages.colorImage...\n');
fprintf('Creating image...\n');

SaveDir = smi_helpers.mkSMITETmpDir('unitTest', 'colorImage');

% create image
SZ = 256;
NFrames = 1;
Data = smi_sim.GaussBlobs.genRandomBlobImage(SZ,NFrames);

% inputs
ColorMap = parula(256);
sortedVals = sort(Data(:));
NumEl = numel(sortedVals);
MinMax = [sortedVals(round(NumEl*0.1)),sortedVals(round(NumEl*0.9))];

% test with only image input
fprintf('Testing with image as only input...\n');
[RGBim]=smi_vis.GenerateImages.colorImage(Data);
imshow(RGBim);
saveas(gcf, fullfile(SaveDir, 'cI1.png'));
pause(3);
close all
% test with image and colormap input
fprintf('Testing with image and colormap input...\n');
[RGBim]=smi_vis.GenerateImages.colorImage(Data,ColorMap);
imshow(RGBim)
saveas(gcf, fullfile(SaveDir, 'cI2.png'));
pause(3)
close all
% test without colormap (default should be hot)
fprintf('Testing with image, colormap and minmax input...\n');
[RGBim]=smi_vis.GenerateImages.colorImage(Data,ColorMap,MinMax);
imshow(RGBim)
saveas(gcf, fullfile(SaveDir, 'cI3.png'));
pause(3)
close all

% finish
fprintf('Done, test successful!\n\n');
success = 1;
end

./MATLAB/+smi_vis/@GenerateImages/scalebar.m
function [ImageOut,Image] = scalebar(Image,PixelSize,Length,Location)
%scalebar puts a scalebar of a desired length on the input image.
%   
%   Creates a scale bar of desired length on the input image. 
%   
% INPUTS:
%   Image:      Input image
%   PixelSize:  Pixel size of input image (in um)
%   Length:     Desired length of the scalebar (in um)
%   Location:   Desired location of scalebar on image. Options are
%   {topleft, topright, bottomleft, bottomright}. Default is set as
%   'bottomright'.
%
% OUTPUTS:
%   Imageout:   Output image with scalebar superimposed
%   Image:      The same as input image
%
% REQUIRES:
%   Matlab
%   Statistics Toolbox

% Created by
%   Sandeep Pallikkuth, Lidke Lab, 2017       

if nargin<3
    msg1='Not enough input. Please input image, pixel size, scalebar length and scale bar location !';
    error(msg1);
elseif nargin<4
    Location='bottomright';
end

% Processing input image
sizein=size(Image);     % determine size of image
channels=length(sizein);    
in=Image;

% Scalebar Color
sbcolor=[255 255 255];    %white scalebar

% Calculate scale bar length
if PixelSize>Length
    disp('Input scalebar length smaller than pixel size. Scalebar length re-sized to 10 pixels');
    barlength=10;
else
    barlength=round(Length/PixelSize);
end

%fprintf( ...
% 'scalebar: size = %d, PixelSize = %g um, Length = %d um, barlength = %d\n',...
%        sizein(1), PixelSize, Length, barlength);


% Calculate scale bar width
barwidth=round(sizein(2)*0.015);

%
if channels==3
    switch Location
        case 'bottomright'
            in(round(0.9*sizein(1))-barwidth:round(0.9*sizein(1)),round(0.9*sizein(2))-barlength:round(0.9*sizein(2)),1)=sbcolor(1);
            in(round(0.9*sizein(1))-barwidth:round(0.9*sizein(1)),round(0.9*sizein(2))-barlength:round(0.9*sizein(2)),2)=sbcolor(2);
            in(round(0.9*sizein(1))-barwidth:round(0.9*sizein(1)),round(0.9*sizein(2))-barlength:round(0.9*sizein(2)),3)=sbcolor(3);
        case 'bottomleft'
            in(round(0.9*sizein(1))-barwidth:round(0.9*sizein(1)),round(0.1*sizein(2)):round(0.1*sizein(2))+barlength,1)=sbcolor(1);
            in(round(0.9*sizein(1))-barwidth:round(0.9*sizein(1)),round(0.1*sizein(2)):round(0.1*sizein(2))+barlength,2)=sbcolor(2);
            in(round(0.9*sizein(1))-barwidth:round(0.9*sizein(1)),round(0.1*sizein(2)):round(0.1*sizein(2))+barlength,3)=sbcolor(3);
        case 'topright'
            in(round(0.1*sizein(1))-barwidth:round(0.1*sizein(1)),round(0.9*sizein(2))-barlength:round(0.9*sizein(2)),1)=sbcolor(1);
            in(round(0.1*sizein(1))-barwidth:round(0.1*sizein(1)),round(0.9*sizein(2))-barlength:round(0.9*sizein(2)),2)=sbcolor(2);
            in(round(0.1*sizein(1))-barwidth:round(0.1*sizein(1)),round(0.9*sizein(2))-barlength:round(0.9*sizein(2)),3)=sbcolor(3);
        case 'topleft'
            in(round(0.1*sizein(1))-barwidth:round(0.1*sizein(1)),round(0.1*sizein(2)):round(0.1*sizein(2))+barlength,1)=sbcolor(1);
            in(round(0.1*sizein(1))-barwidth:round(0.1*sizein(1)),round(0.1*sizein(2)):round(0.1*sizein(2))+barlength,2)=sbcolor(2);
            in(round(0.1*sizein(1))-barwidth:round(0.1*sizein(1)),round(0.1*sizein(2)):round(0.1*sizein(2))+barlength,3)=sbcolor(3);
    end
else
    switch Location
        case 'bottomright'
            in(round(0.9*sizein(1))-barwidth:round(0.9*sizein(1)),round(0.9*sizein(2))-barlength:round(0.9*sizein(2)),1)=sbcolor(1);
        case 'bottomleft'
            in(round(0.9*sizein(1))-barwidth:round(0.9*sizein(1)),round(0.1*sizein(2)):round(0.1*sizein(2))+barlength,1)=sbcolor(1);
        case 'topright'
            in(round(0.1*sizein(1))-barwidth:round(0.1*sizein(1)),round(0.9*sizein(2))-barlength:round(0.9*sizein(2)),1)=sbcolor(1);
        case 'topleft'
            in(round(0.1*sizein(1))-barwidth:round(0.1*sizein(1)),round(0.1*sizein(2)):round(0.1*sizein(2))+barlength,1)=sbcolor(1);
    end
end    

ImageOut=in;

if nargout == 0
    imshow(ImageOut)
end

end


./MATLAB/+smi_vis/@GenerateImages/blobColorOverlay.m
function [OverlayImage] = blobColorOverlay(Sequence,SMD,AutoScale)
%blobColorOverlay creates overlay of fitted emitters onto data.
%   
%   Creates color overlay of fitted emitters (green) onto data (red). 
%   smi_sim.GaussBlobs.gaussBlobImage is used to generate the blobs of the
%   fitted emitters. 
%   
% INPUTS:
%   Sequence:   Data stack onto which fitted emitters will be overlayed
%   SMD:        Structure containing at least the following fields:
%       X:          Gaussian Blob Center X (Pixels) 
%       Y:          Gaussian Blob Center Y (Pixels) 
%       PSFSigma:   Gaussian Sigma (Pixels).  Can be scalar or 1x2. 
%       Photons:    Integrated Photons in Blob 
%       Bg:         Photons per Pixel
%       FrameNum:   Frame number of Gaussian Blob Location
%   AutoScale   scale the intensity of the Model based on max intensity of
%               rawdata (0:not change intensity of the model or 1:change it)
%
% OUTPUTS:
%   OverlayImage:   (Optional) Image of fitted emitters (green) overlayed 
%                   onto data (red). If no output is given, overlay image
%                   will be displayed
%
% REQUIRES:
%   Statistics Toolbox
%   Parallel Procesing Toolbox
%   NVidia GPU

% Created by:
%   Marjolein Meddens and Hanieh Mazloom-Farsibaf 2017, Lidke Lab        

if nargin<3
    AutoScale=0;
end 

% generate blob stack for fits
SZ = [size(Sequence,1),size(Sequence,2)];
NFrames = size(Sequence,3);
SMD.XSize = SZ(1);
SMD.YSize = SZ(2);
[Model] = smi_sim.GaussBlobs.gaussBlobImage(SMD);

% scale the intensity of the Model based on the Max(data)
if AutoScale && max(Sequence(:))>max(Model(:))
    Model2=Model*(2*(max(Sequence(:))/max(Model(:))));
else
    Model2=Model;
end
% overlay onto data
OverlayImage=smi_vis.GenerateImages.rgbImage(Sequence,Model2,Model2*0);

if nargout == 0
    smi_vis.GenerateImages.showim(OverlayImage);
end

end

./MATLAB/+smi_vis/@GenerateImages/circleImage_unitTest.m
function [Success] =  circleImage_unitTest()
%circleImage_unitTest tests the class method circleImage().
%
% OUTPUTS:
%   Success: A boolean to indicate the success (1) or failure (0) of this
%            unit test.

% Created by:
%   David J. Schodt (Lidke lab, 2021)

SaveDir = smi_helpers.mkSMITETmpDir('unitTest', 'circleImage');

% Seed the random number generator so that the simulated SMD is predictable
% NOTE: If this is changed, there will almost certainly be entries of
%       Success that are 0.
rng(1234)

% Simulate several emitter positions.
% NOTE: Most of these parameters were chosen arbitrarily, HOWEVER, there
%       may be some checks below that might be affected by changing these
%       parameters (i.e., causing some elements of Success to be 0 even if
%       things worked correctly).
FrameSize = 64;
NEmitters = 100;
Coordinates = FrameSize * rand(NEmitters, 2);

% Construct two SMD structures, each with half of the emitters.
NEmittersPerChannel = round(NEmitters / 2);
SMD1 = smi_core.SingleMoleculeData.createSMD();
SMD1.XSize = FrameSize;
SMD1.YSize = FrameSize;
SMD1.X = Coordinates(1:NEmittersPerChannel, 1);
SMD1.Y = Coordinates(1:NEmittersPerChannel, 2);
SMD1.X_SE = 0.1*rand(NEmittersPerChannel, 1) + 0.1;
SMD1.Y_SE = SMD1.X_SE;
SMD2 = smi_core.SingleMoleculeData.createSMD();
SMD2.XSize = FrameSize;
SMD2.YSize = FrameSize;
SMD2.X = Coordinates(NEmittersPerChannel+1:end, 1);
SMD2.Y = Coordinates(NEmittersPerChannel+1:end, 2);
SMD2.X_SE = 0.1*rand(NEmittersPerChannel, 1) + 0.1;
SMD2.Y_SE = SMD2.X_SE;

% Concatenate the two SMDs and try to make a two-color image (I'm doing
% this for the sake of demonstration in case anybody uses this unit test to
% guide their usage of circleImage()).
SMDAll = smi_core.SingleMoleculeData.catSMD(SMD1, SMD2);
ColorMapGreen = repmat([0, 1, 0], NEmittersPerChannel, 1);
ColorMapMagenta = repmat([1, 0, 1], NEmittersPerChannel, 1);
ColorMap = [ColorMapGreen; ColorMapMagenta];
[CircleImage, CircleImageRGB, SRImageZoom] = ...
    smi_vis.GenerateImages.circleImage(SMDAll, ColorMap, [], 16);
figure; imshow(CircleImage);
saveas(gcf, fullfile(SaveDir, 'CircleImage.png'));
figure; imshow(CircleImageRGB);
saveas(gcf, fullfile(SaveDir, 'CircleImageRGB.png'));
Success = 1;


end

./MATLAB/+smi_vis/@GenerateImages/circleImage.m
function [CircleImage, CircleImageRGB, SRImageZoom] = ...
    circleImage(SMR, ColorMap, ...
    SRImageZoom, MinPixelsPerCircle, SEScaleFactor)
%circleImage generates an image with circles for each localization.
% This method generates a circle image of the localizations in SMR.  At
% each localization in SMR, a circle will be placed in the image centered
% at the localization coordinates, with the radius being the mean of X_SE
% and Y_SE for that localization.
%
% INPUTS:
%   SMR: Single Molecule Results structure (an SMD structure that may have
%        been "truncated" so that not all fields are present).
%   ColorMap: A colormap defining the colors of the circles.  The row
%             indices correspond to indices in SMR, i.e., the circle at
%             [SMR.X(ii), SMR.Y(ii)] will have color ColorMap(ii, :). Note
%             that each row of ColorMap should sum to 1, otherwise the
%             output circle images may not be generated correctly.
%             (numeric array, NLocalizations x 3, or NLocalizations x 1 for
%             a single color)(Default = [1, 0, 0])
%   SRImageZoom: Zoom factor of the output images w.r.t. the coordinate
%                system of the localizations.
%                (scalar, integer)(Default = 20)
%   MinPixelsPerCircle: Approximately the number of pixels used for the
%                       smallest SE circle. Note that SRImageZoom takes
%                       precedence over this parameter, so you must set
%                       SRImageZoom = [] for this to work.
%                       (Default = 16 for guidance, but isn't used!)
%   SEScaleFactor: Multiplicative scaling of the mean X/Y standard errors.
%                  This is useful if you have very low SEs but still want
%                  their circles visible, without the need to increase
%                  SRImageZoom. (Default = 1);
%
% OUTPUTS:
%   CircleImage: A grayscale image with localizations in SMR represented by
%                circles, with radii varying with the standard errors.
%                (single array)(dynamic range of [0, 1])
%   CircleImageRGB: Same as output CircleImage but with RGB color channels.
%                   The color will be defined by the input ColorMap.
%                   (single array, mxnx3)(dynamic range of [0, 1])
%   SRImageZoom: Same as input 'SRImageZoom' unless the requested zoom
%                produces an image too large to be written with imwrite().
%                In that case, this will be the value which was actually
%                used.

% Created by:
%   David J. Schodt (Lidke lab, 2021)


% Define default parameters.
if (~exist('ColorMap', 'var') || isempty(ColorMap))
    ColorMap = [1, 0, 0];
end
if (~exist('SRImageZoom', 'var') ...
        || (isempty(SRImageZoom)&&isempty(MinPixelsPerCircle)))
    % NOTE: The special condition here is to ensure SRImageZoom takes
    %       precedence over MinPixelsPerCircle when appropriate (see
    %       documentation for INPUTS: MinPixelsPerCircle above).
    SRImageZoom = 20;
end
if (~exist('MinPixelsPerCircle', 'var') || isempty(MinPixelsPerCircle))
    % As it's currently written, this default won't actually be used (see
    % relation to 'SRImageZoom' and default setting.
    MinPixelsPerCircle = 16;
end
if (~exist('SEScaleFactor', 'var') || isempty(SEScaleFactor))
    SEScaleFactor = 1;
end

% Make local copies of some SMR fields (for very large SMR structures this
% might save time over accessing the fields within the loop(s) below).
X = SMR.X;
X_SE = SMR.X_SE;
Y = SMR.Y;
Y_SE = SMR.Y_SE;

% Set a default standard error if X_SE or Y_SE are empty (may be useful for
% some simulations where the circle images are still needed).
NLocalizations = numel(X);
if (isempty(X_SE) || isempty(Y_SE) || ~any(X_SE) || ~any(Y_SE))
    warning(['circleImage(): X_SE or Y_SE were empty/zero. ', ...
        'Default value of 0.1 pixels will be used.'])
    X_SE = 0.1 * ones(NLocalizations, 1);
    Y_SE = X_SE;
end

% Revise 'ColorMap' if the rows dimension isn't suitable (this will be used
% if the input is only one row, for monochrome images).
if (size(ColorMap, 1) ~= NLocalizations)
    ColorMap = repmat(ColorMap(1, 1:3), NLocalizations, 3);
end

% Revise SRImageZoom if needed.
MeanSE = mean([X_SE, Y_SE], 2) * SEScaleFactor;
SmallestCircumference= 2 * pi * min(MeanSE);
if isempty(SRImageZoom)
    SRImageZoom = ceil(MinPixelsPerCircle / SmallestCircumference);
end

% Define some new parameters.
ImageSize = ceil(SRImageZoom * [SMR.YSize, SMR.XSize]);
RGBChannels = 3;
if ((RGBChannels*prod(ImageSize)) > (2^32 - 1))
    % imwrite() can't write images this large, so we'll choose a smaller
    % image size.
    ImageSize = floor([1, 1] * 2^16 / sqrt(3));
    RequestedSRImageZoom = SRImageZoom;
    SRImageZoom = ceil(ImageSize(1) / SMR.YSize);
    warning(['smi_vis.GenerateImages.circleImage(): ', ...
        'Requested SRImageZoom=%i is too large and was reset to ', ...
        'SRImageZoom=%i'], RequestedSRImageZoom, SRImageZoom)
end

% Rescale the data based on SRImageZoom.
X = X * SRImageZoom;
Y = Y * SRImageZoom;
MeanSE = MeanSE * SRImageZoom;

% Generate the RGB image if needed.
if (nargout >= 2)
    CircleImageRGB = zeros([ImageSize, 3], 'single');
    for nn = 1:NLocalizations
        % Create the circles by with ~4*circumference points per circle
        % (the extra points can help make the circle appear smooth).
        Theta = linspace(0, 2*pi, ceil(8*pi*MeanSE(nn)));
        CircleRows = round(MeanSE(nn)*cos(Theta) + Y(nn));
        CircleCols = round(MeanSE(nn)*sin(Theta) + X(nn));
        IsValid = ((CircleRows<=ImageSize(1)) & (CircleRows>=1) ...
            & (CircleCols<=ImageSize(2)) & (CircleCols>=1));
        CircleRows = CircleRows(IsValid);
        CircleCols = CircleCols(IsValid);
        for mm = 1:numel(CircleRows)
            CircleImageRGB(CircleRows(mm), CircleCols(mm), 1) = ...
                ColorMap(nn, 1);
            CircleImageRGB(CircleRows(mm), CircleCols(mm), 2) = ...
                ColorMap(nn, 2);
            CircleImageRGB(CircleRows(mm), CircleCols(mm), 3) = ...
                ColorMap(nn, 3);
        end
    end
    
    % Produce the binary 'CircleImage' by summing over the color channels
    % and then converting all pixel values to either 0 or 1.
    CircleImage = single(logical(sum(CircleImageRGB, 3)));
else
    % Generate the monochrome circle image.
    % NOTE: The monochrome circle image SRImageZoom is restricted to the 
    %       same value as the RGB image (for the sake of simplicity in this
    %       code).
    CircleImage = zeros(ImageSize, 'single');
    for nn = 1:NLocalizations
        % Create the binary circle image by creating ~4*circumference
        % points for each circle (the extra points help make the circle
        % appear smooth).
        Theta = linspace(0, 2*pi, ceil(8*pi*MeanSE(nn)));
        CircleRows = round(MeanSE(nn)*cos(Theta) + Y(nn));
        CircleCols = round(MeanSE(nn)*sin(Theta) + X(nn));
        IsValid = ((CircleRows<=ImageSize(1)) & (CircleRows>=1) ...
            & (CircleCols<=ImageSize(2)) & (CircleCols>=1));
        CircleRows = CircleRows(IsValid);
        CircleCols = CircleCols(IsValid);
        for mm = 1:numel(CircleRows)
            CircleImage(CircleRows(mm), CircleCols(mm)) = 1;
        end
    end
end


end
./MATLAB/+smi_vis/@GenerateImages/histogramImage_unitTest.m
function success = histogramImage_unitTest()
%histogramImage_unitTest tests all functionality of histogramImage.

success = 0;
fprintf('\nTesting smi_vis.GenerateImages.histogramImage...\n');

SaveDir = smi_helpers.mkSMITETmpDir('unitTest', 'histogramImage');

% setting display options
%TrueSize = dipgetpref('TrueSize');
%dipsetpref('TrueSize',true)

% create random input
fprintf('Creating data...\n');
rng('default')
SMR.X = 1 + 98*rand(100000,1);
SMR.Y = 1 + 48*rand(100000,1);
SMR.XSize = 100;
SMR.YSize = 50;
SRImageZoom = 4;
ColorMap = 'jet';

% test with no output
fprintf('Testing with no output...\n');
smi_vis.GenerateImages.histogramImage(SMR,SRImageZoom,ColorMap);
saveas(gcf, fullfile(SaveDir, 'hI1.png'));
pause(3)
close all
% test with output
fprintf('Testing with output and all input...\n');
[histIm,RGBim] = smi_vis.GenerateImages.histogramImage(SMR,SRImageZoom,ColorMap);
imshow(histIm)
saveas(gcf, fullfile(SaveDir, 'hI2.png'));
h = imshow(RGBim);
saveas(gcf, fullfile(SaveDir, 'hI3.png'));
% DIPimage:
%pos = h.Position;
%pos(2) = pos(2)-300;
%h.Position = pos;
pause(3)
close all
% test without colormap (default should be hot)
fprintf('Testing with output and no colormap input...\n');
[histIm,RGBim] = smi_vis.GenerateImages.histogramImage(SMR,SRImageZoom);
imshow(histIm)
saveas(gcf, fullfile(SaveDir, 'hI4.png'));
h = imshow(RGBim);
saveas(gcf, fullfile(SaveDir, 'hI5.png'));
% DIPimage:
%pos = h.Position;
%pos(2) = pos(2)-300;
%h.Position = pos;
pause(3)
close all

% setting display options back
%dipsetpref('TrueSize',TrueSize)

% finish
fprintf('Done, test successful!\n\n');
success = 1;
end

./MATLAB/+smi_vis/@GenerateImages/rgbImage.m
function [RGBimage]=rgbImage(R,G,B)
%rgbImage generates RGB image with certain colormap from grey scale image
%
% If no output is requested, the image is displayed in a figure
%
%   INPUT
%      R:   2D Array for Red Image
%      G:   2D Array for Red Image
%      B:   2D Array for Red Image
%   OUTPUT
%      RGBimage - RBG array scaled from 0 to 1
%
%   REQUIRES
%      Matlab 2014b or higher

% check input
if nargin < 3
    error('smi_vis.GenerateImages.rgbImage:: Must have 3 inputs: R,G,B')
end

RGBimage=rescale(cat(3,R,G,B));

if nargout<1
    figure
    imagesc(RGBimage)
    set(gca,'visible','off')
    axis equal
    axis tight
end


end


./MATLAB/+smi_vis/@GenerateImages/circleDriftImage.m
function [CircleDriftImage, SRImageZoom] = ...
    circleDriftImage(SMD, SRImageZoom, ...
    MinPixelsPerCircle, SEScaleFactor)
%circleImageDrift generates a drift image with circles for localizations.
% This method generates a circle drift image of the localizations in SMR.
% At each localization in SMD, a circle will be placed in the image
% centered at the localization coordinates, with the radius being the mean
% of X_SE and Y_SE for that localization.
%
% INPUTS:
%   SMD: Single Molecule Data structure (see smi_core.SingleMoleculeData).
%   SRImageZoom: Zoom factor of the output images w.r.t. the coordinate
%                system of the localizations.
%                (scalar, integer)(Default = 20)
%   MinPixelsPerCircle: Approximately the number of pixels used for the
%                       smallest SE circle. Note that SRImageZoom takes
%                       precedence over this parameter, so you must set
%                       SRImageZoom = [] for this to work.
%                       (Default = 16 for guidance, but isn't used!)
%   SEScaleFactor: Multiplicative scaling of the mean X/Y standard errors.
%                  This is useful if you have very low SEs but still want
%                  their circles visible, without the need to increase
%                  SRImageZoom. (Default = 1);
%
% OUTPUTS:
%   CircleDriftImage: Circle image with colors representing time, as
%                     defined by the parula() colormap.
%                     (single array)(dynamic range of [0, 1])
%   SRImageZoom: Same as input 'SRImageZoom' unless the requested zoom
%                produces an image too large to be written with imwrite().
%                In that case, this will be the value which was actually
%                used.

% Created by:
%   David J. Schodt (Lidke lab, 2021)


% Define default parameters.
if (~exist('SRImageZoom', 'var') ...
        || (isempty(SRImageZoom)&&isempty(MinPixelsPerCircle)))
    % NOTE: The special condition here is to ensure SRImageZoom takes
    %       precedence over MinPixelsPerCircle when appropriate (see
    %       documentation for INPUTS: MinPixelsPerCircle above).
    SRImageZoom = 20;
end
if (~exist('MinPixelsPerCircle', 'var') || isempty(MinPixelsPerCircle))
    % As it's currently written, this default won't actually be used (see
    % relation to 'SRImageZoom' and default setting.
    MinPixelsPerCircle = 16;
end
if (~exist('SEScaleFactor', 'var') || isempty(SEScaleFactor))
    SEScaleFactor = 1;
end

% Prepare the drift image.
ColorMap = parula(SMD.NFrames * SMD.NDatasets);
[~, CircleDriftImage] = smi_vis.GenerateImages.circleImage(...
    SMD, ColorMap(SMD.NFrames*(SMD.DatasetNum-1) + SMD.FrameNum, :), ...
    SRImageZoom, MinPixelsPerCircle, SEScaleFactor);


end
./MATLAB/+smi_vis/@GenerateImages/histogramImage.m
function [HistIm,RgbHistIm] = histogramImage(SMR, SRImageZoom, ColorMap)
%histogramImage generates 2D histogram image from SR data.
%
%   INPUT
%      SMR - structure containing at least fields 'X' and 'Y' having the x
%            and y coordinates of localizations to be plotted
%      SRImageZoom - zoom factor for histogram image (default = 10)
%      ColorMap (optional) - colormap for RBGimage 
%
%   OUTPUT
%      If no output args are given histogram image will be displayed with
%           hot colormap
%      HistIm - gray value histogram image
%      RgbHistIm - RGB histogram image with colormap
%
%   REQUIRES
%      Matlab 2014b or higher

% Created by:
%    Marjolein Meddens, Lidke Lab 2017

% check input
if nargin <1
    error('smi_vis:GenerateImages::histogramImage:notEnoughInputArgs','Need input of atleast SMR');
end

if nargin<2
    disp('No input for SRImageZoom, default value of 10 assigned');
    SRImageZoom=10;
end

if ~isfield(SMR,'X') || ~isfield(SMR,'Y')
    error('smi_vis:GenerateImages::histogramImage:noXYfields','First input should be structure with fields X and Y');
end
if nargin < 3
    ColorMap = 'hot';
end
% calculate size of histogram image
Xsize=(SMR.XSize*SRImageZoom);
Ysize=(SMR.YSize*SRImageZoom);
% transfer coordinates to match histogram image size
X=single(SMR.X*SRImageZoom);
Y=single(SMR.Y*SRImageZoom);
% generate histogram image (using c-function)
HistIm = c_HistRecon(Ysize,Xsize,Y,X,0);
% display image if no output args are given
[~,b]=hist(single(HistIm(HistIm>0)));
imagemax=b(1);
if nargout==0
    h = imshow(HistIm,[0 imagemax]);
    colormap(ColorMap);
end
% create RGB image
if nargout > 1
    cm = eval([ColorMap '(256)']);
    MinMax = [0,imagemax];
    RgbHistIm = smi_vis.GenerateImages.colorImage(HistIm,cm,MinMax);
end

end

./MATLAB/+smi_vis/@GenerateImages/README.md
### +smi_vis/@GenerateImages
    
GenerateImages contains static methods for general visualization functions
of single molecule super-resolution data.

REQUIRES:
- Statistics Toolbox
- Parallel Procesing Toolbox
- NVidia GPU

SEE ALSO (other visualization routines):
- smi_core.DriftCorrection.plotDriftCorrection
- smi_core.FindROI.plotBox
- smi_core.Threshold.rejectedLocalizations

---

methods:
- **[blobColorOverlay](blobColorOverlay.m)**:
  creates color overlay of fitted emitters (green) onto data (red).
- **[colorImage](colorImage.m)**:
  generates RGB image with given colormap from a grey scale image
- **[dispIm](dispIm.m)**:
  produces a flexible GUI for multiple images.
- **[driftImage](driftImage.m)**:
  generates 2D histogram image from SR data.
- **[gaussianImage](gaussianImage.m)**:
  creates gaussian-blob image from SR data.
- **[histogramImage](histogramImage.m)**:
  generates 2D histogram image from SR data.
- **[plotHistogram](plotHistogram.m)**:
  creates a histogram of a field from an SMD structure.
- **[scaleBar](scaleBar.m)**:
  creates a scale bar of desired length on the input image.

./MATLAB/+smi_vis/@GenerateImages/GenerateImages.m
classdef GenerateImages
    
    %GenerateImages contains static methods for general visualization functions
    %   of single molecule super-resolution data.
    %
    % blobColorOverlay creates color overlay of fitted emitters (green) onto data
    %    (red).
    % colorImage generates RGB image with given colormap from a grey scale image
    % dispIm produces a flexible GUI for multiple images.
    % driftImage generates 2D histogram image from SR data.
    % gaussianImage creates gaussian-blob image from SR data.
    % histogramImage generates 2D histogram image from SR data.
    % plotHistogram creates a histogram of a field from an SMD structure.
    % scaleBar creates a scale bar of desired length on the input image.
    %
    % REQUIRES:
    %    Statistics Toolbox
    %    Parallel Procesing Toolbox
    %    NVidia GPU
    %
    % SEE ALSO (other visualization routines):
    %    smi_core.DriftCorrection.plotDriftCorrection
    %    smi_core.FindROI.plotBox
    %    smi_core.Threshold.rejectedLocalizations
    
    % Lidke Lab 2017, 2020
    
    properties
    end
    
    methods(Static)
        [OverlayImage] = blobColorOverlay(Sequence, SMD)
        [RGBimage] = colorImage(Image, ColorMap, MinMax)
        [RGBimage] = rgbImage(R,G,B)
        showim(Image)
        dispIm()
        [DriftIm, DriftImRGB] = driftImage(SMR, SRImageZoom)
        [GaussIm] = gaussianImage(SMR, SRImageZoom, ScalebarLength)
        [CircleImage, CircleImageRGB, SRImageZoom] = ...
            circleImage(SMR, ColorMap, ...
            SRImageZoom, MinPixelsPerCircle, SEScaleFactor);
        [CircleDriftImage, SRImageZoom] = ...
            circleDriftImage(SMR, SRImageZoom, ...
            MinPixelsPerCircle, SEScaleFactor);
        [HistIm, RgbHistIm] = histogramImage(SMR, SRImageZoom, ColorMap)
        [FigHandle] = plotHistogram(Vector_in, Hist_Name)
        [ImageOut, Image] = scalebar(Image, PixelSize, Length, Location)
        [OverlayImage, ColorOrderTag] = overlayNImages(ImageStack);
        
        % Unit tests.
        [success] = blobColorOverlay_unitTest()
        [success] = colorImage_unitTest()
        [success] = driftImage_unitTest()
        [success] = gaussianImage_unitTest()
        [success] = histogramImage_unitTest()
        [Success] =  circleImage_unitTest()
        
        function [success] = unitTest()
            %unitTest tests various class functionality.
            [success(1)] = smi_vis.GenerateImages.blobColorOverlay_unitTest();
            [success(2)] = smi_vis.GenerateImages.colorImage_unitTest();
            [success(3)] = smi_vis.GenerateImages.driftImage_unitTest();
            [success(4)] = smi_vis.GenerateImages.gaussianImage_unitTest();
            [success(5)] = smi_vis.GenerateImages.histogramImage_unitTest();
            [success(6)] = smi_vis.GenerateImages.circleImage_unitTest();
        end
    end % methods(Static)
    
end % classdef GenerateImages

./MATLAB/+smi_vis/@GenerateImages/plotHistogram.m
function [FigHandle] = plotHistograms(Vector_in, Hist_Name)
%plotHistogram creates a histogram of a field from an SMD structure.
% 
% INPUT:
%    Vector_in   Vector of values to create histogram. 
%    Hist_Name   Name of histogram graph (Default=[])
%
% OUTPUT:
%    FigHandle:  Figure handle of histogram plot    

% Created by
%    Hanieh Mazloom-Farsibaf   Apr 2017 (Keith A. Lidke's lab)

if nargin<1
    error('Inter a vector format input for histogram')
end

if nargin<2 || isempty(Hist_Name)
    Hist_Name=inputname(1);
end

Vector_in = single(Vector_in);
Nbin=50; % number of bins in histogram

% In order to produce a better scaled histogram, filter out the top 1%
% of the values.
P = prctile(Vector_in, 99);
V = Vector_in(Vector_in < P);

% Plot the histogram of Hist_Name
FigHandle=figure;
hold on
h = histogram(V, Nbin);
xlabel(sprintf('%s', Hist_Name));
ylabel('Frequency');
title(sprintf('Histogram of %s', Hist_Name));
hold off

end

./MATLAB/+smi_vis/@GenerateImages/gaussianImage.m
function [GaussIm] = gaussianImage(SMD,SRImageZoom,ScalebarLength)
%gaussianImage creates gaussian-blob image from SR data.
%
% INPUTS:
%   SMR              SMD results structure with fields X, Y, Bg, X_SE, Y_SE,
%                    Photons, FrameNum, XSize, YSize
%   SRImageZoom      zoom factor [default value of 10]
%   ScalebarLength   scalebar length (um) [default: 10 um]
%
% OUTPUT:
%   GaussIm - Gaussian blob image 
%
% REQUIRES:
%   smi_sim.GaussBlobs.gaussBlobImage.m (and requirements within)
%   Matlab

% Created by:
%    Sandeep Pallikkuth, Lidke Lab 2017

% checking inputs
if nargin<1
    error('Not enough input. Please input SMR structure and SRImageZoom');
elseif nargin<2
    disp('No input on SRImageZoom. Default value of 10 assigned');
    SRImageZoom=10;
end

if ~exist('ScalebarLength', 'var')
   ScalebarLength = 10; % um
end
% creating inputs for smi_sim.GaussBlobs.gaussBlobImage
RawImageSize=[SMD.YSize SMD.XSize];
SZ=RawImageSize*SRImageZoom; %since we need big enough box sizes
SMDin=SMD;
SMDin.XSize=SZ(1);
SMDin.YSize=SZ(2);
SMDin.Bg=zeros(size(SMD.Bg));
SMDin.X=SMD.X*SRImageZoom;
SMDin.Y=SMD.Y*SRImageZoom;
SMDin.PSFSigma=[SMD.Y_SE,SMD.X_SE]*SRImageZoom;
SMDin.Photons=ones(size(SMD.Photons));
SMDin.FrameNum=ones(size(SMD.FrameNum));
SMDin.NFrames=1;
% creating GaussIm
GaussIm = smi_sim.GaussBlobs.gaussBlobImage(SMDin);
GaussIm = smi.BaGoL.scaleIm(GaussIm);
if (ScalebarLength > 0)
    GaussIm = smi_vis.GenerateImages.scalebar(GaussIm, SMD.PixelSize, ...
        ScalebarLength);
end
GaussIm = smi_vis.GenerateImages.colorImage(GaussIm);

end

./MATLAB/+smi_vis/@GenerateImages/showim.m
function showim(Image)
%showim Displays a nicely formatted images of a grayscale or color image
%
%
%   INPUT
%      Image:   2D or 3D Array
%   OUTPUT
%
%   REQUIRES
%      Matlab 2014b or higher

%make 2^N bigger to make bigger that 256
SZ=max(size(Image,[1,2]));
Mag = 2^ceil(log(256/SZ)/log(2))

figure
imshow(Image,[],'border','tight','initialmagnification',Mag*100)
set(gca,'visible','off')
axis equal
axis tight

end


./MATLAB/+smi_vis/@GenerateImages/gaussianImage_unitTest.m
function success = gaussianImage_unitTest()
%gaussianImage_unitTest tests all functionality of gaussianImage.

success = 0;
fprintf('\nTesting smi_vis.GenerateImages.gaussianImage...\n');

SaveDir = smi_helpers.mkSMITETmpDir('unitTest', 'gaussianImage');

% setting display options
%TrueSize = dipgetpref('TrueSize');
%dipsetpref('TrueSize',true)

% create random input
fprintf('Creating data...\n');
rng('default')
SMD.X = 1 + 98*rand(100000,1);
SMD.Y = 1 + 48*rand(100000,1);
SMD.Z = [];
SMD.X_SE = 0.20*rand(100000,1);
SMD.Y_SE = 0.20*rand(100000,1);
SMD.XSize = 100;
SMD.YSize = 50;
SMD.FrameNum = ones(100000,1);
SMD.Photons = 1000*rand(100000,1);
SMD.Bg = 100*rand(100000,1);
SMD.PixelSize = 0.1;
SRImageZoom = 4;

% test with no output
fprintf('Testing with no output...\n');
smi_vis.GenerateImages.gaussianImage(SMD,SRImageZoom);
saveas(gcf, fullfile(SaveDir, 'gI1.png'));
pause(3)
close all
% test with output
fprintf('Testing with output and all input...\n');
[gaussIm] = smi_vis.GenerateImages.gaussianImage(SMD,SRImageZoom);
imshow(gaussIm)
saveas(gcf, fullfile(SaveDir, 'gI2.png'));
pause(3)
close all

% setting display options back
%dipsetpref('TrueSize',TrueSize)

% finish
fprintf('Done, test successful!\n\n');
success = 1;
end

./MATLAB/+smi_vis/@GenerateImages/colorImage.m
function [RGBimage]=colorImage(Image,ColorMap,MinMax)
%colorImage generates RGB image with certain colormap from grey scale image
%
%   INPUT
%      Image - 2D array containing gray scale values
%      ColorMap (optional) - 3 by N matrix, interpreted as Red Green and
%                            Blue values, default is hot(256)
%      MinMax (optional) - [min max] limits for scaling colormap, default
%                          is min and max values of Image
%
%   OUTPUT
%      If no output args are given histogram image will be displayed with
%           hot colormap
%      RGBimage - RBG version of image with colormap
%
%   REQUIRES
%      Matlab 2014b or higher

% Created by
%    Marjolein Meddens, Lidke Lab 2017

% check input
if nargin < 1
     error('smi_vis:GenerateImages:colorImage:notEnoughInputArgs','Need at least Image input');
end
if nargin < 2
    ColorMap = hot(256);
end
if nargin < 3
    MinMax = [min(Image(:)) max(Image(:))];
end

% combine channels
Image=single(Image);
[r, g, b]=c_GenColorChannels(Image,ColorMap,MinMax(1),MinMax(2));
RGBimage=smi_vis.GenerateImages.rgbImage(r,g,b);
end

./MATLAB/examples/Example_PairCorrelation.m
%% Demonstrate how to call the smi_cluster.PairCorrelation class.

SaveDir = smi_helpers.mkSMITETmpDir('examples', 'PairCorrelation');

PC = smi_cluster.PairCorrelation();
PC.ResultsDir = SaveDir;

% Generated data.
SZ = 1000;
x1 = SZ * rand(2 * SZ, 1);
y1 = SZ * rand(2 * SZ, 1);
XY1 = [x1, y1];
SMD1.X = x1;
SMD1.Y = y1;
x2 = [SZ * rand(3 * SZ, 1)];
y2 = [SZ * rand(3 * SZ, 1)];
XY2 = [x2, y2];
SMD2.X = x2;
SMD2.Y = y2;

PC.ROI = [0, SZ, 0, SZ];   % [x_min, x_max, y_min, y_max]
% These two numbers below are often the same, but the user can increase
% HistBinSize to make bigger internal pixels (or bigger internal histogram
% image bins) and so produce more smoothing, or decrease this quantity and
% attempt greater detail.
PC.PixelSize = 1;         % Actual camera pixel size (nm).
PC.HistBinSize = 1;       % Internal image pixel size (nm).

% Make a RoI structure (see also smi_cluster.ROITools).  This is typically
% used for invoking pair_correlation_ROIcombined with multiple ROIs, which
% are combined.  The size of each ROI need not be the same, although
% cleaner results will be produced if they are all the same size.
n_ROIs = 1;
RoI{1}.ROI = PC.ROI;
RoI{1}.X   = {XY1(:, 1), XY2(:, 1)};
RoI{1}.Y   = {XY1(:, 2), XY2(:, 2)};

% Typically, pair_correlation is used for comparing two images/ROIs, while
% pair_correlation_ROIcombined is used when combining the pair correlation
% results for several pairs of images/ROIs.  pair_correlation_Veatch is
% basically the original Sarah Veatch code left for comparison purposes.
% The results of all three routines in these examples should produce
% similar results (identical for the first two when n_ROIs = 1).
% NOTE: SMD structures or XY matrices can be provided as input.
PC.BaseName = '9021';
results_pcc  = PC.pair_correlation(SMD1, SMD2)
results_pcc  = PC.pair_correlation(XY1, XY2)
results_Rpcc = PC.pair_correlation_ROIcombined(2, n_ROIs, RoI)
results_Vpcc = PC.pair_correlation_Veatch(SMD1, SMD2, 'cross')
results_Vpcc = PC.pair_correlation_Veatch(XY1, XY2, 'cross')

% Auto correlation.
PC.BaseName = '9021_5';
results_pac1  = PC.pair_correlation(SMD1)
results_pac1  = PC.pair_correlation(XY1)
results_Rpacc = PC.pair_correlation_ROIcombined(1, n_ROIs, RoI, 1)
results_Vpac1 = PC.pair_correlation_Veatch(SMD1,  [], 'auto')
results_Vpac1 = PC.pair_correlation_Veatch(XY1,  [], 'auto')

% Auto correlation.
PC.BaseName = '9021_10';
results_pac2  = PC.pair_correlation(SMD2)
results_pac2  = PC.pair_correlation(XY2)
results_Rpac2 = PC.pair_correlation_ROIcombined(1, n_ROIs, RoI, 2)
results_Vpac2 = PC.pair_correlation_Veatch(SMD2, [], 'auto')
results_Vpac2 = PC.pair_correlation_Veatch(XY2, [], 'auto')

fprintf('Done pair correlation.\n');
fprintf('All results in %s\n', PC.ResultsDir);

./MATLAB/examples/Example_Publish.m
% This script will call smi.Publish to generate misc. results for an
% experiment on the sequential microscope.

%% Define the analysis parameters.
% Define the 'CoverslipDir'.
% NOTE: 'CoverslipDir' is the top-level directory which contains the
%        sub-directories 'CoverslipDir'\Cell*\Label*, which themselves
%        contain data in .h5 files 'CoverslipDir'\Cell*\Label*\Data*.h5
CoverslipDir = 'Y:\dschodt\analysis_test_directory\SMA_Publish_testing\21_5_4_HeLa_alpha_beta_tubulin';

% Prepare the SMF structure.
SMF = smi_core.SingleMoleculeFitting;
SMF.Data.CameraType = 'SCMOS';
SMF.Data.CalibrationFilePath = 'Y:\sCMOS Calibrations\Sequential SR\GainCalibration_medianGain_2022_05_26_14_51_08.mat';
SMF.Data.PixelSize = 0.0954; % microns
SMF.BoxFinding.BoxSize = 8; % pixels
SMF.Fitting.FitType = 'XYNBS';
SMF.Fitting.PSFSigma = 1.3; % pixels
SMF.Thresholding.MaxXY_SE = 0.15; % pixels
SMF.Thresholding.MinPhotons = 200;
SMF.FrameConnection.Method = 'LAP-FC';

% Alternatively, you may wish to prepare the SMF using the GUI.
% SMF.gui()

%% Prepare the smi.Publish class and run the standard analysis.
% The smi.Publish class requires the SMF (defined above) as well as the
% 'CoverslipDir'.  All other class properties specify which analyses to do.
Publish = smi.Publish(SMF);
Publish.CoverslipDir = CoverslipDir;
Publish.Verbose = 1;
Publish.GenerateSR = 1;
Publish.GenerateImagingStats = 1;
Publish.GenerateOverlayStats = 0;
Publish.ShiftToReg = 0; % can be useful for color overlay data, use with caution!

% Define trust regions, so that anything that seems to have a shift above the
% value below will be masked out.  Note that PixelSize is in microns/pixel, so
% the multiplying factor (0.2) is in units of microns.
%Publish.MaxBrightfieldShift = 0.2 / SMF.Data.PixelSize; % pixels

% smi.Publish contains several useful methods, however we'll almost always
% just call performFullAnalysis().
Publish.performFullAnalysis();

./MATLAB/examples/hierBaGoL_wrapper.m
% Script to produce BaGoL results from SMITE *_Results.mat files.  The BaGoL
% results are placed in the subdirectory Results_BaGoL, assigned a name below,
% under the directory containing the *_Results.mat files.  hierBaGoL_analysis
% is called separately on each file in a parfor loop, assigning a worker for
% each dataset, so conducive to be run on a multi-core machine.
%
% The wrapper sets parameters and lists files (full paths) to be analyzed and
% optional ROIs to apply in the next to last section.
%
% For _Results.mat files with large numbers of localizations (> 300,000 or so),
% hierBaGoL may crash (or partially crash), so should not be part of a parfor
% loop as a crash will cause ALL of the non-finished parallel jobs to restart.
% Such _Results.mat files should be analyzed in separate MATLABs.
%
% NOTE: MAPN_*.mat files are always produced containing simply the MAPN
% coordinates.  See +smi/@BaGoL/hierBaGoL_analysis.m for more details on files
% produced.
%
% If the variable ROIs is true and only one filename is provided (see below),
% and assuming SMD files are of the form Cell_nn_Label_0n_Results.mat and ROI
% files are of the form Cell_nn_Label_01_Results_ROIs.mat (and are located
% in the subdirectory 'Analysis' of DataDir) as done when choosing ROIs using
% the scripts simpleROIcluster or simplePairCorr, this current script will
% automatically use the ROI information in the _ROIs.mat file to produce a
% series of individual analyses for each ROI which smi.BaGoL.hierBaGoL_run will
% parallelize via a parfor loop.  The set of analyses will take on names of the
% form Cell_nn_Label_0n_Results_ROI_mm.  PairAnalysis.overlayBaGoLROIs is a
% useful function for plotting the ROIs produced by this process, both 1-color
% and 2-color.
%
% See:
%
% Sub-Nanometer Precision using Bayesian Grouping of Localizations
% Mohamadreza Fazel, Michael J. Wester, David J. Schodt, Sebastian Restrepo
% Cruz, Sebastian Strauss, Florian Schueder, Thomas Schlichthaerle, Jennifer M.
% Gillette, Diane S. Lidke, Bernd Rieger, Ralf Jungmann and Keith A. Lidke
% (Nature Communications, 2022)
% 
% Single-molecule localization microscopy super-resolution methods rely on
% stochastic blinking events, which can occur multiple times from each emitter
% over the course of data acquisition.  Typically the blinking events from each
% emitter are treated as independent events, without an attempt to assign them
% to a particular emitter.  We describe a Bayesian method of grouping and
% combining localizations from multiple blinking events that can improve
% localization precision and can provide better than one nanometer precision
% under achievable experimental conditions.  The statistical distribution of
% the number of blinking events per emitter along with the precision of each
% localization event are used to generate a posterior probability distribution
% of the number and location of emitters.  The blinks per emitter distribution
% can be input or learned from data.  We demonstrate the method on a range of
% synthetic data, DNA origami constructs and biological structures using
% DNA-PAINT and dSTORM.
%
% Suggested Pre-filtering actions (frame connection and NN not used for dSTORM
% data) [NOTE that the middle four actions should be performed during the SMLM
% analysis, e.g., Publish]:
%
% SR data -> remove localizations with negative coordinates
%            [smi_helpers.Filters.filterNonNeg called by hierBaGoL_analysis]
%         -> intensity filter [SMF.Thresholding.InMeanMultiplier]
%         -> inflate standard errors [SMF.Data.SEAdjust]
%         -> frame connection, removing connections which involve only a
%            specified number of frames [SMF.FrameConnection.MinNFrameConns]
%         -> Nearest Neighbor filter (N_NN) --- Do not use on dSTORM data!
%            [SMF.Thresholding.NNMedianMultiplier,
%             SMF.Thresholding.MinNumNeighbors]
%         -> BaGoL (via parfor calling hierBaGoL_analysis on each dataset)
%
% The pre-filtering (except for removing negative coordinates) is all now in
% SMLM, although SE_Adjust can be set here as well.

% ----------------------------------------------------------------------

% Output directory name.
Results_BaGoL = 'Results_BaGoLHier';

% Generic parameters.
BaGoLParams.ImageSize = 256;        % (pixel)
%BaGoLParams.PixelSize = 108.018;    % camera back projected size (nm) [TIRF]
BaGoLParams.PixelSize = 97.8;       % (nm) [sequential]
BaGoLParams.OutputPixelSize = 4;    %2; % pixel size for posterior images (nm)
BaGoLParams.N_Burnin = 32000;       % Length of Burn-in chain
BaGoLParams.N_Trials = 8000;        % Length of post-burn-in chain
%BaGoLParams.N_Burnin = 8000;        % Length of Burn-in chain
%BaGoLParams.N_Trials = 2000;        % Length of post-burn-in chain
BaGoLParams.NSamples = 10;          % Number of samples before sampling Xi
BaGoLParams.ClusterDrift = 0;       % Expected magnitude of drift (nm/frame)

% Y_Adjust is sometimes needed to deal with lower left versus upper left
% y-origin issues.  Lower left with y increasing upwards is the default,
% requiring no changes, while upper left with y increasing downwards can
% sometimes occur, so Y must be replaced by Y - Y_Adjust, where Y_Adjust is the
% image size (see below) [pixels].
%BaGoLParams.Y_Adjust = BaGoLParams.ImageSize;
BaGoLParams.Y_Adjust = [];

% SE_Adjust adds to X_SE and Y_SE, so inflates the precision.  For DNA_PAINT
% data, SE_Adjust = 1--2 nm, while for dSTORM, slightly bigger values should
% be used.  Note that this quantity can be specified as an array of length
% n_files if applied differently to each file.
BaGoLParams.SE_Adjust = 0;          % Precision inflation applied to SE (nm)
%BaGoLParams.SE_Adjust = [0, 0];     % Precision inflation applied to SE (nm)

% The values for ROIsz and OverLap directly below are good overall for much
% data, but note that the larger the ROIsz, the more the computational effort.
% Artifacts in dense data can come about if the ROIsz is too large.  The
% pre-clustering cutoff should be around the localization precision.
BaGoLParams.ROIsz = 500;            % ROI size for RJMCMC (nm)
BaGoLParams.OverLap = 50;           % Size of overlapping region (nm)
BaGoLParams.Cutoff = 25;            % Pre-clustering cutoff (nm)
%BaGoLParams.ROIsz = 100;            % ROI size for RJMCMC (nm)
%BaGoLParams.OverLap = 25;           % Size of overlapping region (nm)
%BaGoLParams.ROIsz = 50;             % ROI size for RJMCMC (nm)
%BaGoLParams.OverLap = 10;           % Size of overlapping region (nm)

% k and theta below are the shape and scale parameters for the Gamma
% probability distribution function.  If just one parameter is provided,
% a Poisson distribution is used.
BaGoLParams.Xi = [20, 1];           % [k, theta] parameters for gamma prior

% Note for batch runs, in which Files and DataROI are input by hand, please see
% ### comments below.
BaGoLParams.DataROI = [];           % [Xmin, Xmax, Ymin, Ymax] (pixel)
DataROI = [];

% If ROIs is true, the input file has ROIs already defined (*_ROIs.mat), so use
% them below if only one filename is provided.
%ROIs = true;
ROIs = false;

% If includeROIs is set to a list of integers, then only those ROIs will be
% processed when ROIs is set to true.
includeROIs = [];

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

%start_DataDir = '.';
%Files = uipickfiles('FilterSpec', start_DataDir, 'REFilter', ...
%                    '.*_ResultsStruct.*\.mat', 'Prompt',     ...
%                    '_ResultsStruct.mat files');
% ### Comment out the 4 lines above and use the commented out lines below when
% ### making batch runs, for example, on CARC.  Here, the files to process are
% ### defined relative to the directory where hierBaGoL_wrapper is run.
% ### Absolute pathnames are also fine, especially when used in conjunction
% ### with fullfile.
D1 = '../DATA';
Files = {
fullfile(D1, 'Cell_02_Label_01_Results.mat');
};
%fullfile(D1, 'Cell_03_Label_01_Results.mat');

% DataROI is defined when running BaGoL over only part of the image.
% If DataROI is empty, use the whole image.
% 
% Define a single region of interest for each dataset (units are pixels).
% [YStart, XStart, YEnd, XEnd] = [163, 385, 233, 455]
% [Xmin, Xmax, Ymin, Ymax] (pixel)
% [385, 455, 163, 233]
%DataROI = [
%[120, 136, 190, 206]
%[110, 126,  90, 106]
%];

% Special case in which a single file is broken up into pre-selected ROIs if
% the variable ROIs is set to true.  The ROIs are processed via a parfor loop
% in smi.BaGoL.hierBaGoL_run.  See also comments at the top of this function.
if numel(Files) == 1 && ROIs
   [DataDir, File, Ext] = fileparts(Files{1});
   basename = fullfile(DataDir, 'Analysis', File);
   % Assume SMD files are of the form Cell_nn_Label_0n_Results.mat and ROI
   % files are of the form Cell_nn_Label_01_Results_ROIs.mat (and are located
   % in the subdirectory 'Analysis' of DataDir).
   filename = regexprep(basename, 'Label_02', 'Label_01');

   ROIsFile = load([filename, '_ROIs.mat']);
   n_ROIs = numel(ROIsFile.RoI);
   DataROI = zeros(n_ROIs, 4);
   % Do all the ROIs when includeROIs is empty (the default),
   if isempty(includeROIs)
      for i = 1 : n_ROIs
         DataROI(i, :) = ROIsFile.RoI{i}.ROI ./ BaGoLParams.PixelSize;
      end
   else
      for i = 1 : n_ROIs
         if ismember(i, includeROIs)
            DataROI(i, :) = ROIsFile.RoI{i}.ROI ./ BaGoLParams.PixelSize;
         end
      end
   end

   Files = cell(n_ROIs, 1);
   for i = 1 : n_ROIs
      Files{i} = sprintf('%s_ROI_%02d.mat', basename, i);
   end

end

% ----------------------------------------------------------------------

% Run the BaGoL analyses.
smi.BaGoL.hierBaGoL_run(Files, DataROI, Results_BaGoL, BaGoLParams, ROIs);
%hierBaGoL_run(Files, DataROI, Results_BaGoL, BaGoLParams, ROIs);

fprintf('Done BaGoL.\n');

./MATLAB/examples/plotROIDriver.m
function plotROIDriver(PixelSize, options, start_datadir, SaveDir)
% Plot dot, Gaussian or circle images of SMD/MAPN coordinates per ROI per Cell.
% In other words, this function can plot cluster boundaries overlaid on dot,
% Gaussian or circle plots of SR or BaGoL results.  The driver collects the
% paths and files needed, while plotROI produces the specified plots from these
% and a few other pieces of information for each ROI in each Cell, putting the
% results in SaveDir.
%
% INPUTS:
%    PixelSize       plxel length (nm)
%    options         cell array of strings that are selected from the following
%                    options [DEFAULT = {'BaGoL', 'Gaussian', 'Cluster'}]:
%       SR              SR Results file
%       BaGoL           BaGoL Results file (BGL.SMD)
%       MAPN            BaGoL Results file (BGL.MAPN)
%       Dot             Dot plot
%       Gaussian        Gaussian plot
%       Circle          Circle plot (BaGoL Results file: BGL.SMD + BGL.MAPN)
%       Boundary        Include ROI boundaries
%       Cluster         Include ROI clusters
%    start_datadir   starting data directory from which SaveDir will be made a
%                    subdirectory of by default if SaveDir not provided
%                    [DEFAULT = '.']
%    SaveDir         directory in which to save images
%                    [DEFAULT = fullfile(start_datadir, 'ROIClusterAnalysis')]

%  PixelSize = 97.8; % nm   % pixel length (nm)

   if ~exist('options', 'var')
      options = {'BaGoL', 'Gaussian', 'Cluster'};
   end

   opt.SR = false;
   opt.BaGoL = false;
   opt.MAPN = false;
   opt.Dot = false;
   opt.Gaussian = false;
   opt.Circle = false;
   opt.Boundary = false;
   opt.Cluster = false;

   if contains('SR', options)
      opt.SR = true;
   end
   if contains('BaGoL', options)
      opt.BaGoL = true;
   end
   if contains('MAPN', options)
      opt.MAPN = true;
   end
   if contains('Dot', options)
      opt.Dot = true;
   end
   if contains('Gaussian', options)
      opt.Gaussian = true;
   end
   if contains('Circle', options)
      opt.Circle = true;
   end
   if contains('Boundary', options)
      opt.Boundary = true;
   end
   if contains('Cluster', options)
      opt.Cluster = true;
   end

   CI = smi_cluster.ClusterInterface();

   if ~exist('start_datadir', 'var')
      start_datadir = '.';
   end
   if ~exist('SaveDir', 'var')
      SaveDir = fullfile(start_datadir, 'ROIClusterAnalysis');
   end
   if ~isfolder(SaveDir)
      mkdir(SaveDir);
   end

   % Clusters collected together in a single *_results.mat file.
   [pathnameC, filesC] = smi_helpers.selectFiles(start_datadir, ...
      '*_results.mat single file', '*_results.mat');
   if opt.SR
      [pathnameB, filesB] = smi_helpers.selectFiles(start_datadir, ...
         'SR _Results.mat files', '*_Results.mat');
   elseif opt.BaGoL 
      % BaGoL Result/ResultStruct files.
      [pathnameB, filesB] = smi_helpers.selectFiles(start_datadir, ...
         'MF BaGoL _Results*.mat files', 'BaGoL_Results_*_Results*.mat');
   end

   CI.plotROI(opt, pathnameC, filesC, pathnameB, filesB, PixelSize, SaveDir);

   fprintf('Done.\n');

end

./MATLAB/examples/Example_SMLM_script.m
% A real example used to develop SMLM.  See also smi.SMLM.unitTest

% If true, save plots produced into the ResultsDir defined below for a full
% analysis or a test fit with SMLMobj.VerboseTest < 5.
Saving = false;

% --- 2D ---

% Create an SMF (Single Molecule Fitting) structure with default values, some
% of which will be overridden below.  See smi_core.SingleMoleculeFitting for
% details on the possible parameters that can be set.
SMF = smi_core.SingleMoleculeFitting();

   % Results directory (char array)(Default='FileDir/Results')
SMF.Data.ResultsDir = tempdir;

if Saving
   if ~exist(SMF.Data.ResultsDir, 'dir')
      mkdir(SMF.Data.ResultsDir);
   end
end

% See
%    https://digitalrepository.unm.edu/physics_data/3/#attach_additional_files
%    (DOI: 10.25827/cs2a-dh13)
% for some example sequence files that can be used for testing.

% Set some Single Molecule Fitting (SMF) parameters:

   % File directory (char array)
SMF.Data.FileDir           = ...
   '\\rayleigh.phys.unm.edu\cell-path\Genmab\Data\10082020\Wien133_LQT_CD52_HexElect1\Cell_01\Label_01';
   % File name (cell array of char array)
SMF.Data.FileName         = 'Data_2020-10-8-17-58-54.h5';
   % ID tagged onto saved results (char array)(Default='')
SMF.Data.AnalysisID       = 'ID';
   % 'EMCCD','SCMOS' (Default='EMCCD')
SMF.Data.CameraType       = 'EMCCD';
   % Camera Gain, scalar or image (Default=1)
SMF.Data.CameraGain       = 1;
   % Camera Offset, scalar or image (Default=0)
SMF.Data.CameraOffset     = 0;
   % Perform thresholding? (Default=true)
SMF.Thresholding.On       = true;
   % Maximum allowed precision in x,y (Pixels)(Default=.2)
SMF.Thresholding.MaxXY_SE = 0.1;
   % Perform frame connection? (Default=true)
SMF.FrameConnection.On    = true;
   % Perform drift correction? (Default=true)
SMF.DriftCorrection.On    = true;

% Create an SMLM object using the values in the SMF structure.
SMLMobj = smi.SMLM(SMF);
SMLMobj.Verbose = 1;
% Do a test fit, displaying all the results to the screen (if VerboseTest >= 5,
% otherwise saving the results in ResultsDir/TestFit).  Note that calling
% testFit from the smi.gui is equivalent to what we are doing here.
SMLMobj.VerboseTest = 5;
SMLMobj.testFit(1);
% Do a full analysis, saving results in ResultsDir.
SMLMobj.fullAnalysis();

./MATLAB/examples/Example_DiffusionEstimator.m
% This script demonstrates the usage of smi_stat.DiffusionEstimator.

SaveDir = smi_helpers.mkSMITETmpDir('examples', 'DiffusionEstimator');

%% Single diffusing population, estimating D as the slope of the MSD.
% Simulate some trajectories.
SimParams = smi_sim.SimSPT.defineDefaultParams();
SimParams.ParticleDensity = 0.01; % particles / px^2
SimParams.NFrames = 1000;
SimParams.SubframeDensity = 1;
SimParams.FrameSize = [128, 128];
SimParams.BoundaryCondition = 'Periodic';
SimParams.KOffToOn = 1;
SimParams.KOnToOff = 0;
SimParams.D = 0.0123; % px^2 / frame
SPTSim = smi_sim.SimSPT(SimParams);
SPTSim.createSimulation();
TR = SPTSim.TR;

% Prepare the DiffusionEstimator class and estimate D.
% NOTE: For MSD fitting, the important parameters are 'DiffusionModel', 
%       'FitMethod', 'FrameLagRange', and 'NFitPoints'.  
SMF = smi_core.SingleMoleculeFitting; % used for PixelSize and FrameRate
DE = smi_stat.DiffusionEstimator(TR, SMF);
DE.FitTarget = 'MSD';
DE.DiffusionModel = 'Brownian'; % must be 'Brownian' for MSD fitting
DE.NComponents = 1; % must be 1 for MSD fitting
DE.FitMethod = 'WeightedLS'; % 'WeightedLS' or 'LS'
DE.FrameLagRange = [1, 50]; % range of frame lags computed in MSD
DE.NFitPoints = 5; % # of points in MSD used for fit.
DE.EstimateSEs = true; % estimate standard errors of fit D values
DE.FitIndividualTrajectories = true; % fit each trajectory MSD
DE.UnitFlag = false;
DE.Verbose = 1;
DE.estimateDiffusionConstant();

% Plot the MSD and fit results.
DE.plotEnsembleMSD(axes(figure()), DE.MSDEnsemble, DE.DiffusionStruct, ...
    DE.DiffusionModel, DE.UnitFlag);
saveas(gcf, fullfile(SaveDir, 'DE1.png'));

%% Two diffusing populations, estimating D by fitting the CDF of jumps.
% Simulate some trajectories.
SimParams = smi_sim.SimSPT.defineDefaultParams();
SimParams.ParticleDensity = 0.01; % particles / px^2
SimParams.NFrames = 1000;
SimParams.SubframeDensity = 1;
SimParams.FrameSize = [128, 128];
SimParams.BoundaryCondition = 'Periodic';
SimParams.KOffToOn = 1;
SimParams.KOnToOff = 0;
SimParams.D = [0.0123, 0.00321, 0.00321]; % px^2 / frame
SPTSim = smi_sim.SimSPT(SimParams);
SPTSim.createSimulation();
TR = SPTSim.TR;

% Prepare the DiffusionEstimator class and estimate D.
% NOTE: For CDF fitting, the important parameters are 'DiffusionModel' and
%       'FrameLagRange'.
SMF = smi_core.SingleMoleculeFitting; % used for PixelSize and FrameRate
DE = smi_stat.DiffusionEstimator(TR, SMF);
DE.FitTarget = 'CDFOfJumps';
DE.DiffusionModel = 'Brownian';
DE.NComponents = 2;
DE.FrameLagRange = [2, 2]; % range of frame lags computed in MSD
DE.EstimateSEs = false; % estimate standard errors of fit D values
DE.FitIndividualTrajectories = false; % fit each trajectory MSD
DE.UnitFlag = false;
DE.Verbose = 1;
DE.estimateDiffusionConstant();

% Plot the CDF and fit results.
DE.plotEnsembleCDFOfJumps(axes(figure()), ...
    DE.MSDEnsemble, DE.DiffusionStruct, DE.UnitFlag);
saveas(gcf, fullfile(SaveDir, 'DE2.png'));

%% Two diffusing populations, estimating D with an MLE for the jumps.
% (If estimating standard errors, this is faster than fitting the CDF, and
% the results are similar).

% Prepare the DiffusionEstimator class and estimate D.
% NOTE: For LikelihoodOfJumps maximization, the important parameters are
%       'DiffusionModel' and 'FrameLagRange'.
SMF = smi_core.SingleMoleculeFitting; % used for PixelSize and FrameRate
DE = smi_stat.DiffusionEstimator(TR, SMF);
DE.FitTarget = 'LikelihoodOfJumps';
DE.DiffusionModel = 'Brownian';
DE.NComponents = 2;
DE.FrameLagRange = [1, 5]; % range of frame lags computed in MSD
DE.EstimateSEs = true; % estimate standard errors of fit D values
DE.FitIndividualTrajectories = false; % fit each trajectory MSD
DE.UnitFlag = false;
DE.Verbose = 1;
DE.estimateDiffusionConstant();

./MATLAB/examples/Example_StatisticsClustering.m
% Examples of how to call StatisticsClustering routines.

SaveDir = fullfile(tempdir, 'smite', 'examples', 'StatisticsClustering');
if ~isfolder(SaveDir)
   mkdir(fullfile(tempdir, 'smite'));
   mkdir(fullfile(tempdir, 'smite', 'examples'));
   mkdir(fullfile(tempdir, 'smite', 'examples', 'StatisticsClustering'));
end
SaveDir = smi_helpers.mkSMITETmpDir('examples', 'StatisticsClustering');

% --- 2D ---

SMF = smi_core.SingleMoleculeFitting();
SMF.Data.ResultsDir = SaveDir;
SC = smi_cluster.StatisticsClustering(SMF);
SC.BaseName = 'twoD';
SC.Verbose = 2;
ROI = [0, 1000, 0, 1000];   % nm

if ~exist(SMF.Data.ResultsDir, 'dir')
   mkdir(SMF.Data.ResultsDir);
end

SIM = smi_sim.SimSMLM();
kmer = 6;                % Hextets
radius_kTet = 25;        % Radius of the k-tets (nm)
PixSize = 100;           % nm in a pixel
receptorDensity = 1;     % Receptors/um^2
SIM.Rho = receptorDensity / (1000 / PixSize)^2;
SIM.simkTets(kmer, radius_kTet);

XY = 1000 * rand(2000, 2);
clear RoI

% Make RoI structure.
RoI{1}.X{1} = XY(1:2:end, 1);
RoI{1}.Y{1} = XY(2:2:end, 2);
RoI{1}.X{2} = SIM.SMD_Model.X;
RoI{1}.Y{2} = SIM.SMD_Model.Y;
RoI{1}.ROI  = ROI;

% Make SMD structures.
SMD1.X = RoI{1}.X{1};
SMD1.Y = RoI{1}.Y{1};
SMD2 = SIM.SMD_Model;
SMD2.X = SMD2.X - min(SMD2.X);
SMD2.Y = SMD2.Y - min(SMD2.Y);
SC.ROI = ROI;

fprintf('2D examples:\n\n');

% Analyze a single label dataset.
particle_types = {'A'};

fprintf('pairwiseDist ...\n');
SC.pairwiseDist(particle_types, SMD1);

% hopkins can be called this way or as further below.
%fprintf('hopkins ...\n');
%SC.hopkins(particle_types, SMD1);

fprintf('ripley ...\n');
SC.ripley(particle_types, SMD1);

% Analyze two datasets containing different labels.
particle_types = {'A', 'B'};

% Note that this makes a separate calculation for each label provided in RoI.
fprintf('hopkins ...\n');
SC.hopkins(particle_types, RoI);

% pairwiseMutualDist and bivariateRipley operate on pairs of labels.
fprintf('pairwiseMutualDist ...\n');
SC.pairwiseMutualDist(particle_types, SMD1, SMD2);

% Demonstrate alternative ways to call these routines.  This methodology
% applies to all StatisticsClustering main routines.  Note that
% pairwiseMutualDist and bivariateRipley are expecting either a single
% argument RoI structure (see smi_helpers.ROITools) or two SMD structures or
% two Nx2 (or Nx3) arrays, while the other functions are expecting an RoI
% structure or one SMD structure or one array.
fprintf('bivariateRipley ...\n');
SC.bivariateRipley(particle_types, SMD1, SMD2);
SC.BaseName = 'twoD_array';
SC.bivariateRipley(particle_types, [SMD1.X, SMD1.Y], [SMD2.X, SMD2.Y]);
SC.BaseName = 'twoD_RoI';
SC.ROI = [];
SC.bivariateRipley(particle_types, RoI);

SC.BaseName = 'twoD';
SC.ROI = ROI;

% ROIcombined series.  Here, we only have one ROI (RoI{1}).
fprintf('hopkins_ROIcombined ...\n');
SC.hopkins_ROIcombined(1, RoI);

fprintf('ripley_ROIcombined ...\n');
SC.ripley_ROIcombined(1, RoI);

fprintf('bivariateRipley_ROIcombined ...\n');
SC.bivariateRipley_ROIcombined(particle_types, 1, RoI);

fprintf('Done 2D.\n');

% --- 3D ---

SMF = smi_core.SingleMoleculeFitting();
SMF.Data.ResultsDir = SaveDir;
SC = smi_cluster.StatisticsClustering(SMF);
SC.BaseName = 'threeD';
ROI = [0, 1000, 0, 1000, 0, 1000];   % nm

if ~exist(SMF.Data.ResultsDir, 'dir')
   mkdir(SMF.Data.ResultsDir);
end

XYZ = 1000 * rand(2000, 3);

% Make RoI structure.
clear RoI
RoI{1}.X{1} = XYZ(1:2:end, 1);
RoI{1}.Y{1} = XYZ(1:2:end, 2);
RoI{1}.Z{1} = XYZ(1:2:end, 3);
RoI{1}.X{2} = XYZ(2:2:end, 1);
RoI{1}.Y{2} = XYZ(2:2:end, 2);
RoI{1}.Z{2} = XYZ(2:2:end, 3);
RoI{1}.ROI = ROI;

% Make SMD structures.
SMD1.X = RoI{1}.X{1};
SMD1.Y = RoI{1}.Y{1};
SMD1.Z = RoI{1}.Z{1};
SMD2.X = RoI{1}.X{2};
SMD2.Y = RoI{1}.Y{2};
SMD2.Z = RoI{1}.Z{2};
SC.ROI = ROI;

fprintf('3D examples:\n\n');

particle_types = {'A'};

fprintf('PairwiseDist ...\n');
SC.pairwiseDist(particle_types, SMD1);

fprintf('Hopkins ...\n');
SC.hopkins(particle_types, SMD1);

fprintf('Ripley ...\n');
SC.ripley(particle_types, SMD1);

particle_types = {'A', 'B'};

fprintf('PairwiseMutualDist ...\n');
SC.pairwiseMutualDist(particle_types, SMD1, SMD2);

fprintf('BivariateRipley ...\n');
SC.bivariateRipley(particle_types, SMD1, SMD2);

fprintf('Done 3D.\n');

fprintf('All results in %s\n', SMF.Data.ResultsDir);

./MATLAB/examples/Example_GaussBlobs.m
%% Demonstrate uses of GaussBlobs Class

%% smi_sim.GaussBlobs.gaussBlobImage
% Generate an image stack of randomly located blobs

Rho = .001; %blobs per pixel
SZ=256; 
Photons=500;
PSFSigma=1.3;
Bg=0;

%setup our SMD and SMF
SMD=smi_core.SingleMoleculeData.createSMD()
SMF=smi_core.SingleMoleculeFitting()

SMF.Data.DataROI=[1 1 SZ SZ];

%create some random data
SMD.NFrames=1000;
SMD.NDatasets=1;

for nn=1:SMD.NFrames
    N=poissrnd(Rho*SZ*SZ);
    SMD.FrameNum=cat(1,SMD.FrameNum,nn*ones(N,1));
    SMD.X=cat(1,SMD.X,SZ*rand(N,1));
    SMD.Y=cat(1,SMD.Y,SZ*rand(N,1));
    SMD.Photons=cat(1,SMD.Photons,Photons*rand(N,1));
    SMD.Bg=cat(1,SMD.Bg,Bg*ones(N,1));
    SMD.DatasetNum=cat(1,SMD.DatasetNum,nn*ones(N,1));
    SMD.PSFSigma=cat(1,SMD.PSFSigma,PSFSigma*ones(N,1));
end

%call image stack generator
im=smi_sim.GaussBlobs.gaussBlobImage(SMD,SMF);

sliceViewer(im/max(im(:)))

%% smi_sim.GaussBlobs.gaussBlobImage.genRandomBlobImage
% quick generation of a random blob image

B=smi_sim.GaussBlobs.genRandomBlobImage();
sliceViewer(B/max(B(:)))









./MATLAB/examples/Example_ChannelRegistration.m
% This script demonstrates some of the functionality in the
% ChannelRegistration class.

% NOTE: This class also has a basic GUI which can do (most) of what is done
%       below. You can start using the GUI with 
%           ChannelReg = smi_core.ChannelRegistration;
%           ChannelReg.gui();
%       The GUI cannot be used to transform coordinates/images, so you'll
%       have to do that in script form (as demonstrated below) after
%       computing the transform with the GUI.

%% Simulate some fiducials to mimic format of real fiducial data.
% NOTE: This will save the simulated fiducials in 'FiducialFileDir' as .mat
%       files.
SaveDir = fullfile(tempdir, 'smite', 'examples', 'ChannelRegistration');
if ~isfolder(SaveDir)
   mkdir(fullfile(tempdir, 'smite'));
   mkdir(fullfile(tempdir, 'smite', 'examples'));
   mkdir(fullfile(tempdir, 'smite', 'examples', 'ChannelRegistration'));
end
SaveDir = smi_helpers.mkSMITETmpDir('examples', 'ChannelRegistration');
FiducialFileDir = fullfile(SaveDir, ...
    'example_data', 'channel_registration');
[~, FiducialFiles] = smi_core.ChannelRegistration.simFiducials(128, 8, ...
    FiducialFileDir);
[~, FileNames, Extension] = fileparts(FiducialFiles);

%% Two separate fiducial files, one image per file (2 channels total).
% Define the path to the fiducial files.  The first entry is for the
% reference fiducial and the second is for the moving fiducial.
FiducialFileNames = {sprintf('%s.mat', FileNames{1}); 
    sprintf('%s.mat', FileNames{2})};

% Prepare an SMF structure for fitting the fiducials.
% NOTE: If using ChannelReg.AutoscaleFiducials = true, you can often get
%       away with only changing SMF.Fitting.PSFSigma.
SMF = smi_core.SingleMoleculeFitting;
SMF.Fitting.PSFSigma = 1.3;

% Prepare the channel registration class.
Verbose = 1;
ChannelReg = smi_core.ChannelRegistration(...
    FiducialFileDir, FiducialFileNames, SMF, Verbose);
ChannelReg.AutoscaleFiducials = true;
ChannelReg.ManualCull = true;

% Compute a locally weighted mean transform from the fiducials.
% NOTE: The transform from fiducial 2 to fiducial 1 will be stored in 
%       ChannelReg.RegistrationTransform{2}.
% NOTE: This will produce an interactive plot showing the fiducials and
%       overlain localizations, in which you can cull points that you don't 
%       want to use. If you don't want this to happen, you can set 
%       ChannelReg.ManualCull = false (not recommended).
ChannelReg.TransformationType = 'lwm';
ChannelReg.TransformationBasis = 'coordinates';
ChannelReg.NNeighborPoints = 12;
ChannelReg.findTransform();

% Estimate the resulting registration error in two ways: (1) RMSE between
% fiducial coordinates before and after the transform, and (2) RMSE between
% fiducial coordinates before and after transform using a leave-one-out
% (LOO) analysis.
% NOTE: For the LOO analysis, we have to provide some additional inputs to
%       estimate the RMSE.  These inputs will change depending on the value
%       of ChannelReg.TransformationType, e.g., for 'lwm', we have to input
%       NNeighborPoints, but for 'polynomial', we have to input the
%       PolynomialDegree.
FixedCoordinates = ChannelReg.Coordinates{2}(:, :, 1);
MovingCoordinates = ChannelReg.Coordinates{2}(:, :, 2);
RMSE = sqrt(mean(ChannelReg.estimateRegistrationError(...
    ChannelReg.RegistrationTransform{2}, ...
    MovingCoordinates, FixedCoordinates)));
RMSELOO = sqrt(mean(ChannelReg.estimateRegErrorLOO(...
    ChannelReg.TransformationType, {ChannelReg.NNeighborPoints}, ...
    MovingCoordinates, FixedCoordinates)));

% Visualize the performance of the channel registration.
FixedImages = ChannelReg.FiducialImages(:, :, 1);
MovingImages = ChannelReg.FiducialImages(:, :, 2);
PlotFigure = figure();
ChannelReg.visualizeRegistrationResults(PlotFigure, ...
    ChannelReg.RegistrationTransform{2}, ...
    MovingCoordinates, FixedCoordinates, ...
    MovingImages, FixedImages);
saveas(gcf, fullfile(SaveDir, 'CR1.png'));

% Visualize the registration error.
PlotFigure = figure();
PlotAxes = axes(PlotFigure);
ChannelReg.visualizeRegistrationError(PlotAxes, ...
    ChannelReg.RegistrationTransform{2}, ...
    MovingCoordinates, FixedCoordinates);
saveas(gcf, fullfile(SaveDir, 'CR2.png'));

% Visualize the transform magnitude and gradient (this isn't usually useful
% unless something went very wrong, in which case it might be obvious in
% this plot!).
FiducialSize = diff(ChannelReg.FiducialROI([1, 2; 3, 4])) + 1;
PlotFigure = figure();
ChannelReg.visualizeCoordTransform(PlotFigure, ...
    ChannelReg.RegistrationTransform{2}, FiducialSize);
saveas(gcf, fullfile(SaveDir, 'CR3.png'));

% Visualize the transforms effect on images.
% WARNING: This one hurts my eyes a bit... Also, it's not too useful unless
%          the transform is very dramatic.
PlotFigure = figure();
PlotAxes = axes(PlotFigure);
ChannelReg.visualizeImageTransform(PlotAxes, ...
    ChannelReg.RegistrationTransform{2}, FiducialSize);
saveas(gcf, fullfile(SaveDir, 'CR4.png'));

% Apply the transform to an SMD structure.
% NOTE: The important code is the call to ChannelReg.transformSMD().  The
%       rest is just me preparing an arbitrary SMD structure.
SMD = smi_core.SingleMoleculeData.createSMD();
SMD.X = linspace(1, FiducialSize(2), 100).';
SMD.Y = linspace(1, FiducialSize(1), 100).';
SMDTransformed = ChannelReg.transformSMD(...
    ChannelReg.RegistrationTransform{2}, ...
    SMD);

% Apply the transform to an image (not meant to be viewed, just showing how
% it can be done!).
% NOTE: You should never transform your raw images before analyzing!  This
%       should only be used for qualitative purposes, e.g., to make a movie
%       with SPT data.
NImages = 100;
TestImages = smi_sim.GaussBlobs.genRandomBlobImage(FiducialSize(1), NImages);
TransformedImages = ChannelReg.transformImages(...
    ChannelReg.RegistrationTransform{2}, ...
    TestImages);

% Save the transform.
ChannelReg.exportTransform(FiducialFileDir)

% Open the GUI, which can do all of the above actions (except transform an
% SMD/transform images).
ChannelReg.gui()

%% Single fiducial image with two channels side by side.
% Define the path to the fiducial files.
FiducialFileNames = {sprintf('%s.mat', FileNames{3})};

% Prepare an SMF structure for fitting the fiducials.
% NOTE: If using ChannelReg.AutoscaleFiducials = true, you can often get
%       away with only changing SMF.Fitting.PSFSigma.
SMF = smi_core.SingleMoleculeFitting;
SMF.Fitting.PSFSigma = 1.3;

% Prepare the channel registration class.
Verbose = 1;
ChannelReg = smi_core.ChannelRegistration(...
    FiducialFileDir, FiducialFileNames, SMF, Verbose);
ChannelReg.AutoscaleFiducials = true;
ChannelReg.ManualCull = true;

% Specify the fiducial file formatting. In this case, I'm specifying 
% [1, 2], which means that the fiducial image will be evenly split along
% its columns, with the right half considered the "moving" channel. See
% ChannelRegistration.convertSplitFormatToROIs() for more options.
ChannelReg.SplitFormat = [1, 2];

% Compute a locally weighted mean transform from the fiducials.
% NOTE: The transform from fiducial 2 to fiducial 1 will be stored in 
%       ChannelReg.RegistrationTransform{2}.
% NOTE: This will produce an interactive plot showing the fiducials and
%       overlain localizations, in which you can cull points that you don't 
%       want to use. If you don't want this to happen, you can set 
%       ChannelReg.ManualCull = false (not recommended).
ChannelReg.TransformationType = 'lwm';
ChannelReg.TransformationBasis = 'coordinates';
ChannelReg.NNeighborPoints = 12;
ChannelReg.findTransform();

./MATLAB/examples/Example_Publish_generic.m
% A generic Publish script to analyze multiple directories of data taken under
% the same conditions.
%
% This script will call smi.Publish to generate misc. results for an
% experiment on the sequential microscope.

%% Define the analysis parameters.
% Define the 'CoverslipDir'.
% NOTE: 'CoverslipDir' is the top-level directory which contains the
%        sub-directories 'CoverslipDir'\Cell*\Label*, which themselves
%        contain data in .h5 files 'CoverslipDir'\Cell*\Label*\Data*.h5
CoverslipDir = '/mnt/nas/cellpath/Actin Asters/22-3-8/HeLa_GFP-GPI_Actin';
SCMOSDir = '/mnt/nas/lidkelab/sCMOS Calibrations/Sequential SR/GainCalibration-2015-12-10-17-19-23.mat';

% Prepare the SMF structure.
SMF = smi_core.SingleMoleculeFitting;
SMF.Data.AnalysisID = ''; % ### Set as desired ###
SMF.Data.CameraType = 'SCMOS';
SMF.Data.CalibrationFilePath = SCMOSDir;
SMF.Data.PixelSize = 0.0954; % microns
SMF.Fitting.PSFSigma = 1.3; % pixels
SMF.Fitting.FitType = 'XYNBS';
SMF.FrameConnection.Method = 'LAP-FC';
SMF.FrameConnection.On = true;
SMF.DriftCorrection.On = true;
SMF.Thresholding.MaxPSFSigma = 1.5; % pixels
SMF.Thresholding.MinPSFSigma = 0.9; % pixels
SMF.Thresholding.MinPhotons = 200; % dSTORM
%SMF.Thresholding.MinPhotons = 500; % DNA-PAINT
SMF.Thresholding.MaxXY_SE = 0.15; % pixels

% Additional filtering
%SMF.Data.SEAdjust = 3 / (1000 * SMF.Data.PixelSize); % nm converted to pixels
%SMF.FrameConnection.MinNFrameConns = 2;
%SMF.Thresholding.InMeanMultiplier = 2;
%SMF.Thresholding.NNMedianMultiplier = 3; % DNA-PAINT
%SMF.Thresholding.MinNumNeighbors = 2; % DNA-PAINT

%% Prepare the smi.Publish class and run the standard analysis.
% The smi.Publish class requires the SMF (defined above) as well as the
% 'CoverslipDir'.  All other class properties specify which analyses to do.
Publish = smi.Publish(SMF);
Publish.CoverslipDir = CoverslipDir;
Publish.Verbose = 1;
Publish.GenerateSR = 1;
Publish.GenerateImagingStats = 0;
Publish.GenerateOverlayStats = 0;
Publish.ShiftToReg = 0;% can be useful for color overlay data, use with caution!
Publish.SRImageZoom = 20;

% Define trust regions, so that anything that seems to have a shift above the
% value below will be masked out.  Note that PixelSize is in microns/pixel, so
% the multiplying factor (0.2) is in units of microns.
%Publish.MaxBrightfieldShift = 0.2 / SMF.Data.PixelSize; % pixels

% smi.Publish contains several useful methods, however we'll almost always
% just call performFullAnalysis().
Publish.performFullAnalysis()

% ----------

% Additional directories to Publish can be done by the following lines.

CoverslipDir = '/mnt/nas/cellpath/Actin Asters/22-3-8-b/HeLa_GFP-GPI_Actin';
Publish = smi.Publish(SMF);
Publish.CoverslipDir = CoverslipDir;
Publish.Verbose = 1;
Publish.GenerateSR = 1;
Publish.GenerateImagingStats = 0;
Publish.GenerateOverlayStats = 0;
Publish.ShiftToReg = 0;% can be useful for color overlay data, use with caution!
Publish.SRImageZoom = 20;
Publish.performFullAnalysis()

CoverslipDir = '/mnt/nas/cellpath/Actin Asters/22-3-8-b/HeLa_GFP-GPI_Actinb';
Publish = smi.Publish(SMF);
Publish.CoverslipDir = CoverslipDir;
Publish.Verbose = 1;
Publish.GenerateSR = 1;
Publish.GenerateImagingStats = 0;
Publish.GenerateOverlayStats = 0;
Publish.ShiftToReg = 0;% can be useful for color overlay data, use with caution!
Publish.SRImageZoom = 20;
Publish.performFullAnalysis()

CoverslipDir = '/mnt/nas/cellpath/Actin Asters/22-3-8-c/HeLa_GFP-GPI_Actin';
Publish = smi.Publish(SMF);
Publish.CoverslipDir = CoverslipDir;
Publish.Verbose = 1;
Publish.GenerateSR = 1;
Publish.GenerateImagingStats = 0;
Publish.GenerateOverlayStats = 0;
Publish.ShiftToReg = 0;% can be useful for color overlay data, use with caution!
Publish.SRImageZoom = 20;
Publish.performFullAnalysis()

./MATLAB/examples/Example_LocalizeData.m
%% Demonstrates LocalizeData Class

SaveDir = smi_helpers.mkSMITETmpDir('examples', 'LocalizeData');

%create a test dataset
B = smi_sim.GaussBlobs.genRandomBlobImage();
B = poissrnd(B);

%setup SMF
SMF = smi_core.SingleMoleculeFitting()

%setup LocalizeData object
LD = smi_core.LocalizeData(B, SMF)

%Localize with defaults
[SMD] = LD.genLocalizations();

saveas(gcf, fullfile(SaveDir, 'LD1.png'));

%Set Verbose to give color overlay output
LD.Verbose = 3;
[SMD] = LD.genLocalizations();

saveas(gcf, fullfile(SaveDir, 'LD2.png'));

./MATLAB/examples/simplePairCorr.m
% Work flow: (note results are put in the subdirectory 'Analysis')
% NOTE: smite should be on your MATLAB path.
%
%   Set important parameters:
%      ROI_sizes, Pixel2nm, start_datadir
%   Define the ROIs:
%            _ResultsStruct.mat (or _Results.mat) -> _ROIs.mat
%      (each image [ResultsStruct or Results file] produces a separate ROIs
%       file containing all the ROIs for that image; the idea is to do all the
%       ROI selection early on so it need not be repeated---each image can have
%       multiple ROIs; note that this deals with files in a single directory)
%   Analyze the ROIs one-by-one:
%            _ROIs.mat -> _results.mat, etc.
%      (compute results for each ROI defined by the selected files located in
%       the same directory)
%   Analyze a group of files of ROIs all together:
%            multiple _ROIs.mat
%                 -> ALL_ and analysis_ALL_*.mat
%      (compute combined results for the ROIs defined by the selected files
%       located in the same directory)
%
% Avoid spaces in filenames and conditions!!!
%
% See doAnalysis    for analyses to perform:
%     doBiStats     for mutual pairwise distance and bivariate Ripley's plots
%     doClustering  for cluster parameters: E and minPts
%     doClusterSep2 for cluster separation plots
%     doLocSep2     for nearest neighbor localization separation plots
%     doOverlap1    for overlaps between label 1 clusters and label 2 locs
%     doOverlap2    for overlaps between label 2 clusters and label 1 locs
%     doPairCorr    for pair correlation settings
%     doPlot2       for 2-color plots
%
% Output figure naming conventions:
%    *_ROI*_L1/2_algorithm            clustering by algorithm
%    *_ROI*_L1/2_pairwiseCDF/PDF      NN distances compared to a random dist.
%    *_ROI*_L1,L2_pairwisePDF2/CDF2   NN distances 2-label PDF/CDF
%    *_ROI*_bivripley                 bivariate Ripley's
%    *_ROI*_crosscorr                 ROIwise pairwise cross-correlations
%    *_RC_crosscorrR                  ROI combined pairwise cross-correlation
%    *_cL1_lL2                        L1 clusters, L2 localizations overlap
%    *_cL2_lL1                        L2 clusters, L1 localizations overlap
%    *_ROI*_L1+L2                     2-label plots of localizations
%    *_cs_RC_PDF/CDF                  ROI combined 2-label cluster separations
%    *_ls_ROI*                        histogram per ROI of loc. L1+L2 seps.
%    *_ls_RC_PDF/CDF                  ROI combined localization L1+L2 seps.

%% --- Set important parameters
% Collect the set of files expressing each label together.

PA = smi_cluster.PairAnalysis();

%start_datadir = '/mnt/nas/cellpath/Genmab/Data/20221119_CHO_HAEGFR_antiHA_antiC1Q/PairwiseCorr';
start_datadir = '.';
Analysis = 'Analysis';

particles = {'L1', 'L2'};     % label short descriptors
Color = ['g', 'm'];           % label 1 and 2 colors on display
%Pixel2nm = 108.018;           % pixels to nm [TIRF]
Pixel2nm = 97.8;              % pixels to nm [sequential]
HistBinSize = 5;              % # pixels per bin to collect correlation stats
%RmaxAxisLimit = -1;           % sets r axis limit for pair correlation plots
RmaxAxisLimit = 400;          % sets r axis limit for pair correlation plots
                              % if > 0 (nm)
ROI_sizes = [7000, 7000];     % ROI sizes (nm)
RegistrationNeeded = false;   % 2-color registration via fiducials needed?
RegistrationViaDC = false;    % 2-color registration via drift correction?
E = [20, 20];                 % epsilon: max distance between 2 adjacent points
                              % in a cluster per label (nm)
minPts = [3, 3];              % minimum number of points in a cluster per label
%property.Fig_ext = '';       % if blank, produce .fig files rather than .png

% ROIs to exclude for combined processing---for example for files 1, 2, 3
%    ExcludeROI = {{2, 1}, {3, [2, 4]}}
% excludes ROI 1 from file2, ROIs 2+4 from file3
ExcludeROI = {};

% Preprocess exclusions.
excludedFiles = [];
if ~isempty(ExcludeROI)
   excludedFiles = arrayfun(@(k) ExcludeROI{k}{1}, 1:numel(ExcludeROI));
end

% Set up the results directory.
results_top = uigetdir(start_datadir, 'Directory to hold results directory');
results_dir = fullfile(results_top, Analysis);
data_dir = results_top;
%data_dir = results_dir;   % TESTING
property.Results = results_dir;
% Create results_dir if it does not already exist.
if ~isdir(results_dir)
   mkdir(results_dir);
end

% If true, look for MAPN_*.mat, otherwise *_Results*.mat for BaGoL coordinates.
MAPNfile = false;

% For overlap plots, do NOT plot non-overlapping localizations if false.
PlotNonOverlap = false;

% options:
%    'combined'    only produce combined results over all ROIs
%    'plotting'    produce most individual plots
%    'BiStats'     pairwise mutual distances and bivariate Ripley's statistics
%                  for each ROI
%    'Clustering'  clusters for each label per ROI
%    'Clustering2' C2C nearest neighbor distances between label 1/label 2
%                  clusters per ROI and combined over all ROIs
%    'LocSep2'     nearest neighbor localization distances between labels 1 & 2
%    'Overlap1'    overlaps between label 1 clusters and label 2 localizations
%    'Overlap2'    overlaps between label 2 clusters and label 1 localizations
%    'PairCorr'    pair correlation per ROI and combined over all ROIs
%    'Plot2'       2D plot per ROI
options = ["BiStats", "Clustering", "Clustering2", "LocSep2", ...
           "Overlap1", "Overlap2", "PairCorr", "Plot2"];
options = ["BiStats", "Clustering", "LocSep2", "Overlap2", "PairCorr"];
%options = ["PairCorr"];

fprintf('Done set parameters.\n');

%% ---------- Define the ROIs

% ROIS in a cell are defined by n_ROIs (number of ROIs) and
%    RoI{1:n_ROIs}.ROI             ROI coordinates (xmin, xmax, ymin, ymax)
%    RoI{1:n_ROIs}.X/Y/X_SE/Y_SE   [L1 values, L2 values]

% Collect the Label 1 files.
Files1 = {};
if MAPNfile
   Files1 = uipickfiles('FilterSpec', start_datadir, 'REFilter', ...
                        'MAPN.*\.mat', 'Prompt',                 ...
                        'Label 1 MAPN*.mat files');
else
   Files1 = uipickfiles('FilterSpec', start_datadir, 'REFilter', ...
                        '.*_Results.*\.mat', 'Prompt',           ...
                        'Label 1 _Results*.mat files');
end
n_files = numel(Files1);
if n_files == 0
   error('No files chosen for Label 1!');
end

% Collect the Label 2 files.
Files2 = {};
if MAPNfile
   Files2 = uipickfiles('FilterSpec', start_datadir, 'REFilter', ...
                        'MAPN.*\.mat', 'Prompt',                 ...
                        'Label 2 MAPN*.mat files');
else
   Files2 = uipickfiles('FilterSpec', start_datadir, 'REFilter', ...
                        '.*_Results.*\.mat', 'Prompt',           ...
                        'Label 2 _Results*.mat files');
end

if numel(Files2) ~= n_files
   error(['The two sets should each contain the same number of files!\n', ...
          'Label 1 (%d) versus Label 2 (%d)'], n_files, numel(Files2));
end

% Select the ROIs over all images.
n_ROIs_ALL = PA.defineROIs2(Files1, Files2, Pixel2nm, Color, ROI_sizes, ...
                            results_dir,                                ...
                            RegistrationNeeded, RegistrationViaDC);

%% ---------- Analyze the ROIS one-by-one

% NOTE:
%    results_c{1:n_files}{1:n_ROIs}{1:2}   clustering results by ROI and label
%    results_cs{1:n_files}{1:n_ROIs}       cluster separations between 2 labels
%    results_ls{1:n_files}{1:n_ROIs}       loc. separations between 2 labels
%    results_o1{1:n_files}{1:n_ROIs}       L1 clusters/L2 localizations overlap
%    results_o2{1:n_files}{1:n_ROIs}       L2 clusters/L1 localizations overlap
%    results_pcc{1:n_files}{1:n_ROIs}      pair cross-correlation results
%    resultsRC_pcc{1:n_files}              as above for ROIs combined
% The {1:n_files} is added at this level on the call to doAnalysis.

% Analyze the ROIs in each file.
opts = options;
if ~any(contains(opts, "plotting"))
   opts(end + 1) = "plotting";
end
files = dir(fullfile(data_dir, '*_ROIs.mat'));
n_files = numel(files);
fprintf('n_files = %d\n', n_files);
if n_files == 0
   error('No files chosen!');
end
%[~, files] = ...
%   smi_helpers.selectFiles(results_dir, '_ROIs.mat files', '*_ROIs.mat');
results_c     = cell(n_files, 1);
results_cs    = cell(n_files, 1);
results_ls    = cell(n_files, 1);
results_o1    = cell(n_files, 1);
results_o2    = cell(n_files, 1);
results_pcc   = cell(n_files, 1);
resultsRC_pcc = cell(n_files, 1);
for i = 1 : n_files
   filename = files(i).name;
   %filename = files{i};
   clear n_ROIs RoI
   % Load ROIs from file i.
   load(fullfile(data_dir, filename));
   % Clean up the description.
   desc = regexprep(filename, '_ROIs.mat', '');
   desc = regexprep(desc, '_ResultsStruct_BaGoL', '');
   desc = regexprep(desc, '_ResultsStruct', '');
   [results_pcc{i}, resultsRC_pcc{i}, results_c{i}, results_cs{i}, ...
    results_ls{i}, results_o1{i}, results_o2{i}] = ...
      PA.doAnalysis(n_ROIs, RoI, ROI_sizes, desc, particles, results_dir,  ...
                    opts, Pixel2nm, HistBinSize, RmaxAxisLimit, E, minPts, ...
                    PlotNonOverlap, Color);
end
analysis = 'analysis';
save(fullfile(results_dir, analysis), 'results_pcc', 'resultsRC_pcc', ...
     'results_c', 'results_cs', 'results_ls', 'results_o1', 'results_o2');
% Save analysis.mat
fprintf('Done one-by-one.\n');

%% ---------- Analyze a group of files of ROIs all together

%files = dir(fullfile(data_dir, '*_ROIs.mat'));
[~, files] = ...
   smi_helpers.selectFiles(data_dir, '_ROIs.mat files', '*_ROIs.mat');
n_files = numel(files);
fprintf('n_files = %d\n', n_files);
if n_files == 0
   error('No files chosen!');
end
answer = inputdlg('Name of combined results file:');
desc = answer{1};
if ~startsWith(desc, 'ALL')
   desc = ['ALL_', desc];
end

n_ROIs_ALL = 0;
for i = 1 : n_files
   %filename = files(i).name;
   filename = files{i};
   clear n_ROIs RoI
   % Load ROIs from file i.  Check for exclusions.
   load(fullfile(data_dir, filename));
   j = find(i == excludedFiles);
   if ~isempty(ExcludeROI) && ~isempty(j);
      excludedROIs = ExcludeROI{j}{2};
      RoI(excludedROIs) = [];
      n_ROIs = numel(RoI);
   end
   n_ROIs_ALL = n_ROIs_ALL + n_ROIs;
end
fprintf('n_ROIs_ALL = %d\n', n_ROIs_ALL);

% Combine all the ROIs together and reanalyze.
opts = options;
if ~any(contains(opts, "combined"))
   opts(end + 1) = "combined";
end
RoI_ALL = cell(n_ROIs_ALL, 1);
k = 0;
for i = 1 : n_files
   %filename = files(i).name;
   filename = files{i};
   clear n_ROIs RoI
   % Load ROIs from file i.  Check for exclusions.
   load(fullfile(data_dir, filename));
   j = find(i == excludedFiles);
   if ~isempty(ExcludeROI) && ~isempty(j);
      excludedROIs = ExcludeROI{j}{2};
      RoI(excludedROIs) = [];
      n_ROIs = numel(RoI);
   end
   for j = 1 : n_ROIs
      k = k + 1;
      RoI_ALL{k} = RoI{j};
   end
end

% Save analysisALL.mat
analysis = ['analysis', desc];
[results_pcc_ALL, resultsRC_pcc_ALL, results_c_ALL, results_cs_ALL, ...
 results_ls_ALL, results_o1_ALL, results_o2_ALL] = ...
   PA.doAnalysis(n_ROIs_ALL, RoI_ALL, ROI_sizes, desc, particles,         ...
                 results_dir, opts, Pixel2nm, HistBinSize, RmaxAxisLimit, ...
                 E, minPts, PlotNonOverlap, Color);
save(fullfile(results_dir, analysis), 'results_pcc_ALL',     ...
     'resultsRC_pcc_ALL', 'results_c_ALL', 'results_cs_ALL', ...
     'results_ls_ALL', 'results_o1_ALL', 'results_o2_ALL');
fprintf('Done %s.\n', desc);

./MATLAB/examples/Example_HMM.m
% This script demonstrates the basic usage of smi_stat.HMM.  We start by
% simulating some raw tracking data, reloading the raw data and tracking,
% and finally running the tracking results through the HMM analysis
% pipeline to search for dimers.  Simulated data and results will be saved
% in freshly generated directories under smite/MATLAB/examples/spt/

%% Simulate and save some SPT data in the format expected for real data.
% Simulate some diffusing blobs and save simulated raw data.
rng(12)
DataParams.NDatasets = 10;
SimParams.FrameSize = [64, 64];
SimParams.NFrames = 1000;
SimParams.ParticleDensity = 0.01; % particles / px^2, make 2X target since we split into 2 channels
SimParams.D = 0.1; % px^2 / frame
SimParams.KOffToOn = 0.95;
SimParams.KOnToOff = 0.05;
SimParams.KOnToBleach = 1e-3;
SimParams.Intensity = 1000;
SimParams.KDisconnect = 0.05;
SimParams.InteractionDistance = 0.5; % pixels
SimParams.InteractionProb = 0.5;
SaveDir = fullfile(tempdir, 'smite', 'examples', 'HMM');
if ~isfolder(SaveDir)
   mkdir(fullfile(tempdir, 'smite'));
   mkdir(fullfile(tempdir, 'smite', 'examples'));
   mkdir(fullfile(tempdir, 'smite', 'examples', 'HMM'));
end
DataDir = fullfile(SaveDir, ...
    'example_data', 'spt', smi_helpers.genTimeString());
if ~isfolder(DataDir)
    mkdir(DataDir)
end
[~, SimParams, DataParams] = smi_sim.SimSPT.makeExampleSim(...
    SimParams, DataParams, DataDir); % SimParams and DataParams padded w/ defaults

%% Prepare an SMF structure for each channel.
% NOTE: Channel 1 will not be transformed (it is the reference channel), so
%       we should ensure SMFChannel1.Data.RegistrationFilePath is empty!
PixelSize = 0.1; % must be set to true data values
FrameRate = 20;
SMFChannel1 = smi_core.SingleMoleculeFitting;
SMFChannel1.Data.AnalysisID = 'Channel1';
SMFChannel1.Data.FileDir = DataDir;
SMFChannel1.Data.DataROI = [1, 1, ...
    SimParams.FrameSize(1), SimParams.FrameSize(2)]; % left half of data [YStart, XStart, YEnd, XEnd]
SMFChannel1.Data.RegistrationFilePath = '';
SMFChannel1.Data.PixelSize = PixelSize;
SMFChannel1.Data.FrameRate = FrameRate;
SMFChannel1.Fitting.PSFSigma = SimParams.PSFSigma;
SMFChannel1.Tracking.MaxFrameGap = 20;
SMFChannel2 = copy(SMFChannel1);
SMFChannel2.Data.AnalysisID = 'Channel2';
SMFChannel2.Data.DataROI = [1, 1 + SimParams.FrameSize(2), ...
    SimParams.FrameSize(1), 2*SimParams.FrameSize(2)]; % right half of data
SMFChannel2.Data.RegistrationFilePath = '';

%% Prepare an SPT class object for each channel and then track.
SPTChannel1 = smi.SPT(SMFChannel1, false);
SPTChannel1.GenerateMovies = false;
SPTChannel1.GeneratePlots = false;
SPTChannel2 = smi.SPT(SMFChannel2, false);
SPTChannel2.GenerateMovies = false;
SPTChannel2.GeneratePlots = false;

%% Loop through our data files and track one at a time.
FileList = dir(fullfile(DataDir, 'Data_*.mat'));
FileList = FileList(~[FileList.isdir]); % exclude directories
NFiles = numel(FileList);
for nn = 1:NFiles
    % Update the file name in each of the SPT objects.
    SPTChannel1.SMF.Data.FileName = FileList(nn).name;
    SPTChannel2.SMF.Data.FileName = FileList(nn).name;
    
    % Perform the tracking.
    SPTChannel1.performFullAnalysis()
    SPTChannel2.performFullAnalysis()
end

%% Reload the tracked results and search for dimer candidates.
% NOTE: 'FileDir' is a directory containing both channel 1 and channel 2
%        results files.  findDimerCandidatesFromFiles() will search this
%        directory for files matching FilePatterns{1} and treat those files
%        as channel 1 results.  It will then do the same for
%        FilePatterns{2} (channel 2 results) and then attempt to match the
%        channel 1 and channel 2 files based on their file names (e.g.,
%        Data01_Channel1_Results.mat would be paired to
%        Data01_Channel2_Results.mat).
ResultsDir = fullfile(DataDir, 'Results');
FilePatterns = {'*Channel1_Results.mat'; '*Channel2_Results.mat'};
MaxDimerSeparation = 2; % pixels
MaxSeparation = 5; % pixels
[TRArray, ~, FileList] = smi_stat.HMM.findDimerCandidatesFromFiles(...
    ResultsDir, FilePatterns, MaxDimerSeparation, MaxSeparation);

% Add diffusion coefficients to the TRArray.
% NOTE: You can also do this on a per-trajectory basis if needed.
[TRArray.DiffusionCoefficient] = deal(SimParams.D);

%% Prepare the HMM class and run the analysis.
SMF = smi_core.SingleMoleculeFitting;
SMF.Data.FrameRate = FrameRate; % fps, specific to the loaded TRs above
SMF.Data.PixelSize = PixelSize; % micrometers, specific to the loaded TRs above
HMM = smi_stat.HMM(TRArray, SMF);
HMM.MaxSeparation = MaxSeparation;
HMM.DimerSeparation = SimParams.InteractionDistance; % pixels, TRUE physical separation between dimers
HMM.SaveDir = fullfile(ResultsDir, 'HMM_Results');
HMM.GeneratePlots = [true; true]; % [basic plots; summary plots]
HMM.UnitFlag = false;
HMM.performFullAnalysis()

./MATLAB/examples/singleConditionDriver.m
% Perform cluster analysis for comparison of experimental conditions.  This is
% a batch version of simpleROIcluster_smite for performing parameter studies.
% See pathname/files definition below in Statistics for a single condition.
% 
% NOTE: smite and PlotSpread should be on your MATLAB path.
%
% Work flow: (note results are put in the subdirectory 'Analysis')
%   Set important parameters:
%      ROI_sizes, Pixel2nm, start_datadir, oneROI
%   Statistics for a single condition:
%            _ROIs.mat -> ALL_*
%      (compute statistics for a single condition consisting of a number of
%       images all located in the same directory)
%
% Avoid spaces in filenames and conditions!!!

%% ---------- Set important parameters

doHopkins = true;  % Hopkins' test can be time consuming for dense ROIs 
% Set to false for very dense ROIs to avoid crashes due to lack of memory.
doSigmaActual = false;

ROI_sizes = [2000, 2000];   % [delta_x, delta_y] (nm)
A_ROI = prod(ROI_sizes);    % ROI area (nm^2)
%Pixel2nm = 16000/150;       % conversion factor from pixels to nm
%Pixel2nm = 108.018;         % pixels to nm [TIRF]
Pixel2nm = 97.8;            % pixels to nm [sequential]

% Often, for BaGoL analyses, it is simpler to use a single, large, encompassing
% ROI rather than a series of small ROIs.
oneROI = false;
%oneROI = true;
if oneROI
   ROI_sizes = [256, 256] * Pixel2nm;   % (nm)
   A_ROI = prod(ROI_sizes);
end

% Select the files starting from start_datadir.
%start_datadir = '/mnt/nas/cellpath/Genmab/Data/20220426 CHOK1 HAEGFR initial AB testing/ROIs and DBscan';
%start_datadir = '/mnt/nas/cellpath/Genmab/Publish+BaGoL+cluster/RGY';
start_datadir = 'P:\Genmab\Publish+BaGoL+cluster';

fprintf('Done set parameters.\n');

%  - - - - - Choose _ROIs.mat files

% Interactive input.
%[pathname, files] = smi_helpers.selectFiles(start_datadir, ...
%                       '_ROIs.mat files', '*_ROIs.mat');
%answer = inputdlg('Name of combined results file:');
%condition = answer{1};

% Look for condition/Analysis/*_ROIs.mat or uncomment "files = ..."
% lines below and list files manually.
% Use specified condition.
%condition = '2F8';
%condition = 'B12';
%condition = 'E345R';
condition = 'RGY';
pathname = fullfile(start_datadir, condition, 'Analysis');
FILES = dir(fullfile(pathname, '*_ROIs.mat'));
files = { FILES.name };

% Manual specification.
%files = {
%'Cell_01_Label_01_Results_ROIs.mat'
%};

% base_name is a short identifier describing the analysis.
base_name = condition;

%  - - - - - Set up batch analysis ranges

% Minimum distance between clusters or maximum distance between points in a
% cluster.
E_range = [30, 40, 50];   % (nm)
% Minimum number of points in a cluster.
minPts_range = [3, 6, 10];
% Clustering algorithm.
%algorithm_range = {'DBSCAN', 'Hierarchical', 'Voronoi'};
algorithm_range = {'DBSCAN'};

CI = smi_cluster.ClusterInterface();
CI.singleCondition(pathname, files, algorithm_range, E_range, minPts_range,...
                   Pixel2nm, base_name, A_ROI, doHopkins, doSigmaActual);

./MATLAB/examples/README.md
### ***smite*** examples and unit tests

Self-contained examples of using SMITE code:

|| example code ||
---|---|---
&nbsp;| [Example_ChangeDetection](Example_ChangeDetection.m)                    | change point detection
G     | [Example_ChannelRegistration](Example_ChannelRegistration.m)              | 2-color channel registration
&nbsp;| [Example_Clustering](Example_Clustering.m)                              | various ways to invoke clustering routines
&nbsp;| [Example_DiffusionEstimator](Example_DiffusionEstimator.m)              | diffusion estimator
G     | [Example_GaussBlobs](Example_GaussBlobs.m)                              | generate image stack of randomly located blobs
G     | [Example_HMM](Example_HMM.m)                                            | hidden Markov model for dimer detection
G     | [Example_LocalizeData](Example_LocalizeData.m)                          | find localizations in an image stack
&nbsp;  | [Example_PairCorrelation](Example_PairCorrelation.m)                  | compute auto- and cross-correlations of data
G     | [Example_SPT](Example_SPT.m)                                            | single particle tracking
G     | [Example_SPTBatch](Example_SPTBatch.m)                                  | single particle tracking via batch processing
&nbsp;| [Example_StatisticsClustering](Example_StatisticsClustering.m)          | various statistical measures of clustering
&nbsp;| [Example_simSMLM](Example_simSMLM.m)                                    | generate synthetic data for a Siemen's star

G indicates a GPU is used.

SMITE code templates requiring user-supplied data:

| example code ||
---|---
[Example_Publish](Example_Publish.m)                                            | generate results for a microscope experiment
[Example_Publish_generic](Example_Publish_generic.m)                            | as above for multiple directories of data
[Example_SMLM_Basic](Example_SMLM_Basic.m)                                      | demonstrate basic SMLM functionality
[Example_SMLM_script](Example_SMLM_script.m)                                    | example of SMLM analysis
[hierBaGoL_wrapper](hierBaGoL_wrapper.m)                                        | wrapper used to call BaGoL routines
[plotROIDriver](plotROIDriver.m)                                                | plot dot, Gaussian or circle images of ROIs
[simplePairCorr](simplePairCorr.m)                                              | step-by-step script to choose 2-label ROIs & do various analyses for ROIs separate or combined
[simpleROIcluster](simpleROIcluster.m)                                          | step-by-step script to choose ROIs, cluster and analyze/compare conditions for 1-label data
[singleConditionDriver](singleConditionDriver.m)                                | batch cluster analysis for comparison of experimental conditions for 1-label data
[spt_resolft_track_demo](spt_resolft_track_demo.m)                              | SPT-RESOLFT example

SMITE unit tests (see also [ExpectedResults](../ExpectedResults/README.md)):
- [smi.SMLM.unitTest](../+smi/@SMLM/unitTest.m)
- [smi.SPT.unitTestFFGC](../+smi/@SPT/unitTestFFGC.m) (frame-to-frame and gap closing processes)
- [smi_cluster.Clustering.unitTest](../+smi_cluster/@Clustering/unitTest.m)
- [smi_cluster.PairCorrelation.unitTest](../+smi_cluster/@PairCorrelation/unitTest.m)
- [smi_cluster.StatisticsClustering.unitTest](../+smi_cluster/@StatisticsClustering/unitTest.m)
- [smi_core.ChannelRegistration.unitTest](../+smi_core/@ChannelRegistration/unitTest.m)
- [smi_core.DataToPhotons.unitTest](../+smi_core/@DataToPhotons/unitTest.m)
- [smi_core.DriftCorrection.unitTest](../+smi_core/@DriftCorrection/unitTest.m)
- [smi_core.FrameConnection.unitTest](../+smi_core/@FrameConnection/unitTest.m)
- [smi_core.LocalizeData.unitTest](../+smi_core/@LocalizeData/unitTest.m)
- [smi_core.Threshold.unitTest](../+smi_core/@Threshold/unitTest.m)
- [smi_psf.PointSpreadFunction.unitTest](../+smi_psf/@PointSpreadFunction/unitTest) (does the following unit tests)
  - [smi_psf.PointSpreadFunction.crlbPSFPupil_unitTest](../+smi_psf/@PointSpreadFunction/crlbPSFPupil_unitTest.m)
  - [smi_psf.PointSpreadFunction.optimPSFZernike_unitTest](../+smi_psf/@PointSpreadFunction/optimPSFZernike_unitTest.m)
  - [smi_psf.PointSpreadFunction.psfROIStack_unitTest](../+smi_psf/@PointSpreadFunction/psfROIStack_unitTest.m)
  - [smi_psf.PointSpreadFunction.scalarPSFPrasadZone_unitTest](../+smi_psf/@PointSpreadFunction/scalarPSFPrasadZone_unitTest.m)
  - [smi_psf.PointSpreadFunction.zernikeImage_unitTest](../+smi_psf/@PointSpreadFunction/zernikeImage_unitTest.m)
- [smi_psf.Zernike.unitTest](../+smi_psf/@Zernike/unitTest.m)
- [smi_sim.GaussBlobs.unitTest](../+smi_sim/@GaussBlobs.m)
- [smi_sim.SimSMLM.unitTest](../+smi_sim/@SimSMLM/unitTest.m)
- [smi_stat.ChangeDetection.unitTest](../+smi_stat/@ChangeDetection/unitTest.m)
- [smi_stat.DiffusionEstimator.unitTest](../+smi_stat/@DiffusionEstimator/unitTest.m)
- [smi_stat.HMM.unitTest](../+smi_stat/@HMM/unitTest.m)
- [smi_vis.GenerateImages.blobColorOverlay_unitTest](../+smi_vis/@GenerateImages/blobColorOverlay_unitTest.m)
- [smi_vis.GenerateImages.circleImage_unitTest](../+smi_vis/@GenerateImages/circleImage_unitTest.m)
- [smi_vis.GenerateImages.colorImage_unitTest](../+smi_vis/@GenerateImages/colorImage_unitTest.m)
- [smi_vis.GenerateImages.driftImage_unitTest](../+smi_vis/@GenerateImages/driftImage_unitTest.m)
- [smi_vis.GenerateImages.gaussianImage_unitTest](../+smi_vis/@GenerateImages/gaussianImage_unitTest.m)
- [smi_vis.GenerateImages.histogramImage_unitTest](smi_vis/@GenerateImages/histogramImage_unitTest.m)

./MATLAB/examples/spt_resolft_track_demo.m
%% here only need to select the data, other parameters will be set below
SMF = smi_core.SingleMoleculeFitting;
SMF.gui

%% set path to dark frame file
%offsetfile = 'Y:\sCMOS Calibrations\SPT\GainCalibration_darkFrames_2022_10_26_18_02_10.mat';
offsetfile = '/mnt/nas/lidkelab/sCMOS Calibrations/SPT/GainCalibration_darkFrames_2022_10_26_18_02_10.mat';
load(offsetfile)
ccdoffset = mean(sequence,3);
ccdvar = var(single(sequence),1,3);

%% Prepare the SPT class object.

SPT = smi.SPT(SMF, false);
SPT.GenerateMovies = false;
SPT.GeneratePlots = false;
SPT.SMF.Data.CameraOffset = ccdoffset;
SPT.SMF.Data.CameraGain = 3.8*ones(size(ccdoffset));
SPT.SMF.Data.CameraReadNoise = ccdvar;
SPT.SMF.Data.PixelSize = 0.1; % um
SPT.SMF.BoxFinding.MinPhotons = 20;
SPT.SMF.BoxFinding.BoxSize = 11;
SPT.SMF.Fitting.FitType = 'XYNBSXSY';
SPT.SMF.Fitting.NParams = 6;
SPT.SMF.Fitting.PSFSigma = 2;
SPT.SMF.Fitting.Iterations = 50;
SPT.SMF.Thresholding.AutoThreshLogL = 1;
SPT.SMF.Thresholding.MaxXY_SE = 1;
SPT.SMF.Thresholding.MaxPSFSigma = 3;
SPT.SMF.Thresholding.MinPhotons = 10;
SPT.SMF.Thresholding.MinPValue = 0;
SPT.SMF.FrameConnection.On = 0;
SPT.SMF.DriftCorrection.On = 0;
SPT.performFullAnalysis();

%% show tracks > 20 localizations
Nf = length(SPT.TR);
figure;
ha = axes;hold on
for tt=1:Nf
    trk = SPT.TR(tt);
    if numel(trk.X)>20

        plot3(trk.X,trk.Y,trk.FrameNum,'.-')
    end
end
xlabel('x (pixel)')
ylabel('y (pixel)')
zlabel('frame')
view(30,30)
grid(ha,"on")
%% run change point analysis for tracks > 20 localizations
h = figure('Position',[200,100,600,500]);
tg1 = uitabgroup(h); % tabgroup
LogBayesThreshold = 150;
trackID = []; % save tracks with change points
count = 1;
for ii = 1:Nf
    trk = SPT.TR(ii);
    if numel(trk.X)>20
        icp = smi_stat.ChangeDetection(round(double(trk.Photons)),LogBayesThreshold);
        if ~isempty(icp.ChangePoints)
            xs=1:icp.Nobservations;
            tab1 = uitab(tg1,'title',num2str(ii));
            ha = axes('parent',tab1);
            stairs(xs, icp.Data, '-ko');
            hold on;
            Is=smi_stat.ChangeDetection.modelIntensity(icp.Nobservations, icp.ChangePoints, icp.Intensity);
            stairs(xs, Is, '-r', 'LineWidth', 2.0);
            yl=ylim;
            ylim([0,yl(2)]);
            hold off;
            xlabel('time');
            ylabel('intensity');
            legend('Data', 'Estimated', 'Location', 'North');
            trackID(count) = ii;
            count = count+1;
        end
    end
end

%% add final bleaching step for selected candidate track from above plot
TR_candidate = [];
data = SPT.ScaledData;
h = figure('Position',[200,100,600,500]);
tg1 = uitabgroup(h); % tabgroup
for ii = 1:numel(trackID)
    ind = trackID(ii);
    trk = SPT.TR(ind);
    TR_candidate{ii} = trk;
    % crop data from last bleaching step, 10 frame
    bxsz = 11;
    roi = data(round(trk.Y(end)-bxsz/2):round(trk.Y(end)+bxsz/2),round(trk.X(end)-bxsz/2):round(trk.X(end)+bxsz/2),trk.FrameNum(end)+1:min([trk.FrameNum(end)+10,size(data,3)]));
    roi = movmean(roi,3,3);
    % localization
    NP=6;
    SZ = size(roi,1);
    BSZ=128;
    KernelID='_XYNBSXSY_';
    k = parallel.gpu.CUDAKernel('smi_cuda_gaussMLEv2.ptx','smi_cuda_gaussMLEv2.cu',KernelID);
    NFitsActual = size(roi,3);
    PSFSigma = 2;
    Iterations = 50;
    k.GridSize = [ceil(NFitsActual/BSZ) 1];
    k.ThreadBlockSize = [BSZ 1];
    d_Parameters=zeros(NFitsActual,NP,'single');
    d_CRLBs=zeros(NFitsActual,NP,'single');
    d_LogLikelihood=zeros(NFitsActual,1,'single');

    [P, CRLB,LL] = feval(k,single(roi),PSFSigma,SZ,Iterations,d_Parameters,d_CRLBs,d_LogLikelihood,NFitsActual);
    % add photons from bleaching step to original photon sequence
    photon = gather(P(:,3));
    mask = photon<300 & photon>2;
    photon = photon(mask);
    Photons_laststep =  round(double([trk.Photons;photon]));
    TR_candidate{ii}.Photons_laststep = Photons_laststep;
    % get change point for new photon trace
    icp = smi_stat.ChangeDetection(Photons_laststep,LogBayesThreshold);

    %show plots
    xs=1:icp.Nobservations;
    tab1 = uitab(tg1,'title',num2str(ind));
    ha = axes('parent',tab1);
    stairs(xs, icp.Data, '-ko');
    hold on;
    Is=smi_stat.ChangeDetection.modelIntensity(icp.Nobservations, icp.ChangePoints, icp.Intensity);
    stairs(xs, Is, '-r', 'LineWidth', 2.0);
    yl=ylim;
    ylim([0,yl(2)]);
    hold off;
    xlabel('time');
    ylabel('intensity');
    legend('Data', 'Estimated', 'Location', 'North');

end
%% overlay raw data with selected track
data = SPT.ScaledData;
ind = 1;
trk = SPT.TR(ind);
imt = zeros(size(data));
for ii = 1:length(trk.X)
imt(round(trk.Y(ii)),round(trk.X(ii)),trk.FrameNum(ii)) = 1;
end
overlay(data/median(max(data,[],[1,2]))*100,imt)


./MATLAB/examples/Example_Clustering.m
% Examples of how to call Clustering routines.

% If true, save plots produced into the ResultsDir defined below.
Saving = false;

% --- 2D ---

SaveDir = smi_helpers.mkSMITETmpDir('examples', 'Clustering');

SMF = smi_core.SingleMoleculeFitting();
SMF.Data.ResultsDir = SaveDir;

if Saving
   if ~exist(SMF.Data.ResultsDir, 'dir')
      mkdir(SMF.Data.ResultsDir);
   end
end

% Simulate a sparse collection of hextets.
SIM = smi_sim.SimSMLM();
kmer = 6;                   % Hextets
PixelSize = 100;            % nm in a pixel
radius_kTet = 25/PixelSize; % Radius of the k-tets (pixel)
SZ = 100;                   % linear size of image (pixel)
receptorDensity = 1;        % Receptors/um^2
SIM.Rho = receptorDensity / (1000 / PixelSize)^2;
SIM.StartState = 'Equib';% If Equib, particle starts randomly on or off
SIM.SZ = SZ;
SIM.simkTets(kmer, radius_kTet);
SMD_Data = SIM.genNoisySMD(SIM.SMD_Model);

SZnm = SZ * PixelSize;

Npts = 1000;
% Generate a random cover of points.
xy  = SZnm * rand(2*Npts, 2);
xyz = SZnm * rand(3*Npts, 3);

% Create arrays of (x, y) or (x, y, z) coordinates (nm).
XY1 = zeros(Npts, 2);
XY1(:, 1) = xy(1:2:end, 1);
XY1(:, 2) = xy(2:2:end, 2);

XY3 = zeros(Npts, 3);
XY3(:, 1) = xyz(1:3:end, 1);
XY3(:, 2) = xyz(2:3:end, 1);
XY3(:, 3) = xyz(3:3:end, 1);

% Make SMD structures (pixel).
SMD1.X = XY1(:, 1) ./ PixelSize;
SMD1.Y = XY1(:, 2) ./ PixelSize;

SMD3.X = XY3(:, 1) ./ PixelSize;
SMD3.Y = XY3(:, 2) ./ PixelSize;
SMD3.Z = XY3(:, 3) ./ PixelSize;

SMD2 = SMD_Data;
indx = SMD2.X < 0 | SMD2.X > SZ | SMD2.Y < 0 | SMD2.Y > SZ;
SMD2.X(indx) = [];
SMD2.Y(indx) = [];
SMD2.X_SE(indx) = [];
SMD2.Y_SE(indx) = [];

% Create an array of (x, y) coordinates (nm).
XY2 = zeros(numel(SMD2.X), 2);
XY2(:, 1) = SMD2.X .* PixelSize;
XY2(:, 2) = SMD2.Y .* PixelSize;

fprintf('SMD1 [xmin, xmax, ymin, ymax] = [%5.1f, %5.1f, %5.1f, %5.1f] px\n',...
       min(SMD1.X), max(SMD1.X), min(SMD1.Y), max(SMD1.Y)); 
fprintf('SMD2 [xmin, xmax, ymin, ymax] = [%5.1f, %5.1f, %5.1f, %5.1f] px\n',...
       min(SMD2.X), max(SMD2.X), min(SMD2.Y), max(SMD2.Y)); 

% ========== Set up the smi_cluster.Clustering class (c) =========

% Note that some of the examples below use (x, y) coordinate arrays and some
% use SMD structures to indicate that both types of input may be accepted.
c = smi_cluster.Clustering(SMF);
c.PixelSize = PixelSize;
c.Timing = false;
ROI = [0, SZnm, 0, SZnm];   % nm
A_ROI = (ROI(2) - ROI(1)) * (ROI(4) - ROI(3));   % ROI area (nm^2)

% Compare each ROI nearest neighbor (nn) distances to a random distribution of
% points with the same density.
h = c.nn_ROIrandom(SMD1, A_ROI, 'Random Cover');
if Saving
   saveas(h, fullfile(SMF.Data.ResultsDir, 'RND2_nn'), 'png');
   close
end
h = c.nn_ROIrandom(SMD2, A_ROI, 'Hextets');
if Saving
   saveas(h, fullfile(SMF.Data.ResultsDir, 'HEX2_nn'), 'png');
   close
end

% ========== 2D ==========

fprintf('\n2D examples:\n\n');

% ---------- Random ----------

fprintf('Random:\n\n');
E = 200;      % minimum separation of points between clusters AND
              % maximum separation of points within  clusters (nm)
minPts = 3;   % minimum number of points required to form a cluster
% Ratio of local density / overall density for a point's Voronoi
% region to be considered sufficiently dense for clustering purposes.
c.Alpha = 1.2;

% ---[ XY ]---

% Call with (x, y) coordinate array (nm).  XY1 is a random cover.
algorithm = 'DBSCAN';
[nC, C, centers, ptsI] = c.cluster(algorithm, XY1, E, minPts);
fprintf('%s (E = %g, minPts = %d) number of clusters = %d\n', ...
        algorithm, E, minPts, nC);

% Compute statistics from the results of clustering.
results = c.clusterStats(XY1, C, centers);
fprintf('percentage clustered = %.1f\n', ...
        100 * results.n_clustered/results.n_points);

% Plot the clusters computed.
h = c.plotClusters(XY1, C, centers, ptsI, algorithm);
if Saving
   saveas(h, fullfile(SMF.Data.ResultsDir, ...
                sprintf('RND2_%s_E=%d,N=%d', algorithm, E, minPts)), 'png');
else
   figure(h)
end

% ---[ SMD ]---

% Call with SMD structure (pixel).  SMD1 is a random cover.
for algorithm_range = {'DBSCAN', 'Hierarchal', 'Voronoi'}
   algorithm = algorithm_range{1};
   if strcmp(algorithm, 'Voronoi')
      % Note that Voronoi uses Alpha (and optionally E) for its criteria.
      [nC, C, centers, ptsI] = c.cluster(algorithm, SMD1, [], minPts);
   else
      [nC, C, centers, ptsI] = c.cluster(algorithm, SMD1, E, minPts);
   end
   fprintf('%s (E = %g, minPts = %d) number of clusters = %d\n', ...
           algorithm, E, minPts, nC);

   % Compute statistics from the results of clustering.
   results = c.clusterStats(SMD1, C, centers);
   fprintf('percentage clustered = %.1f\n', ...
           100 * results.n_clustered/results.n_points);

   % Plot the clusters computed.
   h = c.plotClusters(SMD1, C, centers, ptsI, algorithm);
   if Saving
      saveas(h, fullfile(SMF.Data.ResultsDir, ...
                   sprintf('RND2_%s_E=%d,N=%d', algorithm, E, minPts)), 'png');
   else
      figure(h)
   end
end % for algorithm_range
fprintf('\n');

% ---------- Hextets ----------

fprintf('Hextets:\n\n');
E = 50;       % minimum separation of points between clusters AND
              % maximum separation of points within  clusters (nm)
minPts = 3;   % minimum number of points required to form a cluster
% Ratio of local density / overall density for a point's Voronoi
% region to be considered sufficiently dense for clustering purposes.
c.Alpha = 1.2;

% ---[ XY ]---

% Call with (x, y) coordinate array (nm).
algorithm = 'DBSCAN';
[nC, C, centers, ptsI] = c.cluster(algorithm, XY2, E, minPts);
fprintf('%s (E = %g, minPts = %d) number of clusters = %d\n', ...
        algorithm, E, minPts, nC);

% Compute statistics from the results of clustering.
results = c.clusterStats(XY2, C, centers);
fprintf('percentage clustered = %.1f\n', ...
        100 * results.n_clustered/results.n_points);

% Plot the clusters computed.
h = c.plotClusters(XY2, C, centers, ptsI, algorithm);
if Saving
   saveas(h, fullfile(SMF.Data.ResultsDir, ...
                sprintf('HEX2_%s_E=%d,N=%d', algorithm, E, minPts)), 'png');
else
   figure(h)
end

% Plot the clusters computed with the SE of the localizations
h = c.plotClustersSE(SMD2, C, centers, ptsI, algorithm);
if Saving
   saveas(h, fullfile(SMF.Data.ResultsDir, ...
                sprintf('RND2_%s_E=%d,N=%d_SE', algorithm, E, minPts)), 'png');
else
   figure(h)
end

% ---[ SMD ]---

% Call with SMD structure (pixel).  SMD2 is a scattering of hextets.
for algorithm_range = {'DBSCAN', 'Hierarchal', 'Voronoi', 'H-SET'}
   algorithm = algorithm_range{1};
   if strcmp(algorithm, 'Voronoi')
      % Note that Voronoi uses Alpha (and optionally E) for its criteria.
      [nC, C, centers, ptsI] = c.cluster(algorithm, SMD2, [], minPts);
   else
      % H-SET needs to use an SMD structure with X_SE, Y_SE defined.
      [nC, C, centers, ptsI] = c.cluster(algorithm, SMD2, E, minPts);
   end
   fprintf('%s (E = %g, minPts = %d) number of clusters = %d\n', ...
           algorithm, E, minPts, nC);

   % Compute statistics from the results of clustering.
   results = c.clusterStats(SMD2, C, centers);
   fprintf('percentage clustered = %.1f\n', ...
           100 * results.n_clustered/results.n_points);

   % Plot the clusters computed.
   h = c.plotClusters(SMD2, C, centers, ptsI, algorithm);
   if Saving
      saveas(h, fullfile(SMF.Data.ResultsDir, ...
                   sprintf('HEX2_%s_E=%d,N=%d', algorithm, E, minPts)), 'png');
   else
      figure(h)
   end
end % for algorithm_range

% ========== 3D ==========

fprintf('\n3D examples:\n\n');

% ---------- Random ----------

fprintf('Random:\n\n');
E = 500;      % minimum separation of points between clusters AND
              % maximum separation of points within  clusters (nm)
minPts = 3;   % minimum number of points required to form a cluster
% Ratio of local density / overall density for a point's Voronoi
% region to be considered sufficiently dense for clustering purposes.
c.Alpha = 1.2;

% ---[ SMD ]---

% Call with SMD structure (pixel).  SMD3 is a random cover.
for algorithm_range = {'DBSCAN', 'Hierarchal', 'Voronoi'}
   algorithm = algorithm_range{1};
   if strcmp(algorithm, 'Voronoi')
      % Note that Voronoi uses Alpha (and optionally E) for its criteria.
      [nC, C, centers, ptsI] = c.cluster(algorithm, SMD3, [], minPts);
   else
      [nC, C, centers, ptsI] = c.cluster(algorithm, SMD3, E, minPts);
   end
   fprintf('%s (E = %g, minPts = %d) number of clusters = %d\n', ...
           algorithm, E, minPts, nC);

   % Compute statistics from the results of clustering.
   results = c.clusterStats(SMD3, C, centers);
   fprintf('percentage clustered = %.1f\n', ...
           100 * results.n_clustered/results.n_points);

   % Plot the clusters computed.
   h = c.plotClusters3(SMD3, C, centers, ptsI, algorithm);
   view(-37.5, 30);
   if Saving
      saveas(h, fullfile(SMF.Data.ResultsDir, ...
                   sprintf('RND3_%s_E=%d,N=%d', algorithm, E, minPts)), 'png');
   else
      figure(h)
   end
end % for algorithm_range
fprintf('\n');

fprintf('Done.\n');

./MATLAB/examples/Example_SPTBatch.m
% This script demonstrates an example workflow for SPT batch processing.
% Simulated data and tracking results will be saved in
% tempdir/smite/examples/SPTBatch/example_data/spt/

%% Simulate and save some SPT data in the format expected for real data.
% Simulate some diffusing blobs and save simulated raw data.
rng(12)
DataParams.NDatasets = 10;
SimParams.FrameSize = [64, 64];
SimParams.NFrames = 1000;
SimParams.ParticleDensity = 0.01; % particles / px^2, make 2X target since we split into 2 channels
SimParams.D = 0.1; % px^2 / frame
SimParams.KOffToOn = 0.95;
SimParams.KOnToOff = 0.05;
SimParams.KOnToBleach = 1e-3;
SimParams.Intensity = 1000;
SaveDir = smi_helpers.mkSMITETmpDir('examples', 'SPTBatch');
DataDir = fullfile(SaveDir, ...
    'example_data', 'spt', smi_helpers.genTimeString());
if ~isfolder(DataDir)
    mkdir(DataDir)
end
[Files, SimParams, DataParams] = smi_sim.SimSPT.makeExampleSim(...
    SimParams, DataParams, DataDir); % SimParams and DataParams padded w/ defaults

%% Prepare an SMF structure for each channel.
% NOTE: Channel 1 will not be transformed (it is the reference channel), so
%       we should ensure SMFChannel1.Data.RegistrationFilePath is empty!
PixelSize = 0.1; % must be set to true data values
FrameRate = 20;
SMFChannel1 = smi_core.SingleMoleculeFitting;
SMFChannel1.Data.AnalysisID = 'Channel1';
SMFChannel1.Data.FileDir = DataDir;
SMFChannel1.Data.DataROI = [1, 1, ...
    SimParams.FrameSize(1), SimParams.FrameSize(2)]; % left half of data [YStart, XStart, YEnd, XEnd]
SMFChannel1.Data.RegistrationFilePath = '';
SMFChannel1.Data.PixelSize = PixelSize;
SMFChannel1.Data.FrameRate = FrameRate;
SMFChannel1.Fitting.PSFSigma = SimParams.PSFSigma;
SMFChannel1.Tracking.MaxFrameGap = 20;
SMFChannel2 = copy(SMFChannel1);
SMFChannel2.Data.AnalysisID = 'Channel2';
SMFChannel2.Data.DataROI = [1, 1 + SimParams.FrameSize(2), ...
    SimParams.FrameSize(1), 2*SimParams.FrameSize(2)]; % right half of data
SMFChannel2.Data.RegistrationFilePath = '';

%% Prepare an SPT class object for each channel and then track.
SPTChannel1 = smi.SPT(SMFChannel1, false);
SPTChannel1.GenerateMovies = false;
SPTChannel1.GeneratePlots = false;
SPTChannel2 = smi.SPT(SMFChannel2, false);
SPTChannel2.GenerateMovies = false;
SPTChannel2.GeneratePlots = false;

%% Loop through our data files and track one at a time.
FileList = dir(fullfile(DataDir, 'Data_*.mat'));
FileList = FileList(~[FileList.isdir]); % exclude directories
NFiles = numel(FileList);
for nn = 1:NFiles
    % Update the file name in each of the SPT objects.
    SPTChannel1.SMF.Data.FileName = FileList(nn).name;
    SPTChannel2.SMF.Data.FileName = FileList(nn).name;
    
    % Perform the tracking.
    SPTChannel1.performFullAnalysis()
    SPTChannel2.performFullAnalysis()
end

%% Interactively prepare a movie for each channel.
% Define the index of 'FileList' which we'd like to see a movie for.
FileIndex = 1;

% Reload our tracking results (these contain TR, SMD, and SMF).
[~, Channel1FileName] = fileparts(FileList(FileIndex).name);
Channel1ResultsFiles = dir(fullfile(SMFChannel1.Data.ResultsDir, ...
    sprintf('*%s_%s_Results.mat', ...
    Channel1FileName, SMFChannel1.Data.AnalysisID)));
Channel1Results = ...
    load(fullfile(SMFChannel1.Data.ResultsDir, Channel1ResultsFiles(1).name));
[~, Channel2FileName] = fileparts(FileList(FileIndex).name);
Channel2ResultsFiles = dir(fullfile(SMFChannel2.Data.ResultsDir, ...
    sprintf('*%s_%s_Results.mat', ...
    Channel2FileName, SMFChannel2.Data.AnalysisID)));
Channel2Results = ...
    load(fullfile(SMFChannel2.Data.ResultsDir, Channel2ResultsFiles(1).name));

% Reload the raw data.
SMFChannel1.Data.FileName = FileList(FileIndex).name;
SMFChannel2.Data.FileName = FileList(FileIndex).name;
LD = smi_core.LoadData;
[~, RawDataChannel1] = ...
    LD.loadRawData(SMFChannel1, 1, SMFChannel1.Data.DataVariable);
[~, RawDataChannel2] = ...
    LD.loadRawData(SMFChannel2, 1, SMFChannel2.Data.DataVariable);

% If needed, transform the raw data (to make sure the trajectories overlay
% nicely on the raw data!).
if Channel2Results.SMD.IsTransformed
    load(SMFChannel2.Data.RegistrationFilePath, 'RegistrationTransform')
    RawDataChannel2 = smi_core.ChannelRegistration.transformImages(...
        RegistrationTransform, RawDataChannel2);
end

% Prepare the movies using the GUI.
MovieMaker1 = smi_vis.GenerateMovies;
MovieMaker1.TR = Channel1Results.TR;
MovieMaker1.SMD = Channel1Results.SMD;
MovieMaker1.SMF = Channel1Results.SMF;
MovieMaker1.RawData = RawDataChannel1;
MovieMaker1.gui()
MovieMaker2 = smi_vis.GenerateMovies;
MovieMaker2.TR = Channel2Results.TR;
MovieMaker2.SMD = Channel2Results.SMD;
MovieMaker2.SMF = Channel2Results.SMF;
MovieMaker2.RawData = RawDataChannel2;
MovieMaker2.gui()

./MATLAB/examples/Example_ChangeDetection.m
% This script demonstrates the basic usage of the smi_stat.ChangeDetection class.

SaveDir = smi_helpers.mkSMITETmpDir('examples', 'ChangeDetection');

%% simulate data
NObservations = 50;  % Scalar integer: length of data sequence
ChangePoints = round([0.2,0.6]*NObservations); %vector: indexs of change point locations
Intensity = [200,100,60]; %vector: length=length(ChangePoints)+1: mean intensities for each subinterval
Data=smi_stat.ChangeDetection.simulate(NObservations, ChangePoints, Intensity);

% change detection
LogBayesThreshold = 10;
Icp = smi_stat.ChangeDetection(Data,LogBayesThreshold);
Icp.plotIntensityEstimate();
IntensityModel = Icp.IntensityModel; % intensitiy of the model sequence (no noise)
saveas(gcf, fullfile(SaveDir, 'CD1.png'));

%% alternative simulation methods
% given change points
NObservations = 50;  % Scalar integer: length of data sequence
ChangePoints = round([0.2,0.6]*NObservations); %vector: indexs of change point locations
Intensity = [200,100,60]; %vector: length=length(ChangePoints)+1: mean intensities for each subinterval
LogBayesThreshold = 10;
Data=smi_stat.ChangeDetection.simulate(NObservations, ChangePoints, Intensity);

[Icp,F]=smi_stat.ChangeDetection.plotSimulatedEstimate(NObservations, ChangePoints, Intensity, LogBayesThreshold);
saveas(gcf, fullfile(SaveDir, 'CD2.png'));


%% random change points
NObservations = 50;  % Scalar integer: length of data sequence
NChangePoints = 2; % Scalar integer: number of change points to simulate
Meanintensity = 100; % scalar for mean intensity.  Intensities are uniformly distributed on [1, 2*meanIntensity]
LogBayesThreshold = 10;
[Icp,F]=smi_stat.ChangeDetection.plotRandSimulatedEstimate(NObservations, NChangePoints, Meanintensity, LogBayesThreshold);
saveas(gcf, fullfile(SaveDir, 'CD3.png'));

./MATLAB/examples/simpleROIcluster.m
% Perform cluster analysis for comparison of experimental conditions.
% NOTE: sma-cluster and PlotSpread should be on your MATLAB path.
%
% Work flow: (note results are put in the subdirectory 'Analysis')
%   Set important parameters:
%            ROI_sizes, Pixel2nm, start_datadir, oneROI
%      ALWAYS run this first MATLAB section before running the later sections
%      so that necessary parameters are set.
%   Define the ROIs:
%            _ResultsStruct.mat (or _Results.mat) -> _ROIs.mat
%      (each image [ResultsStruct or Results file] produces a separate ROIs
%       file containing all the ROIs for that image; the idea is to do all the
%       ROI selection early on so it need not be repeated---each image can have
%       multiple ROIs; note that this deals with files in a single directory.
%       Many time lab members select the ROIs from the SR _Results.mat files,
%       To transfer these to BaGoL ROIs (necessary, as the ROI files are
%       self-contained, meaning they contain the actual coordinates of the
%       localizations in each ROI), it is necessary to transfer the ROI regions
%       to BaGoL localizations.  See below.)
%   POSSIBLY, define the BaGoL ROIs from the previous ROIs and BaGoL results
%            _ROIs.mat + _BaGoL_Results.mat -> _BaGoL_ROIs.mat
%            _ROIs.mat + MAPN_*.mat         -> _BaGoL_ROIs.mat
%      (the two sets of files should be in corresponding order; the BaGoL
%       coordinates replace the coordinates in the original ROI files)
%   POSSIBLY, combine individually processed BaGoL ROIs into a single _ROIs.mat
%      file using the _ROIs.mat file that was used to define the ROIs
%      originally from the SR data
%            _ROIs.mat + _Results_ROI_*_.mat -> _Results.mat
%   POSSIBLY, filter out some ROIs.
%            _ROIs.mat -> _filtered_ROIs.mat
%   Statistics for a single condition:
%            _ROIs.mat -> ALL_*
%      (compute statistics for a single condition consisting of a number of
%       images all located in the same directory.  Need to define
%       algorithm_range, minPts_range (N) and E_range (epsilon).)
%   Combine results from one or more conditions for further processing:
%            multiple ALL_*_results.mat -> [condition]_results.mat
%      (multiple instantiations of a single condition located in multiple
%       directories are collected into a combined instance in a specified
%       directory.)
%   Combined statistics for two or more conditions:
%            multiple [condition]_results_mat -> 
%      (multiple conditions are plotted on the same graph and placed in a
%       subdirectory for this particular analysis.  The filenames are assumed
%       to have the structure:
%          experimentalConditions#analysisConditions_results.mat
%       where experimentalConditions contains no #.  Statistics for a single
%       condition produces filenames in this format, so can be copied directly.
%       A typical example of a renamed ALL_*_results file is:
%          RGY#DBSCAN_N=3,E=50_results.mat
%   ALTERNATIVELY, combined statistics for multiple conditions and experiments
%      (as above, where line colors and types for CDF2 plots are set by hand)
%
% Avoid spaces in filenames and conditions!!!

%% ---------- Set important parameters

doHopkins = true;   % Hopkins' test can be time consuming for dense ROIs
% Set to false for very dense ROIs to avoid crashes due to lack of memory.
doSigmaActual = false;

ROI_sizes = [2000, 2000];   % [delta_x, delta_y] (nm)
A_ROI = prod(ROI_sizes);    % ROI area (nm^2)
%Pixel2nm = 16000/150;       % conversion factor from pixels to nm
%Pixel2nm = 108.018;         % pixels to nm [TIRF]
Pixel2nm = 97.8;            % pixels to nm [sequential]
Pixel2nmGlobal = Pixel2nm;

RT = smi_helpers.ROITools();
% GaussIm = true indicates that gaussianImage will be used for the ROI
%    selection display.
% OriginLLvsUL = true says to use lower left origin coordinates rather than
%    upper left origin coordinates in the ROI selection display.
% If GaussIm is true, make OriginLLvsUL false for consistency.  The default is:
% GaussIm = false and OriginLLvsUL = true.  Currently, GaussIm only works for
% single labeled molecules.
%RT.GaussIm = true;    RT.OriginLLvsUL = false;
RT.GaussIm = false;   RT.OriginLLvsUL = true;
RT.SRzoom = 4;              % zoom factor for gaussianImage
RT.ROI_sizes = ROI_sizes;   
RT.Pixel2nm = Pixel2nm;
% ClusterInterface contains various helper routines used by this script.
CI = smi_cluster.ClusterInterface();

% Often, for BaGoL analyses, it is simpler to use a single, large, encompassing
% ROI rather than a series of small ROIs.
oneROI = false;
if oneROI
   ROI_sizes = [256, 256] * Pixel2nm;   % (nm)
   A_ROI = prod(ROI_sizes);
end

% Select the files starting from start_datadir.
%start_datadir = 'Y:\Will K\BaGoL_Analysis_WTvsLynKO_DNPvsDF3\DNP24_1ug-mL_WT\Results_BaGoL';
start_datadir = '.';

% If true, look for MAPN_*.mat, otherwise *_Results*.mat for BaGoL coordinates.
%MAPNfile = false;
MAPNfile = true;

% Filtering parameters:
%filter.maxLocROI = 0;     % minimum number of localizations allowed in a ROI
filter.maxLocROI = 500;   % maximum number of localizations allowed in a ROI

% keep_numbering retains the ROI numbering even if there are missing ROIs
% (which will be treated as empty).  See combineBaGoLROIs.
keep_numbering = false;

fprintf('Done set parameters.\n');

%% ----------- Define the ROIs

if MAPNfile
   [pathname, files] = smi_helpers.selectFiles(start_datadir, ...
                            'MAPN*.mat files', 'MAPN_*.mat');
else
   [pathname, files] = smi_helpers.selectFiles(start_datadir, ...
                            '*_Results*.mat files', '*_Results*.mat');
end

CI.defineROIs(pathname, files, Pixel2nmGlobal, RT, oneROI);

%% ---------- Possibly, define BaGoL ROIs from previous ROIs and BaGoL results
%%            (MF BaGoL Results or BaGoL MAPN files)

% NOTE: the two sets of files should be in corresponding order.
% Previously defined ROIs for a series of images.
[pathnameR, filesR] = smi_helpers.selectFiles(start_datadir, ...
                           '_ROIs.mat files', '*_ROIs.mat');
% BaGoL MAPN or Results/ResultStruct files.
if MAPNfile
   [pathnameB, filesB] = smi_helpers.selectFiles(start_datadir, ...
                            'MAPN*.mat files', 'MAPN_*.mat');
else
   [pathnameB, filesB] = smi_helpers.selectFiles(start_datadir, ...
                            '*_Results*.mat files', '*_Results*.mat');
end

CI.defineBaGoLROIs(pathnameR, filesR, pathnameB, filesB, MAPNfile);

%% ---------- Possibly, combine individually processed BaGoL ROIs into a single
%%            _ROIs.mat file using the _ROIs.mat file that was used to define
%%            the ROIs originally from the SR data

[pathnameR, filesR] = smi_helpers.selectFiles(start_datadir, ...
                         '_ROIs.mat file', '*_ROIs.mat');
% BaGoL MAPN or Results/ResultStruct files.
if MAPNfile
   [pathnameB, filesB] = smi_helpers.selectFiles(pathnameR, ...
                            'MAPN*_ROI_*.mat files', 'MAPN_*_ROI_*.mat');
else
   [pathnameB, filesB] = smi_helpers.selectFiles(pathnameR, ...
                            '*_Results_ROI_*.mat files',    ...
                            '*_Results_ROI_*.mat');
end

CI.combineBaGoLROIs(pathnameR, filesR, pathnameB, filesB, MAPNfile, ...
                    keep_numbering);

%% ---------- Possibly, filter out some ROIs

% Interactive input.
[pathname, files] = smi_helpers.selectFiles(start_datadir, ...
                       '_ROIs.mat files', '*_ROIs.mat');
[n_ROIs, RoI] = CI.filterROIs(pathname, files, filter);

%% ---------- Statistics for a single condition

% Main parameters to change: algorithm_range, E_range, minPts_range

%  - - - - - Choose _ROIs.mat files

% Interactive input.
[pathname, files] = smi_helpers.selectFiles(start_datadir, ...
                       '_ROIs.mat files', '*_ROIs.mat');
answer = inputdlg('Name of combined results file:');
condition = answer{1};

% Look for condition/Analysis/*_ROIs.mat or uncomment "files = ..."
% lines below and list files manually.
% Use specified condition.
%condition = 'RGY';
%pathname = fullfile(start_datadir, condition, 'Analysis');
%FILES = dir(fullfile(pathname, '*_Results_ROIs.mat'));
%files = { FILES.name };

% Manual specification.
%files = {
%'Cell_01_Label_01_Results_ROIs.mat'
%};

% base_name is a short identifier describing the analysis.
base_name = condition;

%  - - - - - Set up batch analysis ranges

% Minimum distance between clusters or maximum distance between points in a
% cluster.
%E_range = [30, 40, 50];   % (nm)
E_range = [20];   % (nm)
% Minimum number of points in a cluster.
%minPts_range = [3, 6, 10];
minPts_range = [3];
% Clustering algorithm.
%algorithm_range = {'DBSCAN', 'Hierarchical', 'Voronoi'};
algorithm_range = {'DBSCAN'};

CI.singleCondition(pathname, files, algorithm_range, E_range, minPts_range, ...
                   Pixel2nm, base_name, A_ROI, doHopkins, doSigmaActual);

%% ---------- Combine results from 1 or more conditions for further processing

analysis_dir = uigetdir(start_datadir, 'Directory for combined analyses');
if analysis_dir == 0
   error('No directory specified!');
end
Files = uipickfiles('FilterSpec', start_datadir, 'REFilter', ...
                    '.*_results.mat', 'Prompt', '*_results.mat files');
if ~iscell(Files) & Files == 0
   error('No files specified!');
end
[~, in_file, ~] = fileparts(Files{1});
out_file = regexprep(in_file, '^ALL_', '');
answer = inputdlg('Combined filename', '', [1, 50], {out_file});
if numel(answer) == 0
   error('No Filename specified!');
end
out_file = [answer{1}, '.mat'];

CI.combineResults(Files, analysis_dir, out_file);

%% ---------- Combined statistics for one or more conditions

SC = smi_cluster.StatisticsClustering();
% Make various plots:
%    'f'   frequency
%    'n'   normalized
%    'p'   PDF
%    'c'   CDF
%    'C'   CDF (alternative)
%    's'   PlotSpread
%    'S'   PlotSpread (bars for mean & median)
%    'x'   box
%    'b'   bar
SC.PlotDo = 'CSx';
% Red mean, green median (2 only mean, 3 only median) for PlotSpread plots.
SC.ShowMM = 1;
% Options for CDF2 plots are: 'plot', 'semilogx', 'semilogy', 'loglog'.
SC.LinLog = 'semilogx';

[pathname, files] = smi_helpers.selectFiles(start_datadir, ...
                       '_results.mat files', '*_results.mat');
answer = inputdlg('Output directory identifier:');
base_name = answer{1};

CI.combinedStatistics1(SC, pathname, files, base_name, A_ROI, doHopkins);

%% ---------- Combined statistics for multiple conditions and experiments

SC = smi_cluster.StatisticsClustering();
% Make various plots:
%    'f'   frequency
%    'n'   normalized
%    'p'   PDF
%    'c'   CDF
%    'C'   CDF (alternative)
%    's'   PlotSpread
%    'S'   PlotSpread (bars for mean & median)
%    'x'   box
%    'b'   bar
SC.PlotDo = 'CSx';
% Red mean, green median (2 only mean, 3 only median) for PlotSpread plots.
SC.ShowMM = 1;
% Options for CDF2 plots are: 'plot', 'semilogx', 'semilogy', 'loglog'.
SC.LinLog = 'semilogx';
SC.Ylim = [0.01, 1];

% Use the same color for each experiment under the same condition, different
% colors for different conditions.
%colors = ['b', 'b', 'b', 'b', 'r', 'r', 'r', 'r', 'g', 'g', 'g', 'g']; %GFP
%colors = ['b', 'r', 'g', 'b', 'r', 'g']; %CD277+parental
%colors = ['b', 'b', 'r', 'r', 'g', 'g']; %GFP_exp1+2
%colors = ['b', 'r', 'g']; %GFP3+4combined
colors = ['b', 'r']; %EGFR

% Use different line types to distingush same colored lines when desired.
%line_type = {':', '-.', '-', '--', ':', '-.', '-', '--', ':', '-.', '-', '--'}; %GFP
%line_type = {'-', '-', '-', '--', '--', '--'}; %CD277+parental
%line_type = {'-', '--', '-', '--', '-', '--'}; %GFP_exp1+2
%line_type = {'-', '-', '-'}; %GFP3+4combined
line_type = {'-', '-'}; %EGFR

[pathname, files] = smi_helpers.selectFiles(start_datadir, ...
                       '_results.mat files', '*_results.mat');
answer = inputdlg('Output directory identifier:');
base_name = answer{1};

CI.combinedStatistics2(SC, colors, line_type, pathname, files, base_name, ...
                       A_ROI, doHopkins);

./MATLAB/examples/Example_SMLM_Basic.m
%Demonstrate basic functionality of SMLM Analysis

%Create a SMLM object
SMLMobj=smi.SMLM()  %no input pops open a gui

%Use gui to navigate to a test dataset such as this TIRF DNA-PAINT: 

%  Y:\Sandeep\20-11-2020-DNA_PAINT_Tubulin\Dock2-Cell1-2020-11-12-10-29-58.h5

% Set other SMF parameters and try a test fit from gui



%% Scripted Analysis

%or set it manually:
SMLMobj.SMF.Data.FileDir='Y:\Sandeep\20-11-2020-DNA_PAINT_Tubulin';
SMLMobj.SMF.Data.FileName='Dock2-Cell1-2020-11-12-10-29-58.h5';

%give a Analysis ID
SMLMobj.SMF.Data.FileName='Dock2-Cell1-2020-11-12-10-29-58.h5';





./MATLAB/examples/Example_simSMLM.m
%% Example of generating sythetic SMLM data

SaveDir = smi_helpers.mkSMITETmpDir('examples', 'simSMLM');

%Create sim object

S=smi_sim.SimSMLM()
NWings=20
S.NDatasets=20
S.SZ = 64;
S.simStar(NWings)

% Generate Images 
[Model,Data]=S.genImageStack();

% Generate Noisy Coordinates
[SMD_Noisy]=S.genNoisySMD()
figure;scatter(SMD_Noisy.X,SMD_Noisy.Y)

saveas(gcf, fullfile(SaveDir, 'sS1.png'));

./MATLAB/examples/Example_SPT.m
% This script demonstrates the basic usage of the smi.SPT class.

%% Simulate and save some SPT data in the format expected for real data.
% Simulate some diffusing blobs.
rng(12)
SPTSim = smi_sim.SimSPT;
SPTSim.SimParams.FrameSize = [128, 128];
SPTSim.SimParams.ParticleDensity = 0.002; % particles / px^2
SPTSim.SimParams.D = 0.1; % px^2 / s
SPTSim.SimParams.KOffToOn = 0.9;
SPTSim.SimParams.KOnToOff = 0.05;
SPTSim.SimParams.Intensity = 1000;
SPTSim.createSimulation()
SMF = smi_core.SingleMoleculeFitting;
SMF.Data.DataROI = [1, 1, SPTSim.SMD.YSize, SPTSim.SMD.XSize];
SMF.Fitting.PSFSigma = 1.3;
[~, sequence] = smi_sim.GaussBlobs.gaussBlobImage(SPTSim.SMD, SMF);

% Save the simulated data in a .mat file.
SaveDir = smi_helpers.mkSMITETmpDir('examples', 'SPT');
DataDir = fullfile(SaveDir, 'example_data', 'spt');
if ~isfolder(DataDir)
    mkdir(DataDir)
end
FileName = sprintf('Data_%s.mat', smi_helpers.genTimeString());
save(fullfile(DataDir, FileName), 'sequence')

%% Prepare a new SMF structure which points to the previously saved data.
SMF = smi_core.SingleMoleculeFitting;
SMF.Data.FileDir = DataDir;
SMF.Data.FileName = FileName;
SMF.Fitting.PSFSigma = 1.3;
SMF.Thresholding.AutoThreshLogL = true;
% SMF.gui() % optionally, use SMF GUI to interactively set parameters

%% Prepare the SPT class object.
SPT = smi.SPT(SMF, false);
SPT.GenerateMovies = false;
SPT.GeneratePlots = false;

%% Perform the tracking.
SPT.performFullAnalysis()

%% Interactively prepare a movie.
% Reload our tracking results (this contains TR, SMD, and SMF).
[~, FileName] = fileparts(SMF.Data.FileName{1});
BaseName = [FileName, ...
    smi_helpers.arrayMUX({'_', ''}, isempty(SMF.Data.AnalysisID)), ...
    SMF.Data.AnalysisID];
ResultsFileName = [BaseName, '_Results.mat'];
ResultsFile = fullfile(DataDir, 'Results', ResultsFileName);
load(ResultsFile)

% Reload the raw data.
LD = smi_core.LoadData;
[~, RawData, SMF] = LD.loadRawData(SMF, 1, SMF.Data.DataVariable);

% Open up the movie maker.
MovieMaker = smi_vis.GenerateMovies;
MovieMaker.TR = TR;
MovieMaker.SMD = SMD;
MovieMaker.SMF = SMF;
MovieMaker.RawData = RawData;
MovieMaker.gui()




./MATLAB/+smi_helpers/convertTimeStringToNum.m
function [TimeNum] = convertTimeStringToNum(TimeString, Delimiter)
%convertTimeStringToNum converts a time string to a number.
% This function will take a timestring (e.g., the output from
% smi_helpers.genTimeString()) and convert it to a number which can be used
% for comparison to other times of the same format.
%
% INPUTS:
%   TimeString: A time string given in the format output by genTimeString()
%               (char/string, or cell arraay of char/string)
%               NOTE: Changing the input 'MinFieldWidth' of genTimeString()
%                     might cause issues in this function!
%   Delimiter: A delimiter between the year, month, day, etc. in TimeString
%              (Default = {'_'; '-'; ','; '.'})
%
% OUTPUTS:
%   TimeNum: A number corresponding to TimeString.
%            CAUTION: I haven't been careful about this conversion, so use
%                     caution if trying to use this number for anything
%                     other than, e.g., file sorting, where the absolute
%                     time doesn't really matter.

% Created by:
%   David J. Schodt (Lidke Lab, 2021)


% Set defaults and revise inputs if needed.
if (~exist('Delimiter', 'var') || isempty(Delimiter))
    Delimiter = {'_'; '-'; ','; '.'; ';'; ':'};
end
if ~iscell(TimeString)
    TimeString = {TimeString};
end

% Loop through the input timestrings and convert.
NStrings = numel(TimeString);
TimeNum = NaN(size(TimeString));
for ii = 1:NStrings
    % Break up the time string and convert to a number.
    if iscell(TimeString{ii})
        % Some methods output a cell array of cells (e.g., strsplit()) so
        % we need to access the character array with {1}.
        SplitTimeStamp = strsplit(TimeString{ii}{1}, Delimiter);
    else
        SplitTimeStamp = strsplit(TimeString{ii}, Delimiter);
    end
    for jj = 1:numel(SplitTimeStamp)
        % Ensure we pad with zeros wherever needed, e.g., 2018-2-9-17-41
        % should be 2018-02-09-17-41
        if mod(numel(SplitTimeStamp{jj}), 2)
            SplitTimeStamp{jj} = ['0', SplitTimeStamp{jj}];
        end
    end
    
    % Convert the cell array to a double.
    TimeNum(ii) = str2double(cell2mat(SplitTimeStamp));
end


end
./MATLAB/+smi_helpers/subdivideSMD.m
function [SMDSub, SMDROIs] = subdivideSMD(SMD, SubROISize)
%subdivideSMD divvys up an SMD into sub-ROIs.
% This method divvys up the input localizations in 'SMD' into sub-ROIs 
% matching the size specified in SubROISize, with edge cases taken to be 
% the largest ROI possible (that is smaller than the nominal sub-ROI size).
%
% NOTE: The way I've divided the ROI allows for some localizations to be
%       present in multiple sub-ROIs.
%
% INPUT:
%   SMD: Single Molecule Data structure containing the localizations
%        that'll be subdivided.
%   SubROISize: The nominal size of the output subdivided SMDs.
%               (Pixels)(2x1 array)(Default = [SMD.YSize, SMD.XSize])
%
% OUTPUT:
%   SMDSub: Structure of the subdivided SMDs.
%   SMDROIs: ROIs of the regions corresponding to the divided SMDs.
%            (NROIsx4 array)([YStart, XStart, YEnd, XEnd])
%
% CITATION:

% Created by:
%   David J. Schodt (Lidke Lab, 2021)


% Set defaults if needed.
DataSize = [SMD.YSize, SMD.XSize];
if (~exist('SubROISize', 'var') || isempty(SubROISize))
    SubROISize = DataSize.';
end

% Ensure arrays are properly shaped.
if isrow(SubROISize)
    SubROISize = SubROISize.';
end

% Define the ROIs of the subdivided images.
NDivisions = ceil(DataSize.' ./ SubROISize);
YStart = repmat(1 + SubROISize(1)*(0:(NDivisions(1)-1)).', ...
    [NDivisions(2), 1]);
XStart = repelem(1 + SubROISize(2)*(0:(NDivisions(2)-1)).', ...
    NDivisions(1));
SMDROIs = [YStart, XStart, ...
    min(DataSize(1), YStart+SubROISize(1)-1), ...
    min(DataSize(2), XStart+SubROISize(2)-1)];

% Loop through each ROI and isolate that section of the image.
NROIs = prod(NDivisions);
SMDSub = SMD;
for nn = NROIs:-1:1
    SMDSub(nn, 1) = smi_core.SingleMoleculeData.isolateSubSMD(SMD, ...
        (ceil(SMD.Y)>=SMDROIs(nn, 1)) & (ceil(SMD.X)>=SMDROIs(nn, 2)) ...
        & (floor(SMD.Y)<=SMDROIs(nn, 3)) & (floor(SMD.X)<=SMDROIs(nn, 4)));
end


end
./MATLAB/+smi_helpers/subdivideImage.m
function [DividedImages, ImageROIs] = subdivideImage(Image, SubROISize)
%subdivideImage divvys up an image into sub-ROIs of the image.
% This method divvys up the input image Image into sub-ROIs matching
% the size specified in SubROISize, with edge cases taken to be the largest
% ROI possible (that is smaller than the nominal sub-ROI size).
%
% INPUT:
%   Image: The image which will be roughly divided into SubROISize sized
%          images. (MxN numeric array)
%   SubROISize: The nominal size of the output subdivided images.
%               (Pixels)(2x1 array)(Default = size(Image))
%
% OUTPUT:
%   DividedImages: Cell array of the images subdivided from Image.
%                  (NROIsx1 cell array)
%   ImageROIs: ROIs of the regions corresponding to the divided images.
%              (NROIsx4 array)([YStart, XStart, YEnd, XEnd])
%
% CITATION:

% Created by:
%   David J. Schodt (Lidke Lab, 2021)


% Set defaults if needed.
ImageSize = size(Image, [1, 2]);
if (~exist('SubROISize', 'var') || isempty(SubROISize))
    SubROISize = ImageSize.';
end

% Ensure arrays are properly shaped.
if isrow(SubROISize)
    SubROISize = SubROISize.';
end

% Define the ROIs of the subdivided images.
NDivisions = ceil(ImageSize.' ./ SubROISize);
YStart = repmat(1 + SubROISize(1)*(0:(NDivisions(1)-1)).', ...
    [NDivisions(2), 1]);
XStart = repelem(1 + SubROISize(2)*(0:(NDivisions(2)-1)).', ...
    NDivisions(1));
ImageROIs = [YStart, XStart, ...
    min(ImageSize(1), YStart+SubROISize(1)-1), ...
    min(ImageSize(2), XStart+SubROISize(2)-1)];

% Loop through each ROI and isolate that section of the image.
NROIs = prod(NDivisions);
DividedImages = cell(NROIs, 1);
for nn = 1:NROIs
    DividedImages{nn} = Image(ImageROIs(nn, 1):ImageROIs(nn, 3), ...
        ImageROIs(nn, 2):ImageROIs(nn, 4), :);
end


end
./MATLAB/+smi_helpers/gatherFullPathnames.m
function fullpaths = gatherFullPathnames(paths, files, pattern)
%gatherFullPathnames combines or searches for directory paths and filenames
% matching a pattern.
%
% Matches paths to files.  If neither paths nor files are provided, call up a
% GUI to let the user interactively choose.  If files are provided, but paths
% are not, take the current directory as the starting point.  If paths are
% provided, but files are not, look for filenames matching the pattern.
%
% INPUTS:
%    paths      cell array of directory paths
%    files      cell array of filenames
%    pattern    MATLAB file pattern (e.g., '*_Results.mat')
%
% OUTPUT:
%   fullpaths   cell array of full pathnames of combined directory paths with
%               filenames

% Created by
%    Michael J. Wester (Lidkelab 2022)

   if ~exist('pattern', 'var')
      pattern = '*_Results.mat';
   end
   if ~exist('files', 'var')
      files = {};
   end
   if ~exist('paths', 'var')
      paths = {};
   end

   if ~iscell(paths)
      paths = { paths };
   end
   if ~iscell(files)
      files = { files };
   end

   n_paths = numel(paths);
   n_files = numel(files);

   if n_paths == 0 && n_files == 0
      % If no paths or files are provided, interactively prompt for those
      % matching a pattern.  First, transform a MATLAB pattern into a regular
      % expression pattern.
      REpattern = regexprep(pattern, '*', '.*');
      fullpaths = uipickfiles('FilterSpec', '.', 'REFilter', REpattern, ...
                              'Prompt', [pattern, ' files']);
      fullpaths = fullpaths';
      return;
   end

   if n_files > 0
      n_fullpaths = max(n_paths, n_files);
      fullpaths = cell(n_fullpaths, 1);

      if n_paths == 0
         % Only files are provided.
         for i = 1 : n_fullpaths
            fullpaths{i} = files{i};
         end
      elseif n_paths == n_files
         % Paths and files are both provided in a matched set.
         for i = 1 : n_fullpaths
            fullpaths{i} = fullfile(paths{i}, files{i});
         end
      else
         % Numbers don't match---error!
         error(sprintf('n_paths (%d) != n_files (%d)', n_paths, n_files));
      end
   else   % n_files == 0
      % Look for the pattern in the filenames on each directory path.
      n_fullpaths = 0;
      for i = 1 : n_paths
          D = dir(fullfile(paths{i}, pattern));
          for j = 1 : numel(D)
             n_fullpaths = n_fullpaths + 1;
             fullpaths{n_fullpaths} = fullfile(paths{i}, D(j).name);
          end
      end
      fullpaths = fullpaths';
   end

end

./MATLAB/+smi_helpers/pairTimeStrings.m
function [PairedIndices] = ...
    pairTimeStrings(TimeStrings, TimeStringOptions, Comparison)
%pairTimeStrings pairs time strings based on temporal proximity.
% This function selects indices from the input 'TimeStringOptions' that are
% closest in time to the timestrings provided in 'TimeStrings'.
%
% INPUTS:
%   TimeStrings: Cell array of timestrings formatted as would be output by
%                smi_helpers.genTimeString().
%   TimeStringOptions: Set of timestrings to be paired to 'TimeStrings'.
%   Comparison: Method of selection between the timestrings.
%               (Default = 'Before')
%               'Before': closest timestring that happened BEFORE
%                         'TimeStrings' is selected.
%               'After': closest timestring that happened AFTER
%                        'TimeStrings' is selected.
%               'Nearest': closest timestring is selected, whether it's
%                          before or after in time.
%
% OUTPUTS:
%   PairedIndices: Indices of 'TimeStringOptions' corresponding to pairings
%                  with 'TimeStrings'.  If any of 'TimeStrings' remains
%                  unpaired, it will be given an index of NaN.

% Created by:
%   David J. Schodt (Lidke Lab, 2021)


% Set defaults if needed.
if (~exist('Comparison', 'var') || isempty(Comparison))
    Comparison = 'Before';
end

% Loop through the timestrings and compare.
TimeNums = smi_helpers.convertTimeStringToNum(TimeStrings);
TimeNumOptions = smi_helpers.convertTimeStringToNum(TimeStringOptions);
PairedIndices = NaN(size(TimeStrings));
NStrings = numel(TimeStrings);
NOptions = numel(TimeStringOptions);
for ii = 1:NStrings
    TimeDiff = TimeNums(ii) - TimeNumOptions;
    switch lower(Comparison)
        case 'before'
            ValidInd = find(TimeDiff >= 0);
        case 'after'
            ValidInd = find(TimeDiff <= 0);
        case 'nearest'
            ValidInd = 1:NOptions;
        otherwise
            error('Invalid input ''Comparison'' = %s', Comparison)
    end
    [~, BestIndex] = min(TimeDiff(ValidInd));
    if ~isempty(BestIndex)
        PairedIndices(ii) = ValidInd(BestIndex);
    end
end


end
./MATLAB/+smi_helpers/removeBorder.m
function [Image] = removeBorder(Image, Border, Direction)
%removeBorder removes border pixels from the input image.
% This method isolates a central section of 'Image' which corresponds to
% deleting a border of width 'Border' from the image.
%
% INPUTS:
%   Image: Image(s) containing the border to be removed. (1-4D array)
%   Border: Border to be removed. If given as a scalar, the same border is
%           from all dimensions.
%           (scalar of NDimsx1 vector)(Default = zeros(ndims(Image), 1))
%   Direction: Border mode describing which edges are removed.
%              ('both', 'pre', 'post')(Default = 'both')
%
% OUTPUTS:
%   Image: Input 'Image' with borders removed.

% Created by:
%   David J. Schodt (Lidke Lab, 2021)


% Set defaults.
NDims = ndims(Image);
if (~exist('Border', 'var') || isempty(Border))
    Border = zeros(NDims, 1);
end
if (~exist('Direction', 'var') || isempty(Direction))
    Direction = 'both';
end

% Ensure that 'Border' is valid based on the size of 'Image'.
if isrow(Border)
    Border = Border.';
end
if isscalar(Border)
    % For a scalar border, the same border is removed along each dimension.
    Border = Border * ones(NDims, 1);
else
    % For a vector border, we'll assume the missing dimensions should have
    % a border of 0 (i.e., no border is removed).
    Border = padarray(Border, max(0, [NDims-numel(Border), 0]), ...
        0, 'post');
end
ImSize = size(Image);
MaxBorder = floor(ImSize / 2).';
Border = max(0, min(MaxBorder, Border(1:NDims)));

% Remove the border.
ColonIndices = repmat({':'}, NDims, 1);
for nn = 1:NDims
    NDimIndices = ColonIndices;
    switch lower(Direction)
        case 'pre'
            NDimIndices{nn} = (1+Border(nn)):ImSize(nn);
        case 'post'
            NDimIndices{nn} = 1:(ImSize(nn)-Border(nn));
        otherwise
            NDimIndices{nn} = (1+Border(nn)):(ImSize(nn)-Border(nn));
    end
    Image = Image(NDimIndices{:});
end


end
./MATLAB/+smi_helpers/addBasicGUI.m
function [ControlHandles] = addBasicGUI(GUIParent, ParamStruct, Callback)
%addBasicGUI adds simple GUI controls based on the fields in 'ParamStruct'
% This method will add basic GUI control elements to 'GUIParent', with each
% control representing a setting for a field in 'ParamStruct'.  The
% intention is that for a set of boring parameters in 'ParamStruct' (e.g.,
% scalars, single string entries, logical values, ...), you can produce a
% quick GUI to allow for setting these parameters.
%
% NOTE: This GUI does not update anything in 'ParamStruct', so all updates
%       must be done through the associated 'ControlHandles'.
%
% INPUTS:
%   GUIParent: The 'Parent' of this GUI, e.g., a figure handle.
%   ParamStruct: Structure array containing "scalar" fields (i.e., fields
%                can be set by a single edit box, checkbox, button, etc.)
%   Callback: Callback function to be set for all of the uicontrols (see
%             uicontrol property 'Callback'). (Default = '')
%             NOTE: Each of the uicontrols is given a 'Tag' property with
%                   the name of the corresponding field in 'ParamStruct',
%                   which can be useful for defining a callback function.
%
% OUTPUTS:
%   ControlHandles: Array of uicontrols corresponding to the fields in
%                   'ParamStruct', provided in the same order as the fields
%                   appear in the output of fieldnames(ParamStruct).

% Created by:
%   David J. Schodt (Lidke lab, 2021)


% Set defaults.
if ~exist('Callback', 'var')
    Callback = '';
end

% Define some parameters for the GUI controls.
FieldNames = fieldnames(ParamStruct);
NFields = numel(FieldNames);
ControlWidth = 0.5;
ControlHeight = 1 / NFields;

% Loop through the structure fields and add uicontrol elements.
ControlHandles = cell(NFields, 1);
for nn = 1:NFields
    % Isolate some info. about the nn-th field.
    CurrentName = FieldNames{nn};
    CurrentField = ParamStruct.(CurrentName);
    
    % Add a text description for the current field.
    ControlPosition = [0, 1 - nn/NFields, ControlWidth, ControlHeight];
    uicontrol('Parent', GUIParent, ...
        'Style', 'text', 'String', CurrentName, ...
        'Units', 'normalized', ... 
        'Position', ControlPosition, ...
        'HorizontalAlignment', 'left');
    
    % Create a uicontrol based on the type of the current field.
    if islogical(CurrentField)
        % Logical (boolean) fields are given a checkbox.
        ControlHandles{nn} = uicontrol(GUIParent, ...
            'Style', 'checkbox', 'Value', CurrentField, ...
            'Units', 'normalized', ...
            'Position', ControlPosition + [0.5, 0, 0, 0], ...
            'Callback', Callback, 'Tag', CurrentName);
    elseif (ischar(CurrentField) || isstring(CurrentField))
        % Chars and strings will be given an edit box.
        ControlHandles{nn} = uicontrol(GUIParent, ...
            'Style', 'edit', 'String', CurrentField, ...
            'Units', 'normalized', ...
            'Position', ControlPosition + [0.5, 0, 0, 0], ...
            'Callback', Callback, 'Tag', CurrentName);
    elseif isnumeric(CurrentField)
        % These fields are assumed to be numeric vectors, so we'll attempt 
        % to prepare edit boxes for them.
        EditString = sprintf('%g, ', CurrentField);
        ControlHandles{nn} = uicontrol(GUIParent, ...
            'Style', 'edit', 'String', EditString(1:(end-2)), ...
            'Units', 'normalized', ...
            'Position', ControlPosition + [0.5, 0, 0, 0], ...
            'Callback', Callback, 'Tag', CurrentName);
    else
        % All other fields aren't given a control since they likely can't
        % be set nicely with a simple control.
    end
end


end
./MATLAB/+smi_helpers/@ROITools/get_ROI.m
function [n_ROIs, ROI, index_ROI] = get_ROI(obj, X, Y, x_size, y_size, txt)
% Use the mouse to select ROIs (regions of interest):
%    left click  chooses the center of a fixed size (x_size x y_size) region
%    right click chooses an adjustable rectangular size region
%    key press:
%       backspace or delete   deletes the previous region
%       anything else         terminates selection
%
% INPUTS:
%    X                cell array of the x-coordinates of the labeled points in
%                     the entire image, where X{i} corresponds to the label i
%                     x-coordinates
%    Y                cell array of the y-coordinates of the labeled points in
%                     the entire image, where Y{i} corresponds to the label i
%                     y-coordinates
%    x_size, y_size   box diameters used when clicking the left mouse button
%    txt              text to label the ROI figure
%
% OUTPUTS:
%    n_ROIs           number of ROIs created
%    ROI              cell array of [xmin, xmax, ymin, ymax] for each ROI
%    index_ROI        cell array of labeled point indices in each ROI, where
%                     index_ROI{i}{j} corresponds to label j in ROI i

% Created by
%    Michael J. Wester (2021)

   n_labels = numel(X);

   n_ROIs = 0;   ROI = [];   index_ROI = [];

   BS = char(8);   DEL = char(127);

   % selected = 0   terminate selection
   %            1   valid button press
   %            2   ignored or region delete
   h = figure();
   % An idea by Samantha Schwartz
   %set(h, 'Position', [200, 70, 900, 900*(x_size/y_size)]);
   hold on
   for i = 1 : n_labels
      j = obj.Order(i);
      plot(X{j}, Y{j}, [obj.Color(j), '.'], 'MarkerSize', obj.Msize);
   end
   xlabel('x (nm)');
   ylabel('y (nm)');
   title(txt);
   done = false;
   while ~done
      clickval = waitforbuttonpress;
      if clickval == 0   % if a mouse button was pressed ...
         clickType = get(gcf, 'SelectionType');
         fprintf('%s: ', clickType);
         switch clickType
         case 'normal'   % left button press: draw a fixed rectangle
            selected = 1;
            curpt = get(gca, 'CurrentPoint');
            xmin = curpt(1, 1) - x_size/2;
            xmax = curpt(1, 1) + x_size/2;
            ymin = curpt(1, 2) - y_size/2;
            ymax = curpt(1, 2) + y_size/2;
         case 'alt'      % right button press: draw an adjustable rectangle
            selected = 1;
            rect = getrect;
            xmin = rect(1);
            xmax = rect(1) + rect(3);
            ymin = rect(2);
            ymax = rect(2) + rect(4);
         otherwise       % middle button press (extend) and double click (open)
            selected = 2;
         end
      else   % key was pressed
         charChoice = get(gcf, 'CurrentCharacter');
         % If a backspace or a delete, cancel the previous ROI
         if charChoice == BS | charChoice == DEL
            selected = 2;
            if n_ROIs > 0
               delete(r(n_ROIs));
               %delete(p(n_ROIs));
               delete(t(n_ROIs));

               ROI{n_ROIs} = [];
               index_ROI{n_ROIs} = [];

               fprintf('delete ROI %d\n', n_ROIs);
               n_ROIs = n_ROIs - 1;
            end
         else
            selected = 0;
         end
      end
      if selected == 1
         n_ROIs = n_ROIs + 1;
         fprintf('add ROI %d\n', n_ROIs);

         r(n_ROIs) = plot([xmin, xmin, xmax, xmax, xmin], ...
                          [ymin, ymax, ymax, ymin, ymin], ...
                          'r-', 'LineWidth', 3);

         ROI{n_ROIs} = [xmin, xmax, ymin, ymax];
         for i = 1 : n_labels
            index_ROI{n_ROIs}{i} = ...
               xmin <= X{i} & X{i} <= xmax & ymin <= Y{i} & Y{i} <= ymax;
         end

         not_empty = true;
         for i = 1 : n_labels
            not_empty = not_empty && any(index_ROI{n_ROIs}{i} == true);
         end
         if not_empty
            %XX = [];   YY = [];
            %for i = 1 : n_labels
            %   XX = [ XX; X{i}(index_ROI{n_ROIs}{i}) ];
            %   YY = [ YY; Y{i}(index_ROI{n_ROIs}{i}) ];
            %end
            %p(n_ROIs) = plot(XX, YY, 'r.');   % color the selected points red
            t(n_ROIs) = text((xmin + xmax)/2, (ymin + ymax)/2, ...
                             int2str(n_ROIs));
            t(n_ROIs).Color = 'black';
            t(n_ROIs).FontWeight = 'bold';
         else
            fprintf('One label has no points in this ROI!  Deleting ...\n');
            delete(r(n_ROIs));

            ROI{n_ROIs} = [];
            index_ROI{n_ROIs} = [];

            fprintf('delete ROI %d\n', n_ROIs);
            n_ROIs = n_ROIs - 1;
         end
      elseif selected == 0
         done = true;
      end
   end
   hold off

   if length(ROI) > n_ROIs
      ROI = ROI(~cellfun('isempty', ROI));
      index_ROI = index_ROI(~cellfun('isempty', index_ROI));
   end

end

./MATLAB/+smi_helpers/@ROITools/ROITools.m
classdef ROITools < handle

% ROITools class written by Michael Wester (7/16/2021) <wester@math.unm.edu>
% The New Mexico Center for the Spatiotemporal Modeling of Cell Signaling
% University of New Mexico Health Sciences Center
% Albuquerque, New Mexico, USA   87131
% Copyright (c) 2021 by Michael J. Wester and Keith A. Lidke

% These are tools to select ROIs from an image and save them into a data
% structure.  The main interface function is getROI.  All other methods are
% called by this routine.  getROI can take many types of sources (src):
%
%    a BGL, SMA_SR or SMD data structure,
%    point (x, y) coordinates [provided as N x 2 matrices, or if X_SE and
%       Y_SE are appended, then N x 4 matrices],
%    super-resolution image files containing a BGL, SMA_SR or SMD data
%       structure,
%    or directly from a data structure with fields X and Y (and X_SE, Y_SE or
%       X_STD, Y_STD).
%
% A simple invocation of getROI for a single label image is as follows:
%
%    RT = ROITools;
%    [n_ROIs, RoI, XYsize] = RT.getROI(Label1, 'Image Name');
%
% This produces a cell array of dimension n_ROIs called RoI, defined as follows
% (all units are in nm):
%
%    RoI      cell array for each ROI of
%                ROI          [xmin, xmax, ymin, ymax] of ROI
%                X, Y         (x, y) coordinates of points inside
%                X_SE, Y_SE   (x, y) localization errors for the above
%
% Note that X, Y, X_SE, Y_SE are actually cell arrays.  For example, RoI{1}
% will contain:
%
%    X: {[n1 x 1 double]}, etc.
%
% If src is a cell array, then each element will be taken to be a separate
% label.  For example,
%
%    RT = ROITools;
%    [n_ROIs, RoI, XYsize] = RT.getROI({Label1, Label2}, 'Image Name');
%
% will combine the images for Label1 and Label2, and allow selection of ROIs
% that are compatible with both labels.  In this case, RoI{1} will contain:
%
%    X: {[n1 x 1 double], [n2 x 1 double]}, etc.,
%
% where n1, n2 are the number of localizations from Label1, Label2,
% respectively.
%
% By default, point images will be displayed from which to choose ROIs.  To
% use Gaussian images (currently only available for one label input), set
%
%    RT.GaussIm = true;   RT.OriginLLvsUL = false;
%
% before invoking RT.getROI.  As a final comment, XYsize is the (x, y) image
% size (nm) [1 x 2] needed for displaying coordinates where the origin is in
% the UL corner.  This only is needed for BaGoL files when GaussIm is true---
% see code fragment:
%
%   Xnm = BGL.MAPN.X;
%   if RT.GaussIm   % if GaussIm, the origin is in the upper left corner
%      Ynm = XYsize(2) - BGL.MAPN.Y;
%   else
%      Ynm = BGL.MAPN.Y;
%   end

% =============================================================================
properties

   % Box sizes used when clicking the left mouse button (nm).
   ROI_sizes = [3000, 3000];   % nm
   Color = ['g', 'm', 'k', 'c', 'r', 'y'];   % Label colors.
   Order = 1 : 6;     % Plotting order.
   Msize = 7;         % Marker size.
   XYvsYX  = true;    % Coordinate order.
   % GaussIm = true indicates that gaussianImage will be used for the ROI
   %    selection display.
   % OriginLLvsUL = true says to use lower left origin coordinates rather than
   %    upper left origin coordinates in the ROI selection display.
   % SRzoom is the zoom factor for displaying Gaussian images.
   %
   % If GaussIm is true, make OriginLLvsUL false for consistency.  The default
   % is: GaussIm = false and OriginLLvsUL = true.  Currently, GaussIm only
   % works for single labeled molecules.
   GaussIm = false;       % Use gaussianImage for ROI selection display.
   OriginLLvsUL = true;   % Use LL origin coordinates rather than UL.
   SRzoom = 1;            % Zoom factor for gaussianImage.
   EM = false;            % EM data format for import_XY.
   Transform = {};        % Coordinate transform from label i -> 1.
   Mask = {};             % Boolean image mask to be used with an SMD source

end % properties
% =============================================================================

% =============================================================================
properties(Hidden)

   % For newer image data structures like SMD, PixelSize is defined within the
   % structure and will be used directly.  This property remains for older
   % structures.
   Pixel2nm  = 100;   % Pixel size in nm 

end % properties(Hidden)
% =============================================================================

% =============================================================================
methods

   [n_ROIs, RoI, XYsize] = getROI(obj, src, txt)
   [n_ROIs, RoI] = getROI_XY(obj, XY, XY_SE, x_size, y_size, txt, XYsize, ...
                             SMDimport)
   [n_ROIs, ROI, index_ROI] = get_ROI(obj, X, Y, x_size, y_size, txt)
   [n_ROIs, ROI, index_ROI] = ...
      get_ROI_GaussIm(obj, X, Y, x_size, y_size, txt, SMD)
   [XY, XY_SE, XYsize, SMDimport] = import_XY(obj, src, pixel2nm, fmt)

end % methods
% =============================================================================

end % classdef ROITools

./MATLAB/+smi_helpers/@ROITools/getROI_XY.m
function [n_ROIs, RoI] = getROI_XY(obj, XY, XY_SE, x_size, y_size, ...
                                   txt, XYsize, SMR)
% Let the user select ROIs from (x, y)-coordinates.
%
% INPUTS:
%    XY               cell array of (x, y) coordinates of points labeled in
%                     image (nm); XY{i} is the coordinates for label i
%    XY_SE            cell array of (x, y) standard deviations of the
%                     coordinate values (nm)
%    x_size, y_size   box diameters used when clicking the left mouse button
%                     (nm)
%    txt              text to label the ROI figure
%    XYsize           [OPTIONAL] (x, y) image size (nm) [1 x 2]; needed for
%                     displaying coordinates where the origin in the UL corner
%                     (OriginLLvsUL)
%    SMR              [OPTIONAL] SMR structure from an SMA_SR data structure
%                     needed for gaussianImage in get_ROI (GaussIm)
%
% OUTPUTS:
%    n_ROIs           number of ROIs created
%    RoI              cell array for each ROI of
%                        ROI          [xmin, xmax, ymin, ymax] of ROI
%                        X, Y         (x, y) coordinates of points inside
%                        X_SE, Y_SE   (x, y) localization errors for the above
%                     NOTE: X{i}{j} is the x-coordinates of label j in ROI i,
%                     etc.

% Created by
%    Michael J. Wester (2021)

   if ~exist('SMR', 'var')
      SMR = [];
   end

   if obj.XYvsYX
      ix = 1;
      iy = 2;
   else
      ix = 2;
      iy = 1;
   end

   %if obj.OriginLLvsUL
      ix = 1;
      iy = 2;
   %else   % Below needed for SRtest, but not for SMR.
   %   ix = 2;
   %   iy = 1;
   %end

   n_labels = numel(XY);

   for j = 1 : n_labels
      n = size(XY{j}, 1);
      X_SE{j} = NaN(n, 1);
      Y_SE{j} = NaN(n, 1);

      if obj.OriginLLvsUL
         X{j} = XY{j}(:, ix);
         Y{j} = XY{j}(:, iy);
      else
         X{j} = XY{j}(:, ix);
         Y{j} = XYsize(2) - XY{j}(:, iy);
      end
      if ~isempty(XY_SE{j})
         X_SE{j} = XY_SE{j}(:, ix);
         Y_SE{j} = XY_SE{j}(:, iy);
      end
   end

   if obj.GaussIm && exist('SMR', 'var') && ~isempty(SMR)
      [n_ROIs, ROI, index_ROI] = ...
         obj.get_ROI_GaussIm(X, Y, x_size, y_size, txt, SMR);
   else
      [n_ROIs, ROI, index_ROI] = obj.get_ROI(X, Y, x_size, y_size, txt);
   end
   RoI = cell(1, n_ROIs);
   for i = 1 : n_ROIs
      fprintf('ROI %d extent = [%.2f %.2f %.2f %.2f], pts =', i, ROI{i});
      RoI{i}.ROI   = ROI{i};
      for j = 1 : n_labels
         k = index_ROI{i}{j};
         RoI{i}.X{j}    = X{j}(k);
         RoI{i}.Y{j}    = Y{j}(k);
         RoI{i}.X_SE{j} = X_SE{j}(k);
         RoI{i}.Y_SE{j} = Y_SE{j}(k);
         fprintf(' L%d:%d', j, numel(RoI{i}.X{j}));
      end
      fprintf('\n');
   end

end

./MATLAB/+smi_helpers/@ROITools/README.md
### +smi_helpers/@ROITools

These are tools to select ROIs from an image and save them into a data
structure.  The main interface function is [getROI](getROI.m).
All other methods are
called by this routine.  getROI can take many types of sources (src):

- a BGL, SMA_SR or SMD data structure,
- point (x, y) coordinates [provided as N x 2 matrices, or if X_SE and
     Y_SE are appended, then N x 4 matrices],
- super-resolution image files containing a BGL, SMA_SR or SMD data
     structure,
- or directly from a data structure with fields X and Y (and X_SE, Y_SE or
     X_STD, Y_STD).

---

A simple invocation of getROI for a single label image is as follows:
```
   RT = ROITools;
   [n_ROIs, RoI, XYsize] = RT.getROI(Label1, 'Image Name');
```
This produces a cell array of dimension n_ROIs called RoI, defined as follows
(all units are in nm):
```
   RoI      cell array for each ROI of
               ROI          [xmin, xmax, ymin, ymax] of ROI
               X, Y         (x, y) coordinates of points inside
               X_SE, Y_SE   (x, y) localization errors for the above
```
Note that X, Y, X_SE, Y_SE are actually cell arrays.  For example, RoI{1}
will contain:
```
   X: {[n1 x 1 double]}, etc.
```
If src is a cell array, then each element will be taken to be a separate
label.  For example,
```
   RT = ROITools;
   [n_ROIs, RoI, XYsize] = RT.getROI({Label1, Label2}, 'Image Name');
```
will combine the images for Label1 and Label2, and allow selection of ROIs
that are compatible with both labels.  In this case, RoI{1} will contain:
```
   X: {[n1 x 1 double], [n2 x 1 double]}, etc.,
```
where n1, n2 are the number of localizations from Label1, Label2,
respectively.

By default, point images will be displayed from which to choose ROIs.  To
use Gaussian images (currently only available for one label input), set
```
   RT.GaussIm = true;   RT.OriginLLvsUL = false;
```
before invoking RT.getROI.  As a final comment, XYsize is the (x, y) image
size (nm) [1 x 2] needed for displaying coordinates where the origin is in
the UL corner.  This only is needed for BaGoL files when GaussIm is true---
see code fragment:
```
  Xnm = BGL.MAPN.X;
  if RT.GaussIm   % if GaussIm, the origin is in the upper left corner
     Ynm = XYsize(2) - BGL.MAPN.Y;
  else
     Ynm = BGL.MAPN.Y;
  end
```

---

```
properties:
   % Box sizes used when clicking the left mouse button (nm).
   ROI_sizes = [3000, 3000];   % nm
   Color = ['g', 'm', 'k', 'c', 'r', 'y'];   % Label colors.
   Order = 1 : 6;     % Plotting order.
   Msize = 7;         % Marker size.
   XYvsYX  = true;    % Coordinate order.
   % GaussIm = true indicates that gaussianImage will be used for the ROI
   %    selection display.
   % OriginLLvsUL = true says to use lower left origin coordinates rather than
   %    upper left origin coordinates in the ROI selection display.
   % SRzoom is the zoom factor for displaying Gaussian images.
   %
   % If GaussIm is true, make OriginLLvsUL false for consistency.  The default
   % is: GaussIm = false and OriginLLvsUL = true.  Currently, GaussIm only
   % works for single labeled molecules.
   GaussIm = false;       % Use gaussianImage for ROI selection display.
   OriginLLvsUL = true;   % Use LL origin coordinates rather than UL.
   SRzoom = 1;            % Zoom factor for gaussianImage.
   EM = false;            % EM data format for import_XY.
   Transform = {};        % Coordinate transform from label i -> 1.
   Mask = {};             % Boolean image mask to be used with an SMD source
```

./MATLAB/+smi_helpers/@ROITools/getROI.m
function [n_ROIs, RoI, XYsize] = getROI(obj, src, txt)
% Let the user select ROIs from
%    a BGL, SMA_SR or SMD data structure,
%    point (x, y) coordinates [provided as N x 2 matrices, or if X_SE and
%       Y_SE are appended, then N x 4 matrices],
%    super-resolution image files containing a BGL, SMA_SR or SMD data
%       structure,
%    or directly from a data structure with fields X and Y (and X_SE, Y_SE or
%       X_STD, Y_STD).
%
% INPUTS:
%    obj   various properties used by the algorithms
%       Pixel2nm    conversion factor from pixels to nm 
%       ROI_sizes   box diameters used when clicking the left mouse button (nm)
%       Color       label colors
%       Order       plotting order
%       Msize       marker size
%       XYvsYX      coordinate order
%       OriginLLvsUL coordinate origin (llower left vs. upper left)
%       GaussIm     use Gaussian image for display
%       EM          if true, data is in EM format
%    src   cell array of (x, y) coordinate sources, although it is permissible
%          to omit the cell array for a single source
%    txt   [OPTIONAL] text to label the ROI figure
%
% OUTPUTS (units in nm):
%    n_ROIs      number of ROIs created
%    RoI         cell array for each ROI of
%                   ROI            [xmin, xmax, ymin, ymax] of ROI
%                   X, Y           (x, y) coordinates of points inside
%                   X_SE, Y_SE     (x, y) localization errors for the above
%    XYsize      (x, y) image size (nm) [1 x 2]; needed for
%                displaying coordinates where the origin in the UL corner
%                (OriginLLvsUL)

% Created by:
%    Michael J. Wester (2021)

   if ~exist('txt', 'var')
      txt = '';
   end

   x_size = obj.ROI_sizes(1);
   y_size = obj.ROI_sizes(2);

   n_ROIs = 0;
   RoI = [];

   fmt = '';
   if obj.EM
      fmt = 'EM';
   end

   if ~iscell(src)
      [XY{1}, XY_SE{1}, XYsize, SMR] = obj.import_XY(src, obj.Pixel2nm, fmt);
   else
      n_labels = numel(src);
      for i = 1 : n_labels
         [XY{i}, XY_SE{i}, XYsize, SMR] = ...
            obj.import_XY(src{i}, obj.Pixel2nm, fmt);
      end
   end
   [n_ROIs, RoI] = ...
      obj.getROI_XY(XY, XY_SE, x_size, y_size, txt, XYsize, SMR);

end

./MATLAB/+smi_helpers/@ROITools/import_XY.m
function [XY, XY_SE, XYsize, SMDimport] = import_XY(obj, src, pixel2nm, fmt)
% Import N x 2 (x, y) coordinates and standard deviations from ...
%    a BGL, SMA_SR or SMD data structure,
%    point (x, y) coordinates [provided as N x 2 matrices, or if x_SE and
%       y_SE are appended, then N x 4 matrices],
%    super-resolution image files containing a BGL, SMA_SR or SMD data
%       structure,
%    or directly from a data structure with fields X and Y (and X_SE, Y_SE or
%       X_STD, Y_STD).
%
% INPUTS:
%    src              (x, y) coordinate source
%    pixel2nm         conversion factor from pixels to nm.
%                        NOTE: overridden by existing value in SMD
%    fmt              special data format (e.g., 'EM');
%
% OUTPUTS (units in nm):
%    XY               array of (x, y) point coordinates [N x 2]
%    XY_SE            array of (x, y) standard deviations of the coordinate
%                     values [N x 2]
%    XYsize           (x, y) sizes of the src image [1 x 2]
%    SMDimport        SMD structure either returned or contructed in order for
%                     get_ROI_GaussIm to properly produce a Gaussian image

% Created by:
%    Michael J. Wester (2021)

   if ~exist('fmt', 'var')
      fmt = [];
   end

   XY_SE = [];
   SMDimport = [];

   if strcmp(class(src), 'SMA_SR')
      % src is an SMA_SR data structure
      XY = [ double(src.SMR.X) .* pixel2nm, ...
             double(src.SMR.Y) .* pixel2nm ];
      XY_SE = [ double(src.SMR.X_SE) .* pixel2nm, ...
                double(src.SMR.Y_SE) .* pixel2nm ];
      XYsize = [src.XSize, src.YSize] .* pixel2nm;
      SMDimport = src.SMR;
      SMDimport.PixelSize = pixel2nm / 1000;

   elseif strcmp(class(src), 'BaGoL') || strcmp(class(src), 'smi.BaGoL')
      % src is a BGL.SMD data structure (from BaGoL)
      XY = [ double(src.MAPN.X), double(src.MAPN.Y) ];
      XY_SE = [ double(src.MAPN.X_SE), double(src.MAPN.Y_SE) ];
      %XYsize = [floor(min(min(XY(:, 1:2)))), ceil(max(max(XY(:, 1:2))))];
      XYsize = [256, 256] .* pixel2nm;
      SMDimport = src.MAPN;
      SMDimport.X = SMDimport.X ./ pixel2nm;
      SMDimport.Y = SMDimport.Y ./ pixel2nm;
      SMDimport.X_SE = SMDimport.X_SE ./ pixel2nm;
      SMDimport.Y_SE = SMDimport.Y_SE ./ pixel2nm;
      SMDimport.XSize = XYsize(1) ./ pixel2nm;
      SMDimport.YSize = XYsize(2) ./ pixel2nm;
      SMDimport.PixelSize = pixel2nm / 1000;
      n_locs = numel(src.MAPN.X);
      SMDimport.Bg = zeros(n_locs, 1);
      SMDimport.Photons = 1000 * ones(n_locs, 1);
      SMDimport.FrameNum = ones(n_locs, 1);

   elseif ismatrix(src) && ~ischar(src) && ~isstruct(src)
      % src is a matrix
      n_cols = size(src, 2);
      if n_cols == 2 || n_cols == 4
         XY = src(:, 1:2) .* pixel2nm;
      else
         error('src matrix has %d rather than 2 or 4 columns!', n_cols);
      end
      if n_cols == 4
         XY_SE = src(:, 3:4) .* pixel2nm;
      end
      XYsize = [floor(min(src(:, 1:2))), ceil(max(src(:, 1:2)))] .* pixel2nm;

   elseif ischar(src)
      % src is a filename
      if isempty(fmt)
         load(src);
         if exist('SMD', 'var')
            [XY, XY_SE, XYsize, SMDimport] = obj.import_XY(SMD, pixel2nm);
         elseif exist('SMASR', 'var')
            [XY, XY_SE, XYsize, SMDimport] = obj.import_XY(SMASR, pixel2nm);
         elseif exist('SMR', 'var') & ~isempty(SMR)
            [XY, XY_SE, XYsize, SMDimport] = obj.import_XY(SMR, pixel2nm);
         elseif exist('BGL', 'var')
            [XY, XY_SE, XYsize, SMDimport] = obj.import_XY(BGL, pixel2nm);
         elseif exist('EGF', 'var')
            [XY, XY_SE, XYsize, SMDimport] = obj.import_XY(EGF, pixel2nm);
         elseif exist('MAPN', 'var')
            [XY, XY_SE, XYsize, SMDimport] = ...
               obj.import_XY(MAPN, pixel2nm, 'MAPN');
         else
            error('No BGL, EGF, MAPN, SMASR, SMD, SMR object found in %s!', src);
         end
      elseif strcmp(fmt, 'EM')
         % (x, y) data is in columns (2, 3).
         [x, y] = textread(src, '%*u %u %u %*u', 'headerlines', 1);
         XY = [x, y] .* pixel2nm;
         XYsize = [256, 256] .* pixel2nm;
      elseif strcmp(fmt, 'MAPN')
         % Do nothing here.
      else
         error('Unknown fmt (%s)!', fmt);
      end

   elseif isstruct(src)
      % src should be a data structure with fields X, Y and optionally
      % X_SE, Y_SE or X_STD, Y_STD as well as XSize, YSize
      if isfield(src, 'X') & isfield(src, 'Y')
         % If PixelSize is available, use it!
         if ~isempty(pixel2nm) && isfield(src, 'PixelSize') ...
            && pixel2nm ~= 1000 * src.PixelSize
            warning(['Incompatible pixel2nm/PixelSize specification:\n', ...
                     '(PixelSize from input source = %f overrides pixel2nm = %f)\n'], ...
                     1000 * src.PixelSize, pixel2nm);
            pixel2nm = 1000 * src.PixelSize;
         end
         if ~isempty(obj.Mask)
            src = smi_core.SingleMoleculeData.maskSMD(src, obj.Mask);
         end

         MAPN = ~isempty(fmt) && strcmp(fmt, 'MAPN');
         if MAPN
            XY = [ double(src.X), double(src.Y) ];
         else
            XY = [ double(src.X) .* pixel2nm, double(src.Y) .* pixel2nm ];
         end
         if isfield(src, 'X_SE') & isfield(src, 'Y_SE')
            if MAPN
               XY_SE = [ double(src.X_SE), double(src.Y_SE) ];
            else
               XY_SE = [ double(src.X_SE) .* pixel2nm, ...
                         double(src.Y_SE) .* pixel2nm ];
            end
         elseif isfield(src, 'X_STD') & isfield(src, 'Y_STD')
            XY_SE = [ double(src.X_STD) .* pixel2nm, ...
                      double(src.Y_STD) .* pixel2nm ];
         end
         if isfield(src, 'XSize') & isfield(src, 'YSize')
            XYsize = [src.XSize, src.YSize] .* pixel2nm;
         else
            %XYsize = [ceil(max(src.X)), ceil(max(src.Y))] .* pixel2nm;
            XYsize = [256, 256] .* pixel2nm;
         end
         SMDimport = src;
         if ~isfield(src, 'Z')
            SMDimport.Z = [];
            SMDimport.Z_SE = [];
         end
         if ~isfield(src, 'PixelSize')
            SMDimport.PixelSize = pixel2nm / 1000;
         end
      else
         error('Fields X, Y not found in src!');
      end

   else
      error('Incorrect argument type for src!');
   end

end

./MATLAB/+smi_helpers/@ROITools/get_ROI_GaussIm.m
function [n_ROIs, ROI, index_ROI] = ...
   get_ROI_GaussIm(obj, X, Y, x_size, y_size, txt, SMD)
% Display data for ROI selection with gaussianImage.
%
% Use the mouse to select ROIs (regions of interest):
%    left click  chooses the center of a fixed size (x_size x y_size) region
%    right click chooses an adjustable rectangular size region
%    key press:
%       backspace or delete   deletes the previous region
%       anything else         terminates selection
%
% INPUTS:
%    X                cell array of the x-coordinates of the labeled points in
%                     the entire image, where X{i} corresponds to the label i
%                     x-coordinates
%    Y                cell array of the y-coordinates of the labeled points in
%                     the entire image, where Y{i} corresponds to the label i
%                     y-coordinates
%    x_size, y_size   box diameters used when clicking the left mouse button
%    txt              text to label the ROI figure
%    SMD              SMD structure needed for gaussianImage (GaussIm)
%
% OUTPUTS:
%    n_ROIs           number of ROIs created
%    ROI              cell array of [xmin, xmax, ymin, ymax] for each ROI
%    index_ROI        cell array of labeled point indices in each ROI, where
%                     index_ROI{i}{j} corresponds to label j in ROI i

% Created by
%    Michael J. Wester (2021)

   pixel2nm = obj.Pixel2nm;
   SRzoom   = obj.SRzoom;

   n_labels = numel(X);

   n_ROIs = 0;   ROI = [];   index_ROI = [];

   BS = char(8);   DEL = char(127);

%figure(2); plot(SMD.X * pixel2nm, SMD.Y * pixel2nm, 'k.');
%figure(3); plot(X{1}, Y{1}, 'k.');

   % selected = 0   terminate selection
   %            1   valid button press
   %            2   ignored or region delete
   cm = hot(256);
   cm(1, :) = [0, 0, 0];
   GaussIm = smi_vis.GenerateImages.gaussianImage(SMD, SRzoom);
   P = prctile(GaussIm(GaussIm > 0), 99.9);
   GaussIm(GaussIm > P) = P;
   h = imshow(GaussIm, cm);

   %for i = 2 : n_labels
   %   j = obj.Order(i);
   %   plot(X{j}, Y{j}, obj.Color(j));
   %end

   hold on
   axis off
   title(txt);
   xlabel('x');
   ylabel('y');

   done = false;
   while ~done
      clickval = waitforbuttonpress;
      if clickval == 0   % if a mouse button was pressed ...
         clickType = get(gcf, 'SelectionType');
         fprintf('%s: ', clickType);
         switch clickType
         case 'normal'   % left button press: draw a fixed rectangle
            selected = 1;
            curpt = get(gca, 'CurrentPoint');
            curpt = curpt ./ SRzoom .* pixel2nm;
            xmin = curpt(1, 1) - x_size/2;
            xmax = curpt(1, 1) + x_size/2;
            ymin = curpt(1, 2) - y_size/2;
            ymax = curpt(1, 2) + y_size/2;
         case 'alt'      % right button press: draw an adjustable rectangle
            selected = 1;
            rect = getrect;
            rect = rect ./ SRzoom .* pixel2nm;
            xmin = rect(1);
            xmax = rect(1) + rect(3);
            ymin = rect(2);
            ymax = rect(2) + rect(4);
         otherwise       % middle button press (extend) and double click (open)
            selected = 2;
         end
      else   % key was pressed
         charChoice = get(gcf, 'CurrentCharacter');
         % If a backspace or a delete, cancel the previous ROI
         if charChoice == BS | charChoice == DEL
            selected = 2;
            if n_ROIs > 0
               delete(r(n_ROIs));
               %delete(p(n_ROIs));
               delete(t(n_ROIs));

               ROI{n_ROIs} = [];
               index_ROI{n_ROIs} = [];

               fprintf('delete ROI %d\n', n_ROIs);
               n_ROIs = n_ROIs - 1;
            end
         else
            selected = 0;
         end
      end
      if selected == 1
         n_ROIs = n_ROIs + 1;
         fprintf('add ROI %d', n_ROIs);

         xmin_p = xmin * SRzoom / pixel2nm;
         xmax_p = xmax * SRzoom / pixel2nm;
         ymin_p = ymin * SRzoom / pixel2nm;
         ymax_p = ymax * SRzoom / pixel2nm;

         r(n_ROIs) = plot([xmin_p, xmin_p, xmax_p, xmax_p, xmin_p], ...
                          [ymin_p, ymax_p, ymax_p, ymin_p, ymin_p], ...
                          'g-', 'LineWidth', 3);

         % Adjust for image display where y increases going downward as opposed
         % to normal plots where y increases going upward.
         tmp  = ymin;
         ymin = ymax;
         ymax = tmp;
         ymin = SMD.YSize * pixel2nm - ymin;
         ymax = SMD.YSize * pixel2nm - ymax;

         ROI{n_ROIs} = [xmin, xmax, ymin, ymax];
         for i = 1 : n_labels
            index_ROI{n_ROIs}{i} = ...
               xmin <= X{i} & X{i} <= xmax & ymin <= Y{i} & Y{i} <= ymax;
         end

         not_empty = true;
         for i = 1 : n_labels
            fprintf(' (label %d: %d points)', ...
                    i, numel(find(index_ROI{n_ROIs}{i} == true)));
            not_empty = not_empty && any(index_ROI{n_ROIs}{i} == true);
         end
         fprintf('\n');
         if not_empty
            %XX = [];   YY = [];
            %for i = 1 : n_labels
            %   XX = [ XX; X{i}(index_ROI{n_ROIs}{i}) ];
            %   YY = [ YY; Y{i}(index_ROI{n_ROIs}{i}) ];
            %end
            %XX = XX * SRzoom / pixel2nm;
            %YY = (SMD.YSize * pixel2nm - YY) * SRzoom / pixel2nm;
            %p(n_ROIs) = plot(XX, YY, 'g.'); % color the selected points green
            t(n_ROIs) = text((xmin_p + xmax_p)/2, (ymin_p + ymax_p)/2, ...
                             int2str(n_ROIs));
            t(n_ROIs).Color = 'green';
            t(n_ROIs).FontWeight = 'bold';
         else
            fprintf('One label has no points in this ROI!  Deleting ...\n');
            delete(r(n_ROIs));

            ROI{n_ROIs} = [];
            index_ROI{n_ROIs} = [];

            fprintf('delete ROI %d\n', n_ROIs);
            n_ROIs = n_ROIs - 1;
         end
      elseif selected == 0
         done = true;
      end
   end
   hold off

   if length(ROI) > n_ROIs
      ROI = ROI(~cellfun('isempty', ROI));
      index_ROI = index_ROI(~cellfun('isempty', index_ROI));
   end

end

./MATLAB/+smi_helpers/requiredToolboxes.m
function requiredToolboxes()
% Print out required toolboxes for each directory in the SMITE directory
% structure.

% Created by
%    Michael J. Wester (2021, LidkeLab)

SMITEdirs = {
   'ExternalSoftware'
   'ExternalSoftware/FRCresolution_software'
   'ExternalSoftware/PlotSpread'
   'ExternalSoftware/uipickfiles'
   'MATLAB'
   'MATLAB/+smi'
   'MATLAB/+smi/@BaGoL'
   'MATLAB/+smi/@Publish'
   'MATLAB/+smi/@SMLM'
   'MATLAB/+smi/@SPT'
   'MATLAB/+smi_cluster'
   'MATLAB/+smi_cluster/@Clustering'
   'MATLAB/+smi_cluster/@PairCorrelation'
   'MATLAB/+smi_cluster/@StatisticsClustering'
   'MATLAB/+smi_core'
   'MATLAB/+smi_core/@ChannelRegistration'
   'MATLAB/+smi_core/@DataToPhotons'
   'MATLAB/+smi_core/@DriftCorrection'
   'MATLAB/+smi_core/@FRC'
   'MATLAB/+smi_core/@FindROI'
   'MATLAB/+smi_core/@FrameConnection'
   'MATLAB/+smi_core/@LoadData'
   'MATLAB/+smi_core/@LocalizeData'
   'MATLAB/+smi_core/@SingleMoleculeData'
   'MATLAB/+smi_core/@SingleMoleculeFitting'
   'MATLAB/+smi_core/@Threshold'
   'MATLAB/+smi_core/@TrackingResults'
   'MATLAB/+smi_helpers'
   'MATLAB/+smi_helpers/@ROITools'
   'MATLAB/+smi_psf'
   'MATLAB/+smi_psf/@PointSpreadFunction'
   'MATLAB/+smi_psf/@Zernike'
   'MATLAB/+smi_sim'
   'MATLAB/+smi_sim/@GaussBlobs'
   'MATLAB/+smi_sim/@SimSMLM'
   'MATLAB/+smi_sim/@SimSPT'
   'MATLAB/+smi_stat'
   'MATLAB/+smi_stat/@DiffusionEstimator'
   'MATLAB/+smi_stat/@HMM'
   'MATLAB/+smi_vis'
   'MATLAB/+smi_vis/@GenerateMovies'
   'MATLAB/+smi_vis/@InspectResults'
   'MATLAB/+smi_vis/@GenerateImages'
   'MATLAB/examples'
   'MATLAB/mex'
   'MATLAB/ptx'
   'MATLAB/source'
   'MATLAB/source/c'
   'MATLAB/source/cuda'
   'MATLAB/source/cuda/smi_cuda_FindROI'
   'MATLAB/source/cuda/smi_cuda_PSFSample3DBlob'
   'MATLAB/source/cuda/smi_cuda_gaussBlobROIStack'
   'MATLAB/source/cuda/smi_cuda_gaussMLEv2'
};

nSMITEdirs = numel(SMITEdirs);
for i = 1 : nSMITEdirs
   SMITEdir = fullfile(userpath, 'smite', SMITEdirs{i});
   [fList, pList] = matlab.codetools.requiredFilesAndProducts(SMITEdir);
   nProducts = numel(pList);
   fprintf('%s:\n', SMITEdirs{i});
   for j = 1 : nProducts
      % Eliminate non-toolboxes from the output.
      if ~isempty(strfind(pList(j).Name, ' Toolbox'))
         fprintf('   %s\n', pList(j).Name);
      end
   end
end

end

./MATLAB/+smi_helpers/mkSMITETmpDir.m
function SaveDir = mkSMITETmpDir(subdir1, subdir2)
% Create full pathnames and temporary directories for SMITE testing/examples.
% This will produce SaveDir:
%    tempdir/'smite'/subdir1/subdir2
%
% INPUTS:
%    subdir1   subdirectory name, typically 'unitTest' or 'examples'
%    subdir2   lower level subdirectory name that identifies the type of test
%
% OUTPUT:
%    SaveDir   full pathname for temporary save directory
%              (tempdir/'smite'/subdir1/subdir2)

   SaveDir = fullfile(tempdir, 'smite');
   if ~isfolder(SaveDir)
      mkdir(SaveDir)
   end
   SaveDir = fullfile(SaveDir, subdir1);
   if ~isfolder(SaveDir)
      mkdir(SaveDir)
   end
   SaveDir = fullfile(SaveDir, subdir2);
   if ~isfolder(SaveDir)
      mkdir(SaveDir)
   end

end

./MATLAB/+smi_helpers/filenameWindows2Unix.m
function filenameUnix = filenameWindows2Unix(filenameWindows, prefix)
%filenameWindows2Unix converts the Windows filenameWindows to the Unix filename
% filenameUnix, optionally preceded by prefix.
%
% INPUTS:
%    filenameWindows   Windows filename (character string)
%    prefix            [OPTIONAL] prefix to be prepended to the filename
%
% OUTPUT:
%    filenameUnix      Unix filename (character string)

% Created by
%    Michael Wester (lidkelab 2021)

   % Replace \'s by /'s.
   filename = regexprep(filenameWindows, '\\', '/');
   % Remove leading Windows device specifier if present.
   filename = regexprep(filename, '^[^:]*:', '');
   % Prepend prefix to the Unix filename if supplied.
   if exist('prefix', 'var')
      filename = [prefix, filename];
   end
   filenameUnix = filename;

end

./MATLAB/+smi_helpers/writeMPEG4.m
function writeMPEG4(ResultsDir, FileBaseName, RGBImage)
%writeMPEG4 writes a .mp4 image constructed from the RGB image input on all OS.
%
% writeMPEG4 uses VideoWriter to generate video files.  Note that
% VideoWriter in Linux cannot generate .mp4 files, so it necessary to
% save in a different format and convert to .mp4 via external software
% (ffmpeg), which, of course, must be installed.  ffmpeg can convert
% between a variety of video formats.
%
% INPUT:
%    ResultsDir     output directory
%    FileBaseName   output filename with no extension
%    RGBImage       RGB image stack (4 dimensions: R, G, B, time sequence)
%
% OUTPUT:
%    ResultsDir/FileBaseName.mp4 video file
%
% REQUIREMENTS:
%    ffmpeg installed on Linux systems (https://ffmpeg.org)

% Created by
%    Michael J. Wester (Lidke Lab, 2022)

   islinux = isunix && ~ismac;
   RGBout = fullfile(ResultsDir, FileBaseName);
   RGBImageReordered = permute(RGBImage, [1, 2, 4, 3]);
   % Be sure RGBImageReordered is properly scaled if it is a float array.
   maxRGBImageReordered = max(max(max(max(RGBImageReordered(:)))));
   if isfloat(RGBImageReordered) & maxRGBImageReordered > 1
      RGBImageReordered = RGBImageReordered ./ maxRGBImageReordered;
   end
   % VideoWriter in Linux cannot generate .mp4 files, so it necessary to
   % save in a different format and convert to .mp4 via external software
   % (ffmpeg), which, of course, must be installed.  ffmpeg can convert
   % between a variety of video formats.
   if ~islinux
      v = VideoWriter(RGBout, 'MPEG-4');
   else
      v = VideoWriter(RGBout, 'Motion JPEG AVI');
   end
   open(v);
   writeVideo(v, RGBImageReordered);
   close(v);
   if islinux
      cmd = sprintf('ffmpeg -y -i %s.avi %s.mp4', RGBout, RGBout);
      [status, result] = system(cmd);
      if status ~= 0
         result
      end
   end

end

./MATLAB/+smi_helpers/getFileNames.m
function [FileNames] = getFileNames(FileDir, NameString)
%getFileNames creates a list of filenames in FileDir.
% This function generates a cell array of filenames matching 'NameString'
% (which can contain a wild card '*', but is otherwise not a regexp [see
% usage of MATLAB built-in dir()]) within a directory 'FileDir'.
%
% INPUTS:
%   FileDir: Directory containing the files of interest.
%            (char array)(Default = pwd())
%   NameString: Pattern that files in 'FileDir' must match to be listed.
%               (char array)(Default = '*')
%
% OUTPUTS:
%   FileNames: List of the filenames in 'FileDir' matching 'NameString'.
%              (cell array)

% Created by:
%   David J. Schodt (Lidke Lab, 2021)


% If 'FileDir' is empty, stop now (this is convenient for some methods that
% use this function).
if (~exist('FileDir', 'var') || isempty(FileDir) || ~isfolder(FileDir))
    FileNames = {};
    return
end

% Set defaults if needed.
if (~exist('NameString', 'var') || isempty(NameString))
    NameString = '*';
end

% Determine the contents in 'FileDir'.
DirContents = dir(fullfile(FileDir, NameString));

% Remove the directories listed in 'DirContents'.
SubDirBoolean = [DirContents.isdir];
FileNames = {DirContents(~SubDirBoolean).name}.';


end
./MATLAB/+smi_helpers/@Filters/inflateSE.m
function SMD = inflateSE(SMD, Verbose, SEAdjust)
%inflateSE: Inflate standard errors.
%
% INPUTS:
%    SMD        Single Molecule Data structure
%    Verbose    verbosity flag [Default = false]
%    SEAdjust   standard error inflation amount (pixel) [DEFAULT = 0]
%
% OUTPUT:
%    SMD        modified Single Molecule Data structure

% Created by
%    David J. Schodt and Michael J. Wester (5/24/2022)

if ~exist('Verbose', 'var')
   Verbose = false;
end

if ~exist('SEAdjust', 'var')
   SEAdjust = 0;
end

if SEAdjust > 0
   SMD.X_SE = SMD.X_SE + SEAdjust;
   SMD.Y_SE = SMD.Y_SE + SEAdjust;

   if Verbose >= 2
      fprintf('Inflated standard errors by %g pixels.\n', SEAdjust);
   end
end

end

./MATLAB/+smi_helpers/@Filters/filterNN.m
function SMD = filterNN(SMD, Verbose, n_NN, MedianMultiplier)
%filterNN:  Localizations are filtered based on the NND within MedianMultiplier
% times the median of the localization sigma, that is, localizations are
% eliminated if they do not have n_NN neighbors that are within Medianultiplier
% times the localization sigma median.
%
% Do not use on dSTORM data (set n_NN == 0).
%
% INPUTS:
%    SMD                Single Molecule Data structure
%    Verbose            verbosity flag [DEFAULT = false]
%    n_NN               minimum number of neighbors within
%                       MedianMultiplier*Prec_Median required to retain a
%                       localization [DEFAULT = 0]
%    MedianMultiplier   median multiplier for which localizations satisfying
%                       NND > MedianMultiplier*Prec_Median are removed
%                       [DEFAULT = 3]
%
% OUTPUT:
%    SMD                modified Single Molecule Data structure

% Created by
%    Mohamad Fazel and Michael J. Wester (5/25/2022)

if ~exist('Verbose', 'var')
   Verbose = false;
end

if ~exist('MedianMultiplier', 'var')
   MedianMultiplier = 3;
end

if ~exist('n_NN', 'var')
   n_NN = 0;
end

if n_NN > 0
   Prec_Median = median([SMD.X_SE; SMD.Y_SE]);

   % Original implementation.
%  [~,D]=knnsearch([SMD.X,SMD.Y],[SMD.X,SMD.Y],'K',length(SMD.X));
%  D(:,1)=[];
%  ID = D < 3*Prec_Median;
%  N = sum(ID,2);
%  Ind = N >= n_NN;

   % Less memory intensive and faster implementation.
   Prec_Median = median([SMD.X_SE; SMD.Y_SE]);
   % Find the number of nearest neighbors within MedianMultiplier*Prec_Median
   % for each localization.
   ID = rangesearch([SMD.X, SMD.Y], [SMD.X, SMD.Y], ...
                    MedianMultiplier*Prec_Median);
   % Number of neighbors, removing 1 which self counts the localization.
   N = cellfun(@numel, ID) - 1;
   Ind = N >= n_NN;
 
   % Only retain localizations that satisfy the above criteria.
   SMD = smi_core.SingleMoleculeData.isolateSubSMD(SMD, Ind);

   if Verbose >= 2
      fprintf('Neighbor filtered localizations kept = %d out of %d\n',...
              sum(Ind), numel(Ind));
   end

   if sum(Ind) == 0
      error('No localizations kept!');
   end
end

./MATLAB/+smi_helpers/@Filters/filterIntensity.m
function SMD = filterIntensity(SMD, Verbose, MeanMultiplier)
%filterIntensity: Filter localizations based on intensity.
%
% INPUTS:
%    SMD              Single Molecule Data structure
%    Verbose          verbosity flag [DEFAULT = false]
%    MeanMultiplier   mean multiplier for which localizations satisfying
%                     intensity > MeanMultiplier*mean(intensity) are removed
%                     [DEFAULT = Inf]
%
% OUTPUT:
%    SMD              modified Single Molecule Data structure

% Created by
%    David J. Schodt and Michael J. Wester (5/24/2022)

if ~exist('Verbose', 'var')
   Verbose = false;
end

if ~exist('MeanMultiplier', 'var')
   MeanMultiplier = Inf;
end

% Localizations for which intensity > MeanMultiplier*mean(intensity) are
% removed.
if ~isinf(MeanMultiplier)
   n_prefilter = numel(SMD.X);
   MaxPhotons = MeanMultiplier * mean(SMD.Photons);
   SMD = smi_core.SingleMoleculeData.isolateSubSMD(SMD, ...
                                                   SMD.Photons <= MaxPhotons);

   if Verbose >= 2
      fprintf('Intensity filtered localizations kept = %d out of %d\n', ...
              numel(SMD.X), n_prefilter);
   end

end

./MATLAB/+smi_helpers/@Filters/README.md
### +smi_helpers/@Filters

Filters operating on SMD (Single Molecule Data) structures used especially
for BaGoL analyses:

```
SR data -> remove localizations with negative coordinates
        -> intensity filter
        -> inflate standard errors
        -> frame connection, removing connections which involve only 1 frame
        -> NND filter --- Do not use on dSTORM data!
        -> BaGoL
```

---

static methods:
- **[filterNonNeg](filterNonNeg.m)**:
  filter out localizations with negative coordinates
- **[filterIntensity](filterIntensity.m)**:
  filter localizations based on intensity
- **[inflateSE](inflateSE.m)**:
  inflate standard errors
- **[filterFC](filterFC.m)**:
  filter out localizations representing fewer than nFC frame connections
- **[filterNN](filterNN.m)**:
  localizations are filtered based on the nearest neighbor distance

./MATLAB/+smi_helpers/@Filters/filterNonNeg.m
function SMD = filterNonNeg(SMD, Verbose)
%filterNonNeg: Filter out localizations with negative coordinates.
%
% INPUT:
%    SMD     Single Molecule Data structure
%    Verbose verbosity flag [DEFAULT = false]
%
% OUTPUT:
%    SMD   modified Single Molecule Data structure

% Created by
%    David J. Schodt and Michael J. Wester (5/24/2022)

if ~exist('Verbose', 'var')
   Verbose = false;
end

n_prefilter = numel(SMD.X);
SMD = smi_core.SingleMoleculeData.isolateSubSMD(SMD, SMD.X >= 0 & SMD.Y >= 0);

if Verbose >= 2
   fprintf('Nonnegative localizations kept = %d out of %d\n', ...
           numel(SMD.X), n_prefilter);
end

end

./MATLAB/+smi_helpers/@Filters/Filters.m
classdef Filters < handle

% Filters operating on SMD (Single Molecule Data) structures used especially
% for BaGoL analyses:
%
% SR data -> remove localizations with negative coordinates
%         -> intensity filter
%         -> inflate standard errors
%         -> frame connection, removing connections which involve only 1 frame
%         -> NND filter --- Do not use on dSTORM data!
%         -> BaGoL

methods(Static)

   SMD = filterNonNeg(SMD, Verbose)
   SMD = filterIntensity(SMD, Verbose, MeanMultiplier)
   SMD = inflateSE(SMD, Verbose, SEAdjust)
   SMD = filterFC(SMD, Verbose, nFC)
   SMD = filterNN(SMD, Verbose, n_NN, MedianMultiplier)

end % methods(Static)

end % classdef Filters

./MATLAB/+smi_helpers/@Filters/filterFC.m
function SMD = filterFC(SMD, Verbose, nFC)
%filterFC: Filter out localizations representing fewer than nFC frame connections.
%
% INPUTS:
%    SMD     Single Molecule Data structure
%    Verbose verbosity flag [DEFAULT = false]
%    nFC     minimum number of frame connected localizations representing a
%            single localization allowed [DEFAULT = 1]
%
% OUTPUT:
%    SMD     modified Single Molecule Data structure

% Created by
%    David J. Schodt and Michael J. Wester (5/24/2022)

if ~exist('Verbose', 'var')
   Verbose = false;
end

if ~exist('nFC', 'var')
   nFC = 1;
end

% Remove localizations representing fewer than nFC frame-connected
% localizations.
if nFC > 1
   n_prefilter = numel(SMD.X);
   SMD = smi_core.SingleMoleculeData.isolateSubSMD(SMD, SMD.NCombined >= nFC);

   if Verbose >= 2
      fprintf(['Frame connected filtered localizations kept = %d ', ...
               'out of %d\n'], numel(SMD.X), n_prefilter);
   end
end

end

./MATLAB/+smi_helpers/arrayMUX.m
function [Output] = arrayMUX(OutputOptions, Select)
%arrayMUX is a numel(OutputOptions)-bit multiplexer.
% This function is a multiplexer intended to generalize for most arrays.
% This function works by selecting one of the input 'OutputOptions' based
% on the input 'Select', which defines the index of 'OutputOptions' to be
% returned (with the index starting at 0 following multiplexer convention)
%
% EXAMPLE USAGE:
%   One usage of this is to output a char. array defining options for some
%   other input function, e.g., to change the Display parameter of
%   optimset based on a verbosity level:
%       optimset('fmincon', 'Display', ...
%       	smi_helpers.arrayMUX({'none', 'iter', 'final'}, Verbose)) 
%
% INPUTS:
%   OutputOptions: Array which will be indexed based on 'Select'.
%   Select: Signal which defines which of 'OutputOptions' will be returned,
%           with indexing starting at 0 to maintain multiplexer
%           conventions.
%
% OUTPUTS:
%   Output: The element of 'OutputOptions' selected by 'Select'.

% Created by:
%   David J. Schodt (Lidke Lab, 2021)


% Attempt to select the desired output. 
% NOTE: If a cell array is provided, I'll assume we want the contents of
%       the specified cell and not the cell itself.  This choice was made
%       based on my intended usage of this function at the time of writing.
if iscell(OutputOptions)
    Output = OutputOptions{Select + 1};
else
    Output = OutputOptions(Select + 1);
end


end
./MATLAB/+smi_helpers/README.md
### +smi_helpers

+smi_helpers is the namespace for helper functions and classes of ***smite***:
- [@Filters](@Filters/README.md):
  filters useful for BaGoL operating on SMDs
- [@ROITools](@ROITools/README.md):
  select ROIs from an image; save in a structure

---

functions:
- **[addBasicGUI](addBasicGUI.m)**:
  adds simple GUI controls based on the fields in 'ParamStruct'
- **[arrayMUX](arrayMUX.m)**:
  a multiplexer intended to generalize for most arrays
- **[compressToRange](compressToRange.m)**:
  compresses the 'IntegerArray' to a range of integers with no missing values
- **[convertTimeStringToNum](convertTimeStringToNum.m)**:
  converts a time string to a number
- **[filenameWindows2Unix](filenameWindows2Unix.m)**:
  converts the Windows filenameWindows to the Unix filename filenameUnix,
  optionally preceded by prefix
- **[findStartEndInds](findStartEndInds.m)**:
  finds the start and end indices of events in BoolArray
- **[gatherFullPathnames](gatherFullPathnames.m)**:
  combines or searches for directory paths and filenames matching a pattern
- **[genTimeString](genTimeString.m)**:
  creates a char array with the current time
- **[getDirectoryNames](getDirectoryNames.m)**:
  generates directory names matching a NameString
- **[getFileNames](getFileNames.m)**:
  creates a list of filenames in FileDir
- **[mkSMITETmpDir](mkSMITETmpDir.m)**:
  Create full pathnames and temporary directories for SMITE testing/examples
- **[nMODm](nMODm.m)**:
  modulus such that r is in [1, m] rather than [0, m - 1]
- **[padStruct](padStruct.m)**:
  pads the input 'Struct' with defaults in 'DefaultStruct'
- **[pairText](pairText.m)**:
  creates paired lists of text from two sets of text lists
- **[pairTimeStrings](pairTimeStrings.m)**:
  selects indices from the input 'TimeStringOptions' that are closest in time
  to the timestrings provided in 'TimeStrings'
- **[removeBorder](removeBorder.m)**:
  removes border pixels from the input image
- **[requiredToolboxes](requiredToolboxes.m)**:
  print out required toolboxes for each directory in the SMITE directory
  structure
- **[selectFiles](selectFiles.m)**:
  select a list of files
- **[subdivideImage](subdivideImage.m)**:
  divvys up an image into sub-ROIs of the image
- **[subdivideSMD](subdivideSMD.m)**:
  divvys up an SMD into sub-ROIs
- **[triangle_threshold](triangle_threshold.m)**:
  use the triangle method to find a threshold
- **[writeMPEG4](writeMPEG4.m)**:
  writes a .mp4 image constructed from the RGB image input on all OS

./MATLAB/+smi_helpers/selectFiles.m
function [pathname, files] = selectFiles(startdatadir, txt, pattern)
% Select a list of files.
%
% INPUTS:
%    startdatadir   directory to start looking from
%    txt            [OPTIONAL] a text message to display on the GUI
%    pattern        [OPTIONAL] default pattern for files chosen individually
%
% OUTPUTS:
%    pathname       directory path where files reside
%    files          cell array of filenames of selected files

% Created by
%    Samantha Schwartz (originally); modified by Michael Wester (2021)

   if ~exist('txt', 'var')
      txt = '';
   end
   if ~exist('pattern', 'var') | isempty(pattern)
      pattern = '*.mat';
   end

   [files, pathname] = uigetfile(fullfile(startdatadir, pattern), txt, ...
                                 'Multiselect', 'on');

   % The pathname is 0 when the user aborts the selection.
   if ~exist('pathname', 'var') | pathname == 0
      error('Directory pathname is empty!');
   end

   % Just make sure files is a cell (in case only one file was selected).
   if ~iscell(files)
      files = {files};
   end

end

./MATLAB/+smi_helpers/triangle_threshold.m
function [Cutoff] = triangle_threshold(Data,Percentile,ShowFig)
%triangle_threshold Use the triangle method to find a threshold
%   Implements method by:
%   Zack GW, Rogers WE, Latt SA (1977), 
%   "Automatic measurement of sister chromatid exchange frequency", 
%   J. Histochem. Cytochem. 25 (7): 74153
%
% INPUTS
%   Data: Array of any size
%   Percentile: Remove Percentile of extremum (1e-4)
%   ShowFig:    Show the triangle figure (false)
% OUTPUT
%   Cutoff:     Threhold value

if nargin <2
    Percentile=1e-4;
end

if nargin <3
    ShowFig=false;
end

Data=Data(:);

% Remove extremum
MinV = prctile(Data,Percentile/2);
MaxV = prctile(Data,100-Percentile/2);
Mask = (Data>MinV) & (Data<MaxV);
Data=Data(Mask);

% calculate histogram
[N,EDGES] = histcounts(Data,'BinMethod','fd');
DX=EDGES(2)-EDGES(1);
BinCenters = EDGES(1:end-1)+DX/2;


%find max
ID = find(N==max(N),true,'first');

%find if tail is left or right
if ID>length(N)/2 %peak on right, flip!
    N=fliplr(N);
    BinCenters=fliplr(BinCenters);
end

X=1:length(N);
N=N./max(N)*max(X); % for visualization 

%the line
XMax = find(N==max(N),true,'first');
XMin = find(N==min(N),true,'last');
YMax = N(XMax);
YMin = N(XMin);

Slope = (YMax-YMin)/(XMax-XMin);
Offset = YMax - XMax*Slope;
myline=@(X) Slope*X+Offset;

% distance to line is always proportional to height
h = 0;
Cutoff=0;
for x=X
    testh = myline(x)-N(x);
    if testh>h && x>XMax
        h=testh;
        Cutoff = BinCenters(x);
        IDCutoff=x;
    end
end

if ShowFig
    figure
    bar(X,N,1.0)
    hold on
    plot(X,myline(X),'r')
    Slope2 = tan(pi/2-atan(-Slope)); 
    plot([IDCutoff,max(X)],[N(IDCutoff),(max(X)-IDCutoff)*Slope2+N(IDCutoff)],'r')
    xlabel('Bin ID')
    ylabel('Normalized Counts')
    axis equal
    set(gca,'XTick',X)
    set(gca,'XTickLabel',BinCenters)
end

end


./MATLAB/+smi_helpers/pairText.m
function [PairedList1, PairedList2] = pairText(List1, List2, ExcludeText)
%pairText creates paired lists of text from two sets of text lists.
% This method will remove the 'ExcludeText' from each char/string array in
% 'List1' and 'List2' and then attempt to match the two lists based on the
% remaining char/strings.
%
% EXAMPLE:
%   List1 = {'file1_ch1.mat', 'file3_ch1.mat', 'file2_ch1.mat'};
%   List2 = {'file2_ch2.mat', 'file1_ch2.mat', 'file3_ch2.mat'};
%   [PairedList1, PairedList2] = smi_helpers.pairText(List1, List2, ...
%                                {'ch1', 'ch2'});
%
% INPUTS:
%   List1: Cell array of text. (cell array of char)
%   List2: Cell array of text.  Entries in 'List2' will (ideally) be
%          matched one-to-one with files in 'List1' after erasing the
%          sub-strings contained in 'ExcludeText'. (cell array of char)
%   ExcludeText: Sub-strings which will be erased from 'List1' and 'List2'
%                before attempting to match those lists. 
%                (char/cell array of char)
%
% OUTPUTS:
%   PairedList1: Text entries from 'List1' which were paired to entries in
%                'List2'. (cell array of char)
%   PairedList2: Text entries from 'List2' which were paired to entries in
%                'List1'.  The indexing of 'PairedList1' and 'PairedList2'
%                should match, so that PairedList1{ii} is matched to the
%                text entry in PairedList2{ii}. (cell array of char)

% Created by:
%   David J. Schodt (Lidke Lab, 2021)


% Remove the 'ExcludeText' from each of the lists.
List1Erase = erase(List1, ExcludeText);
List2Erase = erase(List2, ExcludeText);

% Loop through the lists and search for matching strings in the opposite
% list.
NList1 = numel(List1);
NList2 = numel(List2);
PairedList1 = {};
PairedList2 = {};
for ii = 1:NList1
    for jj = 1:NList2
        if strcmp(List1Erase{ii}, List2Erase{jj})
            PairedList1 = [PairedList1; List1{ii}];
            PairedList2 = [PairedList2; List2{jj}];
        end
    end
end

% Ensure output arrays match the "shape" of the input arrays.
if isrow(List1)
    PairedList1 = PairedList1.';
end
if isrow(List2)
    PairedList2 = PairedList2.';
end


end
./MATLAB/+smi_helpers/genTimeString.m
function [TimeString] = genTimeString(Delimiter, MinFieldWidth)
%genTimeString creates a char array with the current time.
% This method creates a char array which contains the current time as
% determined by clock().
%
% INPUTS:
%   Delimiter: Delimiter between the time values in the output 'TimeString'
%              (e.g., the underscore in '2021_2_17_19_3_26')
%              (char array)(Default = '_')
%   MinFieldWidth: Minimum field width.  For example, if MinFieldWidth = 2,
%                  the output would look like '2021_02_17_19_03_26',
%                  whereas MinFieldWidth = 1 would result in 
%                  '2021_2_17_19_3_26'. (Default = 2)
%
% OUTPUTS:
%   TimeString: char array containing the current time. (char array)

% Created by:
%   David J. Schodt (Lidke Lab, 2021)


% Set defaults if needed.
if (~exist('Delimiter', 'var') || isempty(Delimiter))
    Delimiter = '_';
end
if (~exist('MinFieldWidth', 'var') || isempty(MinFieldWidth))
    MinFieldWidth = 2;
end

% Create the time string.
CurrentTime = round(clock());
TimeString = sprintf(['%0', num2str(MinFieldWidth), 'i', Delimiter], ...
    CurrentTime);
TimeString = TimeString(1:end-1);
    

end
./MATLAB/+smi_helpers/getDirectoryNames.m
function DirNames = getDirectoryNames(BaseDir, NameString)
%getDirectoryNames generates directory names matching a NameString.
% This function generates a cell array of directory names matching 
% NameString (which can contain a wild card '*') within a directory
% BaseDir.
%
% INPUTS:
%   BaseDir: Character array/string containing the parent directory which
%            contains the directories of interest.
%   NameString: Character array/string describing the names of 
%               sub-directories of interest. (Default = '*')
%
% OUTPUTS:
%   DirNames: Cell array of directory names matching the NameString.

% Created by:
%   David J. Schodt (Lidke Lab, 2018)


% Set defaults if needed.
if (~exist('NameString', 'var') || isempty(NameString))
    NameString = '*';
end

% Create a list of the contents within BaseDir.
DirContents = dir(fullfile(BaseDir, NameString));

% Grab the boolean array from DirContents which tells us which of the
% structure of contents are actually directories.
SubDirBoolean = [DirContents.isdir];

% Create a boolean describing the "valid" directories (i.e., not the . and
% .. current and parent directories).
ValidDirBoolean = ~(strcmp({DirContents.name}, '.') ...
    | strcmp({DirContents.name}, '..'));

% Create a cell array containing the names of the sub-directories.
DirNames = {DirContents(SubDirBoolean & ValidDirBoolean).name}.';


end
./MATLAB/+smi_helpers/compressToRange.m
function [Range] = compressToRange(IntegerArray)
%compressToRange compresses the 'IntegerArray' to a range of integers.
% This function compresses an array of integers into a range of integers
% with no missing values.

% EXAMPLES:
%   Range = smi_helpers.compressToRange([2; 4; 6; 6; 7; 10])
%       -> Range = [1; 2; 3; 3; 4; 5]
%   Range = smi_helpers.compressToRange([1; 5; 8; 8; 11; 3])
%       -> Range = [1; 3; 4; 4; 5; 2]

% Created by:
%   David J. Schodt (Lidke Lab, 2021)


% Ensure Range consists of the set of integers 1:numel(IntegerArray)
% without skipping any integers.
[IntsSorted, SortIndices] = sort(IntegerArray);
IntList = unique(IntsSorted);
NPerInt = groupcounts(IntsSorted);
NCumulative = [0; cumsum(NPerInt)];
NInts = numel(IntList);
for nn = 1:NInts
    % Set all entries with IntegerArray==nn equal to nn.
    IndexArray = (1:NPerInt(nn)) + NCumulative(nn);
    IntsSorted(IndexArray) = nn;
end
Range = NaN(size(IntegerArray));
Range(SortIndices) = IntsSorted;


end
./MATLAB/+smi_helpers/nMODm.m
function r = nMODm(n, m)
% Modulus such that r is in [1, m] rather than [0, m - 1].
%
% Input:
%    n   integer
%    m   integer modulus
% Output:
%    r   remainder

   r = mod(n, m);
   if r <= 0
      r = r + m;
   end

end

./MATLAB/+smi_helpers/padStruct.m
function [Struct] = padStruct(Struct, DefaultStruct)
%padStruct pads the input 'Struct' with defaults in 'DefaultStruct'.
% This method merges the two structures 'Struct' and 'DefaultStruct', with
% values in 'Struct' taking precedent unless not available.
%
% INPUTS:
%   Struct: Structure array which is to be padded.
%   DefaultStruct: Structure array of "default" fields that will be
%                  added to 'Struct' unless already present in 'Struct', in
%                  which case the "default" values are ignored.
%
% OUTPUTS:
%   Struct: Input 'Struct' padded with values from 'DefaultStruct'.

% Created by:
%   David J. Schodt (Lidke Lab, 2021)


% Loop through the fields of the default fields and add them to
% 'Struct' as needed.
DefaultFieldNames = fieldnames(DefaultStruct);
InputFieldNames = fieldnames(Struct);
for pp = 1:numel(DefaultFieldNames)
    if ~any(ismember(DefaultFieldNames{pp}, InputFieldNames))
        % The field DefaultParameterNames{pp} is not present in the
        % Struct structure and so the default must be added.
        Struct.(DefaultFieldNames{pp}) = ...
            DefaultStruct.(DefaultFieldNames{pp});
    elseif iscell(DefaultStruct.(DefaultFieldNames{pp}))
        % Type casting can't be done on cells as above, so we'll just place
        % whatever is present in a cell array.
        if ~iscell(Struct.(DefaultFieldNames{pp}))
            Struct.(DefaultFieldNames{pp}) = ...
                {Struct.(DefaultFieldNames{pp})};
        end
    end
end


end
./MATLAB/+smi_helpers/findStartEndInds.m
function [StartInds, EndInds] = findStartEndInds(BoolArray)
%findStartEndInds finds the start and end indices of events in BoolArray.
% This function finds the starting and ending indices of each series of
% trues in a 1D boolean array.  For example,
% findStartEndInds([0; 1; 1; 1; 0; 0; 1; 0; 1; 1]) should return
% StartInds = [2; 7; 9] and EndInds = [4; 7; 10].
%
% INPUTS:
%   BoolArray: 1D array of logical values.
%
% OUTPUTS:
%   StartInds: Array of starting indices for series of trues.
%   EndInds: Array of ending indices corresponding to the start indices in
%            'StartInds'.

% Created by:
%   David J. Schodt (Lidke Lab, 2022)


% Find the starting indices of each series of trues, ensuring that we
% capture events starting with the first index of BoolArray.
StartInds = unique([...
    find(BoolArray, 1, 'first'); ...
    find(diff(BoolArray)==1) + 1]);

% Find the end indices for each of StartInds. 
EndInds = find(diff(BoolArray)==-1);
if (numel(StartInds) ~= numel(EndInds))
    % This can be reached for a series that ends with 'true' on the last
    % index of BoolArray.
    EndInds = [EndInds; numel(BoolArray)];
end


end
./MATLAB/+smi_cluster/@StatisticsClustering/StatisticsClustering.m
classdef StatisticsClustering < handle

% StatisticsClustering contains statistics and plots for detecting clustering.
% Data can be 2D or 3D.
%
% StatisticsClustering class written by Michael Wester (10/17/2017)
% <wester@math.unm.edu>
% The New Mexico Center for the Spatiotemporal Modeling of Cell Signaling
% University of New Mexico Health Sciences Center
% Albuquerque, New Mexico, USA   87131
% Copyright (c) 2018 by Michael J. Wester and Keith A. Lidke

% The main routines here are:
%    hopkins              hopkins_ROIcombined           Hopkins' statistic
%    ripley               ripley_ROIcombined            Ripley's statistics
%    bivariateRipley      bivariateRipley_ROIcombined   Bivariate Ripley's
%    pairwiseDist                                       Pairwise distances
%    pairwiseMutualDist                                 Piarwise mutual dist.
%    plotCombined
%       Frequency, CDF, PDF, plotSpread, box and bar plots of an array.
%
% The _ROIcombined plots are averaged results over a series of ROIs and
% expect n_ROIs and a RoI structure (see smi_helpers.ROITools).
%
% Note that pairwiseMutualDist and bivariateRipley are expecting either a
% single argument RoI structure or two SMD structures or two Nx2 (or Nx3)
% arrays, while the other statistical functions are expecting an RoI
% structure or one SMD structure or one array.
%
% plotCombined is a handy way to plot the same data in several different ways
% as indicated by the user.

% =============================================================================
properties

   % If ROI is provided, it will be used, otherwise the xy_size will be
   % calculated using the (x_min, x_max, y_min, y_max) computed from the data
   % as
   %    xy_size = min(x_max - x_min, y_max - y_min)
   ROI = [];   % [x_min, x_max, x_max, y_max]   % nm

   Font_props = {'FontSize', 15, 'FontWeight', 'bold'};
   Line_props = {'LineWidth', 3};
   Fig_ext = 'png';
   BaseName = '';         % Descriptive name for the result files
   ResultsDir = '.';      % Directory to store results
   Xlim = [];             % x-axis limits if defined
   Ylim = [];             % y-axis limits if defined

   % Properties used by plotCombined.
   PlotDo = 'fnpcCsSxb';  % Plots to do for plotCombined (fnpcCsSxb)
   LinLog = 'plot';       % Plot type for plotCombined CDF2 plots:
                          %   'plot', 'semilogx', 'semilogy', 'loglog'
   LegendTitle = '';      % Optional legend title
   ShowMM = 1;            % Red mean and green median (2 only mean, 3
                          %    only median) for PlotSpread plots
   CSV = false;           % If true, produce a CSV file of the data

   % Properties below are used by various routines.
   Rate          =  20;   % Sampling rate for statistical functions
   Dendro_cutoff =  50;   % Cluster cutoff for Dendrogram analysis (nm)
   Ripley_cutoff = 200;   % Ripley distance cutoff (nm)
   Confidence    = 2.576; % Bivariate Ripley confidence interval
      % 95% confidence interval: Confidence = 1.96
      % 99% confidence interval: Confidence = 2.576
   Nsims         = 20;    % Simulations to run for bivariateRipley,
                          % pairwiseDist, pairwiseMutualDist

   PixelSize = 100;       % Camera pixel size (nm)

   Verbose = 1;           % verbosity level

end % properties
% =============================================================================

% =============================================================================
methods

% Constructor.  SMF is an optional argument.
function obj = StatisticsClustering(SMF)

   if ~exist('SMF', 'var')
      SMF = smi_core.SingleMoleculeFitting();
   end
   obj.ResultsDir = SMF.Data.ResultsDir;
   obj.PixelSize  = SMF.Data.PixelSize;

end

end % methods
% =============================================================================

% =============================================================================
methods(Static)

   [X,V]=histogram(A,ab,n)
   H = hopkinstat(P,A,B,mm)
   H = hopkinstat3(P,A,B,C,mm)
   success = unitTest()

end % methods(Static)
% =============================================================================

end % classdef StatisticsClustering

./MATLAB/+smi_cluster/@StatisticsClustering/unitTest.m
% Test calling StatisticsClustering routines.
function success = unitTest()

success = 0;

SaveDir = smi_helpers.mkSMITETmpDir('unitTest', 'StatisticsClustering');

% Examples of how to call StatisticsClustering routines.

% --- 2D ---

SMF = smi_core.SingleMoleculeFitting();
SMF.Data.ResultsDir = SaveDir;
SC = smi_cluster.StatisticsClustering(SMF);
SC.BaseName = 'twoD';
SC.Verbose = 2;
ROI = [0, 1000, 0, 1000];   % nm

if ~exist(SMF.Data.ResultsDir, 'dir')
   mkdir(SMF.Data.ResultsDir);
end

SIM = smi_sim.SimSMLM();
kmer = 6;                % Hextets
radius_kTet = 25;        % Radius of the k-tets (nm)
PixSize = 100;           % nm in a pixel
receptorDensity = 1;     % Receptors/um^2
SIM.Rho = receptorDensity / (1000 / PixSize)^2;
SIM.simkTets(kmer, radius_kTet);

XY = 1000 * rand(2000, 2);
clear RoI

% Make RoI structure.
RoI{1}.X{1} = XY(1:2:end, 1);
RoI{1}.Y{1} = XY(2:2:end, 2);
RoI{1}.X{2} = SIM.SMD_Model.X;
RoI{1}.Y{2} = SIM.SMD_Model.Y;
RoI{1}.ROI  = ROI;

% Make SMD structures.
SMD1.X = RoI{1}.X{1};
SMD1.Y = RoI{1}.Y{1};
SMD2 = SIM.SMD_Model;
SMD2.X = SMD2.X - min(SMD2.X);
SMD2.Y = SMD2.Y - min(SMD2.Y);
SC.ROI = ROI;

fprintf('2D examples:\n\n');

% Analyze a single label dataset.
particle_types = {'A'};

fprintf('pairwiseDist ...\n');
SC.pairwiseDist(particle_types, SMD1);

% hopkins can be called this way or as further below.
%fprintf('hopkins ...\n');
%SC.hopkins(particle_types, SMD1);

fprintf('ripley ...\n');
SC.ripley(particle_types, SMD1);

% Analyze two datasets containing different labels.
particle_types = {'A', 'B'};

% Note that this makes a separate calculation for each label provided in RoI.
fprintf('hopkins ...\n');
SC.hopkins(particle_types, RoI);

% pairwiseMutualDist and bivariateRipley operate on pairs of labels.
fprintf('pairwiseMutualDist ...\n');
SC.pairwiseMutualDist(particle_types, SMD1, SMD2);

% Demonstrate alternative ways to call these routines.  This methodology
% applies to all StatisticsClustering main routines.  Note that
% pairwiseMutualDist and bivariateRipley are expecting either a single
% argument RoI structure (see smi_helpers.ROITools) or two SMD structures or
% two Nx2 (or Nx3) arrays, while the other functions are expecting an RoI
% structure or one SMD structure or one array.
fprintf('bivariateRipley ...\n');
SC.bivariateRipley(particle_types, SMD1, SMD2);
SC.BaseName = 'twoD_array';
SC.bivariateRipley(particle_types, [SMD1.X, SMD1.Y], [SMD2.X, SMD2.Y]);
SC.BaseName = 'twoD_RoI';
SC.ROI = [];
SC.bivariateRipley(particle_types, RoI);

SC.BaseName = 'twoD';
SC.ROI = ROI;

% ROIcombined series.  Here, we only have one ROI (RoI{1}).
fprintf('hopkins_ROIcombined ...\n');
SC.hopkins_ROIcombined(1, RoI);

fprintf('ripley_ROIcombined ...\n');
SC.ripley_ROIcombined(1, RoI);

fprintf('bivariateRipley_ROIcombined ...\n');
SC.bivariateRipley_ROIcombined(particle_types, 1, RoI);

fprintf('Done 2D.\n');

% --- 3D ---

SMF = smi_core.SingleMoleculeFitting();
SMF.Data.ResultsDir = SaveDir;
SC = smi_cluster.StatisticsClustering(SMF);
SC.BaseName = 'threeD';
ROI = [0, 1000, 0, 1000, 0, 1000];   % nm

if ~exist(SMF.Data.ResultsDir, 'dir')
   mkdir(SMF.Data.ResultsDir);
end

XYZ = 1000 * rand(2000, 3);

% Make RoI structure.
clear RoI
RoI{1}.X{1} = XYZ(1:2:end, 1);
RoI{1}.Y{1} = XYZ(1:2:end, 2);
RoI{1}.Z{1} = XYZ(1:2:end, 3);
RoI{1}.X{2} = XYZ(2:2:end, 1);
RoI{1}.Y{2} = XYZ(2:2:end, 2);
RoI{1}.Z{2} = XYZ(2:2:end, 3);
RoI{1}.ROI = ROI;

% Make SMD structures.
SMD1.X = RoI{1}.X{1};
SMD1.Y = RoI{1}.Y{1};
SMD1.Z = RoI{1}.Z{1};
SMD2.X = RoI{1}.X{2};
SMD2.Y = RoI{1}.Y{2};
SMD2.Z = RoI{1}.Z{2};
SC.ROI = ROI;

fprintf('3D examples:\n\n');

particle_types = {'A'};

fprintf('PairwiseDist ...\n');
SC.pairwiseDist(particle_types, SMD1);

fprintf('Hopkins ...\n');
SC.hopkins(particle_types, SMD1);

fprintf('Ripley ...\n');
SC.ripley(particle_types, SMD1);

particle_types = {'A', 'B'};

fprintf('PairwiseMutualDist ...\n');
SC.pairwiseMutualDist(particle_types, SMD1, SMD2);

fprintf('BivariateRipley ...\n');
SC.bivariateRipley(particle_types, SMD1, SMD2);

fprintf('Done 3D.\n');

fprintf('All results in %s\n', SMF.Data.ResultsDir);

success = 1;

end

./MATLAB/+smi_cluster/@StatisticsClustering/hopkinstat3.m
function H = hopkinstat3(P,A,B,C,mm)
% Compute a Hopkin's statistic for the 3D particles P.
% Written by Michael Wester and Stanly Steinberg in 2008.
% The particle region is [0,A] x [0,B] x [0,C].
% m is the number of tests points.
% n is the number of particles.
%n = length(P);
n = numel(P) / 3;
m = min(mm, n);
% Create the indices of m test particles.
index = [0,m+1];
while ( (length(index) < m) | (index(1) < 1) | (index(end) > n) )
   index = unique(round(1/2+n*rand(m,1)));
end
T = P(index,:);
% Create m test points
S = rand(m,3)*diag([A,B,C]);
% Compute the minimum distance.
U = ones(1,m)*sqrt(A^2+B^2+C^2);
% W = ones(1,m)*sqrt(A^2+B^2+C^2);
W = U;
for k = 1:m
   for i = 1:n
      dist = sqrt((S(k,1)-P(i,1))^2 + (S(k,2)-P(i,2))^2 + (S(k,3)-P(i,3))^2);
      if dist > 0 
         U(k) = min(U(k), dist);
      end

      dist = sqrt((T(k,1)-P(i,1))^2 + (T(k,2)-P(i,2))^2 + (T(k,3)-P(i,3))^2);
      if dist > 0 
         W(k) = min(W(k), dist);
      end
   end
end
H = (sum(U.^3)/(sum(U.^3)+sum(W.^3)));

end

./MATLAB/+smi_cluster/@StatisticsClustering/pairwiseMutualDist.m
function results = pairwiseMutualDist(obj, particle_types, SMD1, SMD2)
% Plot pairwise distances and CDFs between two populations of particles.
%
% INPUTS:
%    obj             various properties used by the algorithms
%       Font_props      [{'FontSize', 15, 'FontWeight', 'bold'}]
%       Line_props      [{'LineWidth', 3}]
%       Fig_ext         figure extension
%       ResultsDir      directory to store results
%       BaseName        name to identify saved plots, which will have various
%                       descriptive suffixes attached
%       Nsims           number of random simulations to perform
%    particle_types   cell array of particle types (names)
%                     e.g., particle_types = {'5', '10'};
%    SMD1 and SMD2    (x, y) coordinates of the dataset (nm) in the format
%                     (1) SMD structure: SMD1.X, SMD1.Y, SMD2.X and SMD2.Y,
%                     (2) N x 2 array of coordinates,
%                     (3) RoI struct with fields (nm):
%       ROI               [x_min, x_max, y_min, y_max, {z_min, z_max}]] of ROI
%       X, Y{, Z}         (x, y, z) coordinates of points inside where X, Y, Z
%                         are of the form {[n1 x 1]}
%
% OUTPUTS:
%    results          results structure:
%       bins             number of histogram bins
%       sims             number of random simulations performed
%       x, y             cell array of point coordinates for random simulations
%       xx               
%       f                

% Created by
%    Michael J. Wester (2021)

   base_name = obj.BaseName;
   base_text = regexprep(base_name, '_', '\\_');

   % Dimension (2D or 3D)
   dim = 2;
   if ~exist('SMD2', 'var')
      if iscell(SMD1) && ismatrix(SMD1) && isfield(SMD1{1}, 'ROI')
         RoI = SMD1;
         if isempty(obj.ROI)
            obj.ROI = RoI{1}.ROI;
         end
         if isfield(RoI{1}, 'Z') && numel(RoI{1}.Z) > 0
            dim = 3;
         end
      else
         error('Unrecognized format for SMD1!');
      end
   elseif ismatrix(SMD1) && ismatrix(SMD2) ...
      && size(SMD1, 2) > 1 && size(SMD2, 2) > 1
      RoI{1}.X = {SMD1(:, 1), SMD2(:, 1)};
      RoI{1}.Y = {SMD1(:, 2), SMD2(:, 2)};
      if size(SMD1, 2) == 3 && size(SMD2, 2) == 3
         dim == 3;
         RoI{1}.Z = {SMD1(:, 3), SMD2(:, 3)};
      end
   elseif isstruct(SMD1) && isstruct(SMD2)
      RoI{1}.X = {SMD1.X, SMD2.X};
      RoI{1}.Y = {SMD1.Y, SMD2.Y};
      if isfield(SMD1, 'Z') && isfield(SMD2, 'Z') ...
         && numel(SMD1.Z) > 0 && numel(SMD2.Z) > 0
         dim == 3;
         RoI{1}.Z = {SMD1.Z, SMD2.Z};
      end
   else
      error('Unrecognized format for SMD1/SMD2!');
   end

   bins = 100;
   sims = obj.Nsims;
   %sims = 20;

   if ~isempty(obj.Fig_ext)
      figure('Visible', 'off');
   else
      figure;
   end
   axes(obj.Font_props{:})
   hold on

   if length(particle_types) ~= 2
      error('Mutual distances can only be computed between 2 particle types!');
   end

% P   cell array of point coordinates (n x 2 per cell element)
%     e.g., P{1} = [x1, y1];   P{2} = [x2, y2];
%     where P{1} is (n1 x 2), P{2} is (n2 x 2)

   if dim == 2
      P{1} = [RoI{1}.X{1}, RoI{1}.Y{1}];
      P{2} = [RoI{1}.X{2}, RoI{1}.Y{2}];
   else
      P{1} = [RoI{1}.X{1}, RoI{1}.Y{1}, RoI{1}.Z{1}];
      P{2} = [RoI{1}.X{2}, RoI{1}.Y{2}, RoI{1}.Z{2}];
   end

   X = P{1};
   Y = P{2};
   D = pdist2(X, Y);
   D = D(:);
%  M = mean(D);
%  S = std(D);

   % Establish the positions of the bin centers (x) based on a normal random
   % distribution that inherits its characteristics from the coordinates in
   % X given the specified number of bins (also, see comment below).
%  Xr = M + S*randn(size(X));
%  Yr = M + S*randn(size(Y));
%  Dr = pdist2(Xr, Yr);
%  [~, x] = hist(Dr, bins);

%  y = hist(D, x);
   [y, x] = hist(D, bins);
   plot(x, y, 'k-', obj.Line_props{:});

   % Create a random distribution with the same characteristics as X:
   % based on the same number of points, mean, standard deviation.  Average
   % over the specified number of simulations (sims).
%  YR = 0;
%  for i = 1 : sims
%     Xr = M + S*randn(size(X));
%     Dr = pdist(Xr);
%     yr = hist(Dr, x);
%     YR = YR + yr;
%  end
%  yr = YR / sims;
%  plot(x, yr, 'r--', obj.Line_props{:});

%  legend('data', 'random', 'Location', 'NorthEast');
   title(['Pairwise Distance PDF for ', base_text, '\_', ...
          particle_types{1}, ',', particle_types{2}]);
   xlabel('distance (nm)');
   ylabel('frequency');
   hold off
   name = fullfile(obj.ResultsDir, [base_name, '_', particle_types{1}, ...
                                    ',', particle_types{2},            ...
                                    '_pairwisePDF2']);
   if ~isempty(obj.Fig_ext)
      print(['-d', obj.Fig_ext], name);
   else
      saveas(gcf, name);
      delete(gcf);
   end

   if ~isempty(obj.Fig_ext)
      figure('Visible', 'off');
   else
      figure;
   end
   axes(obj.Font_props{:})
   hold on

   [f, xx] = ecdf(sort(D));
   plot(xx, f, 'k-', obj.Line_props{:});

   %f = cumsum(1 : numel(D));
   %f = f / f(end);
   %xx = sort(D);
   %plot(xx, f, 'b-', obj.Line_props{:});

%  [fr, xxr] = ecdf(sort(Dr));
%  plot(xxr, fr, 'r--', obj.Line_props{:});

   %fr = cumsum(1 : numel(Dr));
   %fr = fr / fr(end);
   %xxr = sort(Dr);
   %plot(xxr, fr, 'm--', obj.Line_props{:});

%  legend('data', 'random', 'Location', 'SouthEast');
   title(['Pairwise Distance CDF for ', base_text, '\_', ...
          particle_types{1}, ',', particle_types{2}]);
   xlabel('distance (nm)');
   ylabel('frequency');
   hold off
   name = fullfile(obj.ResultsDir, [base_name, '_', particle_types{1}, ...
                                    ',', particle_types{2},            ...
                                    '_pairwiseCDF2']);
   if ~isempty(obj.Fig_ext)
      print(['-d', obj.Fig_ext], name);
   else
      saveas(gcf, name);
      delete(gcf);
   end

results.bins = bins;
results.sims = sims;
results.x = x;
results.y = y;
results.xx = xx;
results.f = f;

end

./MATLAB/+smi_cluster/@StatisticsClustering/plotCombined.m
function P = plotCombined(obj, y, bin_width, x_label, ...
                          legend_labels, x_abbrev, colors, line_type)
% Combined frequency, CDF, PDF, plotSpread, box and bar plots of the arrays y.
%
% INPUTS:
%    obj         various properties used by the algorithms
%       Font_props      [{'FontSize', 15, 'FontWeight', 'bold'}]
%       Line_props      [{'LineWidth', 3}]
%       Fig_ext         figure extension
%       BaseName        name to identify saved plots, which will have various
%                       descriptive suffixes attached 
%       PlotDo          ['fnpcCsSxb'] plots to do:
%                                   'f'   frequency
%                                   'n'   normalized
%                                   'p'   PDF
%                                   'c'   CDF
%                                   'C'   CDF (alternative)
%                                   's'   PlotSpread
%                                   'S'   PlotSpread (bars for mean & median)
%                                   'x'   box
%                                   'b'   bar
%       ShowMM          [1]      red mean and green median (2 only mean, 3 only
%                                median) for PlotSpread plots
%       LinLog          ['plot'] options for CDF2 plots are:
%                                'plot', 'semilogx', 'semilogy', 'loglog'
%       ResultsDir      directory to store results
%       Xlim            []       x-axis limits if defined
%       Ylim            []       y-axis limits if defined
%       LegendTitle     ['']     legend title if specified
%       CSV             [false]  produce a CSV file of the data if true
%    y           cell array of data arrays (need not be the same length)
%    bin_width   bin width for histogram plots
%    x_label     text for the x-label
%    legend_labels   {legend_label1, legend_label2, ...}
%    x_abbrev    abbreviated identifier for plots used in constructing the
%                filename
%    colors      [OPTIONAL] colors for plots     (CDF alternative)
%    line_type   [OPTIONAL] line types for plots (CDF alternative)
%
% OUTPUTS:
%    P           P-value for KS test on y{i} and y{j}
%
% REQUIRES:
%    PlotSpread

% Created by
%    Michael Wester (2019)

   base_name = obj.BaseName;

   n = numel(y);

   if ~exist('line_type', 'var')
      line_type = cell(1, n);
      for i = 1 : n
         line_type{i} = '-';
      end
   end
   if ~exist('colors', 'var')
      colors = ['b', 'r', 'g', 'k', 'c', 'm'];
      if n > 6
         colors = [colors, colors];
         line_type = {'-', '-', '-', '-', '-', '-', ...
                      '--', '--', '--', '--', '--', '--'};
      end
   end

   base_text = regexprep(base_name, '_', '\\_');
   x_text = regexprep(x_label, '_', '\\_');
   legend_text = {};
   for i = 1 : numel(legend_labels)
      legend_text{i} = regexprep(legend_labels{i}, '_', '\\_');
   end

   if obj.CSV
      produceCSVfile(y, obj.ResultsDir, base_name, x_label, legend_labels, ...
                        x_abbrev);
   end

   % frequency
   if any(obj.PlotDo == 'f')
      figure;
      %axes(obj.Font_props{:})
      hold on
      for i = 1 : n
         h(i) = histogram(y{i});
         if ~isempty(bin_width)
            h(i).BinWidth = bin_width;
         end
      end
      if ~isempty(obj.Xlim)
         xlim(obj.Xlim);
      end
      title(base_text);
      xlabel(x_text);
      ylabel('frequency');
      if ~isempty(legend_text)
         lgd = legend(legend_text, 'Location', 'best');
         if ~isempty(obj.LegendTitle)
            title(lgd, obj.LegendTitle);
         end
      end
      hold off
      name = fullfile(obj.ResultsDir, [base_name, x_abbrev, '_freq']);
      if ~isempty(obj.Fig_ext)
         saveas(gcf, name, obj.Fig_ext)
      end
      saveas(gcf, name, 'fig');
      close
   end

   % normalized
   if any(obj.PlotDo == 'n')
      figure;
      %axes(obj.Font_props{:})
      hold on
      hedge_min = 0;
      hedge_max = -1;
      for i = 1 : n
         [hcounts, hedges] = histcounts(y{i});
         if hedges(end) > hedge_max;
            hedge_min = hedges(1);
            hedge_max = hedges(end);
            delta = hedges(2) - hedges(1);
         end
      end
      edges = hedge_min : delta : hedge_max;

      for i = 1 : n
         [hcounts, hedges] = histcounts(y{i}, edges);
         %if ~isempty(bin_width)
         %   h(i).BinWidth = bin_width;
         %end
         if max(hcounts) == 0
            counts = hcounts;
         else
            counts = hcounts / max(hcounts);
         end
         h = histogram('BinEdges', edges, 'BinCounts', counts);
      end
      if ~isempty(obj.Xlim)
         xlim(obj.Xlim);
      end
      title(base_text);
      xlabel(x_text);
      ylabel('normalized frequency');
      if ~isempty(legend_text)
         lgd = legend(legend_text, 'Location', 'best');
         if ~isempty(obj.LegendTitle)
            title(lgd, obj.LegendTitle);
         end
      end
      hold off
      name = fullfile(obj.ResultsDir, [base_name, x_abbrev, '_normalized']);
      if ~isempty(obj.Fig_ext)
         saveas(gcf, name, obj.Fig_ext)
      end
      saveas(gcf, name, 'fig');
      close
   end

   % PDF
   if any(obj.PlotDo == 'p')
      figure;
      %axes(obj.Font_props{:})
      hold on
      for i = 1 : n
         h(i) = histogram(y{i});
         h(i).Normalization = 'probability';
         if ~isempty(bin_width)
            h(i).BinWidth = bin_width;
         end
      end
      if ~isempty(obj.Xlim)
         xlim(obj.Xlim);
      end
      title(base_text);
      xlabel(x_text);
      ylabel('PDF');
      if ~isempty(legend_text)
         lgd = legend(legend_text, 'Location', 'best');
         if ~isempty(obj.LegendTitle)
            title(lgd, obj.LegendTitle);
         end
      end
      hold off
      name = fullfile(obj.ResultsDir, [base_name, x_abbrev, '_PDF']);
      if ~isempty(obj.Fig_ext)
         saveas(gcf, name, obj.Fig_ext)
      end
      saveas(gcf, name, 'fig');
      close
   end

   % CDF
   if any(obj.PlotDo == 'c')
      figure;
      %axes(obj.Font_props{:})
      hold on
      for i = 1 : n
         h(i) = histogram(y{i});
         h(i).Normalization = 'cdf';
         if ~isempty(bin_width)
            h(i).BinWidth = bin_width;
         end
      end
      BinLimits(1) = min([h.BinLimits]);
      BinLimits(2) = max([h.BinLimits]);
      for i = 1 : n
         h(i).BinLimits = BinLimits;
      end
      if ~isempty(obj.Xlim)
         xlim(obj.Xlim);
      end
      title(base_text);
      xlabel(x_text);
      ylabel('CDF');
      if ~isempty(legend_text)
         lgd = legend(legend_text, 'Location', 'best');
         if ~isempty(obj.LegendTitle)
            title(lgd, obj.LegendTitle);
         end
      end
      hold off
      %X1 = h1.BinEdges;
      %Y1 = h1.Values;
      name = fullfile(obj.ResultsDir, [base_name, x_abbrev, '_CDF']);
      if ~isempty(obj.Fig_ext)
         saveas(gcf, name, obj.Fig_ext)
      end
      saveas(gcf, name, 'fig');
      close
   end

   % CDF (alternative)
   if any(obj.PlotDo == 'C')
      isnull = all(cellfun(@isempty, y));
      figure;
      %axes(obj.Font_props{:})
      %hold on
      if ~isempty(obj.Xlim)
         x_max = obj.Xlim(2);
      elseif ~isnull
         %x_max = max(cellfun(@max, y));
         x_max = 0;
         for i = 1 : n
            if ~isempty(y{i})
               x_max = max(x_max, max(y{i}));
            end
         end
      else
         x_max = 1;
      end
      k = 0;
      if ~isnull
         T = cell(1, n);
         X = cell(1, n);
         Y = cell(1, n);
         for i = 1 : n
            if ~isempty(y{i})
               y_i = y{i};
               if any(isnan(y_i))
                  y_i(isnan(y_i)) = [];
               end
               if ~isempty(y_i)
                  k = k + 1;
                  T{i} = tabulate(y_i);
                  X{i} = [0; T{i}(:, 1); x_max];
                  Y{i} = [0; cumsum(T{i}(:, 2)) / numel(y_i); 1];
                  switch obj.LinLog
                  case 'semilogx'
                     semilogx(X{i}, Y{i}, [colors(i), line_type{i}], ...
                              obj.Line_props{:});
                  case 'semilogy'
                     semilogy(X{i}, Y{i}, [colors(i), line_type{i}], ...
                              obj.Line_props{:});
                  case 'loglog'
                     loglog(X{i}, Y{i}, [colors(i), line_type{i}], ...
                            obj.Line_props{:});
                  otherwise
                     plot(X{i}, Y{i}, [colors(i), line_type{i}], ...
                          obj.Line_props{:});
                  end
                  if k == 1
                     hold on
                  end
               end
            end
         end
      end
      if ~isempty(obj.Xlim)
         xlim(obj.Xlim);
      end
      if ~isempty(obj.Ylim)
         ylim(obj.Ylim);
      end
      title(base_text);
      xlabel(x_text);
      ylabel('CDF');
      if ~isempty(legend_text)
         j = 0;
         leg_text = {};
         for i = 1 : n
            if ~isempty(y{i}) && ~all(isnan(y{i}))
               j = j + 1;
               leg_text{j} = legend_text{i};
            end
         end
         lgd = legend(leg_text, 'Location', 'best');
         if ~isempty(obj.LegendTitle)
            title(lgd, obj.LegendTitle);
         end
      end
      hold off
      name = fullfile(obj.ResultsDir, [base_name, x_abbrev, '_CDF2']);
      if ~isempty(obj.Fig_ext)
         saveas(gcf, name, obj.Fig_ext)
      end
      saveas(gcf, name, 'fig');
      close

      if obj.CSV
         y_CDF      = cell(2*n, 1);
         labels_CDF = cell(2*n, 1);
         for i = 1 : n
            j = 2*i - 1;
            y_CDF{j}     = X{i};
            y_CDF{j + 1} = Y{i};
            labels_CDF{j}     = [legend_labels{i}, ':x'];
            labels_CDF{j + 1} = [legend_labels{i}, ':y'];
         end
         produceCSVfile(y_CDF, obj.ResultsDir, base_name, x_label, ...
                        labels_CDF, [x_abbrev, '_CDF2']);
      end
   end

   % PlotSpread
   if any(obj.PlotDo == 's')
      figure;
      %axes(obj.Font_props{:})
      if ~isempty(obj.Xlim)
         x_max = obj.Xlim(2);
      elseif ~all(cellfun(@isempty, y))
         %x_max = max(cellfun(@max, y));
         x_max = 0;
         for i = 1 : n
            if ~isempty(y{i})
               x_max = max(x_max, max(y{i}));
            end
         end
      else
         x_max = 1;
      end
      plotSpread(y, 'showMM', obj.ShowMM, 'xNames', legend_text);
      hold on
      if ~isempty(obj.Xlim)
         ylim(obj.Xlim);
      end
      title(base_text);
      ylabel(x_text);
      if n > 1
         set(gca, 'XTickLabelRotation', 45);
      end
      hold off
      name = fullfile(obj.ResultsDir, [base_name, x_abbrev, '_PS']);
      if ~isempty(obj.Fig_ext)
         saveas(gcf, name, obj.Fig_ext)
      end
      saveas(gcf, name, 'fig');
      close
   end

   % PlotSpread (bars for mean & median)
   if any(obj.PlotDo == 'S')
      figure;
      %axes(obj.Font_props{:})
      if ~isempty(obj.Xlim)
         x_max = obj.Xlim(2);
      elseif ~all(cellfun(@isempty, y))
         %x_max = max(cellfun(@max, y));
         x_max = 0;
         for i = 1 : n
            if ~isempty(y{i})
               x_max = max(x_max, max(y{i}));
            end
         end
      else
         x_max = 1;
      end
      plotSpreadMM(y, 'showMM', obj.ShowMM + 10, 'xNames', legend_text);
      hold on
      if ~isempty(obj.Xlim)
         ylim(obj.Xlim);
      end
      if n == 1
         title(sprintf('%s\nmean = %g, median = %g', ...
                       base_text, mean(y{1}), median(y{1})));
      else
         title(base_text);
      end
      ylabel(x_text);
      if n > 1
         set(gca, 'XTickLabelRotation', 45);
      end
      hold off
      name = fullfile(obj.ResultsDir, [base_name, x_abbrev, '_PSMM']);
      if ~isempty(obj.Fig_ext)
         saveas(gcf, name, obj.Fig_ext)
      end
      saveas(gcf, name, 'fig');
      close
   end

   % box plot
   if any(obj.PlotDo == 'x')
      Y  = [];
      ID = [];
      for i = 1 : n
         if isrow(y{i})
            Y = [Y, y{i}];
         else
            Y = [Y, y{i}'];
         end
         ID = [ID, repmat(i, 1, numel(y{i}))];
      end
      if ~isempty(legend_text)
         boxplot(Y, char(legend_labels{ID}));
      else
         boxplot(Y);
      end
      hold on
      title(base_text);
      ylabel(x_text);
      if n > 1
         set(gca, 'XTickLabelRotation', 45);
      end
      hold off
      name = fullfile(obj.ResultsDir, [base_name, x_abbrev, '_box']);
      if ~isempty(obj.Fig_ext)
         saveas(gcf, name, obj.Fig_ext)
      end
      saveas(gcf, name, 'fig');
      close
   end

   % bar graph (with error spread)
   if any(obj.PlotDo == 'b')
      m = arrayfun(@(i) mean(y{i}), 1:n);
      s = arrayfun(@(i)  std(y{i}), 1:n);
      if ~isempty(legend_text)
         bar(categorical(legend_text, legend_text), m);
      else
         bar( m);
      end
      hold on
      errorbar(1:n, m, s, '.', 'CapSize', 25);
      title(base_text);
      ylabel(['mean ', x_text]);
      if n > 1
         set(gca, 'XTickLabelRotation', 45);
      end
      hold off
      name = fullfile(obj.ResultsDir, [base_name, x_abbrev, '_bar']);
      if ~isempty(obj.Fig_ext)
         saveas(gcf, name, obj.Fig_ext)
      end
      saveas(gcf, name, 'fig');
      close
   end

   % KS test
   P = zeros(n);
   for i = 1 : n
      P(i, i) = 1;
      for j = i+1 : n
         if ~isempty(y{i}) && ~isempty(y{j}) ...
            && ~all(isnan(y{i})) && ~all(isnan(y{j}))
            [~, P(i, j)] = kstest2(y{i}, y{j});
         else
            P(i, j) = NaN;
         end
         P(j, i) = P(i, j);
      end
   end

end

function produceCSVfile(y, ResultsDir, base_name, x_label, legend_labels, ...
                           x_abbrev)
% Save the data in .csv format as a standard feature.

   n = numel(y);

   name = fullfile(ResultsDir, [base_name, x_abbrev, '.csv']);
   out = fopen(name, 'w');
   Ny = cellfun(@numel, y);   % number of entries per column
   maxNy = max(Ny);   % max number of entries per column
   % Label each column
   for j = 1 : n
      fprintf(out, '%s', legend_labels{j});
      if j < n
         fprintf(out, ',');
      else
         fprintf(out, '\n');
      end
   end
   % Make a header listing the number of data entries per column.
   for j = 1 : n
      fprintf(out, '%d', Ny(j));
      if j < n
         fprintf(out, ',');
      else
         fprintf(out, '\n');
      end
   end
   for i = 1 : maxNy   % i indexes rows
      for j = 1 : n    % j indexes columns
         if i <= Ny(j)
            fprintf(out, '%f', y{j}(i));
         end
         if j < n
            fprintf(out, ',');
         else
            fprintf(out, '\n');
         end
      end
   end
   fclose(out);

end

./MATLAB/+smi_cluster/@StatisticsClustering/hopkins.m
function results = hopkins(obj, particle_types, SMD)
% Use the Hopkins' statistic to test the clustering of the points in SMD.
%
% INPUTS:
%    obj             various properties used by the algorithms
%       Font_props      [{'FontSize', 15, 'FontWeight', 'bold'}]
%       Line_props      [{'LineWidth', 3}]
%       Fig_ext         figure extension
%       ResultsDir      directory to store results
%       BaseName        name to identify saved plots, which will have various
%                       descriptive suffixes attached
%       Rate            [ 20]    sampling rate for statistical functions
%    particle_types   cell array of particle types (names)
%                     e.g., particle_types = {'5', '10'};
%                         are of the form {[n1 x 1], [n2 x 1]}
%    SMD              (x, y) coordinates of the dataset (nm) in the format
%                     (1) SMD structure: SMD.X and SMD.Y,
%                     (2) N x 2 array of coordinates,
%                     (3) RoI struct with fields (nm):
%       ROI               [x_min, x_max, y_min, y_max, {z_min, z_max}]] of ROI
%       X, Y{, Z}         (x, y, z) coordinates of points inside where X, Y, Z
%                         are of the form {[n1 x 1]}
%
% OUTPUTS:
%    results          results structure:
%       test             number of test points
%       ntests           number of Hopkins statistics to use
%       bins             number of bins for the probability graphs
%       fitting          Gaussian fitting of the data? (boolean)
%       H                Hopkins' statistic
%       xa               analytic distribution for the Hopkins test (x-axis)
%       ya               analytic distribution for the Hopkins test (y-axis)

% Created by
%    Michael Wester and Stanly Steinberg (2008)

base_name = obj.BaseName;
base_text = regexprep(base_name, '_', '\\_');

% Dimension (2D or 3D)
dim = 2;
if iscell(SMD) && ismatrix(SMD) && isfield(SMD{1}, 'ROI')
   RoI = SMD;
   if isempty(obj.ROI)
      obj.ROI = RoI{1}.ROI;
   end
   if isfield(RoI{1}, 'Z') && numel(RoI{1}.Z) > 0
      dim = 3;
   end
elseif ismatrix(SMD) && size(SMD, 2) > 1
   RoI{1}.X = {SMD(:, 1)};
   RoI{1}.Y = {SMD(:, 2)};
   if size(SMD, 2) == 3
      dim == 3;
      RoI{1}.Z = {SMD1(:, 3)};
   end
elseif isstruct(SMD)
   RoI{1}.X = {SMD.X};
   RoI{1}.Y = {SMD.Y};
   if isfield(SMD, 'Z') && numel(SMD.Z) > 0
      dim == 3;
      RoI{1}.Z = {SMD.Z};
   end
else
   error('Unrecognized format for SMD1/SMD2!');
end

% H_nm             horizontal size of the ROI (nm)
% V_nm             vertical   size of the ROI (nm)
% D_nm             depth      size of the ROI (nm) for 3D stats [OPTIONAL]
H_nm = obj.ROI(2) - obj.ROI(1);
V_nm = obj.ROI(4) - obj.ROI(3);
if dim == 3
   D_nm = obj.ROI(6) - obj.ROI(5);
else
   D_nm = -1;
end

test = 5;        % The number of test points.
ntests = 1000;   % The number of Hopkins statistics to use.
bins = 100;      % The number of bins for the probability graphs.
fitting = false; % Gaussian fitting of the data.

% Compute the Hopkins' statistic for each negative.
for m = 1 : length(particle_types)
   if obj.Verbose >= 2
      fprintf('Compute the Hopkins statistic for %s %s (%dD).\n', ...
              base_name, particle_types{m}, dim);
   end
   if dim == 2
      P = [RoI{1}.X{m}, RoI{1}.Y{m}];
   else
      P = [RoI{1}.X{m}, RoI{1}.Y{m}, RoI{1}.Z{m}];
   end
   X = [];
   if D_nm <= 0   % 2D
      for i = 1 : ntests
         X = [X, smi_cluster.StatisticsClustering.hopkinstat( ...
                    P, H_nm, V_nm, test)];
      end
   else   % 3D
      for i = 1 : ntests
         X = [X, smi_cluster.StatisticsClustering.hopkinstat3( ...
                    P, H_nm, V_nm, D_nm, test)];
      end
   end
   H{m} = X;
end

% The analytic distribution for the Hopkins test:
xa = linspace(0, 1, obj.Rate);
ya = ((xa.^(test-1)).*((1-xa).^(test-1)))/(gamma(test)^2/gamma(2*test));

% Plot the summary statistics.
% The PDF for each negative in the experiment.
if obj.Verbose >= 2
   fprintf('   Plot the Hopkins statistics.\n');
end
for m = 1 : length(particle_types)
   if ~isempty(obj.Fig_ext)
      figure('Visible', 'off');
   else
      figure;
   end
   axes(obj.Font_props{:})
   hold on
   [X, V] = smi_cluster.StatisticsClustering.histogram(H{m}, [0, 1], bins);
   Pr = V*bins/ntests;
   bar(X, Pr, 1)
   hold on
   if fitting
      % Gaussian fit to the data.
      f = fit(X', Pr', 'gauss2');
      [fit_max, i_max] = max(f(X));
      x_max = X(i_max);
      h = plot(f, 'g');
      set(h, obj.Line_props{1}, obj.Line_props{2});
   end
   plot(xa, ya, 'r', obj.Line_props{:})
   axis([0 1 0 ceil(max(max(Pr), max(ya)))]);
   xlabel('H -- The Hopkins Statistic');
   ylabel('PDF');
   if fitting
      title({['Hopkins PDF for ', base_text, '\_', particle_types{m}], ...
             sprintf('(x, fit)_{max} = (%5.3f, %.3f)', x_max, fit_max)});
   else
      title(['Hopkins PDF for ', base_text, '\_', particle_types{m}]);
   end
   if fitting
      legend('data', 'Gaussian fit', 'random', 'Location', 'NorthWest');
   else
      legend('data', 'random', 'Location', 'NorthWest');
   end
   name = fullfile(obj.ResultsDir, ...
                   [base_name, '_', particle_types{m}, '_hopkinspdf']);
   if ~isempty(obj.Fig_ext)
      print(['-d', obj.Fig_ext], name);
   else
      saveas(gcf, name);
      delete(gcf);
   end
end

hold off

results.test = test;
results.ntests = ntests;
results.bins = bins;
results.fitting = fitting;
results.H = H;
results.xa = xa;
results.ya = ya;

end

./MATLAB/+smi_cluster/@StatisticsClustering/bivariateRipley_ROIcombined.m
function results = ...
   bivariateRipley_ROIcombined(obj, particle_types, n_ROIs, RoI)
% Use bivariate Ripley statistics to test the clustering of a series of ROIs
% all of the same size.
%
% INPUTS:
%    obj         various properties used by the algorithms
%       Font_props      [{'FontSize', 15, 'FontWeight', 'bold'}]
%       Line_props      [{'LineWidth', 3}]
%       Fig_ext         figure extension
%       ResultsDir      directory to store results
%       BaseName        name to identify saved plots, which will have various
%                       descriptive suffixes attached
%
%       Rate            [ 20]    sampling rate for statistical functions
%       Ripley_cutoff   [200]    Ripley distance cutoff (nm)
%       Confidence      [2.576]  bivariate Ripley confidence interval:
%                                   95% confidence interval: Confidence = 1.96
%                                   99% confidence interval: Confidence = 2.576
%       Nsims         = [100]    bivariate Ripley simulations to run
%    particle_types   cell array of particle types (names)
%                     e.g., particle_types = {'5', '10'};
%    n_ROIs           number of ROIs to combine
%    RoI              n_ROIs cell array containing the following fields (nm):
%       ROI              ROI limits in the form
%                           [x_min, x_max, y_min, y_max {, z_min, z_max}]
%       X, Y, Z          cell arrays of (x, y {, z}) coordinates
%                           e.g., X{1} = 1st label x-coordinates, X{2} = 2nd
%                           label where X{1} is (n1 x 1), X{2} is (n2 x 1)
%
% OUTPUTS:
%    results          results structure:
%       R               L(R) statistic
%       E               simulation results
%       A               simulation means
%       High            A + stderr
%       Low             A - stderr

% Created by
%    Michael Wester and Stanly Steinberg (2008)

base_name = obj.BaseName;

% Dimension (2D or 3D)
dim = 2;
if isfield(RoI{1}, 'Z') && numel(RoI{1}.Z) > 0
   dim = 3;
end

% Compute the bivariate Ripley statistics.
% Add Q for second species
if obj.Verbose >= 2
   fprintf('Compute the bivariate Ripley statistic for %s.\n', base_name);
end

% Divide the interval [0, cutoff] into Rate number of pieces of length dr.
% The look at the distance d between two points and add 1 to R(d/dr).
% This provides a PDF for the distances.
dr = obj.Ripley_cutoff/obj.Rate;
RipleyK = zeros(1, obj.Rate + 1);;
% H_nm   horizontal size of the ROI (nm)
% V_nm   vertical   size of the ROI (nm)
% D_nm   depth      size of the ROI (nm)
for m = 1 : n_ROIs
   x_min = RoI{m}.ROI(1);
   x_max = RoI{m}.ROI(2);
   y_min = RoI{m}.ROI(3);
   y_max = RoI{m}.ROI(4);
   H_nm = x_max - x_min;
   V_nm = y_max - y_min;
   if dim == 3
      z_min = RoI{m}.ROI(5);
      z_max = RoI{m}.ROI(6);
      D_nm = z_max - z_min;
   end

   X = [RoI{m}.X{1}, RoI{m}.Y{1}];
   Y = [RoI{m}.X{2}, RoI{m}.Y{2}];
   if dim == 3
      X = [RoI{m}.X{1}, RoI{m}.Y{1}, RoI{m}.Z{1}];
      Y = [RoI{m}.X{2}, RoI{m}.Y{2}, RoI{m}.Z{2}];
   end
   nX = length(X);
   nY = length(Y);
   R = zeros(1, obj.Rate);
   if dim == 2
      %for i = 1 : length(X)
      %   for j = 1 : length(Y)
      for i = 1 : nX
         for j = 1 : nY
            p = ceil(sqrt((X(i,1) - Y(j,1))^2 + (X(i,2) - Y(j,2))^2)/dr);
            if p > 0 & p <= obj.Rate
               R(p) = R(p) + 1;
            end
         end
      end
   else   % dim == 3
      for i = 1 : nX
         for j = 1 : nY
            p = ceil(sqrt((X(i,1) - Y(j,1))^2 + (X(i,2) - Y(j,2))^2 + ...
                          (X(i,3) - Y(j,3))^2)/dr);
            if p > 0 & p <= obj.Rate
               R(p) = R(p) + 1;
            end
         end
      end
   end

   % Add a zero to the beginning of R for nicer plotting.
   R = [0, R];
   % Convert the PDF to a CDF.
   for i = 2 : length(R)
      R(i) = R(i) + R(i-1);
   end
   
   % Compute the intensity and normalize R.
   % This needs a fix. xxx
   % xxx should use the area of the crop_area (err crop region).
   % A = H_nm*V_nm = (x_max - x_min)*(y_max - y_min)
   if dim == 2
      lambda1 = nX/(H_nm*V_nm);
      lambda2 = nY/(H_nm*V_nm);
      R = R/(lambda1*lambda2*(H_nm*V_nm));
   else
      lambda1 = nX/(H_nm*V_nm*D_nm);
      lambda2 = nY/(H_nm*V_nm*D_nm);
      R = R/(lambda1*lambda2*(H_nm*V_nm*D_nm));
   end
   K(1, 2) = {R};
   % Accumulate over each ROI.
   RipleyK = RipleyK + R;
end
% Normalize over all ROIs.
RipleyK = RipleyK / n_ROIs;
K(1, 2) = {RipleyK};

% Plot sqrt of Ripley
if obj.Verbose >= 2
   fprintf('   Plotting the L(r) statistic for %s.\n', base_name);
end
%if ~isempty(obj.Fig_ext)
%   figure('Visible', 'off');
%else
   figure;
%end
axes(obj.Font_props{:})
grid on
hold on
N = sqrt(K{1, 2}/pi) - [0:obj.Rate]*dr;
plot([0:obj.Rate]*dr, N, '-r', obj.Line_props{:})
xlabel('Distance (nm)');
ylabel('L(r)-r ');
NN = N;

for s = 1 : obj.Nsims
   % Create random point vectors for simulations
   % and calculate Ripley statistic
   if dim == 2
      %Xr = [rand(length(X),1)*H_nm rand(length(X),1)*V_nm];
      %Yr = [rand(length(Y),1)*H_nm rand(length(Y),1)*V_nm];
      Xr = [rand(nX,1)*H_nm rand(nX,1)*V_nm];
      Yr = [rand(nY,1)*H_nm rand(nY,1)*V_nm];
      Rr = zeros(1, obj.Rate);
      %for i = 1 : length(Xr)
      %   for j = 1 : length(Yr)
      for i = 1 : nX
         for j = 1 : nY
            p=ceil(sqrt((Xr(i,1) - Yr(j,1))^2 + (Xr(i,2) - Yr(j,2))^2)/dr);
            if p > 0 & p <= obj.Rate
               Rr(p) = Rr(p) + 1;
            end
         end
      end
   else
      Xr = [rand(nX,1)*H_nm rand(nX,1)*V_nm rand(nX,1)*D_nm];
      Yr = [rand(nY,1)*H_nm rand(nY,1)*V_nm rand(nY,1)*D_nm];
      Rr = zeros(1, obj.Rate);
      for i = 1 : nX
         for j = 1 : nY
            p=ceil(sqrt((Xr(i,1) - Yr(j,1))^2 + (Xr(i,2) - Yr(j,2) + ...
                         Xr(i,3) - Yr(j,3))^2)/dr);
            if p > 0 & p <= obj.Rate
               Rr(p) = Rr(p) + 1;
            end
         end
      end
   end
   % Add a zero to the beginning of R for nicer plotting.
   Rr = [0, Rr];
   % Convert the PDF to a CDF.
   for i = 2 : length(Rr)
      Rr(i) = Rr(i) + Rr(i-1);
   end
   % Compute the intensity and normalize R.
% Fix area here also xxx.
   if dim == 2
      %lambda1r = length(Xr)/(H_nm*V_nm);
      %lambda2r = length(Yr)/(H_nm*V_nm);
      lambda1r = nX/(H_nm*V_nm);
      lambda2r = nY/(H_nm*V_nm);
      Rr = Rr/(lambda1*lambda2*(H_nm*V_nm));
   else
      lambda1r = nX/(H_nm*V_nm*D_nm);
      lambda2r = nY/(H_nm*V_nm*D_nm);
      Rr = Rr/(lambda1*lambda2*(H_nm*V_nm*D_nm));
   end
   N = sqrt(Rr/pi) - [0:obj.Rate]*dr;
   % Plot all random simulations
%  plot([0:obj.Rate]*dr, N, obj.Line_props{:})
   hold on
   % Put Ripley data into a matrix
   E(s, 1:length(Rr))=N;
end

for ss = 1 : length(Rr)
   % Calculate standard deviation of all simulations at particular dr
   S(ss, 1) = std(E(:, ss));
   % Calculate mean of all simulations at particular dr 
   A(ss) = mean(E(:, ss));
   High(ss) = A(ss)+obj.Confidence*S(ss);
   Low(ss)  = A(ss)-obj.Confidence*S(ss);
end

% Plot data
% grid off
% set(gca, 'Box', 'on', 'LineWidth', 3, 'FontSize', 18, 'FontWeight', 'bold')
plot([0:obj.Rate]*dr, High, '--k', obj.Line_props{:});
plot([0:obj.Rate]*dr, Low,  '--k', obj.Line_props{:});
plot([0:obj.Rate]*dr, H_nm, '*k', obj.Line_props{:});

% Fit the figure
b_n = regexprep(base_name, '_', '\\_');
p_t = particle_types{1};
for i = 2 : length(particle_types)
   p_t = [p_t ',' particle_types{i}];
end
p_t = regexprep(p_t, '_', '\\_');

%axis([0 200 min(Low)-5 max(NN)+5])
axis([0 obj.Ripley_cutoff min(Low)-5 max(NN)+5])
title(['Bivariate Ripley Analysis for ', b_n, ' (', p_t, ')'])
legend('data', 'confidence', 'Location', 'Best')
name = fullfile(obj.ResultsDir, [base_name, '_bivripley_RC']);
if ~isempty(obj.Fig_ext)
   print(['-d', obj.Fig_ext], name);
end
%else
   saveas(gcf, name, 'fig');
   delete(gcf);
%end

% m       is the number of different types of particles.
% n       is the number of images in the experiment.
% Rate    is the sampling rate.

results.R = R;
results.E = E;
results.A = A;
results.High = High;
results.Low  = Low;

end

./MATLAB/+smi_cluster/@StatisticsClustering/bivariateRipley.m
function results = bivariateRipley(obj, particle_types, SMD1, SMD2)
% Bivariate Ripley's statistic to test the clustering of the points in
% SMD1 and SMD2.
%
% INPUTS:
%    obj              various properties used by the algorithms
%       Font_props      [{'FontSize', 15, 'FontWeight', 'bold'}]
%       Line_props      [{'LineWidth', 3}]
%       Fig_ext         figure extension
%       ResultsDir      directory to store results
%       BaseName        name to identify saved plots, which will have various
%                       descriptive suffixes attached
%
%       Rate            [ 20]    sampling rate for statistical functions
%       Ripley_cutoff   [200]    Ripley distance cutoff (nm)
%       Confidence      [2.576]  bivariate Ripley confidence interval:
%                                   95% confidence interval: Confidence = 1.96
%                                   99% confidence interval: Confidence = 2.576
%       Nsims           [100]    bivariate Ripley simulations to run
%    particle_types   cell array of particle types (names)
%                     e.g., particle_types = {'5', '10'};
%    SMD1 and SMD2    (x, y) coordinates of the two datasets (nm) in the format
%                     (1) SMD structures: SMD1.X, SMD1.Y, SMD2.X and SMD2.Y,
%                     (2) N x 2 array of coordinates,
%                     (3) RoI struct with fields (nm) [SMD2 not provided here]:
%       ROI               [x_min, x_max, y_min, y_max, {z_min, z_max}]] of ROI
%       X, Y{, Z}         (x, y, z) coordinates of points inside where X, Y, Z
%                         are of the form {[n1 x 1], [n2 x 1]}
%
% OUTPUTS:
%    results          results structure:
%       r               r-axis: [0 : obj.Rate] * dr
%       R               L(R) statistic
%       E               simulation results
%       A               simulation means
%       High            A + stderr
%       Low             A - stderr

% Created by
%    Michael Wester and Stanly Steinberg (2008)

base_name = obj.BaseName;

% Dimension (2D or 3D)
dim = 2;
if ~exist('SMD2', 'var')
   if iscell(SMD1) && ismatrix(SMD1) && isfield(SMD1{1}, 'ROI')
      RoI = SMD1;
      if isempty(obj.ROI)
         obj.ROI = RoI{1}.ROI;
      end
      if isfield(RoI{1}, 'Z') && numel(RoI{1}.Z) > 0
         dim = 3;
      end
   else
      error('Unrecognized format for SMD1!');
   end
elseif ismatrix(SMD1) && ismatrix(SMD2) ...
   && size(SMD1, 2) > 1 && size(SMD2, 2) > 1
   RoI{1}.X = {SMD1(:, 1), SMD2(:, 1)};
   RoI{1}.Y = {SMD1(:, 2), SMD2(:, 2)};
   if size(SMD1, 2) == 3 && size(SMD2, 2) == 3
      dim == 3;
      RoI{1}.Z = {SMD1(:, 3), SMD2(:, 3)};
   end
elseif isstruct(SMD1) && isstruct(SMD2)
   RoI{1}.X = {SMD1.X, SMD2.X};
   RoI{1}.Y = {SMD1.Y, SMD2.Y};
   if isfield(SMD1, 'Z') && isfield(SMD2, 'Z') ...
      && numel(SMD1.Z) > 0 && numel(SMD2.Z) > 0
      dim == 3;
      RoI{1}.Z = {SMD1.Z, SMD2.Z};
   end
else
   error('Unrecognized format for SMD1/SMD2!');
end

% H_nm             horizontal size of the ROI (nm)
% V_nm             vertical   size of the ROI (nm)
% D_nm             depth      size of the ROI (nm) for 3D stats [OPTIONAL]
H_nm = obj.ROI(2) - obj.ROI(1);
V_nm = obj.ROI(4) - obj.ROI(3);
if dim == 3
   D_nm = obj.ROI(6) - obj.ROI(5);
else
   D_nm = -1;
end

if dim == 2
   P{1} = [RoI{1}.X{1}, RoI{1}.Y{1}];
   P{2} = [RoI{1}.X{2}, RoI{1}.Y{2}];
else
   P{1} = [RoI{1}.X{1}, RoI{1}.Y{1}, RoI{1}.Z{1}];
   P{2} = [RoI{1}.X{2}, RoI{1}.Y{2}, RoI{1}.Z{2}];
end

% Compute the bivariate Ripley statistics.
% Add Q for second species
if obj.Verbose >= 2
   fprintf('Compute the bivariate Ripley statistic for %s.\n', base_name);
end

% Divide the interval [0, cutoff] into Rate number of pieces of length dr.
% The look at the distance d between two points and add 1 to R(d/dr).
% This provides a PDF for the distances.
dr = obj.Ripley_cutoff/obj.Rate;
X = P{1};
Y = P{2};
nX = length(X);
nY = length(Y);
R = zeros(1, obj.Rate);
if dim == 2
   %for i = 1 : length(X)
   %   for j = 1 : length(Y)
   for i = 1 : nX
      for j = 1 : nY
         p = ceil(sqrt((X(i,1) - Y(j,1))^2 + (X(i,2) - Y(j,2))^2)/dr);
         if p > 0 & p <= obj.Rate
            R(p) = R(p) + 1;
         end
      end
   end
else
   for i = 1 : nX
      for j = 1 : nY
         p = ceil(sqrt((X(i,1) - Y(j,1))^2 + (X(i,2) - Y(j,2))^2 + ...
                       (X(i,3) - Y(j,3))^2)/dr);
         if p > 0 & p <= obj.Rate
            R(p) = R(p) + 1;
         end
      end
   end
end

% Add a zero to the beginning of R for nicer plotting.
R = [0, R];
% Convert the PDF to a CDF.
for i = 2 : length(R)
   R(i) = R(i) + R(i-1);
end
   
% Compute the intensity and normalize R.
% This needs a fix. xxx
% xxx should use the area of the crop_area (err crop region).
% A = H_nm*V_nm
if dim == 2
   %lambda1 = length(X)/(H_nm*V_nm);
   %lambda2 = length(Y)/(H_nm*V_nm);
   lambda1 = nX/(H_nm*V_nm);
   lambda2 = nY/(H_nm*V_nm);
   R = R/(lambda1*lambda2*(H_nm*V_nm));
else
   lambda1 = nX/(H_nm*V_nm*D_nm);
   lambda2 = nY/(H_nm*V_nm*D_nm);
   R = R/(lambda1*lambda2*(H_nm*V_nm*D_nm));
end
K(1, 2) = {R};

% Plot sqrt of Ripley
if obj.Verbose >= 2
   fprintf('   Plotting the L(r) statistic for %s.\n', base_name);
end
if ~isempty(obj.Fig_ext)
   figure('Visible', 'off');
else
   figure;
end
axes(obj.Font_props{:})
grid on
hold on
N = sqrt(K{1, 2}/pi) - [0:obj.Rate]*dr;
plot([0:obj.Rate]*dr, N, '-r', obj.Line_props{:})
xlabel('Distance (nm)');
ylabel('L(r)-r ');
NN = N;

for s = 1 : obj.Nsims
   % Create random point vectors for simulations
   % and calculate Ripley statistic
   if dim == 2
      %Xr = [rand(length(X),1)*H_nm rand(length(X),1)*V_nm];
      %Yr = [rand(length(Y),1)*H_nm rand(length(Y),1)*V_nm];
      Xr = [rand(nX,1)*H_nm rand(nX,1)*V_nm];
      Yr = [rand(nY,1)*H_nm rand(nY,1)*V_nm];
      Rr = zeros(1, obj.Rate);
      %for i = 1 : length(Xr)
      %   for j = 1 : length(Yr)
      for i = 1 : nX
         for j = 1 : nY
            p=ceil(sqrt((Xr(i,1) - Yr(j,1))^2 + (Xr(i,2) - Yr(j,2))^2)/dr);
            if p > 0 & p <= obj.Rate
               Rr(p) = Rr(p) + 1;
            end
         end
      end
   else
      Xr = [rand(nX,1)*H_nm rand(nX,1)*V_nm rand(nX,1)*D_nm];
      Yr = [rand(nY,1)*H_nm rand(nY,1)*V_nm rand(nY,1)*D_nm];
      Rr = zeros(1, obj.Rate);
      for i = 1 : nX
         for j = 1 : nY
            p=ceil(sqrt((Xr(i,1) - Yr(j,1))^2 + (Xr(i,2) - Yr(j,2) + ...
                         Xr(i,3) - Yr(j,3))^2)/dr);
            if p > 0 & p <= obj.Rate
               Rr(p) = Rr(p) + 1;
            end
         end
      end
   end
   % Add a zero to the beginning of R for nicer plotting.
   Rr = [0, Rr];
   % Convert the PDF to a CDF.
   for i = 2 : length(Rr)
      Rr(i) = Rr(i) + Rr(i-1);
   end
   % Compute the intensity and normalize R.
% Fix area here also xxx.
   if dim == 2
      %lambda1r = length(Xr)/(H_nm*V_nm);
      %lambda2r = length(Yr)/(H_nm*V_nm);
      lambda1r = nX/(H_nm*V_nm);
      lambda2r = nY/(H_nm*V_nm);
      Rr = Rr/(lambda1*lambda2*(H_nm*V_nm));
   else
      lambda1r = nX/(H_nm*V_nm*D_nm);
      lambda2r = nY/(H_nm*V_nm*D_nm);
      Rr = Rr/(lambda1*lambda2*(H_nm*V_nm*D_nm));
   end
   N = sqrt(Rr/pi) - [0:obj.Rate]*dr;
   % Plot all random simulations
%  plot([0:obj.Rate]*dr, N, obj.Line_props{:})
   hold on
   % Put Ripley data into a matrix
   E(s, 1:length(Rr))=N;
end

for ss = 1 : length(Rr)
   % Calculate standard deviation of all simulations at particular dr
   S(ss, 1) = std(E(:, ss));
   % Calculate mean of all simulations at particular dr 
   A(ss) = mean(E(:, ss));
   High(ss) = A(ss)+obj.Confidence*S(ss);
   Low(ss)  = A(ss)-obj.Confidence*S(ss);
end

% Plot data
% grid off
% set(gca, 'Box', 'on', 'LineWidth', 3, 'FontSize', 18, 'FontWeight', 'bold')
plot([0:obj.Rate]*dr, High, '--k', obj.Line_props{:});
plot([0:obj.Rate]*dr, Low,  '--k', obj.Line_props{:});
plot([0:obj.Rate]*dr, H_nm, '*k', obj.Line_props{:});

% Fit the figure
b_n = regexprep(base_name, '_', '\\_');
p_t = particle_types{1};
for i = 2 : length(particle_types)
   p_t = [p_t ',' particle_types{i}];
end
p_t = regexprep(p_t, '_', '\\_');

%axis([0 200 min(Low)-5 max(NN)+5])
axis([0 obj.Ripley_cutoff min(Low)-5 max(NN)+5])
title(['Bivariate Ripley Analysis for ', b_n, ' (', p_t, ')'])
legend('data', 'confidence', 'Location', 'Best')
name = fullfile(obj.ResultsDir, [base_name, '_bivripley']);
if ~isempty(obj.Fig_ext)
   print(['-d', obj.Fig_ext], name);
else
   saveas(gcf, name);
   delete(gcf);
end

% m       is the number of different types of particles.
% n       is the number of images in the experiment.
% Rate    is the sampling rate.

results.r = [0:obj.Rate]*dr;
results.R = R;
results.E = E;
results.A = A;
results.High = High;
results.Low  = Low;

end

./MATLAB/+smi_cluster/@StatisticsClustering/README.md
### +smi_cluster/@StatisticsClustering

StatisticsClustering contains statistics and plots for detecting clustering.
Data can be 2D or 3D.

See [MATLAB/examples/Example_StatisticsClustering.m](../../examples/Example_StatisticsClustering.m)
for 2D and 3D examples.

The main routines here are:
```
   hopkins              hopkins_ROIcombined           Hopkins' statistic
   ripley               ripley_ROIcombined            Ripley's statistics
   bivariateRipley      bivariateRipley_ROIcombined   Bivariate Ripley's
   pairwiseDist                                       Pairwise distances
   pairwiseMutualDist                                 Piarwise mutual dist.
   plotCombined
      Frequency, CDF, PDF, plotSpread, box and bar plots of an array.
```
The _ROIcombined plots are averaged results over a series of ROIs and
expect n_ROIs and a RoI structure (see smi_helpers.ROITools).

Note that pairwiseMutualDist and bivariateRipley are expecting either a
single argument RoI structure or two SMD structures or two Nx2 (or Nx3)
arrays, while the other statistical functions are expecting an RoI
structure or one SMD structure or one array.

**plotCombined** is a handy way to plot the same data in several different ways
as indicated by the user.

---

properties:
```
   % If ROI is provided, it will be used, otherwise the xy_size will be
   % calculated using the (x_min, x_max, y_min, y_max) computed from the data
   % as
   %    xy_size = min(x_max - x_min, y_max - y_min)
   ROI = [];   % [x_min, x_max, x_max, y_max]   % nm

   Font_props = {'FontSize', 15, 'FontWeight', 'bold'};
   Line_props = {'LineWidth', 3};
   Fig_ext = 'png';
   BaseName = '';         % Descriptive name for the result files
   ResultsDir = '.';      % Directory to store results
   Xlim = [];             % x-axis limits if defined
   Ylim = [];             % y-axis limits if defined

   % Properties used by plotCombined.
   PlotDo = 'fnpcCsSxb';  % Plots to do for plotCombined (fnpcCsSxb)
   LinLog = 'plot';       % Plot type for plotCombined CDF2 plots:
                          %   'plot', 'semilogx', 'semilogy', 'loglog'
   LegendTitle = '';      % Optional legend title
   ShowMM = 1;            % Red mean and green median (2 only mean, 3
                          %    only median) for PlotSpread plots
   CSV = false;           % If true, produce a CSV file of the data

   % Properties below are used by various routines.
   Rate          =  20;   % Sampling rate for statistical functions
   Dendro_cutoff =  50;   % Cluster cutoff for Dendrogram analysis (nm)
   Ripley_cutoff = 200;   % Ripley distance cutoff (nm)
   Confidence    = 2.576; % Bivariate Ripley confidence interval
      % 95% confidence interval: Confidence = 1.96
      % 99% confidence interval: Confidence = 2.576
   Nsims         = 20;    % Simulations to run for bivariateRipley,
                          % pairwiseDist, pairwiseMutualDist

   PixelSize = 100;       % Camera pixel size (nm)

   Verbose = 1;           % verbosity level
```

---

methods:
- **[bivariateRipley](bivariateRipley.m)**:
  Bivariate Ripley's statistic to test the clustering of the points in
  SMD1 and SMD2
- **[bivariateRipley_ROIcombined](bivariateRipley_ROIcombined.m)**:
  Use bivariate Ripley statistics to test the clustering of a series of ROIs
  all of the same size
- **[histogram](histogram.m)**:
  simple histogram function
- **[hopkins](hopkins.m)**:
  Use the Hopkins' statistic to test the clustering of the points in SMD
- **[hopkins_ROIcombined](hopkins_ROIcombined.m)**:
  Use Hopkins' statistics to test the clustering of a series of ROIs
- **[hopkinstat](hopkinstat.m)**:
  Compute a Hopkin's statistic for the 2D particles P
- **[hopkinstat3](hopkinstat3.m)**:
  Compute a Hopkin's statistic for the 3D particles P
- **[pairwiseDist](pairwiseDist.m)**:
  plots pairwise distances and CDFs
- **[pairwiseMutualDist](pairwiseMutualDist.m)**:
  Plot pairwise distances and CDFs between two populations of particles
- **[plotCombined](plotCombined.m)**:
  Combined frequency, CDF, PDF, plotSpread, box and bar plots of the arrays y
- **[ripley](ripley.m)**:
  Use Ripley's statistics to test the clustering of the points in SMD
- **[ripley_ROIcombined](ripley_ROIcombined.m)**:
  Use Ripley's statistics to test the clustering of a series of ROIs
- **[unitTest](unitTest.m)**:
  Test calling StatisticsClustering routines

./MATLAB/+smi_cluster/@StatisticsClustering/ripley.m
function results = ripley(obj, particle_types, SMD)
% Use Ripley's statistics to test the clustering of the points in SMD.
%
% INPUTS:
%    obj              various properties used by the algorithms
%       Font_props      [{'FontSize', 15, 'FontWeight', 'bold'}]
%       Line_props      [{'LineWidth', 3}]
%       Fig_ext         figure extension
%       ResultsDir      directory to store results
%       BaseName        name to identify saved plots, which will have various
%                       descriptive suffixes attached
%       Rate            [ 20]    sampling rate for statistical functions
%       Ripley_cutoff   [200]    Ripley distance cutoff (nm)
%    particle_types   cell array of particle types (names)
%                     e.g., particle_types = {'5', '10'};
%    SMD              (x, y) coordinates of the dataset (nm) in the format
%                     (1) SMD structure: SMD.X and SMD.Y,
%                     (2) N x 2 array of coordinates,
%                     (3) RoI struct with fields (nm):
%       ROI               [x_min, x_max, y_min, y_max, {z_min, z_max}]] of ROI
%       X, Y{, Z}         (x, y, z) coordinates of points inside where X, Y, Z
%                         are of the form {[n1 x 1]}
%
% OUTPUTS:
%    results          results structure:
%       r                r-axis: [0 : obj.Rate] * dr
%       K                K(r)

% Created by
%    Michael Wester and Stanly Steinberg (2008)

base_name = obj.BaseName;
base_text = regexprep(base_name, '_', '\\_');

% Dimension (2D or 3D)
dim = 2;
if iscell(SMD) && ismatrix(SMD) && isfield(SMD{1}, 'ROI')
   RoI = SMD;
   if isempty(obj.ROI)
      obj.ROI = RoI{1}.ROI;
   end
   if isfield(RoI{1}, 'Z') && numel(RoI{1}.Z) > 0
      dim = 3;
   end
elseif ismatrix(SMD) && size(SMD, 2) > 1
   RoI{1}.X = {SMD(:, 1)};
   RoI{1}.Y = {SMD(:, 2)};
   if size(SMD, 2) == 3
      dim == 3;
      RoI{1}.Z = {SMD1(:, 3)};
   end
elseif isstruct(SMD)
   RoI{1}.X = {SMD.X};
   RoI{1}.Y = {SMD.Y};
   if isfield(SMD, 'Z') && numel(SMD.Z) > 0
      dim == 3;
      RoI{1}.Z = {SMD.Z};
   end
else
   error('Unrecognized format for SMD1/SMD2!');
end

% H_nm             horizontal size of the ROI (nm)
% V_nm             vertical   size of the ROI (nm)
% D_nm             depth      size of the ROI (nm) for 3D stats [OPTIONAL]
H_nm = obj.ROI(2) - obj.ROI(1);
V_nm = obj.ROI(4) - obj.ROI(3);
if dim == 3
   D_nm = obj.ROI(6) - obj.ROI(5);
else
   D_nm = -1;
end

M = length(particle_types);
for i = 1 : M
   probes{i} = particle_types{i};
end

colors = {'r', 'g', 'b'};

% Dimension (2D or 3D)
dim = 2;
if D_nm > 0
   dim = 3;
end

% Compute the Ripley statistcs.

% Divide the interval [0, cutoff] into Rate number of pieces of length dr.
% The look at the distance d between two points and add 1 to R(d/dr).
% This provides a PDF for the distances.
dr=obj.Ripley_cutoff/obj.Rate;
for m = 1 : length(particle_types)
   if obj.Verbose >= 2
      fprintf('Compute Ripley statistic for %s %s (%dD).\n', ...
              base_name, particle_types{m}, dim);
   end
   if dim == 2
      P = [RoI{1}.X{m}, RoI{1}.Y{m}];
   else
      P = [RoI{1}.X{m}, RoI{1}.Y{m}, RoI{1}.Z{m}];
   end
   X = P;
   nX = length(X);
   R = zeros(1, obj.Rate);
   if dim == 2
      %for i = 1 : length(X)
      for i = 1 : nX
         for j = 1 : i - 1
            p = ceil(sqrt((X(j,1) - X(i,1))^2 + (X(j,2) - X(i,2))^2)/dr);
            if p > 0 & p <= obj.Rate
               R(p) = R(p) + 1;
            end
         end
      end
   else
      for i = 1 : nX
         for j = 1 : i - 1
            p = ceil(sqrt((X(j,1) - X(i,1))^2 + (X(j,2) - X(i,2))^2 + ...
                          (X(j,3) - X(i,3))^2)/dr);
            if p > 0 & p <= obj.Rate
               R(p) = R(p) + 1;
            end
         end
      end
   end
   % Add a zero to the beginning of R for nicer plotting.
   R = [0, R];
   % Compensate for the j=1:i-1 savings.
   R = 2*R;
   % Convert the PDF to a CDF.
   for i = 2 : length(R)
      R(i) = R(i) + R(i-1);
   end
   % Average over the number of particles.
   %R = R/length(X);
   R = R/nX;
   % Compute the intensity and normalize R.
   if dim == 2
      %lambda = length(X)/(H_nm*V_nm);
      lambda = nX/(H_nm*V_nm);
   else
      lambda = nX/(H_nm*V_nm*D_nm);
   end
   R = R/lambda;
   K(m) = {R};
end

% Plot Ripley
if obj.Verbose >= 2
   fprintf('   Plot Ripley statistic.\n');
end
if ~isempty(obj.Fig_ext)
   figure('Visible', 'off');
else
   figure;
end
axes(obj.Font_props{:})
grid on
hold on
% The analytic expected value.
plot([0:obj.Rate]*dr, pi*([0:obj.Rate]*dr).^2, 'k', ...
     obj.Line_props{:})
mx = 0;
for m = 1 : length(particle_types)
   N = K{m};
   mx = max(mx, max(N));
   plot([0:obj.Rate]*dr, N, colors{m}, obj.Line_props{:})
end
legend({'random', probes{:}}, 'Location', 'NorthWest');
axis([0 obj.Ripley_cutoff 0 mx]);
xlabel('r (nm)');
ylabel('K(r)');
title(['Ripley for ', base_text]);
hold off
name = fullfile(obj.ResultsDir, [base_name, '_ripley']);
if ~isempty(obj.Fig_ext)
   print(['-d', obj.Fig_ext], name);
else
   saveas(gcf, name);
   delete(gcf);
end

% Plot sqrt of Ripley
if obj.Verbose >= 2
   fprintf('   Plot the L(r) statistic.\n');
end
if ~isempty(obj.Fig_ext)
   figure('Visible', 'off');
else
   figure;
end
axes(obj.Font_props{:})
grid on
hold on
mx = 0;
for m = 1 : length(particle_types)
   N = sqrt(K{m}/pi) - [0 : obj.Rate]*dr;
%  mx = max(mx, max(N));
   plot([0:obj.Rate]*dr, N, colors{m}, obj.Line_props{:})
end
legend(probes, 'Location', 'NorthWest');
xlabel('r (nm)');
ylabel('L(r) - r ');
title(['Ripley L(r) - r for ', base_text]);
hold off
name = fullfile(obj.ResultsDir, [base_name, '_l_r_ripley']);
if ~isempty(obj.Fig_ext)
   print(['-d', obj.Fig_ext], name);
else
   saveas(gcf, name);
   delete(gcf);
end

% Plot Ripley/(pi*r^2) (in microns)
if ~isempty(obj.Fig_ext)
   figure('Visible', 'off');
else
   figure;
end
axes(obj.Font_props{:})
grid on
hold on
mx = 0;
if obj.Verbose >= 2
   fprintf('   Plot the K(r)/(pi r^2) statistic.\n');
end
for m = 1 : length(particle_types)
   % Avoid dividing by 0.
   N = K{m}(2:length(K{m}));
   N = N./(pi*(dr*[1:obj.Rate]).^2);
   mx = max(mx, max(N));
   plot([0:obj.Rate]*dr, [0, N], colors{m}, obj.Line_props{:});
end
legend(probes, 'Location', 'NorthEast');
axis([0 obj.Ripley_cutoff 0 mx]);
xlabel('r (nm)');
ylabel('K(r)/(\pi r^2)');
title(['Normalized Ripley for ', base_text]);
hold off
name = fullfile(obj.ResultsDir, [base_name, '_norm_ripley']);
if ~isempty(obj.Fig_ext)
   print(['-d', obj.Fig_ext], name);
else
   saveas(gcf, name, 'fig');
   delete(gcf);
end

% m       is the number of different types of particles.
% n       is the number of images in the experiment.
% Rate    is the sampling rate.

results.r = [0:obj.Rate]*dr;
results.K = K;

end

./MATLAB/+smi_cluster/@StatisticsClustering/ripley_ROIcombined.m
function results = ripley_ROIcombined(obj, n_ROIs, RoI)
% Use Ripley's statistics to test the clustering of a series of ROIs
% all of the same size.
%
% INPUTS:
%    obj         various properties used by the algorithms
%       Font_props      [{'FontSize', 15, 'FontWeight', 'bold'}]
%       Line_props      [{'LineWidth', 3}]
%       Fig_ext         figure extension
%       ResultsDir      directory to store results
%       BaseName        name to identify saved plots, which will have various
%                       descriptive suffixes attached
%       Rate            [ 20]    sampling rate for statistical functions
%       Ripley_cutoff   [200]    Ripley distance cutoff (nm)
%    n_ROIs      number of ROIs to combine
%    RoI         n_ROIs cell array containing the following fields (nm):
%       ROI      ROI limits in the form
%                   [x_min, x_max, y_min, y_max {, z_min, z_max}]
%       X,Y{,Z}  (x, y, z) coordinates of points inside where X, Y, Z are of
%                the form {[n1 x 1]}, that is, referenced by X{1}
%
% OUTPUTS:
%    results     results structure:
%       r           r-axis: [0 : obj.Rate] * dr
%       K           K(r)

% Originally written by Michael Wester and Stanly Steinberg in 2008; extended
% to 3D and combined ROIs in 2017--2018.

base_name = obj.BaseName;
b_n = regexprep(base_name, '_', '\\_');

% Dimension (2D or 3D)
dim = 2;
if isfield(RoI{1}, 'Z') && numel(RoI{1}.Z) > 0
   dim = 3;
end

% Divide the interval [0, cutoff] into Rate number of pieces of length dr.
% The look at the distance d between two points and add 1 to R(d/dr).
% This provides a PDF for the distances.
dr=obj.Ripley_cutoff/obj.Rate;
K = zeros(1, obj.Rate + 1);
for m = 1 : n_ROIs
   x_min = RoI{m}.ROI(1);
   x_max = RoI{m}.ROI(2);
   y_min = RoI{m}.ROI(3);
   y_max = RoI{m}.ROI(4);
   if dim == 3
      z_min = RoI{m}.ROI(5);
      z_max = RoI{m}.ROI(6);
   end

   if dim == 2
      X = [RoI{m}.X{1}, RoI{m}.Y{1}];
   else
      X = [RoI{m}.X{1}, RoI{m}.Y{1}, RoI{m}.Z{1}];
   end
   nX = length(X);
   R = zeros(1, obj.Rate);
   if dim == 2
      for i = 1 : nX
         for j = 1 : i - 1
            p = ceil(sqrt((X(j,1) - X(i,1))^2 + (X(j,2) - X(i,2))^2)/dr);
            if p > 0 & p <= obj.Rate
               R(p) = R(p) + 1;
            end
         end
      end
   else
      for i = 1 : nX
         for j = 1 : i - 1
            p = ceil(sqrt((X(j,1) - X(i,1))^2 + (X(j,2) - X(i,2))^2 + ...
                          (X(j,3) - X(i,3))^2)/dr);
            if p > 0 & p <= obj.Rate
               R(p) = R(p) + 1;
            end
         end
      end
   end
   % Add a zero to the beginning of R for nicer plotting.
   R = [0, R];
   % Compensate for the j=1:i-1 savings.
   R = 2*R;
   % Convert the PDF to a CDF.
   for i = 2 : length(R)
      R(i) = R(i) + R(i-1);
   end
   % Average over the number of particles.
   R = R/nX;
   % Compute the intensity and normalize R.
   if dim == 2
      lambda = nX/((x_max - x_min)*(y_max - y_min));
   else
      lambda = nX/((x_max - x_min)*(y_max - y_min)*(z_max - z_min));
   end
   R = R/lambda;
   % Accumulate over each ROI.
   K = K + R;
end
% Normalize over all ROIs.
K = K / n_ROIs;

% Plot Ripley
if ~isempty(obj.Fig_ext)
   figure('Visible', 'off');
else
   figure;
end
axes(obj.Font_props{:})
grid on
hold on
% The analytic expected value.
A = pi*([0:obj.Rate]*dr).^2;
plot([0:obj.Rate]*dr, A, 'k', obj.Line_props{:})
plot([0:obj.Rate]*dr, K, 'r', obj.Line_props{:})
legend({'random', 'probes'}, 'Location', 'NorthWest');
axis([0 obj.Ripley_cutoff 0 max(K)]);
xlabel('r (nm)');
ylabel('K(r)');
title(['Ripley K [RC] for ', b_n]);
hold off
name = fullfile(obj.ResultsDir, [base_name, '_ripleyK_RC']);
if ~isempty(obj.Fig_ext)
   print(['-d', obj.Fig_ext], name);
else
   saveas(gcf, name);
   delete(gcf);
end

% Plot sqrt of Ripley
if ~isempty(obj.Fig_ext)
   figure('Visible', 'off');
else
   figure;
end
axes(obj.Font_props{:})
hold on
grid on
M = sqrt(A/pi) - [0 : obj.Rate]*dr;
N = sqrt(K/pi) - [0 : obj.Rate]*dr;
plot([0:obj.Rate]*dr, M, 'k', obj.Line_props{:})
plot([0:obj.Rate]*dr, N, 'r', obj.Line_props{:})
legend({'random', 'probes'}, 'Location', 'Best');
xlabel('r (nm)');
ylabel('L(r) - r ');
title(['Ripley L(r) - r [RC] for ', b_n]);
hold off
name = fullfile(obj.ResultsDir, [base_name, '_ripleyL_RC']);
if ~isempty(obj.Fig_ext)
   print(['-d', obj.Fig_ext], name);
else
   saveas(gcf, name);
   delete(gcf);
end

% Plot Ripley/(pi*r^2) (in nm)
if ~isempty(obj.Fig_ext)
   figure('Visible', 'off');
else
   figure;
end
axes(obj.Font_props{:})
hold on
grid on
% Avoid dividing by 0.
M = A(2:length(A));
M = M./(pi*(dr*[1:obj.Rate]).^2);
N = K(2:length(K));
N = N./(pi*(dr*[1:obj.Rate]).^2);
plot([0:obj.Rate]*dr, [1, M], 'k', obj.Line_props{:});
plot([0:obj.Rate]*dr, [1, N], 'r', obj.Line_props{:});
legend({'random', 'probes'}, 'Location', 'Best');
axis([0 obj.Ripley_cutoff 0 max(N)]);
xlabel('r (nm)');
ylabel('K(r)/(\pi r^2)');
title(['Normalized Ripley [RC] for ', b_n]);
hold off
name = fullfile(obj.ResultsDir, [base_name, '_ripleyNormalized_RC']);
if ~isempty(obj.Fig_ext)
   print(['-d', obj.Fig_ext], name);
else
   saveas(gcf, name);
   delete(gcf);
end

results.r = [0:obj.Rate]*dr;
results.K = K;

end

./MATLAB/+smi_cluster/@StatisticsClustering/histogram.m
function [X,V]=histogram(A,ab,n)
% Written by Michael Wester and Stanly Steinberg in 2008.
% Sort A into bins whose edges are given by ab(1)+i*(ab(2)-ab(1))/n, i=0:n.
L = ab(2)-ab(1);
X = linspace(L/(2*n),1-L/(2*n),n);
V=zeros(1,n);
for i=1:length(A)
	k=floor(n*(A(i)-ab(1))/L)+1;
	V(k)=V(k) + 1;
end

end

./MATLAB/+smi_cluster/@StatisticsClustering/hopkins_ROIcombined.m
function H = hopkins_ROIcombined(obj, n_ROIs, RoI)
% Use Hopkins' statistics to test the clustering of a series of ROIs.
%
% INPUTS:
%    obj         various properties used by the algorithms
%       Font_props      [{'FontSize', 15, 'FontWeight', 'bold'}]
%       Fig_ext         figure extension
%       ResultsDir      directory to store results
%       BaseName        name to identify saved plots, which will have various
%                       descriptive suffixes attached
%       Xlim            []       x-axis limits if defined
%       Ylim            []       y-axis limits if defined
%    n_ROIs      number of ROIs to combine
%    ROIs        n_ROIs cell array containing the following fields (nm):
%       ROI      ROI limits in the form
%                   [x_min, x_max, y_min, y_max {, z_min, z_max}]
%       X,Y{,Z}  (x, y, z) coordinates of points inside where X, Y, Z are of
%                the form {[n1 x 1]}, that is, referenced by X{1}
% OUTPUTS:
%    H           mean Hopkin's statistic (over ntests) for each ROI

% Originally written by Michael Wester and Stanly Steinberg in 2008; extended
% to 3D and combined ROIs in 2017--2018.

base_name = obj.BaseName;

test = 5;        % The number of test points.
ntests = 1000;   % The number of Hopkins statistics to use.

% Dimension (2D or 3D)
dim = 2;
if isfield(RoI{1}, 'Z') && numel(RoI{1}.Z) > 0
   dim = 3;
end

% Compute ntests Hopkins' statistics (using test probes) for each ROI.
H  = zeros(1, n_ROIs);
HS = zeros(1, ntests);
for i = 1 : n_ROIs
   if dim == 2
      X = [RoI{i}.X{1}, RoI{i}.Y{1}];
   else
      X = [RoI{i}.X{1}, RoI{i}.Y{1}, RoI{i}.Z{1}];
   end
   ROI = RoI{i}.ROI;
   x_min = ROI(1);
   x_max = ROI(2);
   y_min = ROI(3);
   y_max = ROI(4);
   % hopkinstat assumes the region is [0, x_max - x_min] x [0, y_max - y_min],
   % so shift the coordinates appropriately.
   X(:, 1) = X(:, 1) - x_min;
   X(:, 2) = X(:, 2) - y_min;
   if dim == 2
      for j = 1 : ntests
         HS(j) = smi_cluster.StatisticsClustering.hopkinstat( ...
                    X, x_max - x_min, y_max - y_min, test);
      end
   else
      z_min = ROI(5);
      z_max = ROI(6);
      X(:, 3) = X(:, 3) - z_min;
      for j = 1 : ntests
         HS(j) = smi_cluster.StatisticsClustering.hopkinstat3( ...
                    X, x_max - x_min, y_max - y_min, ...
                                            z_max - z_min, test);
      end
   end
   % H(i) will be the mean of the ntests Hopkins' statistics for ROI i.
   H(i) = mean(HS);
end

if isempty(base_name)
   return;
end

base_text = regexprep(base_name, '_', '\\_');

% Plot a histogram of the findings.
if ~isempty(obj.Fig_ext)
   figure('Visible', 'off');
else
   figure;
end
axes(obj.Font_props{:})
hold on
histogram(H, 25);
xlim([0, 1]);
if ~isempty(obj.Xlim)
    xlim(obj.Xlim);
end
title([base_text, ' [all ROIs]']);
xlabel('H (Hopkins statistic)');
ylabel('frequency');
hold off
name = fullfile(obj.ResultsDir, [base_name, '_hopkins_RC']);
if ~isempty(obj.Fig_ext)
   print(['-d', obj.Fig_ext], name);
else
   saveas(gcf, name);
   delete(gcf);
end

% Plot a PDF of the findings.
if ~isempty(obj.Fig_ext)
   figure('Visible', 'off');
else
   figure;
end
axes(obj.Font_props{:})
hold on
% For some reason, Normalization = PDF does not work correctly, but probability
% does, so ...
%histogram(H, 25, 'Normalization', 'PDF');
histogram(H, 25, 'Normalization', 'probability');
xlim([0, 1]);
ylim([0, 1]);
if ~isempty(obj.Xlim)
    xlim(obj.Xlim);
end
if ~isempty(obj.Ylim)
    ylim(obj.Ylim);
end
title([base_text, ' [all ROIs]']);
xlabel('H (Hopkins statistic)');
ylabel('probability');
hold off
name = fullfile(obj.ResultsDir, [base_name, '_hopkins_PDF_RC']);
if ~isempty(obj.Fig_ext)
   print(['-d', obj.Fig_ext], name);
else
   saveas(gcf, name);
   delete(gcf);
end

end

./MATLAB/+smi_cluster/@StatisticsClustering/hopkinstat.m
function H = hopkinstat(P,A,B,mm)
% Compute a Hopkin's statistic for the 2D particles P.
% Written by Michael Wester and Stanly Steinberg in 2008.
% The particle region is [0,A] x [0,B] .
% m is the number of tests points.
% n is the number of particles.
%n = length(P);
n = numel(P) / 2;
m = min(mm, n);
% Create the indices of m test particles.
index = [0,m+1];
while ( (length(index) < m) | (index(1) < 1) | (index(end) > n) )
   index = unique(round(1/2+n*rand(m,1)));
end
T = P(index,:);
% Create m test points
S = rand(m,2)*diag([A,B]);
% Compute the minimum distance.
U = ones(1,m)*sqrt(A^2+B^2);
% W = ones(1,m)*sqrt(A^2+B^2);
W = U;
for k = 1:m
   for i = 1:n
      dist = sqrt((S(k,1)-P(i,1))^2 + (S(k,2)-P(i,2))^2);
      if dist > 0 
         U(k) = min(U(k), dist);
      end

      dist = sqrt((T(k,1)-P(i,1))^2 + (T(k,2)-P(i,2))^2);
      if dist > 0 
         W(k) = min(W(k), dist);
      end
   end
end
H = (sum(U.^2)/(sum(U.^2)+sum(W.^2)));

end

./MATLAB/+smi_cluster/@StatisticsClustering/pairwiseDist.m
function results = pairwiseDist(obj, particle_types, SMD)
%pairwiseDist plots pairwise distances and CDFs.
%
% INPUTS:
%    obj             various properties used by the algorithms
%       Font_props      [{'FontSize', 15, 'FontWeight', 'bold'}]
%       Line_props      [{'LineWidth', 3}]
%       Fig_ext         figure extension
%       ResultsDir      directory to store results
%       BaseName        name to identify saved plots, which will have various
%                       descriptive suffixes attached
%       Nsims           number of random simulations to perform
%    particle_types  cell array of particle types (names)
%                    e.g., particle_types = {'5', '10'};
%    SMD              (x, y) coordinates of the dataset (nm) in the format
%                     (1) SMD structure: SMD.X and SMD.Y,
%                     (2) N x 2 array of coordinates,
%                     (3) RoI struct with fields (nm):
%       ROI               [x_min, x_max, y_min, y_max, {z_min, z_max}]] of ROI
%       X, Y{, Z}         (x, y, z) coordinates of points inside where X, Y, Z
%                         are of the form {[n1 x 1]}
%
% OUTPUTS:
%    results         results structure:
%       bins            number of histogram bins
%       sims            number of random simulations performed
%       x_, y_          cell array of point coordinates for random simulations
%       y_r             mean y-random coordinates

% Created by
%    Michael J. Wester (2020)

   base_name = obj.BaseName;
   base_text = regexprep(base_name, '_', '\\_');

   % Dimension (2D or 3D)
   dim = 2;
   if iscell(SMD) && ismatrix(SMD) && isfield(SMD{1}, 'ROI')
      RoI = SMD;
      if isfield(RoI{1}, 'Z') && numel(RoI{1}.Z) > 0
         dim = 3;
      end
   elseif ismatrix(SMD) && size(SMD, 2) > 1
      RoI{1}.X = {SMD(:, 1)};
      RoI{1}.Y = {SMD(:, 2)};
      if size(SMD, 2) == 3
         dim == 3;
         RoI{1}.Z = {SMD1(:, 3)};
      end
   elseif isstruct(SMD)
      RoI{1}.X = {SMD.X};
      RoI{1}.Y = {SMD.Y};
      if isfield(SMD, 'Z') && numel(SMD.Z) > 0
         dim == 3;
         RoI{1}.Z = {SMD.Z};
      end
   else
      error('Unrecognized format for SMD1/SMD2!');
   end

   bins = 100;
   sims = obj.Nsims;
   %sims = 20;

   for m = 1 : length(particle_types)
      if ~isempty(obj.Fig_ext)
         figure('Visible', 'off');
      else
         figure;
      end
      axes(obj.Font_props{:})
      hold on

      if dim == 2
         X = [RoI{1}.X{m}, RoI{1}.Y{m}];
      else
         X = [RoI{1}.X{m}, RoI{1}.Y{m}, RoI{1}.Z{m}];
      end
      D = pdist(X);
      M = mean(D);
      S = std(D);

      % Establish the positions of the bin centers (x) based on a normal random
      % distribution that inherits its characteristics from the coordinates in
      % X given the specified number of bins (also, see comment below).
      Xr = M + S*randn(size(X));
      Dr = pdist(Xr);
      [~, x] = hist(Dr, bins);

      y = hist(D, x);
      plot(x, y, 'k-', obj.Line_props{:});

      % Create a random distribution with the same characteristics as X:
      % based on the same number of points, mean, standard deviation.  Average
      % over the specified number of simulations (sims).
      YR = 0;
      for i = 1 : sims
         Xr = M + S*randn(size(X));
         Dr = pdist(Xr);
         yr = hist(Dr, x);
         YR = YR + yr;
      end
      yr = YR / sims;
      plot(x, yr, 'r--', obj.Line_props{:});

      x_{m} = x;
      y_{m} = y;
      y_r{m} = yr;

      legend('data', 'random', 'Location', 'NorthEast');
      title(['Pairwise Distance PDF for ', base_text, '\_', ...
             particle_types{m}]);
      xlabel('distance (nm)');
      ylabel('frequency');
      hold off
      name = fullfile(obj.ResultsDir, ...
                      [base_name, '_', particle_types{m}, '_pairwisePDF']);
      if ~isempty(obj.Fig_ext)
         print(['-d', obj.Fig_ext], name);
      else
         saveas(gcf, name);
         delete(gcf);
      end

      if ~isempty(obj.Fig_ext)
         figure('Visible', 'off');
      else
         figure;
      end
      axes(obj.Font_props{:})
      hold on

      [f, xx] = ecdf(sort(D));
      plot(xx, f, 'k-', obj.Line_props{:});

      %f = cumsum(1 : numel(D));
      %f = f / f(end);
      %xx = sort(D);
      %plot(xx, f, 'b-', obj.Line_props{:});

      [fr, xxr] = ecdf(sort(Dr));
      plot(xxr, fr, 'r--', obj.Line_props{:});

      %fr = cumsum(1 : numel(Dr));
      %fr = fr / fr(end);
      %xxr = sort(Dr);
      %plot(xxr, fr, 'm--', obj.Line_props{:});

      legend('data', 'random', 'Location', 'SouthEast');
      title(['Pairwise Distance CDF for ', base_text, '\_', ...
             particle_types{m}]);
      xlabel('distance (nm)');
      ylabel('frequency');
      hold off
      name = fullfile(obj.ResultsDir, ...
                      [base_name, '_', particle_types{m}, '_pairwiseCDF']);
      if ~isempty(obj.Fig_ext)
         print(['-d', obj.Fig_ext], name);
      else
         saveas(gcf, name);
         delete(gcf);
      end
   end

results.bins = bins;
results.sims = sims;
results.x_ = x_;
results.y_ = y_;
results.y_r = y_r;

end

./MATLAB/+smi_cluster/@PairCorrelation/unitTest.m
% Test calling PairCorrelation routines.
function success = unitTest()

success = 0;

%% Demonstrate how to call the smi_cluster.PairCorrelation class.

SaveDir = smi_helpers.mkSMITETmpDir('unitTest', 'PairCorrelation');

PC = smi_cluster.PairCorrelation();
PC.ResultsDir = SaveDir;

% Generated data.
SZ = 1000;
x1 = SZ * rand(2 * SZ, 1);
y1 = SZ * rand(2 * SZ, 1);
XY1 = [x1, y1];
SMD1.X = x1;
SMD1.Y = y1;
x2 = [SZ * rand(3 * SZ, 1)];
y2 = [SZ * rand(3 * SZ, 1)];
XY2 = [x2, y2];
SMD2.X = x2;
SMD2.Y = y2;

PC.ROI = [0, SZ, 0, SZ];   % [x_min, x_max, y_min, y_max]
% These two numbers below are often the same, but the user can increase
% HistBinSize to make bigger internal pixels (or bigger internal histogram
% image bins) and so produce more smoothing, or decrease this quantity and
% attempt greater detail.
PC.PixelSize = 1;         % Actual camera pixel size (nm).
PC.HistBinSize = 1;       % Internal image pixel size (nm).

% Make a RoI structure (see also smi_cluster.ROITools).  This is typically
% used for invoking pair_correlation_ROIcombined with multiple ROIs, which
% are combined.  The size of each ROI need not be the same, although
% cleaner results will be produced if they are all the same size.
n_ROIs = 1;
RoI{1}.ROI = PC.ROI;
RoI{1}.X   = {XY1(:, 1), XY2(:, 1)};
RoI{1}.Y   = {XY1(:, 2), XY2(:, 2)};

% Typically, pair_correlation is used for comparing two images/ROIs, while
% pair_correlation_ROIcombined is used when combining the pair correlation
% results for several pairs of images/ROIs.  pair_correlation_Veatch is
% basically the original Sarah Veatch code left for comparison purposes.
% The results of all three routines in these examples should produce
% similar results (identical for the first two when n_ROIs = 1).
% NOTE: SMD structures or XY matrices can be provided as input.
PC.BaseName = '9021';
results_pcc  = PC.pair_correlation(SMD1, SMD2)
results_pcc  = PC.pair_correlation(XY1, XY2)
results_Rpcc = PC.pair_correlation_ROIcombined(2, n_ROIs, RoI)
results_Vpcc = PC.pair_correlation_Veatch(SMD1, SMD2, 'cross')
results_Vpcc = PC.pair_correlation_Veatch(XY1, XY2, 'cross')

% Auto correlation.
PC.BaseName = '9021_5';
results_pac1  = PC.pair_correlation(SMD1)
results_pac1  = PC.pair_correlation(XY1)
results_Rpacc = PC.pair_correlation_ROIcombined(1, n_ROIs, RoI, 1)
results_Vpac1 = PC.pair_correlation_Veatch(SMD1,  [], 'auto')
results_Vpac1 = PC.pair_correlation_Veatch(XY1,  [], 'auto')

% Auto correlation.
PC.BaseName = '9021_10';
results_pac2  = PC.pair_correlation(SMD2)
results_pac2  = PC.pair_correlation(XY2)
results_Rpac2 = PC.pair_correlation_ROIcombined(1, n_ROIs, RoI, 2)
results_Vpac2 = PC.pair_correlation_Veatch(SMD2, [], 'auto')
results_Vpac2 = PC.pair_correlation_Veatch(XY2, [], 'auto')

fprintf('Done pair correlation.\n');
fprintf('All results in %s\n', PC.ResultsDir);

success = 1;

end

./MATLAB/+smi_cluster/@PairCorrelation/pair_correlation_ROIcombined.m
function results = pair_correlation_ROIcombined(obj, n_labels, n_ROIs, ...
                                                ROIs, label_num)
% Combine ROIs while performing pair correlation.
% Modified from code originally written by Carolyn Pehlke.
%
% INPUTS:
%    obj           various properties used by the algorithms
%       BaseName      descriptive name for the results files
%       Fig_ext       figure extension
%       Font_props    [{'FontSize', 15, 'FontWeight', 'bold'}]
%       HistBinSize   histogram bin size sometims known as pixel size (nm)
%       Lines         if true, plot lines rather than points for g(r) vs. r
%       ResultsDir    directory to store results
%       Rmax_axis     sets plotting limit if > 0
%    n_labels      number of different labeled particles:
%                  1 -> auto-correlation, 2 -> cross_correlation
%    n_ROIs        number of ROIs to combine
%    ROIs          contains (x, y) coordinates of the two datasets (nm)---see
%                  smi_helpers.ROITools
%    label_num     [OPTIONAL] if n_labels = 1, then whether x1, y1 or x2, y2
%                  should be used for the coordinates contained in ROIs
%
% OUTPUTS:
%    results       structure containing various results from the algorithm

   if n_labels == 2
      corr_type = 'C';   % cross-correlation
   else
      corr_type = 'A';   % auto-correlation
   end

   base_name     = obj.BaseName;
   hist_bin_size = obj.HistBinSize;

   ROI_size = zeros(n_ROIs, 1);
   IM1 = cell(n_ROIs, 1);
   if corr_type == 'C'
      IM2 = cell(n_ROIs, 1);
   end
   for j = 1 : n_ROIs
      x_min = ROIs{j}.ROI(1);
      x_max = ROIs{j}.ROI(2);
      y_min = ROIs{j}.ROI(3);
      y_max = ROIs{j}.ROI(4);
      ROI_size(j) = min(x_max - x_min, y_max - y_min);

      % Compute the number of pixels in x and y.
      imszX = round((x_max - x_min) / hist_bin_size);
      imszY = round((y_max - y_min) / hist_bin_size);
      % Create a blank image.
      im1 = zeros(imszX, imszY);
      if corr_type == 'C'
         im2 = zeros(imszX, imszY);
      end
      % Convert (x, y) coordinates into pixel units.
      if ~exist('label_num', 'var')
         label_num = 1;
      end
      if label_num == 1
         x1 = round((ROIs{j}.X{1} - x_min) / hist_bin_size) + 1;
         y1 = round((ROIs{j}.Y{1} - y_min) / hist_bin_size) + 1;
      elseif label_num == 2
         x1 = round((ROIs{j}.X{2} - x_min) / hist_bin_size) + 1;
         y1 = round((ROIs{j}.Y{2} - y_min) / hist_bin_size) + 1;
      else
         error('Invalid label_num: %d!', label_num);
      end
      if corr_type == 'C'
         x2 = round((ROIs{j}.X{2} - x_min) / hist_bin_size) + 1;
         y2 = round((ROIs{j}.Y{2} - y_min) / hist_bin_size) + 1;
      end
      % Get the pixels within the image size.
      mask1 = (x1 > 0) & (y1 > 0) & (x1 <= imszX) & (y1 <= imszY);
      x1 = x1(mask1);
      y1 = y1(mask1);
      if corr_type == 'C'
         mask2 = (x2 > 0) & (y2 > 0) & (x2 <= imszX) & (y2 <= imszY);
         x2 = x2(mask2);
         y2 = y2(mask2);
      end
      % Make a histogram image.
      for i = 1 : size(x1, 1)
         im1(x1(i), y1(i)) = im1(x1(i), y1(i)) + 1;
      end
      if corr_type == 'C'
         for i = 1 : size(x2, 1)
            im2(x2(i), y2(i)) = im2(x2(i), y2(i)) + 1;
         end
      end
      IM1{j} = im1;
      if corr_type == 'C'
         IM2{j} = im2;
      end
   end
   % Establish rmax as half the size of the ROI in pixels.
   rmax = round(min(ROI_size) / (2 * hist_bin_size));

   if corr_type == 'C'
      % Pair crosscorrelation using Veatch method.
      [G, r, g, dg, rmax] = ...
         smi_cluster.PairCorrelation.get_corr(n_ROIs, rmax, IM1, IM2);
   else
      % Pair autocorrelation using Veatch method.
      [G, r, g, dg, rmax] = ...
         smi_cluster.PairCorrelation.get_corr(n_ROIs, rmax, IM1);
   end

   % Convert back to nm
   r_nm = r * hist_bin_size;

   if corr_type == 'C'
      i1 = 0;   i2 = 0;   % intensity sums
      p1 = 0;   p2 = 0;   % pixel sums
      for i = 1 : n_ROIs
         i1 = i1 + sum(sum(IM1{i}));
         i2 = i2 + sum(sum(IM2{i}));
         p1 = p1 + prod(size(IM1{i}));
         p2 = p2 + prod(size(IM2{i}));
      end
      rho1 = i1 / p1;
      rho2 = i2 / p2;
      %rho1 = mean(mean(im1));
      %rho2 = mean(mean(im2));
      rho = sqrt(rho1 * rho2);
      %paircorr = [{[im1, im2]}, {[r', g', dg']}, {rho}, {G}];
   else
      i1 = 0;   % intensity sum
      p1 = 0;   % pixel sum
      for i = 1 : n_ROIs
         i1 = i1 + sum(sum(IM1{i}));
         p1 = p1 + prod(size(IM1{i}));
      end
      rho = i1 / p1;
      %rho = mean(mean(im1));
      %paircorr = [{im1}, {[r', g', dg']}, {rho}, {G}];
   end

   [estimates, errors, model] = ...
      smi_cluster.PairCorrelation.pc_GaussFit(r', g', rmax, rho);
   %  SMA_Cluster.pc_GaussFit(paircorr{2}(:,1), paircorr{2}(:,2), rmax, ...
   %                          paircorr{3});
   estimates = abs(estimates);

   if ~isempty(obj.Fig_ext)
      figure('Visible', 'off');
   else
      figure;
   end
   axes(obj.Font_props{:});
   hold on
   if ~isdir(obj.ResultsDir)
      mkdir(obj.ResultsDir);
   end
   if corr_type == 'C'
      name = fullfile(obj.ResultsDir, [base_name, '_crosscorrR']);
   else
      name = fullfile(obj.ResultsDir, [base_name, '_autocorrR']);
   end
   if obj.Lines
      plot(r_nm(2:end),g(2:end),'k.-','MarkerSize',20,'LineWidth',2)
      %plot(r_nm(2:end),paircorr{2}(2:end,2),'k.-', ...
      %     'MarkerSize',20,'LineWidth',2)
   else
      plot(r_nm(2:end),g(2:end),'k.','MarkerSize',10,'LineWidth',2)
      %plot(r_nm(2:end),paircorr{2}(2:end,2),'k.','MarkerSize',10,'LineWidth',2)
   end
   plot(r_nm(2:end),ones(1, numel(r) - 1),'b:','LineWidth',3)
   plot(r_nm(2:end),model(2:end),'--r','LineWidth',3)
   if corr_type == 'C'
      flegend{1} = 'Cross-Correlation';
   else
      flegend{1} = 'Auto-Correlation';
   end
   flegend{2} = 'g(r) Random';
   flegend{3} = 'Fit';
   axis tight
   if obj.Rmax_axis > 0
      xlim([0, obj.Rmax_axis]);
   end
   title(regexprep(base_name, '_', '\\_'));
   xlabel('r (nm)');
   ylabel('g(r)');
   legend(flegend, 'Location', 'Best');
   hold off

   if ~isempty(obj.Fig_ext)
      print(['-d', obj.Fig_ext], name);
      saveas(gcf, name);
   else
      saveas(gcf, name);
      delete(gcf);
   end

   Afound=estimates(1);
   s_d_found_pixels=estimates(2);
   Bfound=estimates(3);
   s_l_found_pixels=estimates(4);

   Afound_SE=errors(1);
   s_d_found_pixels_SE=errors(2);
   Bfound_SE=errors(3);
   s_l_found_pixels_SE=errors(4);

   s_d_found=s_d_found_pixels*hist_bin_size;
   s_l_found=s_l_found_pixels*hist_bin_size;
   s_d_found_SE=s_d_found_pixels_SE*hist_bin_size;
   s_l_found_SE=s_l_found_pixels_SE*hist_bin_size;

   % display results
   if corr_type == 'C'
      fprintf('Pair Cross-correlation for %s:\n\n', base_name);
   else
      fprintf('Pair Auto-correlation for %s:\n\n', base_name);
   end

   fprintf('Objects per domain ');
   fprintf('found:\t%5.3g +/- %5.3g\n',Afound,Afound_SE);

   fprintf('Domain size sigma ');
   fprintf('found:\t%5.3g +/- %5.3g\n',s_d_found,s_d_found_SE);

   fprintf('Localizations per object ');
   fprintf('found:\t%5.3g +/- %5.3g\n',Bfound,Bfound_SE);

   fprintf('Localization precision sigma ');
   fprintf('found:\t%5.3g +/- %5.3g\n',s_l_found,s_l_found_SE);

   results.G  = G;
   results.r  = r_nm;
   results.g  = g;
   results.dg = dg;
   results.objs_per_domain          = Afound;
   results.objs_per_domain_SE       = Afound_SE;
   results.sigma_domain             = s_d_found;
   results.sigma_domain_SE          = s_d_found_SE;
   results.localizations_per_obj    = Bfound;
   results.localizations_per_obj_SE = Bfound_SE;
   results.sigma_localization       = s_l_found;
   results.sigma_localization_SE    = s_l_found_SE;
   results.model = model;

end

./MATLAB/+smi_cluster/@PairCorrelation/get_corr.m
function [C, r, c, dc, rmax] = get_corr(n_ROIs, rmax, II1, II2)
% function [G, r, g, dg] = get_crosscorr(I1, I2, rmax)
% calculates autocorrelation function for two dimensional images
%
% INPUTS
% nROIs = number of ROIs to be correlated
% II1 = cell array of ROI images in first  image to be autocorrelated
% II2 = cell array of ROI images in second image to be autocorrelated
% rmax = maximum r value to correlate in units of pixels.
%
% OUTPUTS
% C = two dimensional cross-correlation function.  x and y values range between
%    -rmax:rmax
% r = radius values
% c = angularly averaged autocorrelation function.
% dc = errors on angularly averaged g
% rmax = adjusted input rmax value
%
% NOTE: G(r=0) is just the dot product of the image.  For display purposes,
% G(r=0) is set to zero in the 2D autocorrelation output.  g(r=0) [g(1)]
% retains the proper value.
%
% Last updated 01.24.11 by Sarah Veatch.

% Modified by
%    Michael J. Wester (2021)

if exist('II2', 'var')
   corr_type = 'C';
else
   corr_type = 'A';
end

L1min = 1e+10;
L2min = 1e+10;
L1max = -1;
L2max = -1;
for i = 1 : n_ROIs
   L1 = size(II1{i}, 1)+rmax; % size of fft2 (for zero padding)
   L2 = size(II1{i}, 2)+rmax; % size of fft2 (for zero padding)
   L1min = min(L1min, L1);
   L2min = min(L2min, L2);
   L1max = max(L1max, L1);
   L2max = max(L2max, L2);
end
Lmax_min = min(L1max, L2max);

% Adjust rmax if it is too big and would cause problems cropping C1:
%    Need floor(Lmax_min/2+1) - rmax >= 1
if floor(Lmax_min/2) < rmax
   fprintf('rmax adjusted from %.1f to ', rmax);
   rmax = floor(Lmax_min/2);
   fprintf('%.1f\n', rmax);
end

sum_A  = 0;
sum_N1 = 0;
sum_N2 = 0;
sum_FF = 0;
sum_NP = 0;
for i = 1 : n_ROIs
   I1 = II1{i};
   if corr_type == 'C'
      I2 = II2{i};
      if sum(size(I1)==size(I2))<2,
         disp('images are not the same size')
         return
      end
   end

   N1 = sum(sum(I1));        % Total intensity in I1
   if corr_type == 'C'
      N2 = sum(sum(I2));     % Total intensity in I2
   end
   A = prod(size(I1));       % area of mask
   mask = ones(size(I1));

   I1 = double(I1);          % convert to double
   if corr_type == 'C'
      I2 = double(I2);       % convert to double
   end

   %L1 = size(I1, 1)+rmax;    % size of fft2 (for zero padding)
   %L2 = size(I1, 2)+rmax;    % size of fft2 (for zero padding)

   % Normalization for correct boundary conditions
   % Center the (L1, L2) size mask within the maximal (L1max, L2max) extents.
   NP = real(fftshift(ifft2(abs(fft2(mask, L1max, L2max)).^2)));
   %NP = real(fftshift(ifft2(abs(fft2(mask, L1, L2)).^2)));
   % Collect the image areas (C1_A), image intensities (C1_N1 and C1_N2), FFT
   % transforms (C1_FF) and normalizations (C1_NP) separately, the last two
   % centered within the maximal rectangular extents (L1max, L2max), computing
   % the averaged C1 after the end of the loop.
   if corr_type == 'C'
      C1_A  = A;
      C1_N1 = N1;
      C1_N2 = N2;
      C1_FF = real(fftshift(ifft2(fft2(I1, L1max, L2max).* ...
                             conj(fft2(I2, L1max, L2max)))));
      C1_NP = NP;
      %C1 = A^2/N1/N2*real(fftshift(ifft2(fft2(I1, L1, L2).* ...
      %                              conj(fft2(I2, L1, L2)))))./NP;
   else
      % 2D G(r) with proper normalization
      C1_A  = A;
      C1_N1 = N1;
      C1_N2 = N1;
      C1_FF = real(fftshift(ifft2(abs(fft2(I1, L1max, L2max)).^2)));
      C1_NP = NP;
      %C1 = A^2/N1^2*real(fftshift(ifft2(abs(fft2(I1, L1, L2)).^2)))./NP;
   end

   sum_A  = sum_A  + C1_A ;
   sum_N1 = sum_N1 + C1_N1;
   sum_N2 = sum_N2 + C1_N2;
   sum_FF = sum_FF + C1_FF;
   sum_NP = sum_NP + C1_NP;
end
C1 = sum_A^2 / (sum_N1 * sum_N2) * sum_FF ./ sum_NP;

%only return valid part of G:
% a square with sides 2*rmax+1 about the center pixel, that is, the minimal
% rectangular region corresponding to the overlap of all the ROIs.
C = imcrop(C1, [floor(L2max/2+1)-rmax, floor(L1max/2+1)-rmax, 2*rmax, 2*rmax]);
%C = imcrop(C1, [floor(L2/2+1)-rmax, floor(L1/2+1)-rmax, 2*rmax, 2*rmax]);

xvals = ones(1, 2*rmax+1)'*(-rmax:rmax); %map to x positions with center x=0
yvals = (-rmax:rmax)'*ones(1, 2*rmax+1); %map to y positions with center y=0
zvals = C;

% convert x, y to polar coordinates
[theta,r,v] = cart2pol(xvals, yvals, zvals);

% Label each pixel in the minimal square region by its radius r from the
% center, then sort the r's and bin them.  Collect the pixels with radii in
% each bin and average the results to compute c(r).
Ar = reshape(r,1, (2*rmax+1)^2);
Avals = reshape(v,1, (2*rmax+1)^2);
[rr,ind] = sort(Ar);                  % sort by r values
vv = Avals(ind);                      % reindex g
r = 0:floor(max(rr));                 % the radii you want to extract
[n bin] = histc(rr, r-.5);            % bin by radius

for j = 1:rmax+1;                     % now get averages
   m = bin==j;
   n2 = sum(m);                       % the number of pixels in that bin
   if n2==0, vals(j)=0; er(j)=0;      % if no bins, no data
   else
      c(j) = sum(m.*vv)/n2;           % the average G values in this bin
                                      % the variance of the mean
      dc(j) = sqrt(sum(m.*(vv-c(j)).^2))/n2;
   end
end

r = 0:rmax;

end

./MATLAB/+smi_cluster/@PairCorrelation/pc_GaussFit.m
% Fitting pair correlation results written by Keith Lidke
    function [ estimates errors model ] = pc_GaussFit( r,g_r,rmax,rho )
    %PC_GaussFit Fit Pair Correlation to Gaussian domain model
    %
    % INPUTS
    %   r:      correlation length
    %   g_r:    radially averaged correlation
    %   rmax:   limit of correlation fit region
    %   rho:    localization density
    %
    % OUTPUTS
    %   estimates:  estimated parameter values
    %       estimates(1):   objects per domain
    %       estimates(2):   sigma for 2D gaussian domain size
    %       estimages(3):   observations per object
    %       estimates(4):   sigma for Gaussian localization precision
    %   errors:     standard error on estimates calculated as
    %       sqrt(diag(inv(hessian)))
    %   model:      model caculated at estimated value
    %
    %   NOTES:
    %   Requires DERIVESTsuite for hessian calculation (relevant functions
    %   are included below)
    %
    %   r(1) and g_r(1) not used in fit
    A = sqrt(g_r(2));
    B = A;
    X0=abs([A 20 B 20]);
    fitfunc=@Gauss2D;

    rfit=r(2:rmax);
    g_rfit=g_r(2:rmax);

    opts=optimset('MaxFunEvals',1e4,'Display','off','TolX',10^-6,'TolFun',10^-6);
    [estimates sse]= fminsearch(fitfunc,X0,opts,rfit,g_rfit,rho);

    anonfunc=@(X) Gauss2D(X,rfit,g_rfit,rho);
    [H Herrs]=hessian(anonfunc,estimates);
    errors=sqrt(diag(inv(H)))';

    [out model]=Gauss2D(estimates,r,g_r,rho);

    end

    function [out model]=Gauss2D(X0,r,g_r,rho)

    gnorm=inline('1/(2*pi*s^2)*exp(-r.^2/(2*s^2))','s','r');

    A=X0(1);
    sigma_dom=X0(2);
    B=X0(3);
    sigma_loc=X0(4);

    gr_psf=1/rho*gnorm(sqrt(2)*sigma_loc,r)*B;
    seff=sqrt(2*sigma_loc^2+2*sigma_dom^2);
    gr_dom=1/rho*gnorm(seff,r)*A*B;
    model=gr_psf+gr_dom+1;
    out=mean((model-g_r).^2); %mse(model,g_r);

    end

% =============================================================================

function [der,errest,finaldelta] = derivest(fun,x0,varargin)
% DERIVEST: estimate the n'th derivative of fun at x0, provide an error estimate
% usage: [der,errest] = DERIVEST(fun,x0)  % first derivative
% usage: [der,errest] = DERIVEST(fun,x0,prop1,val1,prop2,val2,...)
%
% Derivest will perform numerical differentiation of an
% analytical function provided in fun. It will not
% differentiate a function provided as data. Use gradient
% for that purpose, or differentiate a spline model.
%
% The methods used by DERIVEST are finite difference
% approximations of various orders, coupled with a generalized
% (multiple term) Romberg extrapolation. This also yields
% the error estimate provided. DERIVEST uses a semi-adaptive
% scheme to provide the best estimate that it can by its
% automatic choice of a differencing interval.
%
% Finally, While I have not written this function for the
% absolute maximum speed, speed was a major consideration
% in the algorithmic design. Maximum accuracy was my main goal.
%
%
% Arguments (input)
%  fun - function to differentiate. May be an inline function,
%        anonymous, or an m-file. fun will be sampled at a set
%        of distinct points for each element of x0. If there are
%        additional parameters to be passed into fun, then use of
%        an anonymous function is recommended.
%
%        fun should be vectorized to allow evaluation at multiple
%        locations at once. This will provide the best possible
%        speed. IF fun is not so vectorized, then you MUST set
%        'vectorized' property to 'no', so that derivest will
%        then call your function sequentially instead.
%
%        Fun is assumed to return a result of the same
%        shape as its input x0.
%
%  x0  - scalar, vector, or array of points at which to
%        differentiate fun.
%
% Additional inputs must be in the form of property/value pairs.
%  Properties are character strings. They may be shortened
%  to the extent that they are unambiguous. Properties are
%  not case sensitive. Valid property names are:
%
%  'DerivativeOrder', 'MethodOrder', 'Style', 'RombergTerms'
%  'FixedStep', 'MaxStep'
%
%  All properties have default values, chosen as intelligently
%  as I could manage. Values that are character strings may
%  also be unambiguously shortened. The legal values for each
%  property are:
%
%  'DerivativeOrder' - specifies the derivative order estimated.
%        Must be a positive integer from the set [1,2,3,4].
%
%        DEFAULT: 1 (first derivative of fun)
%
%  'MethodOrder' - specifies the order of the basic method
%        used for the estimation.
%
%        For 'central' methods, must be a positive integer
%        from the set [2,4].
%
%        For 'forward' or 'backward' difference methods,
%        must be a positive integer from the set [1,2,3,4].
%
%        DEFAULT: 4 (a second order method)
%
%        Note: higher order methods will generally be more
%        accurate, but may also suffere more from numerical
%        problems.
%
%        Note: First order methods would usually not be
%        recommended.
%
%  'Style' - specifies the style of the basic method
%        used for the estimation. 'central', 'forward',
%        or 'backwards' difference methods are used.
%
%        Must be one of 'Central', 'forward', 'backward'.
%
%        DEFAULT: 'Central'
%
%        Note: Central difference methods are usually the
%        most accurate, but sometiems one must not allow
%        evaluation in one direction or the other.
%
%  'RombergTerms' - Allows the user to specify the generalized
%        Romberg extrapolation method used, or turn it off
%        completely.
%
%        Must be a positive integer from the set [0,1,2,3].
%
%        DEFAULT: 2 (Two Romberg terms)
%
%        Note: 0 disables the Romberg step completely.
%
%  'FixedStep' - Allows the specification of a fixed step
%        size, preventing the adaptive logic from working.
%        This will be considerably faster, but not necessarily
%        as accurate as allowing the adaptive logic to run.
%
%        DEFAULT: []
%
%        Note: If specified, 'FixedStep' will define the
%        maximum excursion from x0 that will be used.
%
%  'Vectorized' - Derivest will normally assume that your
%        function can be safely evaluated at multiple locations
%        in a single call. This would minimize the overhead of
%        a loop and additional function call overhead. Some
%        functions are not easily vectorizable, but you may
%        (if your matlab release is new enough) be able to use
%        arrayfun to accomplish the vectorization.
%
%        When all else fails, set the 'vectorized' property
%        to 'no'. This will cause derivest to loop over the
%        successive function calls.
%
%        DEFAULT: 'yes'
%
%
%  'MaxStep' - Specifies the maximum excursion from x0 that
%        will be allowed, as a multiple of x0.
%
%        DEFAULT: 100
%
%  'StepRatio' - Derivest uses a proportionally cascaded
%        series of function evaluations, moving away from your
%        point of evaluation. The StepRatio is the ratio used
%        between sequential steps.
%
%        DEFAULT: 2.0000001
%
%        Note: use of a non-integer stepratio is intentional,
%        to avoid integer multiples of the period of a periodic
%        function under some circumstances.
%
%
% See the document DERIVEST.pdf for more explanation of the
% algorithms behind the parameters of DERIVEST. In most cases,
% I have chosen good values for these parameters, so the user
% should never need to specify anything other than possibly
% the DerivativeOrder. I've also tried to make my code robust
% enough that it will not need much. But complete flexibility
% is in there for your use.
%
%
% Arguments: (output)
%  der - derivative estimate for each element of x0
%        der will have the same shape as x0.
%
%  errest - 95% uncertainty estimate of the derivative, such that
%
%        abs(der(j) - f'(x0(j))) < erest(j)
%
%  finaldelta - The final overall stepsize chosen by DERIVEST
%
%
% Example usage:
%  First derivative of exp(x), at x == 1
%   [d,e]=derivest(@(x) exp(x),1)
%   d =
%       2.71828182845904
%
%   e =
%       1.02015503167879e-14
%
%  True derivative
%   exp(1)
%   ans =
%       2.71828182845905
%
% Example usage:
%  Third derivative of x.^3+x.^4, at x = [0,1]
%   derivest(@(x) x.^3 + x.^4,[0 1],'deriv',3)
%   ans =
%       6       30
%
%  True derivatives: [6,30]
%
%
% See also: gradient
%
%
% Author: John D'Errico
% e-mail: woodchips@rochester.rr.com
% Release: 1.0
% Release date: 12/27/2006

par.DerivativeOrder = 1;
par.MethodOrder = 4;
par.Style = 'central';
par.RombergTerms = 2;
par.FixedStep = [];
par.MaxStep = 100;
% setting a default stepratio as a non-integer prevents
% integer multiples of the initial point from being used.
% In turn that avoids some problems for periodic functions.
par.StepRatio = 2.0000001;
par.NominalStep = [];
par.Vectorized = 'yes';

na = length(varargin);
if (rem(na,2)==1)
  error 'Property/value pairs must come as PAIRS of arguments.'
elseif na>0
  par = parse_pv_pairs(par,varargin);
end
par = check_params(par);

% Was fun a string, or an inline/anonymous function?
if (nargin<1)
  help derivest
  return
elseif isempty(fun)
  error 'fun was not supplied.'
elseif ischar(fun)
  % a character function name
  fun = str2func(fun);
end

% no default for x0
if (nargin<2) || isempty(x0)
  error 'x0 was not supplied'
end
par.NominalStep = max(x0,0.02);

% was a single point supplied?
nx0 = size(x0);
n = prod(nx0);

% Set the steps to use.
if isempty(par.FixedStep)
  % Basic sequence of steps, relative to a stepsize of 1.
  delta = par.MaxStep*par.StepRatio .^(0:-1:-25)';
  ndel = length(delta);
else
  % Fixed, user supplied absolute sequence of steps.
  ndel = 3 + ceil(par.DerivativeOrder/2) + ...
     par.MethodOrder + par.RombergTerms;
  if par.Style(1) == 'c'
    ndel = ndel - 2;
  end
  delta = par.FixedStep*par.StepRatio .^(-(0:(ndel-1)))';
end

% generate finite differencing rule in advance.
% The rule is for a nominal unit step size, and will
% be scaled later to reflect the local step size.
fdarule = 1;
switch par.Style
  case 'central'
    % for central rules, we will reduce the load by an
    % even or odd transformation as appropriate.
    if par.MethodOrder==2
      switch par.DerivativeOrder
        case 1
          % the odd transformation did all the work
          fdarule = 1;
        case 2
          % the even transformation did all the work
          fdarule = 2;
        case 3
          % the odd transformation did most of the work, but
          % we need to kill off the linear term
          fdarule = [0 1]/fdamat(par.StepRatio,1,2);
        case 4
          % the even transformation did most of the work, but
          % we need to kill off the quadratic term
          fdarule = [0 1]/fdamat(par.StepRatio,2,2);
      end
    else
      % a 4th order method. We've already ruled out the 1st
      % order methods since these are central rules.
      switch par.DerivativeOrder
        case 1
          % the odd transformation did most of the work, but
          % we need to kill off the cubic term
          fdarule = [1 0]/fdamat(par.StepRatio,1,2);
        case 2
          % the even transformation did most of the work, but
          % we need to kill off the quartic term
          fdarule = [1 0]/fdamat(par.StepRatio,2,2);
        case 3
          % the odd transformation did much of the work, but
          % we need to kill off the linear & quintic terms
          fdarule = [0 1 0]/fdamat(par.StepRatio,1,3);
        case 4
          % the even transformation did much of the work, but
          % we need to kill off the quadratic and 6th order terms
          fdarule = [0 1 0]/fdamat(par.StepRatio,2,3);
      end
    end
  case {'forward' 'backward'}
    % These two cases are identical, except at the very end,
    % where a sign will be introduced.

    % No odd/even trans, but we already dropped
    % off the constant term
    if par.MethodOrder==1
      if par.DerivativeOrder==1
        % an easy one
        fdarule = 1;
      else
        % 2:4
        v = zeros(1,par.DerivativeOrder);
        v(par.DerivativeOrder) = 1;
        fdarule = v/fdamat(par.StepRatio,0,par.DerivativeOrder);
      end
    else
      % par.MethodOrder methods drop off the lower order terms,
      % plus terms directly above DerivativeOrder
      v = zeros(1,par.DerivativeOrder + par.MethodOrder - 1);
      v(par.DerivativeOrder) = 1;
      fdarule = v/fdamat(par.StepRatio,0,par.DerivativeOrder+par.MethodOrder-1);
    end

    % correct sign for the 'backward' rule
    if par.Style(1) == 'b'
      fdarule = -fdarule;
    end

end % switch on par.style (generating fdarule)
nfda = length(fdarule);

% will we need fun(x0)?
if (rem(par.DerivativeOrder,2) == 0) || ~strncmpi(par.Style,'central',7)
  if strcmpi(par.Vectorized,'yes')
    f_x0 = fun(x0);
  else
    % not vectorized, so loop
    f_x0 = zeros(size(x0));
    for j = 1:numel(x0)
      f_x0(j) = fun(x0(j));
    end
  end
else
  f_x0 = [];
end

% Loop over the elements of x0, reducing it to
% a scalar problem. Sorry, vectorization is not
% complete here, but this IS only a single loop.
der = zeros(nx0);
errest = der;
finaldelta = der;
for i = 1:n
  x0i = x0(i);
  h = par.NominalStep(i);

  % a central, forward or backwards differencing rule?
  % f_del is the set of all the function evaluations we
  % will generate. For a central rule, it will have the
  % even or odd transformation built in.
  if par.Style(1) == 'c'
    % A central rule, so we will need to evaluate
    % symmetrically around x0i.
    if strcmpi(par.Vectorized,'yes')
      f_plusdel = fun(x0i+h*delta);
      f_minusdel = fun(x0i-h*delta);
    else
      % not vectorized, so loop
      f_minusdel = zeros(size(delta));
      f_plusdel = zeros(size(delta));
      for j = 1:numel(delta)
        f_plusdel(j) = fun(x0i+h*delta(j));
        f_minusdel(j) = fun(x0i-h*delta(j));
      end
    end

    if ismember(par.DerivativeOrder,[1 3])
      % odd transformation
      f_del = (f_plusdel - f_minusdel)/2;
    else
      f_del = (f_plusdel + f_minusdel)/2 - f_x0(i);
    end
  elseif par.Style(1) == 'f'
    % forward rule
    % drop off the constant only
    if strcmpi(par.Vectorized,'yes')
      f_del = fun(x0i+h*delta) - f_x0(i);
    else
      % not vectorized, so loop
      f_del = zeros(size(delta));
      for j = 1:numel(delta)
        f_del(j) = fun(x0i+h*delta(j)) - f_x0(i);
      end
    end
  else
    % backward rule
    % drop off the constant only
    if strcmpi(par.Vectorized,'yes')
      f_del = fun(x0i-h*delta) - f_x0(i);
    else
      % not vectorized, so loop
      f_del = zeros(size(delta));
      for j = 1:numel(delta)
        f_del(j) = fun(x0i-h*delta(j)) - f_x0(i);
      end
    end
  end

  % check the size of f_del to ensure it was properly vectorized.
  f_del = f_del(:);
  if length(f_del)~=ndel
    error 'fun did not return the correct size result (fun must be vectorized)'
  end

  % Apply the finite difference rule at each delta, scaling
  % as appropriate for delta and the requested DerivativeOrder.
  % First, decide how many of these estimates we will end up with.
  ne = ndel + 1 - nfda - par.RombergTerms;

  % Form the initial derivative estimates from the chosen
  % finite difference method.
  der_init = vec2mat(f_del,ne,nfda)*fdarule.';

  % scale to reflect the local delta
  der_init = der_init(:)./(h*delta(1:ne)).^par.DerivativeOrder;

  % Each approximation that results is an approximation
  % of order par.DerivativeOrder to the desired derivative.
  % Additional (higher order, even or odd) terms in the
  % Taylor series also remain. Use a generalized (multi-term)
  % Romberg extrapolation to improve these estimates.
  switch par.Style
    case 'central'
      rombexpon = 2*(1:par.RombergTerms) + par.MethodOrder - 2;
    otherwise
      rombexpon = (1:par.RombergTerms) + par.MethodOrder - 1;
  end
  [der_romb,errors] = rombextrap(par.StepRatio,der_init,rombexpon);

  % Choose which result to return

  % first, trim off the
  if isempty(par.FixedStep)
    % trim off the estimates at each end of the scale
    nest = length(der_romb);
    switch par.DerivativeOrder
      case {1 2}
        trim = [1 2 nest-1 nest];
      case 3
        trim = [1:4 nest+(-3:0)];
      case 4
        trim = [1:6 nest+(-5:0)];
    end

    [der_romb,tags] = sort(der_romb);

    der_romb(trim) = [];
    tags(trim) = [];
    errors = errors(tags);
    trimdelta = delta(tags);

    [errest(i),ind] = min(errors);

    finaldelta(i) = h*trimdelta(ind);
    der(i) = der_romb(ind);
  else
    [errest(i),ind] = min(errors);
    finaldelta(i) = h*delta(ind);
    der(i) = der_romb(ind);
  end
end

end % mainline end

% ============================================
% subfunction - romberg extrapolation
% ============================================
function [der_romb,errest] = rombextrap(StepRatio,der_init,rombexpon)
% do romberg extrapolation for each estimate
%
%  StepRatio - Ratio decrease in step
%  der_init - initial derivative estimates
%  rombexpon - higher order terms to cancel using the romberg step
%
%  der_romb - derivative estimates returned
%  errest - error estimates
%  amp - noise amplification factor due to the romberg step

srinv = 1/StepRatio;

% do nothing if no romberg terms
nexpon = length(rombexpon);
rmat = ones(nexpon+2,nexpon+1);
switch nexpon
  case 0
    % rmat is simple: ones(2,1)
  case 1
    % only one romberg term
    rmat(2,2) = srinv^rombexpon;
    rmat(3,2) = srinv^(2*rombexpon);
  case 2
    % two romberg terms
    rmat(2,2:3) = srinv.^rombexpon;
    rmat(3,2:3) = srinv.^(2*rombexpon);
    rmat(4,2:3) = srinv.^(3*rombexpon);
  case 3
    % three romberg terms
    rmat(2,2:4) = srinv.^rombexpon;
    rmat(3,2:4) = srinv.^(2*rombexpon);
    rmat(4,2:4) = srinv.^(3*rombexpon);
    rmat(5,2:4) = srinv.^(4*rombexpon);
end

% qr factorization used for the extrapolation as well
% as the uncertainty estimates
[qromb,rromb] = qr(rmat,0);

% the noise amplification is further amplified by the Romberg step.
% amp = cond(rromb);

% this does the extrapolation to a zero step size.
ne = length(der_init);
rhs = vec2mat(der_init,nexpon+2,max(1,ne - (nexpon+2)));
rombcoefs = rromb\(qromb.'*rhs);
der_romb = rombcoefs(1,:).';

% uncertainty estimate of derivative prediction
s = sqrt(sum((rhs - rmat*rombcoefs).^2,1));
rinv = rromb\eye(nexpon+1);
cov1 = sum(rinv.^2,2); % 1 spare dof
errest = s.'*12.7062047361747*sqrt(cov1(1));

end % rombextrap


% ============================================
% subfunction - vec2mat
% ============================================
function mat = vec2mat(vec,n,m)
% forms the matrix M, such that M(i,j) = vec(i+j-1)
[i,j] = ndgrid(1:n,0:m-1);
ind = i+j;
mat = vec(ind);
if n==1
  mat = mat.';
end

end % vec2mat


% ============================================
% subfunction - fdamat
% ============================================
function mat = fdamat(sr,parity,nterms)
% Compute matrix for fda derivation.
% parity can be
%   0 (one sided, all terms included but zeroth order)
%   1 (only odd terms included)
%   2 (only even terms included)
% nterms - number of terms

% sr is the ratio between successive steps
srinv = 1./sr;

switch parity
  case 0
    % single sided rule
    [i,j] = ndgrid(1:nterms);
    c = 1./factorial(1:nterms);
    mat = c(j).*srinv.^((i-1).*j);
  case 1
    % odd order derivative
    [i,j] = ndgrid(1:nterms);
    c = 1./factorial(1:2:(2*nterms));
    mat = c(j).*srinv.^((i-1).*(2*j-1));
  case 2
    % even order derivative
    [i,j] = ndgrid(1:nterms);
    c = 1./factorial(2:2:(2*nterms));
    mat = c(j).*srinv.^((i-1).*(2*j));
end

end % fdamat



% ============================================
% subfunction - check_params
% ============================================
function par = check_params(par)
% check the parameters for acceptability
%
% Defaults
% par.DerivativeOrder = 1;
% par.MethodOrder = 2;
% par.Style = 'central';
% par.RombergTerms = 2;
% par.FixedStep = [];

% DerivativeOrder == 1 by default
if isempty(par.DerivativeOrder)
  par.DerivativeOrder = 1;
else
  if (length(par.DerivativeOrder)>1) || ~ismember(par.DerivativeOrder,1:4)
    error 'DerivativeOrder must be scalar, one of [1 2 3 4].'
  end
end

% MethodOrder == 2 by default
if isempty(par.MethodOrder)
  par.MethodOrder = 2;
else
  if (length(par.MethodOrder)>1) || ~ismember(par.MethodOrder,[1 2 3 4])
    error 'MethodOrder must be scalar, one of [1 2 3 4].'
  elseif ismember(par.MethodOrder,[1 3]) && (par.Style(1)=='c')
    error 'MethodOrder==1 or 3 is not possible with central difference methods'
  end
end

% style is char
valid = {'central', 'forward', 'backward'};
if isempty(par.Style)
  par.Style = 'central';
elseif ~ischar(par.Style)
  error 'Invalid Style: Must be character'
end
ind = find(strncmpi(par.Style,valid,length(par.Style)));
if (length(ind)==1)
  par.Style = valid{ind};
else
  error(['Invalid Style: ',par.Style])
end

% vectorized is char
valid = {'yes', 'no'};
if isempty(par.Vectorized)
  par.Vectorized = 'yes';
elseif ~ischar(par.Vectorized)
  error 'Invalid Vectorized: Must be character'
end
ind = find(strncmpi(par.Vectorized,valid,length(par.Vectorized)));
if (length(ind)==1)
  par.Vectorized = valid{ind};
else
  error(['Invalid Vectorized: ',par.Vectorized])
end

% RombergTerms == 2 by default
if isempty(par.RombergTerms)
  par.RombergTerms = 2;
else
  if (length(par.RombergTerms)>1) || ~ismember(par.RombergTerms,0:3)
    error 'RombergTerms must be scalar, one of [0 1 2 3].'
  end
end

% FixedStep == [] by default
if (length(par.FixedStep)>1) || (~isempty(par.FixedStep) && (par.FixedStep<=0))
  error 'FixedStep must be empty or a scalar, >0.'
end

% MaxStep == 10 by default
if isempty(par.MaxStep)
  par.MaxStep = 10;
elseif (length(par.MaxStep)>1) || (par.MaxStep<=0)
  error 'MaxStep must be empty or a scalar, >0.'
end

end % check_params


% ============================================
% Included subfunction - parse_pv_pairs
% ============================================
function params=parse_pv_pairs(params,pv_pairs)
% parse_pv_pairs: parses sets of property value pairs, allows defaults
% usage: params=parse_pv_pairs(default_params,pv_pairs)
%
% arguments: (input)
%  default_params - structure, with one field for every potential
%             property/value pair. Each field will contain the default
%             value for that property. If no default is supplied for a
%             given property, then that field must be empty.
%
%  pv_array - cell array of property/value pairs.
%             Case is ignored when comparing properties to the list
%             of field names. Also, any unambiguous shortening of a
%             field/property name is allowed.
%
% arguments: (output)
%  params   - parameter struct that reflects any updated property/value
%             pairs in the pv_array.
%
% Example usage:
% First, set default values for the parameters. Assume we
% have four parameters that we wish to use optionally in
% the function examplefun.
%
%  - 'viscosity', which will have a default value of 1
%  - 'volume', which will default to 1
%  - 'pie' - which will have default value 3.141592653589793
%  - 'description' - a text field, left empty by default
%
% The first argument to examplefun is one which will always be
% supplied.
%
%   function examplefun(dummyarg1,varargin)
%   params.Viscosity = 1;
%   params.Volume = 1;
%   params.Pie = 3.141592653589793
%
%   params.Description = '';
%   params=parse_pv_pairs(params,varargin);
%   params
%
% Use examplefun, overriding the defaults for 'pie', 'viscosity'
% and 'description'. The 'volume' parameter is left at its default.
%
%   examplefun(rand(10),'vis',10,'pie',3,'Description','Hello world')
%
% params =
%     Viscosity: 10
%        Volume: 1
%           Pie: 3
%   Description: 'Hello world'
%
% Note that capitalization was ignored, and the property 'viscosity'
% was truncated as supplied. Also note that the order the pairs were
% supplied was arbitrary.

npv = length(pv_pairs);
n = npv/2;

if n~=floor(n)
  error 'Property/value pairs must come in PAIRS.'
end
if n<=0
  % just return the defaults
  return
end

if ~isstruct(params)
  error 'No structure for defaults was supplied'
end

% there was at least one pv pair. process any supplied
propnames = fieldnames(params);
lpropnames = lower(propnames);
for i=1:n
  p_i = lower(pv_pairs{2*i-1});
  v_i = pv_pairs{2*i};

  ind = strmatch(p_i,lpropnames,'exact');
  if isempty(ind)
    ind = find(strncmp(p_i,lpropnames,length(p_i)));
    if isempty(ind)
      error(['No matching property found for: ',pv_pairs{2*i-1}])
    elseif length(ind)>1
      error(['Ambiguous property name: ',pv_pairs{2*i-1}])
    end
  end
  p_i = propnames{ind};

  % override the corresponding default in params
  params = setfield(params,p_i,v_i); %#ok

end

end % parse_pv_pairs

% -----------------------------------------------------------------------------

function [grad,err,finaldelta] = gradest(fun,x0)
% gradest: estimate of the gradient vector of an analytical function of n variables
% usage: [grad,err,finaldelta] = gradest(fun,x0)
%
% Uses derivest to provide both derivative estimates
% and error estimates. fun needs not be vectorized.
%
% arguments: (input)
%  fun - analytical function to differentiate. fun must
%        be a function of the vector or array x0.
%
%  x0  - vector location at which to differentiate fun
%        If x0 is an nxm array, then fun is assumed to be
%        a function of n*m variables.
%
% arguments: (output)
%  grad - vector of first partial derivatives of fun.
%        grad will be a row vector of length numel(x0).
%
%  err - vector of error estimates corresponding to
%        each partial derivative in grad.
%
%  finaldelta - vector of final step sizes chosen for
%        each partial derivative.
%
%
% Example:
%  [grad,err] = gradest(@(x) sum(x.^2),[1 2 3])
%  grad =
%      2     4     6
%  err =
%      5.8899e-15    1.178e-14            0
%
%
% Example:
%  At [x,y] = [1,1], compute the numerical gradient
%  of the function sin(x-y) + y*exp(x)
%
%  z = @(xy) sin(diff(xy)) + xy(2)*exp(xy(1))
%
%  [grad,err ] = gradest(z,[1 1])
%  grad =
%       1.7183       3.7183
%  err =
%    7.537e-14   1.1846e-13
%
%
% Example:
%  At the global minimizer (1,1) of the Rosenbrock function,
%  compute the gradient. It should be essentially zero.
%
%  rosen = @(x) (1-x(1)).^2 + 105*(x(2)-x(1).^2).^2;
%  [g,err] = gradest(rosen,[1 1])
%  g =
%    1.0843e-20            0
%  err =
%    1.9075e-18            0
%
%
% See also: derivest, gradient
%
%
% Author: John D'Errico
% e-mail: woodchips@rochester.rr.com
% Release: 1.0
% Release date: 2/9/2007

% get the size of x0 so we can reshape
% later.
sx = size(x0);

% total number of derivatives we will need to take
nx = numel(x0);

grad = zeros(1,nx);
err = grad;
finaldelta = grad;
for ind = 1:nx
  [grad(ind),err(ind),finaldelta(ind)] = derivest( ...
    @(xi) fun(swapelement(x0,ind,xi)), ...
    x0(ind),'deriv',1,'vectorized','no', ...
    'methodorder',2);
end

end % mainline function end

% -----------------------------------------------------------------------------

function [HD,err,finaldelta] = hessdiag(fun,x0)
% HESSDIAG: diagonal elements of the Hessian matrix (vector of second partials)
% usage: [HD,err,finaldelta] = hessdiag(fun,x0)
%
% When all that you want are the diagonal elements of the hessian
% matrix, it will be more efficient to call HESSDIAG than HESSIAN.
% HESSDIAG uses DERIVEST to provide both second derivative estimates
% and error estimates. fun needs not be vectorized.
%
% arguments: (input)
%  fun - SCALAR analytical function to differentiate.
%        fun must be a function of the vector or array x0.
%
%  x0  - vector location at which to differentiate fun
%        If x0 is an nxm array, then fun is assumed to be
%        a function of n*m variables.
%
% arguments: (output)
%  HD  - vector of second partial derivatives of fun.
%        These are the diagonal elements of the Hessian
%        matrix, evaluated at x0.
%        HD will be a row vector of length numel(x0).
%
%  err - vector of error estimates corresponding to
%        each second partial derivative in HD.
%
%  finaldelta - vector of final step sizes chosen for
%        each second partial derivative.
%
%
% Example usage:
%  [HD,err] = hessdiag(@(x) x(1) + x(2)^2 + x(3)^3,[1 2 3])
%  HD =
%     0     2    18
%
%  err =
%     0     0     0
%
%
% See also: derivest, gradient, gradest
%
%
% Author: John D'Errico
% e-mail: woodchips@rochester.rr.com
% Release: 1.0
% Release date: 2/9/2007

% get the size of x0 so we can reshape
% later.
sx = size(x0);

% total number of derivatives we will need to take
nx = numel(x0);

HD = zeros(1,nx);
err = HD;
finaldelta = HD;
for ind = 1:nx
  [HD(ind),err(ind),finaldelta(ind)] = derivest( ...
    @(xi) fun(swapelement(x0,ind,xi)), ...
    x0(ind),'deriv',2,'vectorized','no');
end

end % mainline function end

% =======================================
%      sub-functions
% =======================================
function vec = swapelement(vec,ind,val)
% swaps val as element ind, into the vector vec
vec(ind) = val;

end % sub-function end

% -----------------------------------------------------------------------------

function [hess,err] = hessian(fun,x0)
% hessian: estimate elements of the Hessian matrix (array of 2nd partials)
% usage: [hess,err] = hessian(fun,x0)
%
% Hessian is NOT a tool for frequent use on an expensive
% to evaluate objective function, especially in a large
% number of dimensions. Its computation will use roughly
% O(6*n^2) function evaluations for n parameters.
%
% arguments: (input)
%  fun - SCALAR analytical function to differentiate.
%        fun must be a function of the vector or array x0.
%        fun does not need to be vectorized.
%
%  x0  - vector location at which to compute the Hessian.
%
% arguments: (output)
%  hess - nxn symmetric array of second partial derivatives
%        of fun, evaluated at x0.
%
%  err - nxn array of error estimates corresponding to
%        each second partial derivative in hess.
%
%
% Example usage:
%  Rosenbrock function, minimized at [1,1]
%  rosen = @(x) (1-x(1)).^2 + 105*(x(2)-x(1).^2).^2;
%
%  [h,err] = hessian(rosen,[1 1])
%  h =
%           842         -420
%          -420          210
%  err =
%    1.0662e-12   4.0061e-10
%    4.0061e-10   2.6654e-13
%
%
% Example usage:
%  cos(x-y), at (0,0)
%  Note: this hessian matrix will be positive semi-definite
%
%  hessian(@(xy) cos(xy(1)-xy(2)),[0 0])
%  ans =
%           -1            1
%            1           -1
%
%
% See also: derivest, gradient, gradest, hessdiag
%
%
% Author: John D'Errico
% e-mail: woodchips@rochester.rr.com
% Release: 1.0
% Release date: 2/10/2007

% parameters that we might allow to change
params.StepRatio = 2.0000001;
params.RombergTerms = 3;

% get the size of x0 so we can reshape
% later.
sx = size(x0);

% was a string supplied?
if ischar(fun)
  fun = str2func(fun);
end

% total number of derivatives we will need to take
nx = length(x0);

% get the diagonal elements of the hessian (2nd partial
% derivatives wrt each variable.)
[hess,err] = hessdiag(fun,x0);

% form the eventual hessian matrix, stuffing only
% the diagonals for now.
hess = diag(hess);
err = diag(err);
if nx<2
  % the hessian matrix is 1x1. all done
  return
end

% get the gradient vector. This is done only to decide
% on intelligent step sizes for the mixed partials
[grad,graderr,stepsize] = gradest(fun,x0);

% Get params.RombergTerms+1 estimates of the upper
% triangle of the hessian matrix
dfac = params.StepRatio.^(-(0:params.RombergTerms)');
for i = 2:nx
  for j = 1:(i-1)
    dij = zeros(params.RombergTerms+1,1);
    for k = 1:(params.RombergTerms+1)
      dij(k) = fun(x0 + swap2(zeros(sx),i, ...
        dfac(k)*stepsize(i),j,dfac(k)*stepsize(j))) + ...
        fun(x0 + swap2(zeros(sx),i, ...
        -dfac(k)*stepsize(i),j,-dfac(k)*stepsize(j))) - ...
        fun(x0 + swap2(zeros(sx),i, ...
        dfac(k)*stepsize(i),j,-dfac(k)*stepsize(j))) - ...
        fun(x0 + swap2(zeros(sx),i, ...
        -dfac(k)*stepsize(i),j,dfac(k)*stepsize(j)));

    end
    dij = dij/4/prod(stepsize([i,j]));
    dij = dij./(dfac.^2);

    % Romberg extrapolation step
    [hess(i,j),err(i,j)] =  rombextrap(params.StepRatio,dij,[2 4]);
    hess(j,i) = hess(i,j);
    err(j,i) = err(i,j);
  end
end


end % mainline function end

% =======================================
%      sub-functions
% =======================================
function vec = swap2(vec,ind1,val1,ind2,val2)
% swaps val as element ind, into the vector vec
vec(ind1) = val1;
vec(ind2) = val2;

end % sub-function end

./MATLAB/+smi_cluster/@PairCorrelation/PairCorrelation.m
classdef PairCorrelation < handle

% PairCorrelation class written by Michael Wester, Keith Lidke,
%    and others as noted internally (2/26/2018) <wester@math.unm.edu>
% The New Mexico Center for the Spatiotemporal Modeling of Cell Signaling
% University of New Mexico Health Sciences Center
% Albuquerque, New Mexico, USA   87131
% Copyright (c) 2015-2021 by Michael J. Wester and Keith A. Lidke
%
% PairCorrelation performs pair correlation (auto- and cross-correlation) on
% user selected rectangular regions of interest (ROIs).  Input units are
% assumed to be in units of nm.  Functional dependencies:
%
%    pair_correlation             <- get_autocorr, get_crosscorr, pc_GaussFit
%    pair_correlation_Veatch      <- get_autocorr, get_crosscorr, pc_GaussFit
%    pair_correlation_ROIcombined <- get_corr
%
% pair_correlation (and pair_correlation_Veatch) operates on a single pair of
% images (pair_correlation_Veatch is basically the original code written by
% Sarah Veatch).  pair_correlation_ROIcombined combines pair correlation on a
% series of images/ROIs.
%
% Example main program:
%
%    PC = smi_cluster.PairCorrelation();
%    PC.ResultsDir = 'Results';
%
%    % Data from some external source.
%    [x1, y1] = textread('9021_5.txt',  '%*u %u %u %*u', 'headerlines', 1);
%    SMD1.X = x1;
%    SMD1.Y = y1;
%    XY1 = [x1, y1];
%    [x2, y2] = textread('9021_10.txt', '%*u %u %u %*u', 'headerlines', 1);
%    SMD2.X = x2;
%    SMD2.Y = y2;
%    XY2 = [x2, y2];
%
%    PC.ROI = [0, 7400, 0, 6000];   % [x_min, x_max, y_min, y_max]
%    % These two numbers below are often the same, but the user can increase
%    % HistBinSize to make bigger internal pixels (or bigger internal histogram
%    % image bins) and so produce more smoothing, or decrease this quantity and
%    % attempt greater detail.
%    PC.PixelSize = 2.7559;         % Actual camera pixel size (nm).
%    PC.HistBinSize = 2.7559;       % Internal image pixel size (nm).
%
%    % Make a RoI structure (see also smi_cluster.ROITools).  This is typically
%    % used for invoking pair_correlation_ROIcombined with multiple ROIs, which
%    % are combined.  The size of each ROI need not be the same, although
%    % cleaner results will be produced if they are all the same size.
%    n_ROIs = 1;
%    RoI{1}.ROI = PC.ROI;
%    RoI{1}.X   = {XY1(:, 1), XY2(:, 1)};
%    RoI{1}.Y   = {XY1(:, 2), XY2(:, 2)};
%
%    % Typically, pair_correlation is used for comparing two images/ROIs, while
%    % pair_correlation_ROIcombined is used when combining the pair correlation
%    % results for several pairs of images/ROIs.  pair_correlation_Veatch is
%    % basically the original Sarah Veatch code left for comparison purposes.
%    % The results of all three routines in these examples should produce
%    % similar results (identical for the first two when n_ROIs = 1).
%    % NOTE: SMD structures or XY matrices can be provided as input.
%    PC.BaseName = '9021';
%    results_pcc  = PC.pair_correlation(SMD1, SMD2)
%    results_pcc  = PC.pair_correlation(XY1, XY2)
%    results_Rpcc = PC.pair_correlation_ROIcombined(2, n_ROIs, RoI)
%    results_Vpcc = PC.pair_correlation_Veatch(SMD1, SMD2, 'cross')
%    results_Vpcc = PC.pair_correlation_Veatch(XY1, XY2, 'cross')
%
%    PC.BaseName = '9021_5';
%    results_pac1  = PC.pair_correlation(SMD1)
%    results_pac1  = PC.pair_correlation(XY1)
%    results_Rpacc = PC.pair_correlation_ROIcombined(1, n_ROIs, RoI, 1)
%    results_Vpac1 = PC.pair_correlation_Veatch(SMD1,  [], 'auto')
%    results_Vpac1 = PC.pair_correlation_Veatch(XY1,  [], 'auto')
%
%    PC.BaseName = '9021_10';
%    results_pac2  = PC.pair_correlation(SMD2)
%    results_pac2  = PC.pair_correlation(XY2)
%    results_Rpac2 = PC.pair_correlation_ROIcombined(1, n_ROIs, RoI, 2)
%    results_Vpac2 = PC.pair_correlation_Veatch(SMD2, [], 'auto')
%    results_Vpac2 = PC.pair_correlation_Veatch(XY2, [], 'auto')

% =============================================================================
properties
% =============================================================================

   % If ROI is provided, it will be used, otherwise the xy_size will be
   % calculated using the (x_min, x_max, y_min, y_max) computed from the data
   % as
   %    xy_size = min(x_max - x_min, y_max - y_min)
   ROI = [];   % [x_min, x_max, x_max, y_max]   % nm

   BaseName = ''; % descriptive name for the result files.
   Font_props = {'FontSize', 15, 'FontWeight', 'bold'};
   % If Fig_ext is empty, plot to the screen and save as .fig; otherwise, do
   % not plot to the screen, but save as .fig AND .Fig_ext .
   Fig_ext = 'png';
   Lines   = true;  % If true, plot lines rather than points for g(r) vs. r
   ResultsDir = '.';   % Directory to store results.

   % Pixel size (nm) used for the internal images to be correlated.
   HistBinSize = 100;
   PixelSize = 100;   % Actual camera pixel size (nm).
   Rmax_axis = -1;    % Sets plotting limit if > 0 (nm)
   % Factor to multiply rmax by when fitting a curve to the pair correlation
   % data.  This changes the max limits of the pair correlation data used in
   % the fitting, which may change the fitting curve.  Must be <= 1!
   RmaxFitFactor = 1;
   % Default fit model for pair_correlation_Veatch.  This can also be supplied
   % as the optional last (4th) argument to this function.  Possible choices:
   %    'exponential_and_gaussian', 'exponential_and_cosine', 'exponential'
   Veatch_fit = 'exponential_and_gaussian';
   % Note that pair_correlation and pair_correlation_ROIcombined use a 2D
   % Gaussian fit model.

   Verbose = 1;   % verbosity level

% =============================================================================
end % properties

methods
% =============================================================================

% Constructor.  SMF is an optional argument.
function obj = PairCorrelation(SMF)

   if ~exist('SMF', 'var')
      SMF = smi_core.SingleMoleculeFitting();
   end
   obj.ResultsDir  = SMF.Data.ResultsDir;
   obj.HistBinSize = SMF.Data.PixelSize;
   obj.PixelSize   = SMF.Data.PixelSize;

end

% =============================================================================
end % methods

methods(Static)
% =============================================================================

   [G, r, g, dg, mask, rmax] = get_autocorr(I1, mask, rmax, flag)
   [C, r, c, dc, mask, rmax] = get_crosscorr(I1, I2, mask, rmax, flag)
   [C, r, c, dc, rmax] = get_corr(n_ROIs, rmax, II1, II2)
   [estimates, errors, model] = pc_GaussFit(r,g_r,rmax,rho)
   success = unitTest()

% =============================================================================
end % methods(Static)
% =============================================================================
end % classdef

./MATLAB/+smi_cluster/@PairCorrelation/README.md
### +smi_cluster/@PairCorrelation

PairCorrelation performs pair correlation (auto- and cross-correlation) on
user selected rectangular regions of interest (ROIs).  Input units are
assumed to be in units of nm.  Functional dependencies:
```
   pair_correlation             <- get_autocorr, get_crosscorr, pc_GaussFit
   pair_correlation_Veatch      <- get_autocorr, get_crosscorr, pc_GaussFit
   pair_correlation_ROIcombined <- get_corr
```
pair_correlation (and pair_correlation_Veatch) operates on a single pair of
images (pair_correlation_Veatch is basically the original code written by
Sarah Veatch).  pair_correlation_ROIcombined combines pair correlation on a
series of images/ROIs.

---

Example main program (see [MATLAB/examples/Example_PairCorrelation.m](../../examples/Example_PairCorrelation.m)):
```
   PC = smi_cluster.PairCorrelation();
   PC.ResultsDir = 'Results';

   % Data from some external source.
   [x1, y1] = textread('9021_5.txt',  '%*u %u %u %*u', 'headerlines', 1);
   SMD1.X = x1;
   SMD1.Y = y1;
   XY1 = [x1, y1];
   [x2, y2] = textread('9021_10.txt', '%*u %u %u %*u', 'headerlines', 1);
   SMD2.X = x2;
   SMD2.Y = y2;
   XY2 = [x2, y2];

   PC.ROI = [0, 7400, 0, 6000];   % [x_min, x_max, y_min, y_max]
   % These two numbers below are often the same, but the user can increase
   % HistBinSize to make bigger internal pixels (or bigger internal histogram
   % image bins) and so produce more smoothing, or decrease this quantity and
   % attempt greater detail.
   PC.PixelSize = 2.7559;         % Actual camera pixel size (nm).
   PC.HistBinSize = 2.7559;       % Internal image pixel size (nm).

   % Make a RoI structure (see also smi_cluster.ROITools).  This is typically
   % used for invoking pair_correlation_ROIcombined with multiple ROIs, which
   % are combined.  The size of each ROI need not be the same, although
   % cleaner results will be produced if they are all the same size.
   n_ROIs = 1;
   RoI{1}.ROI = PC.ROI;
   RoI{1}.X   = {XY1(:, 1), XY2(:, 1)};
   RoI{1}.Y   = {XY1(:, 2), XY2(:, 2)};

   % Typically, pair_correlation is used for comparing two images/ROIs, while
   % pair_correlation_ROIcombined is used when combining the pair correlation
   % results for several pairs of images/ROIs.  pair_correlation_Veatch is
   % basically the original Sarah Veatch code left for comparison purposes.
   % The results of all three routines in these examples should produce
   % similar results (identical for the first two when n_ROIs = 1).
   % NOTE: SMD structures or XY matrices can be provided as input.
   PC.BaseName = '9021';
   results_pcc  = PC.pair_correlation(SMD1, SMD2)
   results_pcc  = PC.pair_correlation(XY1, XY2)
   results_Rpcc = PC.pair_correlation_ROIcombined(2, n_ROIs, RoI)
   results_Vpcc = PC.pair_correlation_Veatch(SMD1, SMD2, 'cross')
   results_Vpcc = PC.pair_correlation_Veatch(XY1, XY2, 'cross')

   PC.BaseName = '9021_5';
   results_pac1  = PC.pair_correlation(SMD1)
   results_pac1  = PC.pair_correlation(XY1)
   results_Rpacc = PC.pair_correlation_ROIcombined(1, n_ROIs, RoI, 1)
   results_Vpac1 = PC.pair_correlation_Veatch(SMD1,  [], 'auto')
   results_Vpac1 = PC.pair_correlation_Veatch(XY1,  [], 'auto')

   PC.BaseName = '9021_10';
   results_pac2  = PC.pair_correlation(SMD2)
   results_pac2  = PC.pair_correlation(XY2)
   results_Rpac2 = PC.pair_correlation_ROIcombined(1, n_ROIs, RoI, 2)
   results_Vpac2 = PC.pair_correlation_Veatch(SMD2, [], 'auto')
   results_Vpac2 = PC.pair_correlation_Veatch(XY2, [], 'auto')
```
---

```
properties:
   % If ROI is provided, it will be used, otherwise the xy_size will be
   % calculated using the (x_min, x_max, y_min, y_max) computed from the data
   % as
   %    xy_size = min(x_max - x_min, y_max - y_min)
   ROI = [];   % [x_min, x_max, x_max, y_max]   % nm

   BaseName = ''; % descriptive name for the result files.
   Font_props = {'FontSize', 15, 'FontWeight', 'bold'};
   % If Fig_ext is empty, plot to the screen and save as .fig; otherwise, do
   % not plot to the screen, but save as .fig AND .Fig_ext .
   Fig_ext = 'png';
   Lines   = true;  % If true, plot lines rather than points for g(r) vs. r
   ResultsDir = '.';   % Directory to store results.

   % Pixel size (nm) used for the internal images to be correlated.
   HistBinSize = 100;
   PixelSize = 100;   % Actual camera pixel size (nm).
   Rmax_axis = -1;   % Sets plotting limit if > 0 (nm)
   % Factor to multiply rmax by when fitting a curve to the pair correlation
   % data.  This changes the max limits of the pair correlation data used in
   % the fitting, which may change the fitting curve.  Must be <= 1!
   RmaxFitFactor = 1;
   % Default fit model for pair_correlation_Veatch.  This can also be supplied
   % as the optional last (4th) argument to this function.  Possible choices:
   %    'exponential_and_gaussian', 'exponential_and_cosine', 'exponential'
   Veatch_fit = 'exponential_and_gaussian';
   % Note that pair_correlation and pair_correlation_ROIcombined use a 2D
   % Gaussian fit model.

   Verbose = 1;   % verbosity level
```

./MATLAB/+smi_cluster/@PairCorrelation/get_crosscorr.m
function [C, r, c, dc, mask, rmax] = get_crosscorr(I1, I2, mask, rmax, flag)
% function [G, r, g, dg, mask] = get_crosscorr(I1, I2, mask, rmax, flag)
% calculates autocorrelation function for two dimensional images
%
% INPUTS
% I1 = First image to be autocorrelated
% I2 = Second image to be autocorrelated
% mask = region of interest, If none or [] specificed, user will be asked
%   to define.  To autocorreate the entire images, use mask = ones(size(I1))
% rmax = maximum r value to correlate in units of pixels. default is 100;
% flag = display flag.  insert 1 to display errorbar(r, g, dg) after
%   computation.
%
% OUTPUTS
% C = two dimensional cross-correlation function.  x and y values range between
%    -rmax:rmax
% r = radius values
% c = angularly averaged autocorrelation function.
% dc = errors on angularly averaged g
% mask = masked used for calculation
%
%
% Last updated 01.24.11 by Sarah Veatch.



if nargin<5, flag = 0; end  % flag for display
if (nargin<4 || isempty(rmax)), rmax=100; end  % distance of maximum correlation recorded
if (nargin<3 || isempty(mask)),    %% draw a mask if needed
    hIm = imshow(I1); axis equal tight off;
    %mask = roipoly;
    h = imrect;
    mask = createMask(h,hIm);
end

if sum(size(I1)==size(I2))<2,
    disp('images are not the same size')
    return
end

%mask = ones(size(I1)); end

N1 = sum(sum(I1.*mask));  % Total intensity within mask in I1
N2 = sum(sum(I2.*mask));  % Total intensity within mask in I2
A = sum(sum(mask));      % area of mask

I1 = double(I1);         % convert to double
I2 = double(I2);         % convert to double

L1 = size(I1, 1)+rmax; % size of fft2 (for zero padding)
L2 = size(I1, 2)+rmax; % size of fft2 (for zero padding)

% Adjust rmax if it is too big and would cause problems cropping C1:
%    Need 2*rmax + 1 >= min(size(I1, 1), size(I1, 2)) + rmax
% This fix is for rectangular regions which are treated somewhat differently in
% get_corr, so rectangular regions may produce different results in the two
% routines---use with caution!  (Square region results are identical.)
Lmin = min(L1, L2);
if 2*rmax + 1 > Lmin
   fprintf('rmax adjusted from %.1f to ', rmax);
   rmax = min(size(I1, 1), size(I1, 2)) - 1;
   fprintf('%.1f\n', rmax);

   L1 = size(I1, 1)+rmax; % size of fft2 (for zero padding)
   L2 = size(I1, 2)+rmax; % size of fft2 (for zero padding)
end

NP = real(fftshift(ifft2(abs(fft2(mask, L1, L2)).^2))); % Normalization for correct boundary conditions
C1 = A^2/N1/N2*real(fftshift(ifft2(fft2(I1.*mask,L1, L2).*conj(fft2(I2.*mask, L1, L2)))))./NP;
%G1 = A^2/N^2*real(fftshift(ifft2(abs(fft2(I1.*mask,L1, L2)).^2)))./NP; % 2D G(r) with proper normalization
C = imcrop(C1, [floor(L2/2+1)-rmax, floor(L1/2+1)-rmax, 2*rmax, 2*rmax]);  %only return valid part of G


xvals = ones(1, 2*rmax+1)'*(-rmax:rmax);    %map to x positions with center x=0
yvals = (-rmax:rmax)'*ones(1, 2*rmax+1);    %map to y positions with center y=0
zvals = C;

[theta,r,v] = cart2pol(xvals,yvals, zvals);  % convert x, y to polar coordinates

Ar = reshape(r,1, (2*rmax+1)^2);
Avals = reshape(v,1, (2*rmax+1)^2);
[rr,ind] = sort(Ar);                         % sort by r values
vv = Avals(ind);                             % reindex g
r = 0:floor(max(rr));                        % the radii you want to extract
[n bin] = histc(rr, r-.5);                   % bin by radius

for j = 1:rmax+1;                            % now get averages
    m = bin==j;
    n2 = sum(m);                             % the number of pixels in that bin
    if n2==0, vals(j)=0; er(j)=0;            % if no bins, no data
    else
        c(j) = sum(m.*vv)/n2;               % the average G values in this bin
        dc(j) = sqrt(sum(m.*(vv-c(j)).^2))/n2; % the variance of the mean
    end
end

r = 0:rmax;

%end


if flag,
    r = 0:rmax;
    figure;errorbar(r, c, dc);
    axis tight
end

end

./MATLAB/+smi_cluster/@PairCorrelation/pair_correlation.m
function results = pair_correlation(obj, SMD1, SMD2)
% Perform pair correlation.
%
% INPUTS:
%    obj             various properties used by the algorithms
%       BaseName     descriptive name for the results files
%       Fig_ext      figure extension
%       Font_props   [{'FontSize', 15, 'FontWeight', 'bold'}]
%       HistBinSize  pixel size (nm)
%       Lines        if true, plot lines rather than points for g(r) vs. r
%       ResultsDir   directory to store results
%       ROI          [x_min, x_max, y_min, y_max] (nm)
%       Rmax_axis    sets plotting limit if > 0
%    SMD1 and SMD2   (x, y) coordinates of the two datasets (nm) in the format
%                    (1) SMD structures: SMD1.X, SMD1.Y, SMD2.X and SMD2.Y,
%                    (2) N x 2 array of coordinates.
%                    SMD2 is optional and if omitted or empty requests
%                    auto-correlation rather than cross-correlation.  Units are
%                    assumed to be nm.
%
% OUTPUTS:
%    results         structure containing various results from the algorithm
%       G               2D pair-correlation function values
%       r               radius values (nm)
%       g               angularly averaged pair correlation function
%       dg              errors on angularly averaged g
%       model           model calculated at estimated value
%                    model results
%       objs_per_domain
%       objs_per_domain_SE
%       sigma_domain
%       sigma_domain_SE
%       localizations_per_obj
%       localizations_per_obj_SE
%       sigma_localization
%       sigma_localization_SE

% Modified from code originally written by Carolyn Pehlke.

   % Determine correlation type.
   if ~exist('SMD2', 'var')
      corr_type = 'A';   % auto-correlation
   else
      if isempty(SMD2)
         corr_type = 'A';   % auto-correlation
      else
         corr_type = 'C';   % cross-correlation
      end
   end

   % Allow multiple input formats:
   if isstruct(SMD1) && isfield(SMD1, 'X') && isfield(SMD1, 'Y')
      XY1 = [SMD1.X, SMD1.Y];
   elseif ismatrix(SMD1) && size(SMD1, 2) == 2
      XY1 = SMD1;
   else
      error('SMD1 is not an SMD structure or an N x 2 matrix!');
   end

   if exist('SMD2', 'var')
      if isstruct(SMD2) && isfield(SMD2, 'X') && isfield(SMD2, 'Y')
         XY2 = [SMD2.X, SMD2.Y];
      elseif ismatrix(SMD2) && size(SMD2, 2) == 2
         XY2 = SMD2;
      else
         error('SMD2 is not an SMD structure or an N x 2 matrix!');
      end
   end

   base_name     = obj.BaseName;
   hist_bin_size = obj.HistBinSize;

   if ~isempty(obj.ROI)
      x_min = obj.ROI(1);
      x_max = obj.ROI(2);
      y_min = obj.ROI(3);
      y_max = obj.ROI(4);
      ROI_size = min(obj.ROI([2, 4]) - obj.ROI([1, 3]));
   else
      if corr_type == 'C'
         x_min = min([XY1(:, 1); XY2(:, 1)]);
         x_max = max([XY1(:, 1); XY2(:, 1)]);
         y_min = min([XY1(:, 2); XY2(:, 2)]);
         y_max = max([XY1(:, 2); XY2(:, 2)]);
      else
         x_min = min(XY1(:, 1));
         x_max = max(XY1(:, 1));
         y_min = min(XY1(:, 2));
         y_max = max(XY1(:, 2));
      end
      ROI_size = min(x_max - x_min, y_max - y_min);
   end

   % Set to 1 to get a figure of g(r) with error bars.
   flag = 0;

   % Compute the number of pixels in x and y.
   imszX = round((x_max - x_min) / hist_bin_size);
   imszY = round((y_max - y_min) / hist_bin_size);
   % Create a blank image.
   im1 = zeros(imszX, imszY);
   if corr_type == 'C'
      im2 = zeros(imszX, imszY);
   end
   % Convert (x, y) coordinates into pixel units.
   x1 = round((XY1(:, 1) - x_min) / hist_bin_size) + 1;
   y1 = round((XY1(:, 2) - y_min) / hist_bin_size) + 1;
   if corr_type == 'C'
      x2 = round((XY2(:, 1) - x_min) / hist_bin_size) + 1;
      y2 = round((XY2(:, 2) - y_min) / hist_bin_size) + 1;
   end
   % Get the pixels within the image size.
   mask1 = (x1 > 0) & (y1 > 0) & (x1 <= imszX) & (y1 <= imszY);
   x1 = x1(mask1);
   y1 = y1(mask1);
   if corr_type == 'C'
      mask2 = (x2 > 0) & (y2 > 0) & (x2 <= imszX) & (y2 <= imszY);
      x2 = x2(mask2);
      y2 = y2(mask2);
   end
   % Make a histogram image.
   for i = 1 : size(x1, 1)
      im1(x1(i), y1(i)) = im1(x1(i), y1(i)) + 1;
   end
   if corr_type == 'C'
      for i = 1 : size(x2, 1)
         im2(x2(i), y2(i)) = im2(x2(i), y2(i)) + 1;
      end
   end
   % Establish rmax as half the size of the ROI in pixels.
   rmax = round(ROI_size / (2 * hist_bin_size));
   if corr_type == 'C'
      % Pair crosscorrelation using Veatch method.
      [G, r, g, dg, ~, rmax] = ...
         smi_cluster.PairCorrelation.get_crosscorr(im1, im2, ...
            ones(size(im1)), rmax, flag);
   else
      % Pair autocorrelation using Veatch method.
      [G, r, g, dg, ~, rmax] = ...
         smi_cluster.PairCorrelation.get_autocorr(im1, ones(size(im1)), ...
            rmax, flag);
   end
   % Convert back to nm
   r_nm = r * hist_bin_size;

   if corr_type == 'C'
      rho1 = mean(mean(im1));
      rho2 = mean(mean(im2));
      rho = sqrt(rho1 * rho2);
      paircorr = [{[im1, im2]}, {[r', g', dg']}, {rho}, {G}];
   else
      rho = mean(mean(im1));
      paircorr = [{im1}, {[r', g', dg']}, {rho}, {G}];
   end

   [estimates, errors, model] = ...
      smi_cluster.PairCorrelation.pc_GaussFit(paircorr{2}(:,1), ...
         paircorr{2}(:,2), rmax*obj.RmaxFitFactor, paircorr{3});
%        paircorr{2}(:,2), rmax, paircorr{3});
   estimates = abs(estimates);

   if ~isempty(obj.Fig_ext)
      figure('Visible', 'off');
   else
      figure;
   end
   axes(obj.Font_props{:});
   hold on
   if ~isdir(obj.ResultsDir)
      mkdir(obj.ResultsDir);
   end
   if corr_type == 'C'
      name = fullfile(obj.ResultsDir, [base_name, '_crosscorr']);
   else
      name = fullfile(obj.ResultsDir, [base_name, '_autocorr']);
   end
   if obj.Lines
      plot(r_nm(2:end),paircorr{2}(2:end,2),'k.-', ...
           'MarkerSize',20,'LineWidth',2)
   else
      plot(r_nm(2:end),paircorr{2}(2:end,2),'k.','MarkerSize',10,'LineWidth',2)
   end
   plot(r_nm(2:end),ones(1, numel(r) - 1),'b:','LineWidth',3)
   plot(r_nm(2:end),model(2:end),'--r','LineWidth',3)
   if corr_type == 'C'
      flegend{1} = 'Cross-Correlation';
   else
      flegend{1} = 'Auto-Correlation';
   end
   flegend{2} = 'g(r) Random';
   flegend{3} = 'Fit';
   axis tight
   if obj.Rmax_axis > 0
      xlim([0, obj.Rmax_axis]);
   end
   title(regexprep(base_name, '_', '\\_'));
   xlabel('r (nm)');
   ylabel('g(r)');
   legend(flegend, 'Location', 'Best');
   hold off

   if ~isempty(obj.Fig_ext)
      print(['-d', obj.Fig_ext], name);
      saveas(gcf, name);
   else
      saveas(gcf, name);
      delete(gcf);
   end

   Afound=estimates(1);
   s_d_found_pixels=estimates(2);
   Bfound=estimates(3);
   s_l_found_pixels=estimates(4);

   Afound_SE=errors(1);
   s_d_found_pixels_SE=errors(2);
   Bfound_SE=errors(3);
   s_l_found_pixels_SE=errors(4);

   s_d_found=s_d_found_pixels*hist_bin_size;
   s_l_found=s_l_found_pixels*hist_bin_size;
   s_d_found_SE=s_d_found_pixels_SE*hist_bin_size;
   s_l_found_SE=s_l_found_pixels_SE*hist_bin_size;

   % display results
   if corr_type == 'C'
      fprintf('Pair Cross-correlation for %s:\n\n', base_name);
   else
      fprintf('Pair Auto-correlation for %s:\n\n', base_name);
   end

   fprintf('Objects per domain ');
   fprintf('found:\t%5.3g +/- %5.3g\n',Afound,Afound_SE);

   fprintf('Domain size sigma ');
   fprintf('found:\t%5.3g +/- %5.3g\n',s_d_found,s_d_found_SE);

   fprintf('Localizations per object ');
   fprintf('found:\t%5.3g +/- %5.3g\n',Bfound,Bfound_SE);

   fprintf('Localization precision sigma ');
   fprintf('found:\t%5.3g +/- %5.3g\n',s_l_found,s_l_found_SE);

   results.G  = G;
   results.r  = r_nm;
   results.g  = g;
   results.dg = dg;
   results.objs_per_domain          = Afound;
   results.objs_per_domain_SE       = Afound_SE;
   results.sigma_domain             = s_d_found;
   results.sigma_domain_SE          = s_d_found_SE;
   results.localizations_per_obj    = Bfound;
   results.localizations_per_obj_SE = Bfound_SE;
   results.sigma_localization       = s_l_found;
   results.sigma_localization_SE    = s_l_found_SE;
   results.model = model;

end

./MATLAB/+smi_cluster/@PairCorrelation/get_autocorr.m
function [G, r, g, dg, mask, rmax] = get_autocorr(I1, mask, rmax, flag)
% function [G, r, g, dg, mask] = get_autocorr(I1, mask, rmax, flag)
% calculates autocorrelation function for two dimensional images
%
% INPUTS
% I1 = image to be autocorrelated
% mask = region of interest, If none or [] specificed, user will be asked
%   to define.  To autocorreate the entire images, use mask = ones(size(I1))
% rmax = maximum r value to correlate in units of pixels. default is 100;
% flag = display flag.  insert 1 to display errorbar(r, g, dg) after
%   computation.
%
% OUTPUTS
% G = two dimensional correlation function.  x and y values range between
%    -rmax:rmax
% r = radius values
% g = angularly averaged autocorrelation function.
% dg = errors on angularly averaged g
% mask = masked used for calculation
%
% NOTE: G(r=0) is just the dot product of the image.  For display purposes,
% G(r=0) is set to zero in the 2D autocorrelation output.  g(r=0) [g(1)]
% retains the proper value.
%
% Last updated 01.26.10 by Sarah Veatch.



if nargin<4, flag = 0; end  % flag for display
if (nargin<3 || isempty(rmax)), rmax=100; end  % distance of maximum correlation recorded
if (nargin<2 || isempty(mask)),    %% draw a mask if needed
    imagesc(I1); axis equal tight off;
    mask = roipoly;
end

%mask = ones(size(I1)); end

N = sum(sum(I1.*mask));  % number of particles within mask
A = sum(sum(mask));      % area of mask

I1 = double(I1);         % convert to double

L1 = size(I1, 1)+rmax; % size of fft2 (for zero padding)
L2 = size(I1, 2)+rmax; % size of fft2 (for zero padding)

% Adjust rmax if it is too big and would cause problems cropping C1:
%    Need 2*rmax + 1 >= min(size(I1, 1), size(I1, 2)) + rmax
% This fix is for rectangular regions which are treated somewhat differently in
% get_corr, so rectangular regions may produce different results in the two
% routines---use with caution!  (Square region results are identical.)
Lmin = min(L1, L2);
if 2*rmax + 1 > Lmin
   fprintf('rmax adjusted from %.1f to ', rmax);
   rmax = min(size(I1, 1), size(I1, 2)) - 1;
   fprintf('%.1f\n', rmax);

   L1 = size(I1, 1)+rmax; % size of fft2 (for zero padding)
   L2 = size(I1, 2)+rmax; % size of fft2 (for zero padding)
end

NP = real(fftshift(ifft2(abs(fft2(mask, L1, L2)).^2))); % Normalization for correct boundary conditions
G1 = A^2/N^2*real(fftshift(ifft2(abs(fft2(I1.*mask,L1, L2)).^2)))./NP; % 2D G(r) with proper normalization
G = imcrop(G1, [floor(L2/2+1)-rmax, floor(L1/2+1)-rmax, 2*rmax, 2*rmax]);  %only return valid part of G


xvals = ones(1, 2*rmax+1)'*(-rmax:rmax);    %map to x positions with center x=0
yvals = (-rmax:rmax)'*ones(1, 2*rmax+1);    %map to y positions with center y=0
zvals = G;

[theta,r,v] = cart2pol(xvals,yvals, zvals);  % convert x, y to polar coordinates

Ar = reshape(r,1, (2*rmax+1)^2);
Avals = reshape(v,1, (2*rmax+1)^2);
[rr,ind] = sort(Ar);                         % sort by r values
vv = Avals(ind);                             % reindex g
r = 0:floor(max(rr));                        % the radii you want to extract
[n bin] = histc(rr, r-.5);                   % bin by radius

for j = 1:rmax+1;                            % now get averages
    m = bin==j;
    n2 = sum(m);                             % the number of pixels in that bin
    if n2==0, vals(j)=0; er(j)=0;            % if no bins, no data
    else
        g(j) = sum(m.*vv)/n2;               % the average G values in this bin
        dg(j) = sqrt(sum(m.*(vv-g(j)).^2))/n2; % the variance of the mean
    end
end

r = 0:rmax;

%end

G(rmax+1, rmax+1) = 0;

if flag,
    r = 0:rmax;
    errorbar(r(2:length(r)), g(2:length(r)), dg(2:length(r)));
    axis tight
end

end

./MATLAB/+smi_cluster/@PairCorrelation/pair_correlation_Veatch.m
function results = pair_correlation_Veatch(obj, SMD1, SMD2, correlation, fit)
% Pair correlation as originally written by Sarah L. Veatch.
%
% INPUTS:
%    obj             various properties used by the algorithms
%       BaseName        descriptive name for the results files
%       Fig_ext         figure extension
%       Font_props      [{'FontSize', 15, 'FontWeight', 'bold'}]
%       HistBinSize     pixel size (nm)
%       ResultsDir      directory to store results
%       ROI             [x_min, x_max, y_min, y_max]
%       Veatch_fit      ['exponential_and_gaussian'] fit model
%    SMD1 and SMD2   (x, y) coordinates of the two datasets (nm) in the format
%                    (1) SMD structures: SMD1.X, SMD1.Y, SMD2.X and SMD2.Y,
%                    (2) N x 2 array of coordinates.
%                    SMD2 is optional and if omitted or empty requests
%                    auto-correlation rather than cross-correlation.  Units are
%                    assumed to be nm.
%    correlation     'auto' or 'cross'
%    fit             [OPTIONAL] ['exponential_and_gaussian']
%                    'exponential_and_gaussian', 'exponential_and_cosine' or
%                    'exponential'
%
% OUTPUTS:
%    results         structure containing various results from the algorithm

   % Allow multiple input formats:
   if isstruct(SMD1) && isfield(SMD1, 'X') && isfield(SMD1, 'Y')
      XY1 = [SMD1.X, SMD1.Y];
   elseif ismatrix(SMD1) && size(SMD1, 2) == 2
      XY1 = SMD1;
   else
      error('SMD1 is not an SMD structure or an N x 2 matrix!');
   end

   if exist('SMD2', 'var') && ~isempty(SMD2)
      if isstruct(SMD2) && isfield(SMD2, 'X') && isfield(SMD2, 'Y')
         XY2 = [SMD2.X, SMD2.Y];
      elseif ismatrix(SMD2) && size(SMD2, 2) == 2
         XY2 = SMD2;
      else
         error('SMD2 is not an SMD structure or an N x 2 matrix!');
      end
   end

   base_name     = obj.BaseName;
   hist_bin_size = obj.HistBinSize;
   % Very inelegant, but I didn't want to break up this file into a bunch of
   % separate methods for a probably rarely if ever used functionality,
   % although it is nice to compare with pair_correlation results for
   % debugging purposes.
   property      = obj;

   if ~isempty(obj.ROI)
      x_min = obj.ROI(1);
      x_max = obj.ROI(2);
      y_min = obj.ROI(3);
      y_max = obj.ROI(4);
      ROI_size = min(obj.ROI([2, 4]) - obj.ROI([1, 3]));
   else
      if corr_type == 'C'
         x_min = min([XY1(:, 1); XY2(:, 1)]);
         x_max = max([XY1(:, 1); XY2(:, 1)]);
         y_min = min([XY1(:, 2); XY2(:, 2)]);
         y_max = max([XY1(:, 2); XY2(:, 2)]);
      else
         x_min = min(XY1(:, 1));
         x_max = max(XY1(:, 1));
         y_min = min(XY1(:, 2));
         y_max = max(XY1(:, 2));
      end
      ROI_size = min(x_max - x_min, y_max - y_min);
   end

   dataA(:, 1) = XY1(:, 1) - x_min;
   dataA(:, 2) = XY1(:, 2) - y_min;
   if exist('XY2', 'var') && ~isempty(XY2)
      dataB(:, 1) = XY2(:, 1) - x_min;
      dataB(:, 2) = XY2(:, 2) - y_min;
   else
      dataB = [];
   end

%% Filter the localisations
%rule = 1: precision or intensity
%rule = 2: both
% rule = 1;
% limits = [10 50]; %[min max]
% dataCol = 7; % variable to be used for filtering. Use a vector for two parameters eg [1 3]
% dataA = filter_localisations(dataA,dataCol,rule,limits);
% if ~isempty(dataB)
%     dataB = filter_localisations(dataB,dataCol,rule,limits);
% end
%% set some variables:
camPixSize = hist_bin_size; %pixel size on ccd in nm
originalX = round((x_max - x_min)/hist_bin_size);
originalY = round((y_max - y_min)/hist_bin_size); % image size in pixels
xScale = originalX .* camPixSize;
yScale = originalY .* camPixSize;
% nmPixSizeX = xScale / image_resolution;
% nmPixSizeY = yScale / image_resolution;
%nmPixSize = sqrt(nmPixSizeX^2 + nmPixSizeY^2); % pixel size in 2D histogram
nmPixSize = hist_bin_size;
image_resolution = [xScale/nmPixSize, yScale/nmPixSize]; % resolution for 2D histogram of localisation data
%image_resolution(1)
%% apply channel alignment?
transformation = []; %enter filename to apply transformation
calc_new = 0;
t_params = {transformation, calc_new};

%% set the type of correlation and the function to fit to the data
%%'auto' for auto-correlation, 'cross' for cross-correlation
if ~exist('correlation', 'var')
   correlation = 'auto';
   %correlation = 'cross';
end
if ~exist('fit', 'var')
   fit = obj.Veatch_fit;
   %fit = 'exponential_and_gaussian'; %name should match available fit functions
   %fit = 'exponential_and_cosine'; %name should match available fit functions
   %fit = 'exponential'; %name should match available fit functions
end

%radius = 1000; %in pixels
% Establish rmax as half the size of the ROI in pixels.
radius = round(ROI_size / (2 * hist_bin_size));

%% extract the (possibly filtered) x-y coordinates
% this step converts the coordinates pixels to nm; remove multiplication by
% camPixSize to work with data already in nm
Ax = dataA(:, 1);
Ay = dataA(:, 2);
Axy = [Ax Ay];
%Axy = [Ax Ay].*camPixSize;
if ~isempty(dataB)
    Bx = dataB(:, 1);
    By = dataB(:, 2);
    Bxy = [Bx By];
    %Bxy = [Bx By].*camPixSize;
else
    Bxy = [];
end

%% calculate the correlation and the fit
[correlation_data, params] = run_correlation_and_fit(Axy, Bxy, image_resolution, nmPixSize, t_params, [xScale yScale], correlation, fit, radius, base_name, property);

fprintf('Veatch %s-correlation using an %s fit for %s:', ...
        correlation, fit, base_name);
%correlation_data
params{1}
if numel(params) > 1
   params{2}
end

results.correlation_data = correlation_data;
results.params = params{1};

end

% -----------------------------------------------------------------------------

function [corrData, params] = run_correlation_and_fit(varargin) %(input1, input2, Xcol, Ycol, res, nm pix size, range, correlation type, fittype, radius)

    channel1 = varargin{1};
    channel2 = varargin{2};
    res = varargin{3};
    nmpixSize = varargin{4};
    t_params = varargin{5};
    range = varargin{6};
    Xrange = [0 range(1)];
    Yrange = [0 range(2)];
    correlation = varargin{7};
    fit = varargin{8};
    maxrad1 = varargin{9};
    base_name = varargin{10};
    property = varargin{11};

    %calculate histograms
    if ~isempty(channel2)
        density(:,:,1) = hist2d(channel1,res(1), res(2),Xrange,Yrange);
        density(:,:,2) = hist2d(channel2,res(1), res(2),Xrange,Yrange);
        density(:,:,3) = zeros(size(density(:,:,1),1),size(density(:,:,1),2));
    else
        density = hist2d(channel1,res(1), res(2),Xrange,Yrange);
    end
    N = {};
    data = {};
    N{1} = size(channel1,1);
    if isempty(channel2)
        numChannels = 1;
        data{1} = channel1;
        data{2} = [];
    else
        numChannels = 2;
        N{2} = size(channel2,1);
        if ~isempty(t_params{1}) && t_params{2} == 0
            tformData = load(t_params{1});
            TFORM = tformData.TFORM;
            data{1} = tformfwd(TFORM,channel1);
        elseif isempty(t_params{1}) && t_params{2} == 0
            data{1} = channel1;
        elseif isempty(t_params{1}) && t_params{2} == 1
            [in_points,base_points,~,TFORM] = transformChannels(nmpixSize,density);
            data{1} = tformfwd(TFORM,channel1);
        end
        data{2} = channel2;
    end
        %calculate histograms
    if numChannels == 2
        density(:,:,1) = hist2d(data{1},res(1), res(2),Xrange,Yrange);
        density(:,:,2) = hist2d(data{2},res(1), res(2),Xrange,Yrange);
        density(:,:,3) = zeros(size(density(:,:,1),1),size(density(:,:,1),2));
    else
        density = hist2d(data{1},res(1), res(2),Xrange,Yrange);
        cmax = 5;
        cmin = min(min(density));
    end

%   %display for ROI definition
%   LUT = RedMap;
%   r = LUT(:,2);
%   g = LUT(:,1);
%   b = LUT(:,3);
%   k = 1:numel(r);
%   map(k,:)=[r(k) g(k) b(k)];
%   figure;hIm = imagesc(Xrange,Yrange,density,[cmin,cmax]); axis equal tight off; colormap(map)
%   %mask = roipoly;
%   h = imrect;
%   pos = getPosition(h)
%   mask = createMask(h,hIm);
%   figure;imagesc(mask);axis equal tight off;colormap('gray')
%   figure;imagesc(density.*mask,[cmin,cmax]);axis equal tight off; colormap(map)
    params = {};
    corrData = repmat(struct('twoDcorr',[],'radius',[],'correlation',[],'error',[],'mask',[],'type',[],'L',[]),numChannels,1);
    L = {};
%     for ii = 1:numChannels
%         [corrData(ii).L,vq] = ripley(h,data{ii},maxrad1*nmpixSize);
%         fname = sprintf('clustermap0%d.tif',ii);
%         imwrite(uint16(vq),fname,'tif','compression','lzw')
%     end
    % the input parameters for the fit depend on the fit type
    switch fit
        case 'exponential_and_gaussian'
            P = [];
            P(1) = 800; % the decay of the exponential (in nm)
            P(2) = 10; %the amplitude of the exponential (y intercept)
            P(3) = 20; %sqrt(2)* the PSF of the image. (the half with of the gaussian) in nm
            P(4) = 1; % the surface density of the probe (in 1/um^2)
        case 'exponential_and_cosine'
            P = [];
            P(1) = 800; % the decay of the exponential (in nm)
            P(2) = 10; %the amplitude of the exponential (y intercept)
            P(3) = 20; %sqrt(2)* the PSF of the image. (the half with of the gaussian) in nm
        case 'exponential'
            P = [];
            P(1) = 800; % the decay of the exponential (in nm)
            P(2) = 10; %the amplitude of the exponential (y intercept)
    end

    %calculate correlation
    % Set to 1 to get a figure of g(r) with error bars.
    flag = 0;
    switch correlation
        case 'auto'
            for iChan = 1: numChannels
                Imsize1=min(size(density(:,:,1)));
                if Imsize1<1.25*maxrad1
                    maxrad1=round(Imsize1/1.25);
                end
                mask = ones(size(density(:,:,iChan)));
                [G, r, g, dg, maskout] = ...
                   smi_cluster.PairCorrelation.get_autocorr( ...
                      im2bw(density(:,:,iChan)), mask, maxrad1, flag);
                if isnan(g)
                    errordlg('auto-correlation calculation failed. try changing radius','modal');
                    return
                else
                    params{iChan} = fitData(r,g,dg,nmpixSize,fit,P,base_name,correlation,property);
                    corrData(iChan).twoDcorr = G;
                    corrData(iChan).radius = r;
                    corrData(iChan).correlation = g;
                    corrData(iChan).error = dg;
                    corrData(iChan).mask = maskout;
                    corrData(iChan).type = 'auto';
                end
            end
        case 'cross'
            Imsize1=min(size(density(:,:,1)));
            if Imsize1<1.25*maxrad1
                maxrad1=round(Imsize1/1.25);
            end

            if numChannels == 2
                mask = ones(size(density(:,:,1)));
                [C, r, c, dc, maskout] = ...
                   smi_cluster.PairCorrelation.get_crosscorr( ...
                      density(:,:,1), density(:,:,2), mask, maxrad1, flag);
            else
                errordlg('two channels are required to calculate cross-correlation','modal');
                return
            end

            if isnan(c)
                errordlg('cross-correlation calculation failed. try changing radius','modal');
                return
            else
                params{1} = fitData(r,c,dc,nmpixSize,fit,P,base_name,correlation,property);
                corrData(1).twoDcorr = C;
                corrData(1).radius = r;
                corrData(1).correlation = c;
                corrData(1).error = dc;
                corrData(1).mask = maskout;
                corrData(1).type = 'cross';
            end
    end
end

% -----------------------------------------------------------------------------

function params = fitData(x,y,err,pixSize,type,Pin,base_name,correlation,property)
%fit the data

    switch type
        case 'exponential_and_gaussian'
            params = repmat(struct('cluster_size',[],'magnitude',[],'density',[],'sigma',[]),1,1);
        case 'exponential_and_cosine'
            params = repmat(struct('cluster_size',[],'magnitude',[],'r0',[]),1,1);
        case 'exponential'
            params = repmat(struct('cluster_size',[],'magnitude',[]),1,1);
    end

    x = x .* pixSize;
    if ~isempty(property.Fig_ext)
       figure('Visible', 'off');
    else
       figure;
    end
    axes(property.Font_props{:});
    hold on
    errorbar(x(2:end), y(2:end), err(2:end), 'k.', 'LineWidth', 2)
    plot(x(2:end),ones(1, numel(x) - 1), 'b:', 'LineWidth', 3)
    switch type
        case 'exponential_and_gaussian'
            P0 = [Pin(1), Pin(2), Pin(3), Pin(4)];

            P = lsqcurvefit(@(P, r) exponential_and_gaussian(P, r), P0, x(2:end), y(2:end)-1);
            %P = lsqcurvefit('exponential_and_gaussian', P0, x(2:end), y(2:end)-1);

            %hold on
            plot(x, exponential_and_gaussian(P, x)+1, 'r', 'LineWidth', 3)
            %hold off

            %legend ('data', 'fit')

            params.cluster_size = P(1); %characteristic size of structure
            params.magnitude = P(2); % magnitude of clustering
            params.sigma = P(3)/sqrt(2); %in nm
            params.density = P(4); %in 1/um^2
        case 'exponential_and_cosine'
            P0 = [Pin(1), Pin(2), Pin(3)];
            P = lsqcurvefit(@(P, r) exponential_and_cosine(P, r), P0, x(2:end), y(2:end)-1);
            %P = lsqcurvefit('exponential_and_cosine', P0, x(2:end), y(2:end)-1);

            %hold on
            plot(x, exponential_and_cosine(P, x)+1, 'r', 'LineWidth', 3)
            %hold off

            %legend ('data', 'fit')

            params.cluster_size = P(1); %characteristic size of structure
            params.magnitude = P(2); % magnitude of clustering
            params.r0 = P(3); %in nm
        case 'exponential'
            P0 = [Pin(1), Pin(2)];
            P = lsqcurvefit(@(P, r) exponential(P, r), P0, x(2:end), y(2:end)-1);
            %P = lsqcurvefit('exponential', P0, x(2:end), y(2:end)-1);

            %hold on
            plot(x, exponential(P, x)+1, 'r', 'LineWidth', 3)
            %hold off

            %legend ('data', 'fit')

            params.cluster_size = P(1); %characteristic size of structure
            params.magnitude = P(2); % magnitude of clustering
    end
    legend(sprintf('%s-correlation data', correlation), 'g(r) Random', 'fit');
    axis tight
    xlabel('r (nm)');
    ylabel('g(r)');
    title(sprintf('%s (Veatch)', regexprep(base_name, '_', '\\_')));
    hold off
    if ~isdir(property.ResultsDir)
       mkdir(property.ResultsDir);
    end
    name = fullfile(property.ResultsDir, ...
                    sprintf('%s_%scorrV', base_name, correlation));
    if ~isempty(property.Fig_ext)
       print(['-d', property.Fig_ext], name);
       saveas(gcf, name);
    else
       saveas(gcf, name);
       delete(gcf);
    end
end

% =============================================================================

function [Hout Xbins Ybins] = hist2d(D, varargin) %Xn, Yn, Xrange, Yrange)
%HIST2D 2D histogram
%
% [H XBINS YBINS] = HIST2D(D, XN, YN, [XLO XHI], [YLO YHI])
% [H XBINS YBINS] = HIST2D(D, 'display' ...)
%
% HIST2D calculates a 2-dimensional histogram and returns the histogram
% array and (optionally) the bins used to calculate the histogram.
%
% Inputs:
%     D:         N x 2 real array containing N data points or N x 1 array
%                 of N complex values
%     XN:        number of bins in the x dimension (defaults to 20)
%     YN:        number of bins in the y dimension (defaults to 20)
%     [XLO XHI]: range for the bins in the x dimension (defaults to the
%                 minimum and maximum of the data points)
%     [YLO YHI]: range for the bins in the y dimension (defaults to the
%                 minimum and maximum of the data points)
%     'display': displays the 2D histogram as a surf plot in the current
%                 axes
%
% Outputs:
%     H:         2D histogram array (rows represent X, columns represent Y)
%     XBINS:     the X bin edges (see below)
%     YBINS:     the Y bin edges (see below)
%
% As with histc, h(i,j) is the number of data points (dx,dy) where
% x(i) <= dx < x(i+1) and y(j) <= dx < y(j+1). The last x bin counts
% values where dx exactly equals the last x bin value, and the last y bin
% counts values where dy exactly equals the last y bin value.
%
% If D is a complex array, HIST2D splits the complex numbers into real (x)
% and imaginary (y) components.
%
% Created by Amanda Ng on 5 December 2008

% Modification history
%   25 March 2009 - fixed error when min and max of ranges are equal.
%   22 November 2009 - added display option; modified code to handle 1 bin

    % PROCESS INPUT D
    if nargin < 1 %check D is specified
        error 'Input D not specified'
    end

    Dcomplex = false;
    if ~isreal(D) %if D is complex ...
        if isvector(D) %if D is a vector, split into real and imaginary
            D=[real(D(:)) imag(D(:))];
        else %throw error
            error 'D must be either a complex vector or nx2 real array'
        end
        Dcomplex = true;
    end

    if (size(D,1)<size(D,2) && size(D,1)>1)
        D=D';
    end

    if size(D,2)~=2;
        error('The input data matrix must have 2 rows or 2 columns');
    end

    % PROCESS OTHER INPUTS
    var = varargin;

    % check if DISPLAY is specified
    index = find(strcmpi(var,'display'));
    if ~isempty(index)
        display = true;
        var(index) = [];
    else
        display = false;
    end

    % process number of bins
    Xn = 20; %default
    Xndefault = true;
    if numel(var)>=1 && ~isempty(var{1}) % Xn is specified
        if ~isscalar(var{1})
            error 'Xn must be scalar'
        elseif var{1}<1 %|| ~isinteger(var{1})
            error 'Xn must be an integer greater than or equal to 1'
        else
            Xn = var{1};
            Xndefault = false;
        end
    end

    Yn = 20; %default
    Yndefault = true;
    if numel(var)>=2 && ~isempty(var{2}) % Yn is specified
        if ~isscalar(var{2})
            error 'Yn must be scalar'
        elseif var{2}<1 %|| ~isinteger(var{2})
            error 'Xn must be an integer greater than or equal to 1'
        else
            Yn = var{2};
            Yndefault = false;
        end
    end

    % process ranges
    if numel(var) < 3 || isempty(var{3}) %if XRange not specified
        Xrange=[min(D(:,1)),max(D(:,1))]; %default
    else
        if nnz(size(var{3})==[1 2]) ~= 2 %check is 1x2 array
            error 'XRange must be 1x2 array'
        end
        Xrange = var{3};
    end
    if Xrange(1)==Xrange(2) %handle case where XLO==XHI
        if Xndefault
            Xn = 1;
        else
            Xrange(1) = Xrange(1) - floor(Xn/2);
            Xrange(2) = Xrange(2) + floor((Xn-1)/2);
        end
    end

    if numel(var) < 4 || isempty(var{4}) %if XRange not specified
        Yrange=[min(D(:,2)),max(D(:,2))]; %default
    else
        if nnz(size(var{4})==[1 2]) ~= 2 %check is 1x2 array
            error 'YRange must be 1x2 array'
        end
        Yrange = var{4};
    end
    if Yrange(1)==Yrange(2) %handle case where YLO==YHI
        if Yndefault
            Yn = 1;
        else
            Yrange(1) = Yrange(1) - floor(Yn/2);
            Yrange(2) = Yrange(2) + floor((Yn-1)/2);
        end
    end

    % SET UP BINS
    Xlo = Xrange(1) ; Xhi = Xrange(2) ;
    Ylo = Yrange(1) ; Yhi = Yrange(2) ;
    if Xn == 1
        XnIs1 = true;
        Xbins = [Xlo Inf];
        Xn = 2;
    else
        XnIs1 = false;
        Xbins = linspace(Xlo,Xhi,Xn) ;
    end
    if Yn == 1
        YnIs1 = true;
        Ybins = [Ylo Inf];
        Yn = 2;
    else
        YnIs1 = false;
        Ybins = linspace(Ylo,Yhi,Yn) ;
    end

    Z = linspace(1, Xn+(1-1/(Yn+1)), Xn*Yn);

    % split data
    Dx = floor((D(:,1)-Xlo)/(Xhi-Xlo)*(Xn-1))+1;
    Dy = floor((D(:,2)-Ylo)/(Yhi-Ylo)*(Yn-1))+1;
    Dz = Dx + Dy/(Yn) ;

    % calculate histogram
    h = reshape(histc(Dz, Z), Yn, Xn);

    if nargout >=1
        Hout = h;
    end

    if XnIs1
        Xn = 1;
        Xbins = Xbins(1);
        h = sum(h,1);
    end
    if YnIs1
        Yn = 1;
        Ybins = Ybins(1);
        h = sum(h,2);
    end

    % DISPLAY IF REQUESTED
    if ~display
        return
    end

    [x y] = meshgrid(Xbins,Ybins);
    dispH = h;

    % handle cases when Xn or Yn
    if Xn==1
        dispH = padarray(dispH,[1 0], 'pre');
        x = [x x];
        y = [y y];
    end
    if Yn==1
        dispH = padarray(dispH, [0 1], 'pre');
        x = [x;x];
        y = [y;y];
    end

    surf(x,y,dispH);
    colormap(jet);
    if Dcomplex
        xlabel real;
        ylabel imaginary;
    else
        xlabel x;
        ylabel y;
    end

end

% -----------------------------------------------------------------------------

function y = exponential_and_gaussian(P, r)
xi = P(1);
A = P(2);
s = P(3);
rho = P(4)*1e-6;
if length(P)<5, C = 0; else C = P(5); end

A2 = 1/2/pi/s^2/rho;
y = A2*exp(-r.^2/2/s^2) + A*exp(-r/xi)+C;

end

% -----------------------------------------------------------------------------

function y = exponential_and_cosine(P, r)
xi = P(1);
A = P(2);
r0 = P(3);
if length(P)<4, C = 1; else C = P(4); end

y = C + A*exp(-r/xi).*cos((pi*r)/2/r0);

end

% -----------------------------------------------------------------------------

function y = exponential(P, r)
xi = P(1);
A = P(2);
if length(P)<3, C = 0; else C = P(3); end

y = A*exp(-r/xi)+C;

end

./MATLAB/+smi_cluster/@PairAnalysis/doLocSep2.m
function results_ls = ...
   doLocSep2(n_ROIs, RoI, desc, particles, results_dir, plotting)
% Find the nearest neighbor of each label 2 localization to each label 1
% localization.
%
% INPUTS:
%    n_ROIs        number of ROIs
%    RoI           data structure containing x and y coordinates per ROI
%    desc          string identifying the analysis
%    particles     string array describing the two particles
%    results_dir   output directory
%    plotting      true if producing plots
%
% OUTPUTS:
%    results_ls      localization separation between labels
%                       results_ls{1:n_ROIs}s
%                          .indx   index of nearest neighbor to each loc.
%                          .dist   NN localization distances
%       Also, figures *_ls_ROI*   histogram per ROI of loc. L1+L2 separations
%             *_ls_RC_PDF/CDF     ROI combined PDF and CDF over each cell

% Created by
%    Michael J. Wester (2022)

   xtxt = sprintf('%s-%s localization separation distances (nm)', ...
                  particles{1}, particles{2});
   results_ls = cell(n_ROIs, 1);
   bin_width = 5;
   dist_all = [];
   for i = 1 : n_ROIs
      label1 = [RoI{i}.X{1}, RoI{i}.Y{1}];
      label2 = [RoI{i}.X{2}, RoI{i}.Y{2}];
      [indx, dist] = knnsearch(label1, label2);
      results_ls{i}.indx = indx;
      results_ls{i}.dist = dist;
      dist_all = [dist_all; dist];

      if plotting
         figure('Visible', 'off');
         hold on
         histogram(results_ls{i}.dist, 'BinWidth', bin_width);
         xlabel(xtxt);
         ylabel('frequency');
         txt = sprintf('%s_ls_ROI%d', desc, i);
         title(regexprep(txt, '_', '\\_'));
         hold off
         saveas(gcf, fullfile(results_dir, txt));
         print(fullfile(results_dir, txt), '-dpng');
      end
   end

   % Combined plot over all ROIs.
   SC = smi_cluster.StatisticsClustering();
   SC.BaseName = desc;
   SC.ResultsDir = results_dir;
   SC.PlotDo = 'pC';
   P = SC.plotCombined({dist_all}, bin_width, xtxt, {}, '_ls_RC');

end

./MATLAB/+smi_cluster/@PairAnalysis/defineROIs2.m
function n_ROIs_ALL = ...
   defineROIs2(Files1, Files2, Pixel2nm, Color, ROI_sizes, ResultsDir, ...
               RegistrationNeeded, RegistrationViaDC)
% Select ROIs simultaneously for label 1 and label 2 over all images.
%
% INPUTS:
%    Files1       list of label 1 files fully specified
%    Files2       list of label 2 files fully specified
%                 NOTE: The number of label 1 and label 2 files should be the
%                 same as the ROIs will be specified for both simultaneously
%    Pixel2nm     conversion factor from pixels to nm
%    Color        label 1 and 2 colors on display
%    ROI_sizes    ROI length and width, e.g., [2000, 2000] (nm)
%    ResultsDir   directory in which to place the files generated
%    RegistrationNeeded   2-color registration via fiducials needed?
%    RegistrationViaDC    2-color registration via drift correction?
%
% OUTPUTS:
%    n_ROIs_ALL   total number of ROIs selected over all label 1/2 image pairs
%    *_ROIs.mat   data files specifying the ROIs selected for each image
%    *_ROIs.png   images identifying the ROIs selected per pair of label 1/2
%                 files
%    Note: data file defines n_ROIs (number of ROIs) and
%       RoI{1:n_ROIs}.ROI             ROI coordinates (xmin, xmax, ymin, ymax)
%       RoI{1:n_ROIs}.X/Y/X_SE/Y_SE   [L1 values, L2 values]

% Created by
%    Michael J. Wester (2022)

   RT = smi_helpers.ROITools();
   RT.EM = false;      % if true, data is in EM format
   RT.Color = Color;   % label 1 and 2 colors on display
   RT.ROI_sizes = ROI_sizes;
   RT.Pixel2nm = Pixel2nm;

   n_ROIs_ALL = 0;
   n_files = numel(Files1);
   for i = 1 : n_files
      Label1 = Files1{i};
      Label2 = Files2{i};

      B1 = load(Label1);
      B2 = load(Label2);
      if isfield(B1, 'BGL') || isfield(B1, 'MAPN')
         % BaGoL_Results files (coordinate units are nm).
         if isfield(B1, 'BGL')
            SMD1 = B1.BGL.MAPN;
            SMD2 = B2.BGL.MAPN;
         else
            SMD1 = B1.MAPN;
            SMD2 = B2.MAPN;
         end
         % Convert to pixels from nm as this is now an SMD structure.
         SMD1.X = SMD1.X / Pixel2nm;
         SMD1.Y = SMD1.Y / Pixel2nm;
         SMD2.X = SMD2.X / Pixel2nm;
         SMD2.Y = SMD2.Y / Pixel2nm;
         SMD1.X_SE = SMD1.X_SE / Pixel2nm;
         SMD1.Y_SE = SMD1.Y_SE / Pixel2nm;
         SMD2.X_SE = SMD2.X_SE / Pixel2nm;
         SMD2.Y_SE = SMD2.Y_SE / Pixel2nm;
      elseif isfield(B1, 'SMD')
         % SMD Results files (coordinate units are pixels).
         SMD1 = B1.SMD;
         SMD2 = B2.SMD;
      elseif isfield(B1, 'SMR')
         % SR ResultsStruct files.
         SMD1 = B1.SMR;
         SMD2 = B2.SMR;
      else
         error('Unknown result structure!');
      end

      if RegistrationNeeded
         [SMD2.X, SMD2.Y] = ...
            transformPointsInverse(R.LWMTransform, SMD2.X, SMD2.Y);
      end
      if RegistrationViaDC
         [delta12, Statistics] = ...
            smi_core.DriftCorrection.regViaDC(SMD1, SMD2);
         fprintf('regViaDC Cell %d deltas: [%g, %g]\n', i, delta12);
         SMD2.X = SMD2.X - delta12(1);
         SMD2.Y = SMD2.Y - delta12(2);
      end

      % The below assumes files are named like *_L1.ext and *_L2.ext where
      % L1/L2 are text distinguishing Label 1 from Label 2, and .ext is the
      % file extension (e.g., '.mat', 'txt', etc.).
      [filepath, filename] = fileparts(Files1{i});
      desc = regexprep(filename, '_ResultsStruct$', '');

      % Select ROIs for each pair of files (identified by Label1 and Label2).
      txt = regexprep(desc, '_', '\\_');
      %  Use the mouse to select ROIs (regions of interest):
      %    left click  chooses the center of a fixed size (x_size x y_size)
      %                region
      %    right click chooses an adjustable rectangular size region
      %    key press:
      %       backspace or delete   deletes the previous region
      %       anything else         terminates selection
      [n_ROIs, RoI, XYsize] = RT.getROI({SMD1, SMD2}, txt);
      n_ROIs_ALL = n_ROIs_ALL + n_ROIs;

      % Redefine Pixel2nm for later use.
      Pixel2nmSAVE = Pixel2nm;
      Pixel2nm = 1;
      saveas(gcf, fullfile(ResultsDir, sprintf('%s_ROIs.fig', desc)));
      print(fullfile(ResultsDir, sprintf('%s_ROIs.png', desc)), '-dpng');
      save(fullfile(ResultsDir, sprintf('%s_ROIs.mat', desc)), ...
           'Label1', 'Label2', 'Pixel2nm', 'XYsize', 'n_ROIs', 'RoI');
      close
      Pixel2nm = Pixel2nmSAVE;
      fid = fopen(fullfile(ResultsDir, sprintf('%s_ROIs.txt', desc)), 'w');
      for i = 1 : n_ROIs
         fprintf(fid, '%d %7.3f %7.3f %7.3f %7.3f\n', ...
                      i, RoI{i}.ROI ./ Pixel2nm);
      end
      fclose(fid);
   end
   fprintf('Done ROIs.\n');

end

./MATLAB/+smi_cluster/@PairAnalysis/doOverlap.m
function results_o = doOverlap(n_ROIs, RoI, results_c, l12, desc,      ...
                               particles, results_dir, PlotNonOverlap, ...
                               Color, plotting)
% Find overlaps between label 1/2 clusters and label 2/1 localizations.
%
% INPUTS:
%    n_ROIs        number of ROIs
%    RoI           data structure containing x and y coordinates per ROI; see
%                  defineROIs2
%    results_c     results from ckustering (see doClustering)
%    l12           true  (1) for label 1 clusters/label 2 localizations
%                  false (0) for label 2 clusters/label 1 localizations
%    desc          string identifying the analysis
%    particles     string array describing the two particles
%    results_dir   output directory
%    PlotNonOverlap if true, plot non-overlapping locs as black dots, otherwise
%                  omit them from the plot
%    Color         label 1 and label 2 colors on display
%    plotting      true if producing plots
%
% OUTPUTS:
%    results_o       overlap between label l1 cluster/label l2 localizations
%                       results_o{1:n_ROIs}
%                          .CluLabel   clusters label
%                          .LocLabel   localizations label
%                          .Ltotal     total Loclabel localizations in ROI
%                          .Lin        overlap locs. wrt CluLabel clusters
%       Also, figures *_cLl1_lLl2 Color(l1) Ll1 clusters, Color(l2) Ll2 locs.
%       where l1 identifies clusters and l2 identifies localizations (see
%       l12 in the inputs).

% Created by
%    Michael J. Wester (2022)

   results_o = cell(n_ROIs, 1);
   if l12
      l1 = 1;   % clusters label
      l2 = 2;   % localizations label
   else
      l1 = 2;   % clusters label
      l2 = 1;   % localizations label
   end
   for i = 1 : n_ROIs
      ROI = RoI{i}.ROI;

      % Collect label l1 cluster information for ROI i.
      nC    = results_c{i}{l1}.nC;   % number of clusters found
      C     = results_c{i}{l1}.C;    % indices of cluster points per cluster
      xyROI = results_c{i}{l1}.XY;   % (x, y) coordinates of locs in ROI i
      ihull = results_c{i}{l1}.indices_hull;   % boundary indices per cluster
      % Note that the last boundary index is the same as the first for drawing
      % purposes, so the number of actual boundary vertices is one less per
      % cluster.
      nBoundaryPtsPerC = cellfun(@numel, ihull) - 1;   % perC = per Cluster
      % Construct xv, yv from all the cluster boundary points.  This will be
      % arranged like:
      %    [b11, b12, b13, NaN, b21, b22, b23, b24];
      % where bij is the j boundary point of the ith cluster.  NaN's separate
      % clusters.
      xyv = zeros(sum(nBoundaryPtsPerC) - 1, 2);
      j = 1;
      k = 0;
      nB = nBoundaryPtsPerC(j);
      xyv(k + 1 : k + nB, :) = xyROI(C{j}(ihull{j}(1 : nB)), :);
      k = k + nBoundaryPtsPerC(j);
      for j = 2 : nC
         k = k + 1;
         xyv(k, :) = NaN;
         nB = nBoundaryPtsPerC(j);
         xyv(k + 1 : k + nB, :) = xyROI(C{j}(ihull{j}(1 : nB)), :);
         k = k + nBoundaryPtsPerC(j);
      end
      xv = xyv(:, 1);
      yv = xyv(:, 2);

      % Collect label l2 localizations inside ROI i.
      xq = RoI{i}.X{l2};
      yq = RoI{i}.Y{l2};

      % Here's the magic that does the hard work.
      in = inpolygon(xq, yq, xv, yv);
      n_total = numel(in);
      n_in = sum(in);

      results_o{i}.CluLabel = l1;      % clusters label
      results_o{i}.LocLabel = l2;      % localizations label
      results_o{i}.Ltotal = n_total;   % total l2 localizations in ROI i
      results_o{i}.Lin = n_in;         % overlapping l2 locs wrt l1 clusters

      if plotting
         figure;
         axes('FontSize', 15, 'FontWeight', 'bold');
         hold on
         % Plot the ROI boundaries.
         plot([ROI(1), ROI(2), ROI(2), ROI(1), ROI(1)], ...
              [ROI(3), ROI(3), ROI(4), ROI(4), ROI(3)], 'r-', 'LineWidth', 2);
         % Plot the l1 clusters.
         for j = 1 : nC
            xyc = xyROI(C{j}(ihull{j}), :);
            plot(xyc(:, 1), xyc(:, 2), [Color(l1), '-']);
         end
         % Plot l2 localizations outside clusters.
         if PlotNonOverlap
            plot(xq(~in), yq(~in), 'k.');
         end
         % Plot l2 localizations inside clusters (or on their boundary).
         plot(xq(in),  yq(in),  [Color(l2), 'x']);
         xlabel('x (nm)');
         ylabel('y (nm)');
         title(sprintf(['ROI %d L%d clusters/L%d locs, ', ...
                        'overlap %d/%d = %.2f%%'],        ...
                       i, l1, l2, n_in, n_total, 100 * n_in/n_total));
         hold off

         txt = sprintf('%s_ROI%d_cL%d_lL%d', desc, i, l1, l2);
         print(gcf, fullfile(results_dir, sprintf('%s.png', txt)), ...
                    '-dpng', '-r1200');
         savefig(gcf, fullfile(results_dir, sprintf('%s.fig', txt)), ...
                      'compact');
         close
      end
   end

end

./MATLAB/+smi_cluster/@PairAnalysis/overlayBaGoLROIs.m
function overlayBaGoLROIs(pathnameB, filesB, MAPNfile, ROI_sizes, SRImageZoom)
% ---------- Possibly, produce Gaussian overlay images of individually
%            processed BaGoL ROIs
% This function will overlay label 1 onto label 2 Gaussian images produced from
% the input ROI file names into appropriately named files.  This assumes the
% various files involved are following a naming convention.  For example, the
% BaGoL results files oer ROI are named:
%    BaGoL_Results_Cell_01_Label_01_Results_ROI_01_ResultsStruct.mat
%    BaGoL_Results_Cell_01_Label_01_Results_ROI_02_ResultsStruct.mat
%    ...
%    BaGoL_Results_Cell_01_Label_02_Results_ROI_01_ResultsStruct.mat
%    ...
%    BaGoL_Results_Cell_02_Label_01_Results_ROI_01_ResultsStruct.mat
%    ...
% and the BaGoL MAPN coordinates per ROI are named:
%    MAPN_Cell_01_Label_01_Results_ROI_01.mat
%    MAPN_Cell_01_Label_01_Results_ROI_02.mat
%    ...
%    MAPN_Cell_01_Label_02_Results_ROI_01.mat
%    ...
%    MAPN_Cell_02_Label_01_Results_ROI_01.mat
%    ...
% The collection of ROIs (overlaying both labels) produced from the BaGoL data:
%    Cell_01_ROI_01_OverlayLabels_BaGoL.png
%    Cell_01_ROI_02_OverlayLabels_BaGoL.png
%    ...
%    Cell_02_ROI_01_OverlayLabels_BaGoL.png
%    ...
%
% INPUTS:
%    pathnameB   path to where the BaGoL files below are located
%    filesB      BaGoL files to collect ROI coordinate info from
%    MAPNfile    if false, assume BaGoL_Results_*_Results*.mat files,
%                otherwise if true, assume MAPN_*.mat files
%    ROI_sizes   ROI dimensions in x and y (nm)
%    SRImageZoom image resolution magnification factor [default = 4]
%
% OUTPUTS:
%    Saves pathnameB/Analysis/*_OverlayLabels_BaGoL.png
%    Saves pathnameB/Analysis/*_OverlayLabels_BaGoL_circle.png

% Created by
%    Michael J. Wester (2023)

   if ~exist('SRImageZoom', 'var')
      SRImageZoom = 4;
   end

   results_dir = pathnameB;

   n_labels = 2;
   n_Label2 = 0;
   n_files = numel(filesB);
   % Each file contains a singly labeled ROI.
   for i = 1 : n_files
      fileB = filesB{i};
      % Extract the cell, label and ROI numbers from the file name.
      c = str2num(regexprep(fileB, '^.*Cell_([0-9][0-9]).*$',  '$1'));
      l = str2num(regexprep(fileB, '^.*Label_([0-9][0-9]).*$', '$1'));
      r = str2num(regexprep(fileB, '^.*ROI_([0-9][0-9]).*$',   '$1'));
      fprintf('Cell %02d ROI %02d Label %02d\n', c, r, l);

      % If this is a label 2 file name, assume it has been or will be processed
      % with the label 1 file, so skip this iteration of the loop.
      if l == 2
         n_Label2 = n_Label2 + 1;
         continue;
      end

      ResultsFile = sprintf('Cell_%02d_ROI_%02d_OverlayLabels_BaGoL', c, r);
      SaveFile = fullfile(pathnameB, ResultsFile);
      ResultsFile = sprintf('Cell_%02d_ROI_%02d_OverlayLabels_BaGoL_circle',...
                            c, r);
      SaveFileC = fullfile(pathnameB, ResultsFile);

      % Here, fileB is label 1.
      fileB1 = fileB;
      fileB2 = regexprep(fileB1, 'Label_01', 'Label_02');

      dataB1 = load(fullfile(pathnameB, fileB1));
      dataB2 = load(fullfile(pathnameB, fileB2));

      ScalebarLength = 500; % nm (smi.BaGoL.scalebar)
      if MAPNfile
         dataB1_MAPN = dataB1.MAPN;
         dataB2_MAPN = dataB2.MAPN;
         XStart = dataB1.XStart;
         YStart = dataB1.YStart;
         PImageSize = dataB1.PImageSize;
         PixelSize = dataB1.PixelSize;
         PixelSize1 = PixelSize;

         BGL1 = smi.BaGoL;
         BGL1.XStart = XStart;
         BGL1.YStart = YStart;
         BGL1.PImageSize = PImageSize;
         BGL1.PixelSize = PixelSize / SRImageZoom;
         BGL1.MAPN = dataB1_MAPN;

         BGL2 = smi.BaGoL;
         BGL2.XStart = XStart;
         BGL2.YStart = YStart;
         BGL2.PImageSize = PImageSize;
         BGL2.PixelSize = PixelSize / SRImageZoom;
         BGL2.MAPN = dataB2_MAPN;
      else
         dataB1_MAPN = dataB1.BGL.MAPN;
         dataB2_MAPN = dataB2.BGL.MAPN;
         XStart = dataB1.BGL.XStart;
         YStart = dataB1.BGL.YStart;
         PixelSize = dataB1.BGL.PixelSize;

         BGL1 = dataB1.BGL;
         PixelSize1 = BGL1.PixelSize;
         BGL1.PixelSize = BGL1.PixelSize / SRImageZoom;

         BGL2 = dataB2.BGL;
         PixelSize2 = BGL2.PixelSize;
         BGL2.PixelSize = BGL2.PixelSize / SRImageZoom;
      end

      % Produce Gaussian Images for the two labels, then overlay them.
      BaGoLScalebarLength = ScalebarLength / BGL1.PixelSize;
      GaussIm1 = BGL1.genMAPNIm(1);
      GaussIm1 = BGL1.scaleIm(GaussIm1, 98);
      GaussIm1 = BGL1.scalebar(GaussIm1, 1, BaGoLScalebarLength);

      BaGoLScalebarLength = ScalebarLength / BGL2.PixelSize;
      GaussIm2 = BGL2.genMAPNIm(1);
      GaussIm2 = BGL2.scaleIm(GaussIm2, 98);
      GaussIm2 = BGL2.scalebar(GaussIm2, 1, BaGoLScalebarLength);

      ImageStack = zeros([size(GaussIm1, 1), size(GaussIm1, 2), 2]);
      ImageStack(:, :, 1) = GaussIm1;
      ImageStack(:, :, 2) = GaussIm2;
      [OverlayImage, ColorOrderTag] = ...
         smi_vis.GenerateImages.overlayNImages(ImageStack);
      imwrite(OverlayImage, hot(256), [SaveFile, '.png']);

      % Circle image of label 1 versus label 2.
      XSize = ROI_sizes(1);
      YSize = ROI_sizes(2);
      PixelSize = PixelSize1 / SRImageZoom;
      RadiusScale = 2;
      CircleIm = BGL1.genSRMAPNOverlay(BGL1.MAPN, BGL2.MAPN, ...
                    XSize, YSize, PixelSize, pathnameB,      ...
                    BGL1.XStart, BGL1.YStart, RadiusScale, ScalebarLength);
      imwrite(CircleIm, [SaveFileC, '.png']);
   end

   % Consistency check.
   if n_labels * n_Label2 ~= n_files
      error('%d (# labels) * %d (# label 2 ROIs) != %d (# files)!', ...
            n_labels, n_Label2, n_files);
   end

   fprintf('Done overlaying BaGoL ROIs: %s.\n', results_dir);

end

./MATLAB/+smi_cluster/@PairAnalysis/README.md
### +smi_cluster/@PairAnalysis

A collection of functions that interface with the main smi.PairCorrelation
routines.
These are used in the MATLAB/examples simplePairCorrelation.m, which performs a
series of steps (one per section, mostly optional) to analyze pairs of 1-color
SR files (so 2-color) produced
by smi.SMLM by computing clusters and various statistics.

---

methods:
- **[defineROIs2](defineROIs2.m)**:
  Select ROIs simultaneously for label 1 and label 2 over all images
- **[doAnalysis](doAnalysis.m)**:
  Dispatches analyses to various helper functions depending options provided
- **[doBiStats](doBiStats.m)**:
  Pairwise mutual distances and bivariate Ripley's statistics for each ROI
- **[doClusterSep2](doClusterSep2.m)**:
  Find the nearest neighbor of each label 2 cluster to each label 1 cluster
  using center-to-center distances
- **[doClustering](doClustering.m)**:
  Clustering for each label in each ROI given epsilon (E) and minPts
- **[doLocSep2](doLocSep2.m)**:
  Find the nearest neighbor of each label 2 localization to each label 1
  localization
- **[doOverlap](doOverlap.m)**:
  Find overlaps between label 1/2 clusters and label 2/1 localizations
- **[doPairCorr](doPairCorr.m)**:
  Pair cross-correlation for each ROI and combined ROI
- **[doPlot2](doPlot2.m)**:
  Plot 2D ROIs
- **[overlayBaGoLROIs](overlayBaGoLROIs.m)**:
  overlay label 1 onto label 2 Gaussian images produced from the input ROI file
  names into appropriately named files

./MATLAB/+smi_cluster/@PairAnalysis/doPairCorr.m
function [results_pcc, resultsRC_pcc] = ...
   doPairCorr(n_ROIs, RoI, ROI_sizes, desc, results_dir, combined, ...
              plotting, HistBinSize, RmaxAxisLimit)
% Pair cross-correlation for each ROI and combined ROIs.
%
% INPUTS:
%    n_ROIs        number of ROIs
%    RoI           data structure containing x and y coordinates per ROI
%    ROI_sizes     ROI sizes (nm)
%    desc          string identifying the analysis
%    results_dir   output directory
%    combined      analysis is combined over all ROIs
%    plotting      true if producing plots
%    HistBinSize   number of pixels per bin to collect correlation statistics
%    RmaxAxisLimit sets r axis limit for pair correlation plots if > 0 (nm)
%
% OUTPUTS:
%    results_pcc     pair cross-correlation
%                       results_pcc{1:n_ROIs}
%                          .G       2D pair-correlation function values
%                          .r       radius values (nm)
%                          .g       angularly averaged pair corr. function
%                          .dg      errors on angularly averaged g
%                          .model   model calculated at estimated value
%                          ....     various model results
%       Also, figures *_ROI*_crosscorr (ROIwise pairwise cross-correlations)
%    resultsRC_pcc   ROIs combined pair cross-correlation
%                       results_pcc{1:n_ROIs}
%                          see results_pcc (ROI combined pairwise_crosscorr)
%       Also, figures *_RC_crosscorrR

% Created by
%    Michael J. Wester (2022)

   pc = smi_cluster.PairCorrelation();

   pc.ResultsDir = results_dir;    % results directory
   pc.Fig_ext = 'png';             % figure extension
   pc.Rmax_axis = RmaxAxisLimit;   % sets plotting limit if > 0
   % Histogram bin size for pairwise correlation---this is the number of pixels
   % per bin over which correlation statistics are collected.
   pc.HistBinSize = HistBinSize;

   ROIs_combined = cell(n_ROIs, 1);
   results_pcc   = cell(n_ROIs, 1);
   resultsRC_pcc = [];
   for i = 1 : n_ROIs
      if plotting
         fprintf('ROI %d\n\n', i);
      end

      txt = sprintf('%s_ROI%d', desc, i);
      pc.BaseName = txt;
      pc.ROI = RoI{i}.ROI;
      XY1 = [ RoI{i}.X{1}, RoI{i}.Y{1} ];
      XY2 = [ RoI{i}.X{2}, RoI{i}.Y{2} ];

      ROIs_combined{i} = RoI{i};

      if plotting || combined
         results_pcc{i} = pc.pair_correlation(XY1, XY2);
      end
   end

   % Combined plot over all the ROIs.
   if combined && n_ROIs > 0
      fprintf('ROI combined\n\n');
      txt = sprintf('%s_RC', desc);
      pc.BaseName = txt;
      resultsRC_pcc = ...
         pc.pair_correlation_ROIcombined(2, n_ROIs, ROIs_combined, 1)
   end

   if combined
      gmax = zeros(n_ROIs, 1);
      den1 = zeros(n_ROIs, 1);
      den2 = zeros(n_ROIs, 1);
      ROI_area = prod(ROI_sizes);
      for i = 1 : n_ROIs
         gmax(i) = max(results_pcc{i}.g);
         den1(i) = numel(ROIs_combined{i}.X{1}) ./ ROI_area;
         den2(i) = numel(ROIs_combined{i}.X{2}) ./ ROI_area;
      end

      h = figure;
      axes('FontSize', 15, 'FontWeight', 'bold');
      hold on
      plot(den1, gmax, 'k.', 'MarkerSize', 10);
      xlabel('density Label 1 (#/nm^2)');
      ylabel('g_{max}');
      txt = sprintf('%s_gmax_den1', desc);
      title(regexprep(txt, '_', '\\_'));
      hold off
      saveas(h, fullfile(results_dir, sprintf('%s.png', txt)));
      close

      h = figure;
      axes('FontSize', 15, 'FontWeight', 'bold');
      hold on
      plot(den2, gmax, 'k.', 'MarkerSize', 10);
      xlabel('density Label 2 (#/nm^2)');
      ylabel('g_{max}');
      txt = sprintf('%s_gmax_den2', desc);
      title(regexprep(txt, '_', '\\_'));
      hold off
      saveas(h, fullfile(results_dir, sprintf('%s.png', txt)));
      close
   end

end

./MATLAB/+smi_cluster/@PairAnalysis/doPlot2.m
function doPlot2(n_ROIs, RoI, desc, particles, results_dir, Color, plotting)
% Plot 2D ROIs.
%
% INPUTS:
%    n_ROIs        number of ROIs
%    RoI           data structure containing x and y coordinates per ROI
%    desc          string identifying the analysis
%    particles     string array describing the two particles
%    results_dir   output directory
%    Color         label 1 and label 2 colors on display
%    plotting      true if producing plots
%
% OUTPUTS:
%    Figures *_ROI*_L1+L2   Color(1) L1 and Color(2) L2 localizations

% Created by
%    Michael J. Wester (2022)

   if ~plotting
      return;
   end
   for i = 1 : n_ROIs
      h = figure;
      axes('FontSize', 15, 'FontWeight', 'bold');
      hold on
      plot(RoI{i}.X{1}, RoI{i}.Y{1}, [Color(1), '.']);
      plot(RoI{i}.X{2}, RoI{i}.Y{2}, [Color(2), '.']);
      txt = sprintf('%s ROI%d %s+%s', regexprep(desc, '_', '\\_'), i, ...
                    particles{1}, particles{2});
      title(txt);
      xlabel('x (xm)');
      ylabel('y (xm)');
      hold off
      txt = sprintf('%s_ROI%d_%s+%s', desc, i, particles{1}, particles{2});
      saveas(h, fullfile(results_dir, sprintf('%s.png', txt)));
      close
   end

end

./MATLAB/+smi_cluster/@PairAnalysis/PairAnalysis.m
classdef PairAnalysis < handle

% PairAnalysis class written by Michael Wester
%    (10/13/2022) <wester@math.unm.edu>
% The New Mexico Center for the Spatiotemporal Modeling of Cell Signaling
% University of New Mexico Health Sciences Center
% Albuquerque, New Mexico, USA   87131
% Copyright (c) 2015-2023 by Michael J. Wester and Keith A. Lidke

% A collection of functions that interface with the main PairCorr routines.

% =============================================================================
properties
% =============================================================================

% =============================================================================
end % properties
% =============================================================================

% =============================================================================
methods
% =============================================================================

% =============================================================================
end % methods
% =============================================================================

% =============================================================================
methods(Static)
% =============================================================================

   n_ROIs_ALL = defineROIs2(Files1, Files2, Pixel2nm, Color, ROI_sizes, ...
                            ResultsDir, RegistrationNeeded, RegistrationViaDC);
   [results_pcc, resultsRC_pcc, results_c, results_cs, results_ls,   ...
    results_o1, results_o2] =                                        ...
      doAnalysis(n_ROIs, RoI, ROI_sizes, desc, particles, results_dir,      ...
                 options, PixelSize, HistBinSize, RmaxAxisLimit, E, minPts, ...
                 PlotNonOverlap, Color)
   doBiStats(n_ROIs, RoI, desc, particles, results_dir, combined)
   results_c = doClustering(n_ROIs, RoI, desc, results_dir, plotting, ...
                            PixelSize, E, minPts)
   results_cs = ...
      doClusterSep2(n_ROIs, results_c, desc, particles, results_dir, plotting)
   results_ls = doLocSep2(n_ROIs, RoI, desc, particles, results_dir, plotting)
   [results_pcc, resultsRC_pcc] = ...
      doPairCorr(n_ROIs, RoI, ROI_sizes, desc, results_dir, combined, ...
                 plotting, HistBinSize, RmaxAxisLimit)
   results_o = doOverlap(n_ROIs, RoI, results_c, l12, desc, particles, ...
                         results_dir, PlotNonOverlap, Color, plotting)
   overlayBaGoLROIs(pathnameB, filesB, MAPNfile, ROI_sizes, SRImageZoom);
   doPlot2(n_ROIs, RoI, desc, particles, results_dir, Color, plotting)

% =============================================================================
end % methods(Static)
% =============================================================================
end % classdef

./MATLAB/+smi_cluster/@PairAnalysis/doClusterSep2.m
function results_cs = ...
   doClusterSep2(n_ROIs, results_c, desc, particles, results_dir, plotting)
% Find the nearest neighbor of each label 2 cluster to each label 1 cluster
% using center-to-center distances.
%
% INPUTS:
%    n_ROIs        number of ROIs
%    results_c     clustering results data structure produced by doClustering
%                  invoking smi_cluster.Clustering.clusterStats
%    desc          string identifying the analysis
%    particles     string array describing the two particles
%    results_dir   output directory
%    plotting      true if producing plots
%
% OUTPUTS:
%    results_cs      cluster separation between labels
%                       results_cs{1:n_ROIs}s
%                          .indx   index of nearest neighbor to each cluster
%                          .dist   NN cluster c2c distances
%       Also, figures *_cs_ROI*   histogram per ROI of cluster L1+L2 seps.
%             *_cs_RC_PDF/CDF     ROI combined PDF and CDF over each cell

% Created by
%    Michael J. Wester (2022)

   xtxt = sprintf('%s-%s cluster separation distances (nm)', ...
                  particles{1}, particles{2});
   results_cs = cell(n_ROIs, 1);
   dist_all = [];
   for i = 1 : n_ROIs
      centers1 = results_c{i}{1}.centers';
      centers2 = results_c{i}{2}.centers';
      [indx, dist] = knnsearch(centers1, centers2);
      results_cs{i}.indx = indx;
      results_cs{i}.dist = dist;
      dist_all = [dist_all; dist];

      if plotting
         figure('Visible', 'off');
         hold on
         histogram(results_cs{i}.dist, 'BinWidth', 50);
         xlabel(xtxt);
         ylabel('frequency');
         txt = sprintf('%s_cs_ROI%d', desc, i);
         title(regexprep(txt, '_', '\\_'));
         hold off
         saveas(gcf, fullfile(results_dir, txt));
         print(fullfile(results_dir, txt), '-dpng');
      end
   end

%  figure('Visible', 'off');
%  hold on
%  histogram(dist_all, 'BinWidth', 50);
%  xlabel(xtxt);
%  ylabel('frequency');
%  txt = sprintf('%s_cs_RC', desc);
%  title(regexprep(txt, '_', '\\_'));
%  hold off
%  saveas(gcf, fullfile(results_dir, txt));
%  print(fullfile(results_dir, txt), '-dpng');

   % Combined plot over all ROIs.
   SC = smi_cluster.StatisticsClustering();
   SC.BaseName = desc;
   SC.ResultsDir = results_dir;
   SC.PlotDo = 'pC';
   P = SC.plotCombined({dist_all}, 50, xtxt, {}, '_cs_RC');

end

./MATLAB/+smi_cluster/@PairAnalysis/doBiStats.m
function doBiStats(n_ROIs, RoI, desc, particles, results_dir, combined)
% Pairwise mutual distances and bivariate Ripley's statistics for each ROI.
%
% INPUTS:
%    n_ROIs        number of ROIs
%    RoI           data structure containing x and y coordinates per ROI
%    desc          string identifying the analysis
%    particles     string array describing the two particles
%    results_dir   output directory
%    combined      produce combined bivariate Ripley over all ROIs
%
% OUTPUTS:
%    Figures *_ROI*_L1/2_pairwiseCDF/PDF    compared to a random distribution
%            *_ROI*_L1,L2_pairwisePDF2/CDF2 2-label PDF/CDF
%            *_ROI*_bivripley               bivariate Ripley

% Created by
%    Michael J. Wester (2022)

   SC = smi_cluster.StatisticsClustering();
   SC.ResultsDir = results_dir;

   if ~combined
      results_birip = cell(n_ROIs, 1);
      for i = 1 : n_ROIs
         SC.BaseName = sprintf('%s_ROI%d', desc, i);
         % Compare the actual distribution of nearest neighbor distances to a
         % random distribution per ROI.
         SC.pairwiseDist(particles, RoI);
         % Produce a plot of the distribution of nearest neighbor distances
         % between the localizations in the two labels.
         SC.pairwiseMutualDist(particles, RoI);
         % Bivariate Ripley plot of the localizations per ROI.
         SC.bivariateRipley(particles, RoI);
      end
   else
      % Combined bivariate Ripley over all ROIs.
      SC.BaseName = desc;
      SC.bivariateRipley_ROIcombined(particles, n_ROIs, RoI);
   end

end

./MATLAB/+smi_cluster/@PairAnalysis/doAnalysis.m
function [results_pcc, resultsRC_pcc, results_c, results_cs, results_ls, ...
          results_o1, results_o2] =                                      ...
   doAnalysis(n_ROIs, RoI, ROI_sizes, desc, particles, results_dir,      ...
              options, PixelSize, HistBinSize, RmaxAxisLimit, E, minPts, ...
              PlotNonOverlap, Color)
% Dispatches analyses to various helper functions depending options provided.
%
% INPUTS:
%    n_ROIs        number of ROIs
%    RoI           data structure containing x and y coordinates per ROI
%    ROI_sizes     ROI sizes (nm)
%    desc          string identifying the analysis
%    particles     string array describing the two particles
%    results_dir   output directory
%    options       string array of strings specifying analyses to be performed:
%                      'combined'    the analysis is combined over all ROIs
%                      'plotting'    plots are to be produced.
%                      'BiStats'     pairwise mutual distances and bivariate
%                                    Ripley's statistics for each ROI
%                      'Clustering'  clusters for each label per ROI
%                      'Clustering2' C2C nearest neighbor distances between
%                                    label 1/label 2 clusters per ROI and
%                                    combined over all ROIs
%                      'LocSep2'     NN localization distances between L1 & L2
%                      'Overlap1'    overlap between L1 clusters/L2 locs.
%                      'Overlap2'    overlap between L2 clusters/L1 locs.
%                      'PairCorr'    pair correlation per ROI and combined over
%                                    all ROIs
%                      'Plot2'       2D plot per ROI
%    PixelSize     conversion factor conversion factor (nm)
%    HistBinSize   number of pixels per bin to collect correlation statistics;
%                  a good guess is the PixelSize
%    RmaxAxisLimit sets r axis limit for pair correlation plots if > 0 (nm)
%    E             2-element array defining epsilon for clustering each label
%    minPts        2-element array defining min cluster size for each label
%    PlotNonOverlap if true, plot non-overlapping locs as black dots, otherwise
%                  omit them from the plot
%    Color         label 1 and label 2 colors on display
%
% OUTPUTS:
%    desc_results.mat containing the various results_ cell arrays for one cell
%    Various results containers from the called helper functions in case the
%    user wants to have more details:
%                       bivariate statistics
%          Also, figures *_ROI*_L1/2_pairwiseCDF/PDF compared to a random dist.
%                *_ROI*_L1,L2_pairwisePDF2/CDF2      2-label PDF/CDF
%                *_ROI*_bivripley                    bivariate Ripley
%       results_pcc     pair cross-correlation
%                          results_pcc{1:n_ROIs}
%                             .G       2D pair-correlation function values
%                             .r       radius values (nm)
%                             .g       angularly averaged pair corr. function
%                             .dg      errors on angularly averaged g
%                             .model   model calculated at estimated value
%                             ....     various model results
%          Also, figures *_ROI*_crosscorr (ROIwise pairwise cross-correlations)
%       resultsRC_pcc   ROIs combined pair cross-correlation
%                          results_pcc{1:n_ROIs}
%                             see results_pcc (ROI combined pairwise_crosscorr)
%          Also, figures *_RC_crosscorrR
%       results_c       clustering of the 2 labels
%                          results_c{1:n_ROIs}{1:2}
%                             output of smi_cluster.Clustering.clusterStats
%                             .C         cluster indices
%                             .centers   coordinates of cluster centers
%                             .ptsI      indices of isolated points
%          Also, figures *_ROI*_L1/2_algorithm
%       results_cs      cluster separation between labels
%                          results_cs{1:n_ROIs}s
%                             .indx   index of nearest neighbor to each cluster
%                             .dist   NN cluster c2c distances
%          Also, figures *_cs_ROI*   histogram per ROI of cluster L1+L2 seps.
%                *_cs_RC_PDF/CDF     ROI combined PDF and CDF over each cell
%       results_ls      nearest neighbor localization separation between labels
%                          results_ls{1:n_ROIs}s
%                             .indx   index of nearest neighbor to each cluster
%                             .dist   NN localization distances
%          Also, figures *_ls_ROI*   histogram per ROI of loc. L1+L2 seps.
%                *_ls_RC_PDF/CDF     ROI combined PDF and CDF over each cell
%       results_o1      overlap between label 1 cluster/label 2 localizations
%                          results_o1{1:n_ROIs}
%                             .CluLabel   clusters label
%                             .LocLabel   localizations label
%                             .Ltotal     total Loclabel localizations in ROI
%                             .Lin        overlap locs. wrt CluLabel clusters
%          Also, figures *_cL1_lL2 Color(1) L1 clusters, Color(2) L2 locs.
%       results_o2      overlap between label 2 cluster/label 1 localizations
%                          results_o2{1:n_ROIs}
%                              as resultso1
%          Also, figures *_cL2_lL1 Color(1) L2 clusters, Color(2) L1 locs.
%                        plotting
%          Also, figures *_ROI*_L1+L2   Color(1) L1 and Color(2) L2 locs.

% Created by
%    Michael J. Wester (2022)

   PA = smi_cluster.PairAnalysis();

   % combined   indicates the analysis is combined over all ROIs.
   % plotting   indicates if plots are to be produced.
   combined = false;
   plotting = false;

   if any(contains(options, "combined"))
      combined = true;
   end
   if any(contains(options, "plotting"))
      plotting = true;
   end

   results_pcc = [];
   resultsRC_pcc = [];
   results_c = [];
   results_cs = [];
   results_ls = [];
   results_o1 = [];
   results_o2 = [];

   % Pairwise mutual distances and bivariate Ripley's per ROI and the latter
   % also combined over all ROIs.
   if any(contains(options, "BiStats"))
      PA.doBiStats(n_ROIs, RoI, desc, particles, results_dir, combined);
   end

   % Clusters for each label per ROI.
   if any(contains(options, "Clustering"))
      results_c  = PA.doClustering(n_ROIs, RoI, desc, results_dir, plotting,...
                                PixelSize, E, minPts);
   end

   % C2C nearest neighbor distances between label 1/label 2 clusters per ROI
   % and combined over all ROIs.
   if any(contains(options, "Clustering2"))
      results_cs = PA.doClusterSep2(n_ROIs, results_c, desc, particles, ...
                                    results_dir, plotting);
   end

   % Nearest neighbor distances between label 1/label 2 localizations per ROI
   % and combined over all ROIs.
   if any(contains(options, "LocSep2"))
      results_ls = PA.doLocSep2(n_ROIs, RoI, desc, particles, results_dir, ...
                                plotting);
   end

   % Overlaps between label 1 clusters and label 2 localizations.
   if any(contains(options, "Overlap1"))
      l12 = true;
      results_o1 = PA.doOverlap(n_ROIs, RoI, results_c, l12, desc,      ...
                                particles, results_dir, PlotNonOverlap, ...
                                Color, plotting);
   end

   % Overlaps between label 2 clusters and label 1 localizations.
   if any(contains(options, "Overlap2"))
      l12 = false;
      results_o2 = PA.doOverlap(n_ROIs, RoI, results_c, l12, desc,      ...
                                particles, results_dir, PlotNonOverlap, ...
                                Color, plotting);
   end

   % Pair correlation per ROI and combined over all ROIs.
   if any(contains(options, "PairCorr"))
      [results_pcc, resultsRC_pcc] =                                        ...
         PA.doPairCorr(n_ROIs, RoI, ROI_sizes, desc, results_dir, combined, ...
                       plotting, HistBinSize, RmaxAxisLimit);
   end

   % 2D plot per ROI.
   if any(contains(options, "Plot2"))
      PA.doPlot2(n_ROIs, RoI, desc, particles, results_dir, Color, plotting);
   end

   % Save results.
   save(fullfile(results_dir, sprintf('%s_results.mat', desc)), 'n_ROIs', ...
        'RoI', 'results_pcc', 'resultsRC_pcc', 'results_c', 'results_cs', ...
        'results_o1', 'results_o2');

end

./MATLAB/+smi_cluster/@PairAnalysis/doClustering.m
function results_c = doClustering(n_ROIs, RoI, desc, results_dir, plotting, ...
                                  PixelSize, E, minPts)
% Clustering for each label in each ROI given epsilon (E) and minPts.
%
% INPUTS:
%    n_ROIs        number of ROIs
%    RoI           data structure containing x and y coordinates per ROI
%    desc          string identifying the analysis
%    results_dir   output directory
%    plotting      true if producing plots
%    PixelSize     conversion factor conversion factor (nm)
%    E             2-element array defining epsilon for clustering each label
%    minPts        2-element array defining min cluster size for each label
%
% OUTPUTS:
%    results_c       clustering of the 2 labels
%                       results_c{1:n_ROIs}{1:2}
%                          output of smi_cluster.Clustering.clusterStats
%                          .C         cluster indices
%                          .centers   coordinates of cluster centers
%                          .ptsI      indices of isolated points
%       Also, figures *_ROI_L1/2_algorithm

% Created by
%    Michael J. Wester (2022)

   %E = 50;      % epsilon: max distance between 2 adjacent points in a cluster
   %minPts = 3;  % minimum number of points in a cluster

   c = smi_cluster.Clustering();
   c.PixelSize = PixelSize;
   c.Plotting = true;
   c.Alpha = 2;
   c.Valgorithm = 2;
   c.ShrinkFactor = 0.5;   % used to make cluster boundaries convex or concave
   algorithm = 'DBSCAN';   % clustering algorithm
   options = 'O';

   XY = cell(2, 1);
   results_c = cell(n_ROIs, 1);
   for i = 1 : n_ROIs
      XY{1} = [ RoI{i}.X{1}, RoI{i}.Y{1} ];
      XY{2} = [ RoI{i}.X{2}, RoI{i}.Y{2} ];

      for j = 1 : 2
         [nC, C, centers, ptsI] = c.cluster(algorithm, XY{j}, E(j), minPts(j));
         fprintf('%s number of clusters ROI %d label %d = %d\n', ...
                 algorithm, i, j, nC);

         results_c{i}{j} = c.clusterStats(XY{j}, C, centers);
         results_c{i}{j}.C = C;
         results_c{i}{j}.centers = centers;
         results_c{i}{j}.ptsI = ptsI;

         if plotting
            txt = sprintf('%s ROI%d L%d', desc, i, j);
            clusterFig = c.plotClusters(XY{j}, C, centers, ptsI, txt, options);
            %showm(clusterFig);
            txt = sprintf('%s_ROI%d_L%d_%s', desc, i, j, algorithm);
            saveas(clusterFig, fullfile(results_dir, sprintf('%s.png', txt)));
         end
      end
   end

end

./MATLAB/+smi_cluster/@Clustering/unitTest.m
% Test calling Clustering routines.
function success = unitTest()

success = 0;

SaveDir = smi_helpers.mkSMITETmpDir('unitTest', 'Clustering');

% Examples of how to call Clustering routines.

% If true, save plots produced into the ResultsDir defined below.
Saving = true;

% --- 2D ---

SMF = smi_core.SingleMoleculeFitting();
SMF.Data.ResultsDir = SaveDir;

if Saving
   if ~exist(SMF.Data.ResultsDir, 'dir')
      mkdir(SMF.Data.ResultsDir);
   end
end

% Simulate a sparse collection of hextets.
SIM = smi_sim.SimSMLM();
kmer = 6;                   % Hextets
PixelSize = 100;            % nm in a pixel
radius_kTet = 25/PixelSize; % Radius of the k-tets (pixel)
SZ = 100;                   % linear size of image (pixel)
receptorDensity = 1;        % Receptors/um^2
SIM.Rho = receptorDensity / (1000 / PixelSize)^2;
SIM.StartState = 'Equib';% If Equib, particle starts randomly on or off
SIM.SZ = SZ;
SIM.simkTets(kmer, radius_kTet);
SMD_Data = SIM.genNoisySMD(SIM.SMD_Model);

SZnm = SZ * PixelSize;

Npts = 1000;
% Generate a random cover of points.
xy  = SZnm * rand(2*Npts, 2);
xyz = SZnm * rand(3*Npts, 3);

% Create arrays of (x, y) or (x, y, z) coordinates (nm).
XY1 = zeros(Npts, 2);
XY1(:, 1) = xy(1:2:end, 1);
XY1(:, 2) = xy(2:2:end, 2);

XY3 = zeros(Npts, 3);
XY3(:, 1) = xyz(1:3:end, 1);
XY3(:, 2) = xyz(2:3:end, 1);
XY3(:, 3) = xyz(3:3:end, 1);

% Make SMD structures (pixel).
SMD1.X = XY1(:, 1) ./ PixelSize;
SMD1.Y = XY1(:, 2) ./ PixelSize;

SMD3.X = XY3(:, 1) ./ PixelSize;
SMD3.Y = XY3(:, 2) ./ PixelSize;
SMD3.Z = XY3(:, 3) ./ PixelSize;

SMD2 = SMD_Data;
indx = SMD2.X < 0 | SMD2.X > SZ | SMD2.Y < 0 | SMD2.Y > SZ;
SMD2.X(indx) = [];
SMD2.Y(indx) = [];
SMD2.X_SE(indx) = [];
SMD2.Y_SE(indx) = [];

% Create an array of (x, y) coordinates (nm).
XY2 = zeros(numel(SMD2.X), 2);
XY2(:, 1) = SMD2.X .* PixelSize;
XY2(:, 2) = SMD2.Y .* PixelSize;

fprintf('SMD1 [xmin, xmax, ymin, ymax] = [%5.1f, %5.1f, %5.1f, %5.1f] px\n',...
       min(SMD1.X), max(SMD1.X), min(SMD1.Y), max(SMD1.Y)); 
fprintf('SMD2 [xmin, xmax, ymin, ymax] = [%5.1f, %5.1f, %5.1f, %5.1f] px\n',...
       min(SMD2.X), max(SMD2.X), min(SMD2.Y), max(SMD2.Y)); 

% ========== Set up the smi_cluster.Clustering class (c) =========

% Note that some of the examples below use (x, y) coordinate arrays and some
% use SMD structures to indicate that both types of input may be accepted.
c = smi_cluster.Clustering(SMF);
c.PixelSize = PixelSize;
c.Timing = false;
ROI = [0, SZnm, 0, SZnm];   % nm
A_ROI = (ROI(2) - ROI(1)) * (ROI(4) - ROI(3));   % ROI area (nm^2)

% Compare each ROI nearest neighbor (nn) distances to a random distribution of
% points with the same density.
h = c.nn_ROIrandom(SMD1, A_ROI, 'Random Cover');
if Saving
   saveas(h, fullfile(SMF.Data.ResultsDir, 'RND2_nn'), 'png');
   close
end
h = c.nn_ROIrandom(SMD2, A_ROI, 'Hextets');
if Saving
   saveas(h, fullfile(SMF.Data.ResultsDir, 'HEX2_nn'), 'png');
   close
end

% ========== 2D ==========

fprintf('\n2D examples:\n\n');

% ---------- Random ----------

fprintf('Random:\n\n');
E = 200;      % minimum separation of points between clusters AND
              % maximum separation of points within  clusters (nm)
minPts = 3;   % minimum number of points required to form a cluster
% Ratio of local density / overall density for a point's Voronoi
% region to be considered sufficiently dense for clustering purposes.
c.Alpha = 1.2;

% ---[ XY ]---

% Call with (x, y) coordinate array (nm).  XY1 is a random cover.
algorithm = 'DBSCAN';
[nC, C, centers, ptsI] = c.cluster(algorithm, XY1, E, minPts);
fprintf('%s (E = %g, minPts = %d) number of clusters = %d\n', ...
        algorithm, E, minPts, nC);

% Compute statistics from the results of clustering.
results = c.clusterStats(XY1, C, centers);
fprintf('percentage clustered = %.1f\n', ...
        100 * results.n_clustered/results.n_points);

% Plot the clusters computed.
h = c.plotClusters(XY1, C, centers, ptsI, algorithm);
if Saving
   saveas(h, fullfile(SMF.Data.ResultsDir, ...
                sprintf('RND2_%s_E=%d,N=%d', algorithm, E, minPts)), 'png');
else
   figure(h)
end

% ---[ SMD ]---

% Call with SMD structure (pixel).  SMD1 is a random cover.
for algorithm_range = {'DBSCAN', 'Hierarchal', 'Voronoi'}
   algorithm = algorithm_range{1};
   if strcmp(algorithm, 'Voronoi')
      % Note that Voronoi uses Alpha (and optionally E) for its criteria.
      [nC, C, centers, ptsI] = c.cluster(algorithm, SMD1, [], minPts);
   else
      [nC, C, centers, ptsI] = c.cluster(algorithm, SMD1, E, minPts);
   end
   fprintf('%s (E = %g, minPts = %d) number of clusters = %d\n', ...
           algorithm, E, minPts, nC);

   % Compute statistics from the results of clustering.
   results = c.clusterStats(SMD1, C, centers);
   fprintf('percentage clustered = %.1f\n', ...
           100 * results.n_clustered/results.n_points);

   % Plot the clusters computed.
   h = c.plotClusters(SMD1, C, centers, ptsI, algorithm);
   if Saving
      saveas(h, fullfile(SMF.Data.ResultsDir, ...
                   sprintf('RND2_%s_E=%d,N=%d', algorithm, E, minPts)), 'png');
   else
      figure(h)
   end
end % for algorithm_range
fprintf('\n');

% ---------- Hextets ----------

fprintf('Hextets:\n\n');
E = 50;       % minimum separation of points between clusters AND
              % maximum separation of points within  clusters (nm)
minPts = 3;   % minimum number of points required to form a cluster
% Ratio of local density / overall density for a point's Voronoi
% region to be considered sufficiently dense for clustering purposes.
c.Alpha = 1.2;

% ---[ XY ]---

% Call with (x, y) coordinate array (nm).
algorithm = 'DBSCAN';
[nC, C, centers, ptsI] = c.cluster(algorithm, XY2, E, minPts);
fprintf('%s (E = %g, minPts = %d) number of clusters = %d\n', ...
        algorithm, E, minPts, nC);

% Compute statistics from the results of clustering.
results = c.clusterStats(XY2, C, centers);
fprintf('percentage clustered = %.1f\n', ...
        100 * results.n_clustered/results.n_points);

% Plot the clusters computed.
h = c.plotClusters(XY2, C, centers, ptsI, algorithm);
if Saving
   saveas(h, fullfile(SMF.Data.ResultsDir, ...
                sprintf('HEX2_%s_E=%d,N=%d', algorithm, E, minPts)), 'png');
else
   figure(h)
end

% Plot the clusters computed with the SE of the localizations
h = c.plotClustersSE(SMD2, C, centers, ptsI, algorithm);
if Saving
   saveas(h, fullfile(SMF.Data.ResultsDir, ...
                sprintf('RND2_%s_E=%d,N=%d_SE', algorithm, E, minPts)), 'png');
else
   figure(h)
end

% ---[ SMD ]---

% Call with SMD structure (pixel).  SMD2 is a scattering of hextets.
for algorithm_range = {'DBSCAN', 'Hierarchal', 'Voronoi', 'H-SET'}
   algorithm = algorithm_range{1};
   if strcmp(algorithm, 'Voronoi')
      % Note that Voronoi uses Alpha (and optionally E) for its criteria.
      [nC, C, centers, ptsI] = c.cluster(algorithm, SMD2, [], minPts);
   else
      % H-SET needs to use an SMD structure with X_SE, Y_SE defined.
      [nC, C, centers, ptsI] = c.cluster(algorithm, SMD2, E, minPts);
   end
   fprintf('%s (E = %g, minPts = %d) number of clusters = %d\n', ...
           algorithm, E, minPts, nC);

   % Compute statistics from the results of clustering.
   results = c.clusterStats(SMD2, C, centers);
   fprintf('percentage clustered = %.1f\n', ...
           100 * results.n_clustered/results.n_points);

   % Plot the clusters computed.
   h = c.plotClusters(SMD2, C, centers, ptsI, algorithm);
   if Saving
      saveas(h, fullfile(SMF.Data.ResultsDir, ...
                   sprintf('HEX2_%s_E=%d,N=%d', algorithm, E, minPts)), 'png');
   else
      figure(h)
   end
end % for algorithm_range

% ========== 3D ==========

fprintf('\n3D examples:\n\n');

% ---------- Random ----------

fprintf('Random:\n\n');
E = 500;      % minimum separation of points between clusters AND
              % maximum separation of points within  clusters (nm)
minPts = 3;   % minimum number of points required to form a cluster
% Ratio of local density / overall density for a point's Voronoi
% region to be considered sufficiently dense for clustering purposes.
c.Alpha = 1.2;

% ---[ SMD ]---

% Call with SMD structure (pixel).  SMD3 is a random cover.
for algorithm_range = {'DBSCAN', 'Hierarchal', 'Voronoi'}
   algorithm = algorithm_range{1};
   if strcmp(algorithm, 'Voronoi')
      % Note that Voronoi uses Alpha (and optionally E) for its criteria.
      [nC, C, centers, ptsI] = c.cluster(algorithm, SMD3, [], minPts);
   else
      [nC, C, centers, ptsI] = c.cluster(algorithm, SMD3, E, minPts);
   end
   fprintf('%s (E = %g, minPts = %d) number of clusters = %d\n', ...
           algorithm, E, minPts, nC);

   % Compute statistics from the results of clustering.
   results = c.clusterStats(SMD3, C, centers);
   fprintf('percentage clustered = %.1f\n', ...
           100 * results.n_clustered/results.n_points);

   % Plot the clusters computed.
   h = c.plotClusters3(SMD3, C, centers, ptsI, algorithm);
   view(-37.5, 30);
   if Saving
      saveas(h, fullfile(SMF.Data.ResultsDir, ...
                   sprintf('RND3_%s_E=%d,N=%d', algorithm, E, minPts)), 'png');
   else
      figure(h)
   end
end % for algorithm_range
fprintf('\n');

fprintf('Done.\n');

success = 1;

end

./MATLAB/+smi_cluster/@Clustering/dbscan_Daszykowski.m
function [class,type,Eps]=dbscan_Daszykowski(x,k,Eps)
% Written by Michal Daszykowski
% -------------------------------------------------------------------------
% Function: [class,type]=dbscan(x,k,Eps)
% -------------------------------------------------------------------------
% Aim: 
% Clustering the data with Density-Based Scan Algorithm with Noise (DBSCAN)
% -------------------------------------------------------------------------
% Input: 
% x - data set (m,n); m-objects, n-variables
% k - number of objects in a neighborhood of an object 
% (minimal number of objects considered as a cluster)
% Eps - neighborhood radius, if not known avoid this parameter or put []
% -------------------------------------------------------------------------
% Output: 
% class - vector specifying assignment of the i-th object to certain 
% cluster (m,1)
% type - vector specifying type of the i-th object 
% (core: 1, border: 0, outlier: -1)
% -------------------------------------------------------------------------
% Example of use:
% x=[randn(30,2)*.4;randn(40,2)*.5+ones(40,1)*[4 4]];
% [class,type]=dbscan(x,5,[]);
% -------------------------------------------------------------------------
% References:
% [1] M. Ester, H. Kriegel, J. Sander, X. Xu, A density-based algorithm for 
% discovering clusters in large spatial databases with noise, proc. 
% 2nd Int. Conf. on Knowledge Discovery and Data Mining, Portland, OR, 1996, 
% p. 226, available from: 
% www.dbs.informatik.uni-muenchen.de/cgi-bin/papers?query=--CO
% [2] M. Daszykowski, B. Walczak, D. L. Massart, Looking for 
% Natural Patterns in Data. Part 1: Density Based Approach, 
% Chemom. Intell. Lab. Syst. 56 (2001) 83-92 
% -------------------------------------------------------------------------
% Written by Michal Daszykowski
% Department of Chemometrics, Institute of Chemistry, 
% The University of Silesia
% December 2004
% http://www.chemometria.us.edu.pl

[m,n]=size(x);

if nargin<3 | isempty(Eps)
   [Eps]=epsilon(x,k);
end

x=[[1:m]' x];
[m,n]=size(x);
type=zeros(1,m);
no=1;
touched=zeros(m,1);

for i=1:m
    if touched(i)==0;
       ob=x(i,:);
       D=dist_Daszykowski(ob(2:n),x(:,2:n));
       ind=find(D<=Eps);
    
       if length(ind)>1 & length(ind)<k+1       
          type(i)=0;
          class(i)=0;
       end
       if length(ind)==1
          type(i)=-1;
          class(i)=-1;  
          touched(i)=1;
       end

       if length(ind)>=k+1; 
          type(i)=1;
          class(ind)=ones(length(ind),1)*max(no);
          
          while ~isempty(ind)
                ob=x(ind(1),:);
                touched(ind(1))=1;
                ind(1)=[];
                D=dist_Daszykowski(ob(2:n),x(:,2:n));
                i1=find(D<=Eps);
     
                if length(i1)>1
                   class(i1)=no;
                   if length(i1)>=k+1;
                      type(ob(1))=1;
                   else
                      type(ob(1))=0;
                   end

                   for i=1:length(i1)
                       if touched(i1(i))==0
                          touched(i1(i))=1;
                          ind=[ind i1(i)];   
                          class(i1(i))=no;
                       end                    
                   end
                end
          end
          no=no+1; 
       end
   end
end

i1=find(class==0);
class(i1)=-1;
type(i1)=-1;

end

%...........................................
function [Eps]=epsilon(x,k)

% Function: [Eps]=epsilon(x,k)
%
% Aim: 
% Analytical way of estimating neighborhood radius for DBSCAN
%
% Input: 
% x - data matrix (m,n); m-objects, n-variables
% k - number of objects in a neighborhood of an object
% (minimal number of objects considered as a cluster)



[m,n]=size(x);

Eps=((prod(max(x)-min(x))*k*gamma(.5*n+1))/(m*sqrt(pi.^n))).^(1/n);

end

%............................................
function [D]=dist_Daszykowski(i,x)

% function: [D]=dist(i,x)
%
% Aim: 
% Calculates the Euclidean distances between the i-th object and all objects in x	 
%								    
% Input: 
% i - an object (1,n)
% x - data matrix (m,n); m-objects, n-variables	    
%                                                                 
% Output: 
% D - Euclidean distance (m,1)



[m,n]=size(x);
D=sqrt(sum((((ones(m,1)*i)-x).^2)'));

if n==1
   D=abs((ones(m,1)*i-x))';
end

end

./MATLAB/+smi_cluster/@Clustering/plot_voronoi3.m
function plot_voronoi3(X, Y, Z, v, c, rho, str, dense, ptIDs)
%plot_voronoi3 plots the Voronoi diagram corresponding to (X, Y, Z), coloring
% the cells according to the density rho.
%
% INPUTS:
%    X, Y, Z point coordinates, each [N x 1]
%    v       vertices [N x 2]
%    c       vertex indices cooresponding to each cell [Nc x 1]
%    rho     density of each cell [Nc x 1]
%    str     figure title
%    dense   indices of those cells >= prescribed density criterion
%    ptIDs   [OPTIONAL] write out point IDs if true [default = false]

% Created by
%    Michael J. Wester (2019)

   n_XY = length(X);
   n_v  = size(v, 1);
   n_c  = length(c);

   delta = 0.001 * (max(X) - min(X));
   figure();
   hold on
   dt = delaunayTriangulation(X, Y, Z);
   tetramesh(dt);
   limits = axis;
   colormap(jet);
   caxis([min(rho), max(rho)]);
   for i = 1 : n_c
      c_i = c{i};
      if all(c_i ~= 1)
         fill3(v(c_i, 1), v(c_i, 2), v(c_i, 3), rho(i));
         %fill(v(c_i, 1), v(c_i, 2), floor((i - 1)/(n_c - 1) * 255 + 1));
      end
   end
   plot3(X, Y, Z, 'k.', 'MarkerSize', 10);
   plot3(X(dense), Y(dense), Z(dense), 'r.', 'MarkerSize', 10);
   if exist('ptIDs', 'var') & ptIDs
      for i = 1 : n_XY
         text(X(i) + delta, Y(i), Z(i), sprintf('%d', i), 'Color', 'k');
      end
   end
%  plot(v(:, 1), v(:, 2), 'g.', 'MarkerSize', 10);
%  for i = 2 : n_v
%     text(v(i, 1) + delta, v(i, 2), sprintf('%d', i), 'Color', 'g');
%  end
   axis(limits);
   cb = colorbar;
   cb.Label.String = 'relative density';
   title(str);
   hold off

end

./MATLAB/+smi_cluster/@Clustering/cluster.m
function [nC, C, centers, ptsI] = ...
   cluster(obj, algorithm, SMD, E, minPts)
% Main interface to the clustering algorithms described below:
%
%    DBSCAN_Daszykowski is the recommended DBSCAN algorithm as it is both fast
%    and stable under coordinate reordering.
%
% Martin Ester, Hans-Peter Kriegel and J\"org Sander and Xiaowei Xu, ``A
% Density-Based Algorithm for Discovering Clusters in Large Spatial Databases
% with Noise'', in _Proceedings of 2nd International Conference on Knowledge
% Discovery and Data Mining (KDD-96)_ edited by Evangelos Simoudis, Jiawei Han
% and Usama M. Fayyad, AAAI Press, 1996, 226--231, ISBN:1-57735-004-9,
% DOI:10.1.1.71.1980.
%
% M. Daszykowski, B. Walczak, D. L. Massart, Looking for Natural Patterns in
% Data. Part 1: Density Based Approach, Chemom. Intell. Lab. Syst. 56 (2001)
% 83-92. 
%
%    Hierarchical is Matlab's hierarchal clustering algorithm with some small
%    additions.
%
%    Voronoi is Florian Levet et al's Voronoi based algorithm.
%
% Florian Levet, Eric Hosy, Adel Kechkar, Corey Butler, Anne Beghin, Daniel
% Choquet and Jean-Baptiste Sibarita, ``SR-Tesseler: a method to segment and
% quantify localization-based super-resolution microscopy data'', _Nature
% Methods_, Volume 12, Number 11, 2015, 1065--1071 (DOI:10.1038/NMETH.3579).
%
%    H-SET is the clustering implied by H-SET, in which the nodes that would be
%    combined in normal H-SET are taken to be clusters here.
%
% Jia Lin, Michael J. Wester, Matthew S. Graus, Keith~A. Lidke and Aaron K.
% Neumann, ``Nanoscopic cell wall architecture of an immunogenic ligand in
% _Candida albicans_ during antifungal drug treatment'', _Molecular
% Biology of the Cell_, Volume 27, Number 6, March 15, 2016, 1002--1014
% (DOI: 10.1091/mbc.E15-06-0355, PMID: 26792838, PMCID: PMC4791122).
%
% INPUTS:
%    obj         various properties used by the algorithms
%                --- Properties used by voronoi_Levet: ---
%       Alpha       [2] ratio of local density / overall density for a
%                   point's Voronoi region to be considered sufficiently
%                   dense for clustering purposes
%       Valgorithm  [2] Voronoi algorithm to apply:
%                      1   [0] calculations consider Voronoi regions only
%                      2   [1] calculations consider Voronoi regions and
%                              their adjacent neighbors
%                      3   [1M] consider the median density of each cell
%                               and its neighbors
%       Plotting    [false] produce Voronoi plots
%       PtIDs       [false] label the points in the plots
%                --- Properties used by H-SET: ---
%       PixelSize   [100]      pixel size (nm)
%       Sigma_Reg   [[10, 10]] x, y registration error (nm) 
%    algorithm   one of the clustering algorithms below:
%                DBSCAN_Daszykowski or DBSCAN
%                DBSCAN_Daszykowski_noE (computes its own value for E)
%                Hierarchical or Hierarchal
%                           (Matlab's hierarchical clustering algorithm)
%                Voronoi    (Florian Levet et al's Voronoi based algorithm)
%                H-SET      (clustering implied by the H-SET algorithm)
%    SMD         (x, y) coordinates in the format
%                    (1) SMD structure: SMD.X, SMD.Y with optional SMD.X_SE,
%                        SMD.Y_SE (only needed for H-SET clustering) (pixel)
%                    (2) N x 2 or N x 3 array of coordinates (nm)
%    E           epsilon or cutoff distance (nm).  This is the maximum distance
%                between points in a cluster or the minimum distance between
%                points in different clusters
%    minPts      [OPTIONAL] minimum number of points allowed in a cluster
%                (default = 3)
%
% OUTPUTS:
%    nC          number of clusters found
%    C           cell array of XY indices forming each cluster [nC x 1]
%    centers     coordinates of the center of each cluster [nC x n_dim]
%    ptsI        indices of points not found in any cluster

   if ~exist('minPts', 'var')
      minPts = 3;
   end

   % Check for SMD structure; in this situation, assume the units are pixels.
   SMDstruct = false;
   if isfield(SMD, 'X') & isfield(SMD, 'Y')
      SMDstruct = true;
      if isfield(SMD, 'Z') && ~isempty(SMD.Z)
         XY = [SMD.X, SMD.Y, SMD.Z] .* obj.PixelSize;
      else
         XY = [SMD.X, SMD.Y] .* obj.PixelSize;
      end
   % Check for N x 2 or N x 3 matrix of coordinates.
   elseif ismatrix(SMD) && (size(SMD, 2) == 2 || size(SMD, 2) == 3)
      XY = SMD;
   else
      error('Unrecognized coordinate input!');
   end

   if strcmp(algorithm, 'H-SET') && SMDstruct && ...
         (~isfield(SMD, 'X_SE') || ~isfield(SMD, 'Y_SE'))
      error('X_SE/Y_SE needed for H-SET!');
   end

   n_dim = size(XY, 2);

   if size(XY, 1) == 0
      warning('No points to cluster!');

      nC = 0;
      C = cell(1, nC);
      centers = zeros(n_dim, nC);
      ptsI = [];

      return
   end

   switch algorithm
   case {'DBSCAN_Daszykowski', 'DBSCAN'}

      [ptsC, Ctype] = obj.dbscan_Daszykowski(XY, minPts - 1, E);
      nC = max([0, ptsC]);
      C = cell(1, nC);
      centers = zeros(n_dim, nC);
      for j = 1 : nC
         C{j} = find(ptsC == j);
         centers(:, j) = mean(XY(C{j}, :), 1);
      end
      ptsI = find(ptsC <= 0);
      %isolated = XY(ptsI, :);

   % Here, E (epsilon) is calculated internally by the DBSCAN algorithm.  Note
   % that this value of E will be specific to the input data in XY.
   case 'DBSCAN_Daszykowski_noE'

      [ptsC, Ctype, E] = obj.dbscan_Daszykowski(XY, minPts - 1, []);
      nC = max([0, ptsC]);
      C = cell(1, nC);
      centers = zeros(n_dim, nC);
      for j = 1 : nC
         C{j} = find(ptsC == j);
         centers(:, j) = mean(XY(C{j}, :), 1);
      end
      ptsI = find(ptsC <= 0);

   case {'Hierarchical', 'Hierarchal'}

      [C, ptsI] = obj.hierarchal(XY, E, minPts);
      nC = length(C);
      centers = zeros(n_dim, nC);
      for i = 1 : nC
         centers(:, i) = mean(XY(C{i}, :), 1);
      end

   case 'Voronoi'

      %[area, rho, nC, C] = ...
      %   voronoi_Levet(XY, alpha, epsilon, minPts, algorithm);
      [~, ~, nC_a, C_a] = ...
         obj.voronoi_Levet(XY, obj.Alpha, E, minPts, obj.Valgorithm);
      nC = nC_a{obj.Valgorithm};
      C  = C_a{obj.Valgorithm};
      centers = zeros(n_dim, nC);
      for i = 1 : nC
         centers(:, i) = mean(XY(C{i}, :), 1);
      end
      ptsI = setdiff(1 : size(XY, 1), horzcat(C{:}));

   case 'H-SET'

      % XY is assumed to be the same as [SMD.X, SMD.Y] .* obj.PixelSize
      [nC, C] = obj.cluster_HSET(SMD, minPts);
      centers = zeros(n_dim, nC);
      for i = 1 : nC
         centers(:, i) = mean(XY(C{i}, :), 1);
      end
      ptsI = setdiff(1 : size(XY, 1), horzcat(C{:}));

   otherwise

      error('Unknown algorithm: %s\n', algorithm);

   end

end

./MATLAB/+smi_cluster/@Clustering/plotClusters.m
function clusterFig = plotClusters(obj, SMD, C, centers, ptsI, txt, options)
% Plot and label the 2D clusters.
%
% INPUTS:
%    SMD          (x, y) coordinates in the format
%                     (1) SMD structure: SMD.X, SMD.Y with optional SMD.X_SE,
%                         SMD.Y_SE (only needed for H-SET clustering) (pixel)
%                     (2) N x 2 or N x 3 array of coordinates (nm)
%    C            cell array of XY indices forming each cluster [nC x 1]
%    centers      coordinates of the center of each cluster [nC x n_dim]
%    ptsI         indices of points not found in any cluster
%    txt          descriptive text to add to the plot's title
%    options      [default = 'O'] string containing some of the following:
%                 'L': label each cluster
%                 'O': outline each cluster
%                 'P': print the size of each cluster
%                 '1': use only one color for all clusters
%                 'Y': reverse the y-axis of the plot (useful for comparison
%                      with image plots where (0, 0) is at the upper left)
% OUTPUT:
%    clusterFig   figure handle

   % Check for SMD structure; in this situation, assume the units are pixels.
   SMDstruct = false;
   if isfield(SMD, 'X') & isfield(SMD, 'Y')
      SMDstruct = true;
      if isfield(SMD, 'Z') && ~isempty(SMD.Z)
         XY = [SMD.X, SMD.Y, SMD.Z] .* obj.PixelSize;
      else
         XY = [SMD.X, SMD.Y] .* obj.PixelSize;
      end
   % Check for N x 2 or N x 3 matrix of coordinates.
   elseif ismatrix(SMD) && (size(SMD, 2) == 2 || size(SMD, 2) == 3)
      XY = SMD;
   else
      error('Unrecognized coordinate input!');
   end

   if exist('options', 'var')
      labeling = strfind(options, 'L');
      outlines = strfind(options, 'O');
      printing = strfind(options, 'P');
      onecolor = strfind(options, '1');
      reverseY = strfind(options, 'Y');
   else
      labeling = false;
      outlines = true;
      printing = false;
      onecolor = false;
      reverseY = false;
   end

   colors = 'rgbcmy';
   n_colors = length(colors);

   nC = length(C);
   n_isolated = length(ptsI);
   n_points = size(XY, 1);
   n_clustered = 0;

   clusterFig = figure('Visible', 'off');
   hold on
   if printing
      fprintf('\n');
   end
   for i = 1 : nC
      j = smi_helpers.nMODm(i, n_colors);
      if onecolor
         color = 'm';
      else
         color = colors(j);
      end
      n_pts = length(C{i});
      n_clustered = n_clustered + n_pts;
      if printing
         fprintf('cluster %d has %2d points (%s)\n', i, n_pts, color);
      end
try
      %plot(XY(C{i}, 1), XY(C{i}, 2), [color, '.'], 'MarkerSize', 12);
      plot(XY(C{i}, 1), XY(C{i}, 2), [color, '.']);
      if labeling
         text(centers(1, i), centers(2, i), sprintf('%d', i));
      end
      if outlines
         if length(C{i}) == 2
            plot(XY(C{i}, 1), XY(C{i}, 2), [color, '-'], 'LineWidth', 2);
         elseif length(C{i}) >= 3
            xy = double(XY(C{i}, :));
            %k = convhull(XY(C{i}, 1), XY(C{i}, 2));
            k = boundary(xy(:, 1), xy(:, 2), obj.ShrinkFactor);
            k = C{i}(k);
            plot(XY(k, 1), XY(k, 2), [color, '-'], 'LineWidth', 2);
         end
      end
catch ME
fprintf('### PROBLEM with plotting cluster %d ###\n', i);
fprintf('%s\n', ME.identifier);
fprintf('%s\n', ME.message);
end
   end
   if n_isolated > 0
      %plot(XY(ptsI, 1), XY(ptsI, 2), 'k.', 'MarkerSize', 12);
      plot(XY(ptsI, 1), XY(ptsI, 2), 'k.');
   end
   if reverseY
      set(gca, 'YDir', 'reverse');
   end
   title(sprintf('%s (points = %d, clusters = %d, clustered %% = %.3f)', ...
                 regexprep(txt, '_', '\\_'), n_points, nC,               ...
                 n_clustered/n_points * 100));
   hold off

end

./MATLAB/+smi_cluster/@Clustering/nn_distances.m
function min_d = nn_distances(xy)
%nn_distances is the minimum nearest neighbor distances from each point in xy
% to the other points.
%
% INPUTS:
%    xy      n x 2 (or n x 3) set of coordinates.
%
% OUTPUTS:
%    min_d   minimum nearest neighbor distance for each point in xy

% Created by
%    Michael J. Wester (2019)

   %x_r = xy(:, 1);
   %y_r = xy(:, 2);
   %min_d = min(squareform(pdist([x_r, y_r])) + 1.0e+10 * eye(numel(x_r)));
   % Below is much faster, less memory intensive and works in 3D as well as 2D!
   min_d = [];
   if size(xy, 1) > 1
      [~, min_d] = knnsearch(xy, xy, 'K', 2);
      min_d = min_d(:, 2)';
   end

end

./MATLAB/+smi_cluster/@Clustering/voronoi_Levet.m
function [area, rho, nC, C] = ...
   voronoi_Levet(obj, xy, alpha, epsilon, minPts, algorithm)
%voronoi_Levet implements Voronoi diagram based clustering.  See citation.
%
% INPUTS:
%    obj         various properties used by the algorithms
%       Plotting     produce Voronoi plots
%       PtIDs        label the points in the plots
%       ShrinkFactor 'boundary' compactness factor in the range 0 - 1
%    xy          point coordinates [N x 2] (nm)
%    alpha       ratio of local density / overall density for a point's Voronoi
%                region to be considered sufficiently dense for clustering
%                purposes
%    epsilon     distance constraint for clustering; no constraint if <= 0 (nm)
%    minPts      minimum number of points needed to form a cluster
%    algorithm   cell array of algorithms to apply:
%                1   [0] calculations consider Voronoi regions only
%                2   [1] calculations consider Voronoi regions and their
%                    adjacent neighbors [DEFAULT]
%                3   [1M] consider the median density of each cell and its
%                    neighbors
%
% OUTPUTS:
%    area   cell array of Voronoi cell areas per point
%    rho    cell array of Voronoi cell densities per point
%    nC     cell array of number of clusters discovered
%    C      cell array of indices of points in each cluster
%
% CITATION:
%    Florian Levet, Eric Hosy, Adel Kechkar, Corey Butler, Anne Beghin, Daniel
%    Choquet and Jean-Baptiste Sibarita, ``SR-Tesseler: a method to segment and
%    quantify localization-based super-resolution microscopy data'', _Nature
%    Methods_, 2015 (DOI:10.1038/NMETH.3579).

% Created by
%    Michael J. Wester (2019)

   if ~exist('algorithm', 'var')
      algorithm = 2;
   end

   if any(algorithm < 1 | algorithm > 3)
      error('Invalid algorithm selected: %d', algorithm);
   end

   ShrinkFactor = obj.ShrinkFactor;

   XY = double(xy);
   dim = size(XY, 2);

   X = XY(:, 1);
   Y = XY(:, 2);
   n_XY = length(X);
   if dim == 2
      area_XY = (max(X) - min(X)) * (max(Y) - min(Y));
   else
      Z = XY(:, 3);
      area_XY = (max(X) - min(X)) * (max(Y) - min(Y)) * (max(Z) - min(Z));
   end
   rho_XY = n_XY / area_XY;

   [v, c] = voronoin(XY);
   n_v = size(v, 1);
   n_c = length(c);

   % Find what Voronoi cells (c) contain each vertex (v).
   v2c = cell(1, n_v);  
   for i = 1 : n_c
      c_i = c{i};
      for j = 1 : length(c_i)
         v2c{c_i(j)} = [v2c{c_i(j)}, i];
      end
   end

   % For each cell, collect together the indices for itself and all its
   % neighbors.
   self_nbrs = cell(1, n_c);
   for i = 1 : n_c
      c_i = c{i};
      for j = 1 : length(c_i)
         k = v2c{c_i(j)};
         self_nbrs{i} = [self_nbrs{i}, k];
      end
      self_nbrs{i} = unique(self_nbrs{i});
   end

   % Level 0: consider each cell individually.
   area_0 = zeros(1, n_XY);
   rho_0  = zeros(1, n_XY);
   for i = 1 : n_c
      c_i = c{i};
      if all(c_i ~= 1)
         if dim == 2
            area_0(i) = polyarea(v(c_i, 1), v(c_i, 2));
         else
            [~, area_0(i)] = boundary(v(c_i, 1), v(c_i, 2), v(c_i, 3), ...
                                      ShrinkFactor);
         end
         rho_0(i) = 1 / area_0(i);
      else
         area_0(i) = Inf;
         rho_0(i) = 0;
      end
   end

   if any(algorithm == 1)
      [~, i_rho_0] = find(rho_0 >= alpha*rho_XY);
      [nC_0, C_0] = smi_cluster.Clustering.cluster_voronoi( ...
                       i_rho_0, self_nbrs, epsilon, minPts, XY);

      if obj.Plotting
         if dim == 2
            smi_cluster.Clustering.plot_voronoi(X, Y, v, c, ...
               rho_0 ./ rho_XY, 'rho_0 / rho_a', i_rho_0, obj.PtIDs);
         else
            smi_cluster.Clustering.plot_voronoi3(X, Y, Z, v, c, ...
               rho_0 ./ rho_XY, 'rho_0 / rho_a', i_rho_0, obj.PtIDs);
         end
      end

      area{1} = area_0;
      rho{1}  = rho_0;
      nC{1}   = nC_0;
      C{1}    = C_0;
   end

   if any(algorithm == 2)
      % Level 1: consider each cell and its neighbors.
      area_1 = zeros(1, n_XY);
      rho_1  = zeros(1, n_XY);
      for i = 1 : n_c
         c_i = c{i};
         if all(c_i ~= 1)
            % Cells with vertex 1, which is the point at Infinity, are
            % excluded.
            n_self_nbrs = length(self_nbrs{i});
            for j = 1 : n_self_nbrs
               area_1(i) = area_1(i) + area_0(self_nbrs{i}(j));
            end
            rho_1(i) = n_self_nbrs / area_1(i);
         else
            area_1(i) = Inf;
            rho_1(i) = 0;
         end
      end

      [~, i_rho_1] = find(rho_1 >= alpha*rho_XY);
      [nC_1, C_1] = smi_cluster.Clustering.cluster_voronoi( ...
                       i_rho_1, self_nbrs, epsilon, minPts, XY);

      if obj.Plotting
         if dim == 2
            smi_cluster.Clustering.plot_voronoi(X, Y, v, c, ...
               rho_1 ./ rho_XY, 'rho_1 / rho_a', i_rho_1, obj.PtIDs);
         else
            smi_cluster.Clustering.plot_voronoi3(X, Y, Z, v, c, ...
               rho_1 ./ rho_XY, 'rho_1 / rho_a', i_rho_1, obj.PtIDs);
         end
      end

      area{2} = area_1;
      rho{2}  = rho_1;
      nC{2}   = nC_1;
      C{2}    = C_1;

      %area_1A = zeros(1, n_XY);
      %rho_1A  = zeros(1, n_XY);
      %for i = 1 : n_c
      %   c_i = c{i};
      %   if all(c_i ~= 1)
      %      n_self_nbrs = 0;
      %      for j = 1 : n_c
      %         if ~isempty(intersect(c{i}, c{j}))
      %            n_self_nbrs = n_self_nbrs + 1;
      %            area_1A(i) = area_1A(i) + area_0(j);
      %         end
      %      end
      %      rho_1A(i) = n_self_nbrs / area_1A(i);
      %   else
      %      area_1A(i) = Inf;
      %      rho_1A(i) = 0;
      %   end
      %end
      %plot_voronoi(X, Y, v, c, rho_1A);
   end

   if any(algorithm == 3)
      % Level 1M: consider the median density of each cell and its neighbors.
      area_1M = area_0;
      rho_1M  = zeros(1, n_XY);
      for i = 1 : n_c
         rho_1M(i) = median(rho_0(self_nbrs{i}));
      end

      [~, i_rho_1M] = find(rho_1M >= alpha*rho_XY);
      [nC_1M, C_1M] = smi_cluster.Clustering.cluster_voronoi( ...
                         i_rho_1M, self_nbrs, epsilon, minPts, XY);

      if obj.Plotting
         if dim == 2
            smi_cluster.Clustering.plot_voronoi(X, Y, v, c, ...
               rho_1M ./ rho_XY, 'rho_{1M} / rho_a', i_rho_1M, obj.PtIDs);
         else
            smi_cluster.Clustering.plot_voronoi3(X, Y, Z, v, c, ...
               rho_1M ./ rho_XY, 'rho_{1M} / rho_a', i_rho_1M, obj.PtIDs);
         end
      end

      area{3} = area_1M;
      rho{3}  = rho_1M;
      nC{3}   = nC_1M;
      C{3}    = C_1M;
   end

end

./MATLAB/+smi_cluster/@Clustering/cluster_voronoi.m
function [nC, C] = cluster_voronoi(i_rho, self_nbrs, epsilon, minPts, XY)
% Taking the density indices i_rho that identify points to be clustered,
% generate the clusters C (their number given by nC).
%
% INPUTS:
%    i_rho       indices of all the cells exceeding the density criterion
%    self_nbrs   for each cell, the indices for itself and all its neighbors
%    epsilon     epsilon or cutoff distance (nm)
%    minPts      minimum number of points allowed in a cluster
%    XY          point coordinates [N x 2] (nm)
%
% OUTPUTs:
%    nC          number of clusters found
%    C           cell array of XY indices forming each cluster [nC x 1] (nm)

% Created by
%    Michael J. Wester (2019)

   nC = 0;
   C = {};
   while ~isempty(i_rho)
      % There is at least one more point left to be clustered, so create a new
      % cluster and stuff the point in it while deleting it off the list of
      % points remaining to be clustered.
      C_nC = i_rho(1); 
      i_rho(1) = [];
      % Find the point's neighbors and see if any of them are on the list of
      % points remaining to be clustered.
      lo = 1;
      hi = 1;
      nbrs = self_nbrs{C_nC(lo:hi)};
      l = intersect(nbrs, i_rho);
      while ~isempty(l)
         % If there is an overlap between the neighbors of the points just
         % added to the current cluster and those remaining to be clustered,
         % stuff the overlap in the current cluster, delete them off the list
         % of points remaining to be clustered, and then compute the overlap
         % between the neighbors of these new cluster points and those
         % remaining.
         C_nC = [C_nC, l];
         i_rho = setdiff(i_rho, l);
         lo = hi + 1;
         hi = hi + length(l);
         % Find the unique neighbors of the new points just added to the
         % cluster (and themselves).
         nbrs = unique([ self_nbrs{C_nC(lo:hi)} ]);
         l = intersect(nbrs, i_rho);
      end
      % Eliminate clusters smaller than minPts.
      if length(C_nC) >= minPts
         nC = nC + 1;  
         C{nC} = sort(C_nC);
      end
   end

   % If epsilon > 0, apply further restrictions on the clusters found above.
   % For each Voronoi cluster, apply a secondary clustering algorithm that
   % separates points based on epsilon.  This will, in general, separate the
   % Voronoi clusters into smaller (or same size) clusters and isolated points.
   % Collect together the newly separated clusters and return these.
   if epsilon > 0
      c = smi_cluster.Clustering();
      Algorithm = 'Hierarchal';
      nB = 0;
      B  = {};
      for i = 1 : nC
         xy = XY(C{i}, :);
         [nCC, CC, ~, ~] = c.cluster(Algorithm, xy, epsilon, minPts);
         for j = 1 : nCC
            nB = nB + 1;
            % CC{j} are the point indices of a new cluster, so map these back
            % into the point indices of the original cluster C{i}.
            B{nB} = C{i}(CC{j});
         end
      end

      nC = nB;
      C  = B;
   end

end

./MATLAB/+smi_cluster/@Clustering/hierarchalSingleLabel.m
function [XY_combined, sigma_combined, nodes_combined] = ...
   hierarchalSingleLabel(XY, sigma, Sigma_Reg, LoS)
% Combine multiple clustered points into single labels when appropriate via a
% top-down descent through a hierarchal dendrogram relationship between points.
% n is the original number of points and m is the dimension.
% n' is the final number of points after combinations have occurred.
%
% Inputs:
%    XY          n x m matrix of coordinates (nm)
%    sigma       n x m matrix of position uncertainties (1 std deviation) (nm)
%    Sigma_Reg   1 x m array of registration error (1 standard deviation) (nm)
%    LoS         level of significance [0 <= LoS <= 1 with 0.01 typical]
%
% Outputs:
%    XY_combined      n' x m final coordinate matrix (nm)
%    sigma_combined   n' x m final position uncertainty matrix (nm)
%    nodes_combined   cell array of indices of combined points per cluster

   XY_combined    = XY;
   sigma_combined = sigma;
   nodes_combined = {};

   n_pts   = size(XY, 1);
   n_nodes = n_pts - 1;   % does not include leaf nodes

   if n_pts <= 1
      return
   end

   Z = linkage(XY, 'single');
   %figure(); dendrogram(Z);

   % Find all the leaf nodes contained by each composite node by parsing the
   % Z matrix (see MATLAB linkage documentation).  Note that composite nodes
   % are indexed as node # - n_pts.  E.g., if n_pts = 10, then Z(2, :) is
   % composite node 2 and overall node 12.  Z(2, 1:2) are the nodes (in
   % overall node numbering) that are joined by node 12 which, for example,
   % might be 7 (a leaf node since it is <= 10) and 11 (a composite node whose
   % components are given in Z(1, 1:2)).
   cn = cell(1, n_nodes);
   for i = 1 : n_nodes
      l1 = Z(i, 1);   % child node 1
      l2 = Z(i, 2);   % child node 2
      if l1 <= n_pts
         leaf_nodes = l1;
      else
         leaf_nodes = cn{l1 - n_pts};
      end
      if l2 <= n_pts
         leaf_nodes = [leaf_nodes, l2];
      else
         leaf_nodes = [leaf_nodes, cn{l2 - n_pts}];
      end
      cn{i} = sort(leaf_nodes);
   end

   k = 0;
   % Start with the top-level node and descend down through the tree (the tree
   % is taken to have its root at the top and its leaves at the bottom).
   for i = n_nodes : -1 : 1
      LN = cn{i};
      if ~isempty(LN)
         [Pvalue, XY_wm, sigma_wm] = ...
            smi_cluster.Clustering.singleLabelTest(XY(LN, :), sigma(LN, :), ...
                                                   Sigma_Reg);
         % Delete leaf nodes that are part of a composite single label.
         % Retain the first leaf node to hold the new information.
         if Pvalue > LoS
            cn{i} = LN(1);
            LN_deleted = LN(2 : end);
            % To be deleted at the end, but in order to keep the numbering
            % unchanged within the loop, set to a fantasy value for now.
            XY_combined(LN_deleted, :)    = NaN;
            sigma_combined(LN_deleted, :) = NaN;
            % Replace XY and sigma for this first leaf node with the weighted
            % means of the collapsed cluster.
            XY_combined(LN(1), :)    = XY_wm;
            sigma_combined(LN(1), :) = sigma_wm;
            k = k + 1;
            nodes_combined{k} = LN;
            for j = 1 : i - 1
               % cn{j} = setdiff(cn{j}, LN);
               % --->
               % cn{j} = cn{j}(~ismember(cn{j}, LN));
               % Optimized version of the line above: 
%              cn{j} = ...
%cn{j}(~smi_cluster.Clustering.my_ismemberBuiltinTypes(cn{j}, LN));
               cn{j} = cn{j}(~ismember(cn{j}, LN));
            end
         end
      end
   end

   XY_combined(isnan(XY_combined(:, 1)), :) = [];
   sigma_combined(isnan(sigma_combined(:, 1)), :) = [];

end

./MATLAB/+smi_cluster/@Clustering/plotClusters3.m
function clusterFig = plotClusters3(obj, SMD, C, centers, ptsI, txt, options)
% Plot and label the 3D clusters.
%
% INPUTS:
%    SMD         (x, y) coordinates in the format
%                    (1) SMD structure: SMD.X, SMD.Y with optional SMD.X_SE,
%                        SMD.Y_SE (only needed for H-SET clustering) (pixel)
%                    (2) N x 2 or N x 3 array of coordinates (nm)
%    C            cell array of XY indices forming each cluster [nC x 1]
%    centers      coordinates of the center of each cluster [nC x n_dim]
%    ptsI         indices of points not found in any cluster
%    txt          descriptive text to add to the plot's title
%    options      [default = 'O'] string containing some of the following:
%                 'L': label each cluster
%                 'O': outline each cluster
%                 'P': print the size of each cluster
%                 '1': use only one color for all clusters
% OUTPUT:
%    clusterFig   figure handle

   % Check for SMD structure; in this situation, assume the units are pixels.
   SMDstruct = false;
   if isfield(SMD, 'X') & isfield(SMD, 'Y')
      SMDstruct = true;
      if isfield(SMD, 'Z') && ~isempty(SMD.Z)
         XY = [SMD.X, SMD.Y, SMD.Z] .* obj.PixelSize;
      else
         XY = [SMD.X, SMD.Y] .* obj.PixelSize;
      end
   % Check for N x 2 or N x 3 matrix of coordinates.
   elseif ismatrix(SMD) && (size(SMD, 2) == 2 || size(SMD, 2) == 3)
      XY = SMD;
   else
      error('Unrecognized coordinate input!');
   end

   if exist('options', 'var')
      labeling = strfind(options, 'L');
      outlines = strfind(options, 'O');
      printing = strfind(options, 'P');
      onecolor = strfind(options, '1');
   else
      labeling = false;
      outlines = true;
      printing = false;
      onecolor = false;
   end

   colors = 'rgbcmy';
   n_colors = length(colors);

   nC = length(C);
   n_isolated = length(ptsI);
   n_points = size(XY, 1);
   n_clustered = 0;

   clusterFig = figure('Visible', 'off');
   hold on
   if printing
      fprintf('\n');
   end
   for i = 1 : nC
      j = smi_helpers.nMODm(i, n_colors);
      if onecolor
         color = 'm';
      else
         color = colors(j);
      end
      n_pts = length(C{i});
      n_clustered = n_clustered + n_pts;
      if printing
         fprintf('cluster %d has %2d points (%s)\n', i, n_pts, color);
      end
      plot3(XY(C{i}, 1), XY(C{i}, 2), XY(C{i}, 3), [color, '.'], ...
            'MarkerSize', 12);
      if labeling
         text(centers(1, i), centers(2, i), centers(3, i), sprintf('%d', i));
      end
      if outlines
         if length(C{i}) <= 3
            plot3(XY(C{i}, 1), XY(C{i}, 2), XY(C{i}, 3), [color, '-'], ...
                  'LineWidth', 2);
         else %if length(C{i}) >= 4
            xy = double(XY(C{i}, :));
            %k = convhull(XY(C{i}, 1), XY(C{i}, 2), XY(C{i}, 3));
            k = boundary(xy(:, 1), xy(:, 2), xy(:, 3), obj.ShrinkFactor);
            k = C{i}(k);
            plot3(XY(k, 1), XY(k, 2), XY(k, 3), [color, '-'], 'LineWidth', 2);
            %trisurf(k, XY(:, 1), XY(:, 2), XY(:, 3), 'FaceColor', color);
         end
      end
   end
   if n_isolated > 0
      plot3(XY(ptsI, 1), XY(ptsI, 2), XY(ptsI, 3), 'k.', 'MarkerSize', 12);
   end
   title(sprintf('%s (clusters = %d, clustered %% = %.3f)', ...
                regexprep(txt, '_', '\\_'), nC, n_clustered/n_points * 100));
   hold off

end

./MATLAB/+smi_cluster/@Clustering/README.md
### +smi_cluster/@Clustering

See MATLAB/examples/Example_Clustering for an example using cluster, which
dispatches on "algorithm" to the appropriate routines.

- *DBSCAN_Daszykowski* is the recommended DBSCAN algorithm as it is both fast
  and stable under coordinate reordering.

  Martin Ester, Hans-Peter Kriegel, J\"org Sander and Xiaowei Xu, ``A
  Density-Based Algorithm for Discovering Clusters in Large Spatial Databases
  with Noise'', in _Proceedings of 2nd International Conference on Knowledge
  Discovery and Data Mining (KDD-96)_ edited by Evangelos Simoudis, Jiawei Han
  and Usama M. Fayyad, AAAI Press, 1996, 226--231, ISBN:1-57735-004-9
  (DOI:10.1.1.71.1980).

  M. Daszykowski, B. Walczak, D. L. Massart, Looking for Natural Patterns in
  Data. Part 1: Density Based Approach, Chemometrics and Intelligent
  Laboratory Systems 56(2) (2001) 83-92. (DOI: 10.1016/S0169-7439(01)00111-3).

- *Hierarchical* is Matlab's hierarchal clustering algorithm with some small
  additions.

- *Voronoi* is Florian Levet et al's Voronoi based algorithm.

  Florian Levet, Eric Hosy, Adel Kechkar, Corey Butler, Anne Beghin, Daniel
  Choquet and Jean-Baptiste Sibarita, ``SR-Tesseler: a method to segment and
  quantify localization-based super-resolution microscopy data'', _Nature
  Methods_, Volume 12, Number 11, 2015, 1065--1071 (DOI:10.1038/NMETH.3579).

- *H-SET* is the clustering implied by H-SET, in which the nodes that would be
  combined in normal H-SET are taken to be clusters here.

  Jia Lin, Michael J. Wester, Matthew S. Graus, Keith~A. Lidke and Aaron K.
  Neumann, ``Nanoscopic cell wall architecture of an immunogenic ligand in
  _Candida albicans_ during antifungal drug treatment'', _Molecular
  Biology of the Cell_, Volume 27, Number 6, March 15, 2016, 1002--1014
  (DOI: 10.1091/mbc.E15-06-0355, PMID: 26792838, PMCID: PMC4791122).

---

```
properties:
   % --- Generic properties.
   Font_props = {'FontSize', 15, 'FontWeight', 'bold'};
   Fig_ext = 'png';
   ResultsDir = '.'; % Directory to store results.
   ShrinkFactor = 0.5; % 'boundary' compactness factor in the range 0 - 1
   Verbose = 0; % verbosity level
   Xlim = [];   % x-axis limits if defined
   Ylim = [];   % y-axis limits if defined

   % Properties used by clusterStats.
   DoSigmaActual = true; % this calc. can run out of memory for very dense ROIs
                         % (see clusterStats), so make it optional

   % Properties used by voronoi_Levet.
   Alpha      = 2;
      % Ratio of local density / overall density for a point's Voronoi
      % region to be considered sufficiently dense for clustering purposes
   Valgorithm = 2;       % Voronoi algorithm to apply:
      % 1   [0]  calculations consider Voronoi regions only
      % 2   [1]  calculations consider Voronoi regions and their adjacent
      %          neighbors
      % 3   [1M] consider the median density of each cell and its neighbors
   Plotting   = false;   % Produce Voronoi plots
   PtIDs      = false;   % Label the points in the plots

   % --- H-SET properties.
   % H-SET collapse method: 'hierarchal_singlelabel' or 'trivial'.
   Method = 'hierarchal_singlelabel';
   LoS = 0.01;           % level of significance
   PixelSize = 100;      % conversion from pixels to nm
   PlotFigures = true;   % plot various cluster related figures
   Sigma_Reg = [10, 10]; % registration error in x, y (nm)
   Timing = true;        % produce timings for clustering
```

---

methods:
- **[cluster](cluster.m)**:
  Main interface to the clustering algorithms
- **[clusterSR](clusterSR.m)**:
  Combine multiple clustered points into single localizations when appropriate
  via a top-down descent through a hierarchal dendrogram relationship between
  points
- **[clusterStats](clusterStats.m)**:
  produces large variety of statistics on computed clusters:
```
     nC                number of clusters
     C                 cell array of the indices of the points in each cluster
     SMD               (x, y) coordinates in the format
                        (1) SMD structure: SMD.X, SMD.Y with optional SMD.X_SE,
                            SMD.Y_SE (only needed for H-SET clustering) (pixel)
                        (2) N x 2 or N x 3 array of coordinates (nm)
     n_points          total number of points
     n_clustered       number of points in clusters
     n_isolated        number of points not in clusters
     n_pts             number of points per cluster
     numclust(1,2,3)   number of singlet, double, multiple clusters, where
                       singlet clusters include isolated points (see
                       SRcluster.m for an equivalent definition)
     singlet_faction   numclust(1) / sum(numclust)
     sigma_actual      actual (computed) sigma of each cluster, that is, the
                       standard deviation of the intracluster distances
     indices_hull      cell array of boundary hull indices relative to XY per
                       cluster
     areas             area of each cluster
     equiv_radii       equivalent radius of each cluster
     n_pts_per_area    number of points per area for clusters containing 3 or
                       more points
     perimeters        perimeter of each cluster
     compactness       4 pi area / perimeter^2 of each cluster
     min_c2c_dists     minimum center-to-center distances for each cluster
                       with respect to all the others
     min_e2e_dists     minimum edge-to-edge distances for each cluster convex
                       hull with respect to all the others
     min_c2c_dist      min(min_c2c_dists)
     min_e2e_dist      min(min_e2e_dists)
     nn_within_clust   nearest neighbor distances between points within
                       clusters only
```
- **[cluster_HSET](cluster_HSET.m)**:
  Perform the clustering implied by H-SET, in which the nodes that would be
  combined in normal H-SET are taken to be clusters here
- **[cluster_voronoi](cluster_voronoi.m)**:
  Taking the density indices i_rho that identify points to be clustered, 
  generate the clusters C (their number given by nC)
- **[dbscan_Daszykowski](dbscan_Daszykowski.m)**:
  Clustering the data with Density-Based Scan Algorithm with Noise (DBSCAN);
  this seems to be the same or very similar to MATLAB's dbscan introduced in
  R2019a
- **[edge2edge](edge2edge.m)**:
  the minimum edge-to-edge distance between hull 1 and hull 2
- **[hierarchal](hierarchal.m)**:
  Form clusters such that any point in a cluster is within E of some other
  point in the same cluster
- **[hierarchalSingleLabel](hierarchalSingleLabel.m)**:
  Combine multiple clustered points into single labels when appropriate via a
  top-down descent through a hierarchal dendrogram relationship between points
- **[my_ismemberBuiltinTypes](my_ismemberBuiltinTypes.m)**:
  Extracted and simplified from MATLAB's ismember.m for simplified usage
- **[nn_ROIcombined](nn_ROIcombined.m)**:
  Plots the mean particle nearest neighbor distances for a series of ROIs
- **[nn_ROIrandom](nn_ROIrandom.m)**:
  plots the PDF of nearest neighbor distances (NND) for points in a ROI vs a
  theoretical curve based on the same point density
- **[nn_distances](nn_distances.m)**:
  minimum nearest neighbor distances from each point in xy to the other points
- **[plotClusters](plotClusters.m)**:
  Plot and label the 2D clusters
- **[plotClusters3](plotClusters3.m)**:
  Plot and label the 3D clusters
- **[plotClustersSE](plotClustersSE.m)**:
  Plot and label the 2D clusters, producing circles with radii proportional to
  the standard error (SE)
- **[plot_voronoi](plot_voronoi.m)**:
  plots the Voronoi diagram corresponding to (X, Y), coloring cells
  according to the density rho
- **[plot_voronoi3](plot_voronoi3.m)**:
  plots the Voronoi diagram corresponding to (X, Y, Z), coloring
  the cells according to the density rho
- **[singleLabelTest](singleLabelTest.m)**:
  Tests if a cluster of points came from point source 
- **[voronoi_Levet](voronoi_Levet.m)**:
  implements Voronoi diagram based clustering

- **[unitTest](unitTest.m)**:
  test calling Clustering routines

./MATLAB/+smi_cluster/@Clustering/nn_ROIrandom.m
function hfig = nn_ROIrandom(obj, SMD, A_ROI, desc)
%nn_ROIrandom plots the PDF of nearest neighbor distances (NND) for points in a
% ROI vs a theoretical curve based on the same point density.
%
% INPUTS:
%    SMD         (x, y) coordinates in the format
%                    (1) SMD structure: SMD.X, SMD.Y (pixel)
%                    (2) N x 2 array of coordinates (nm)
%    A_ROI    [OPTIONAL] area of the ROI (nm^2)
%             [default is to compute it from the coordinate extremes]
%    desc     [OPTIONAL] description used for the plot's title [default = '']
%
% OUTPUT:
%    hfig     figure handle

% Created by
%    Michael Wester (2020)

   % Check for SMD structure; in this situation, assume the units are pixels.
   SMDstruct = false;
   if isfield(SMD, 'X') & isfield(SMD, 'Y')
      SMDstruct = true;
      XY = [SMD.X, SMD.Y] .* obj.PixelSize;
   % Check for N x 2 matrix of coordinates.
   elseif ismatrix(SMD) && size(SMD, 2) == 2
      XY = SMD;
   else
      error('Unrecognized coordinate input!');
   end

   if ~exist('desc', 'var')
      desc = '';
   else
      desc = regexprep(desc, '_', '\\_');
   end
   % Compute A_ROI from the coordinate extremes.
   if ~exist('A_ROI', 'var')
      A_ROI = (max(XY(:, 1)) - min(XY(:, 1)))*(max(XY(:, 2)) - min(XY(:, 2)));
   end

   % Nearest neighbor distances (NND).
   [~, D] = knnsearch(XY, XY, 'K', 2);
   if ~isempty(D) && ~isscalar(D)
      D = D(:, 2);
   end

   P = prctile(D, 99);
   hfig = figure;
   hold on
   h = histogram(D(D < P), 30);
   maxD = max(D(D < P));

   % PDF for a random NN distribution.  Details at
   %    https://en.wikipedia.org/wiki/Mean_inter-particle_distance
   % density (#/nm^2)
   rho = size(XY, 1) / A_ROI;   % (#/nm^2)
   a = 1 / sqrt(pi * rho);   % (nm)
   r = 0 : maxD/1000 : maxD;   % (nm)
   PDF = 2/a * (r/a) .* exp(-(r/a).^2);

   %h.Normalization = 'probability';
   h.Normalization = 'PDF';
   xlabel('NN localization distances (nm)');
   ylabel('PDF');
   title(desc);
   plot(r, PDF, 'r-', 'LineWidth', 2);
   legend('data', 'random');
   hold off

end

./MATLAB/+smi_cluster/@Clustering/cluster_HSET.m
function [nC, C] = cluster_HSET(obj, SMD, minPts)
% Perform the clustering implied by H-SET, in which the nodes that would be
% combined in normal H-SET are taken to be clusters here.
%
% INPUTS:
%    obj         various properties used by the algorithms
%       PixelSize    linear dimension of a pixel (nm)
%       Sigma_Reg    pre-computed image registration error (nm)
%    SMD         SMD structure with data for H-SET clustering
%       X, Y         X and Y localization coordinates     (pixel)
%       X_SE, Y_SE   X and Y localization standard errors (pixel)
%    minPts      minimum number of points allowed in a cluster
%
% OUTPUTS:
%    nC          number of clusters found
%    C           cell array of XY indices forming each cluster [nC x 1]

% Created by
%    Michael J. Wester (2021)

   XY    = double([ SMD.X, SMD.Y ]) .* obj.PixelSize;
   sigma = double([ SMD.X_SE, SMD.Y_SE ]) .* obj.PixelSize;
   [XY_new, sigma_new, combined, SRsave] = ...
      obj.clusterSR(XY, sigma, obj.Sigma_Reg);

   nC = 0;
   C = {};
   for i = 1 : numel(combined)
      if numel(combined{i}) >= minPts
         nC = nC + 1;
         C{nC} = combined{i};
      end
   end
   
end

./MATLAB/+smi_cluster/@Clustering/singleLabelTest.m
function [Pvalue, X_Point, Sigma_Point] = singleLabelTest(X, Sigma, Sigma_Reg)
%singleLabelTest Tests if a cluster of points came from point source 
%   This function calculates a p-value for a cluster of points. 
%   The meaning of of the p-value is the probabilty that a more extreme set
%   of N points came from a point source, where N is the number of observed
%   points. 
%
% INPUTS:
%   X,Y  NxM Vectors of positions. N is number of particles, M is dimension
%   X_Sigma, Y_Sigma    NxM Vectors of position uncertainty (1 STD)
%   Sigma_Reg           1xM array of registration error (1 sigma)
%
% OUTPUTS:
%   Pvalue:             Probability of more exterme cluster
%   X_Point:            Weighted mean location value of point source
%   Sigma_Point:        Weighted uncertainty of point source

% Created by
%    Keith Lidke (2021)

N=size(X,1);
M=size(X,2);
DOF = M*N-M;

if DOF==0
    DOF=1;
end

%Make uncertainty larger due to registration error
Sigma = sqrt(Sigma.^2+repmat(Sigma_Reg.^2,[N,1]));

% MLE of center position:
X_Point = sum(X./Sigma.^2,1)./sum(1./Sigma.^2,1);
Sigma_Point = sqrt(1./sum(1./Sigma.^2,1));

%Likelihood at MLE
L=normpdf(X,repmat(X_Point,[N,1]),Sigma);

%Likelihood at Null
L0 = normpdf(X,X,Sigma);

%Calculate likelihood ratio:
R=-2*sum(sum(log(L./L0)));

X2_CDF=inline('gammainc(x/2,k/2)','k','x');
Pvalue=1-X2_CDF(DOF,R);

end

./MATLAB/+smi_cluster/@Clustering/hierarchal.m
function [C, ptsI] = hierarchal(XY, E, minPts)
% Form clusters such that any point in a cluster is within E of some other
% point in the same cluster.
%
% Inputs:
%    XY       matrix of coordinates [N x 2]
%    E        cutoff distance
%    minPts   minimum number of points required for a cluster
%
% Outputs:
%    C        cell array of indices (wrt XY) per cluster [N x 1]
%    ptsI     indices (wrt XY) of isolated points

   if size(XY, 1) == 1
      C{1} = [1];
      ptsI = [];
      return;
   end

   Z = linkage(XY, 'single');
   %figure; dendrogram(Z);
   T = cluster(Z, 'Cutoff', E, 'Criterion', 'distance', 'Depth', 2);
   nC = max(T);

   % Remove clusters of size < minPts, taking the points to be isolated.
   C = [];
   j = 0;
   ptsI = [];
   for i = 1 : nC
      c = find(T == i);
      n = length(c);
      if n >= minPts
         j = j + 1;
         C{j} = c';
      else
         ptsI = [ptsI, c'];
      end
   end
   nC = j;

   ptsI = sort(ptsI);

%  % Check if the isolated points really are isolated or if they can be added
%  % to an existing cluster.  Do a single check here, although this might be
%  % iterated in the general case (or the algorithm rewritten entirely).
%  E2 = E^2;
%  not_isolated = [];
%  for i = 1 : length(ptsI)
%     I = ptsI(i);
%     p = XY(I, :);
%     MIN_d2 = 1.0e10;  
%     for j = 1 : nC
%        c = XY(C{j}, :);
%        min_d2 = min((c(:, 1) - p(1)).^2 + (c(:, 2) - p(2)).^2);
%        if min_d2 < MIN_d2
%           MIN_d2 = min_d2;
%           indx = j;
%        end
%     end
%     % Point is not isolated after all!  Add it into the nearest cluster.
%     if MIN_d2 < E2
%        C{indx} = [C{indx}, I];
%        not_isolated = [not_isolated, I];
%     end
%  end
%  % Removed non-isolated points (as determined above) from the list of
%  % isolated points.
%  ptsI = setdiff(ptsI, not_isolated);

end

./MATLAB/+smi_cluster/@Clustering/edge2edge.m
function min_d = edge2edge(hull1, hull2)
%edge2edge is the minimum edge-to-edge distance between hull 1 and hull 2.
%
% INPUTS:
%    hull1, hull2   (x, y {, z}) coordinates of the two hulls defining the
%                   boundaries of a cluster of points [N x dim]
%
% OUTPUT:
%    min_d          minimum edge-to-edge distance between hull 1 and hull 2

% Created by
%    Michael J. Wester (2019)

   dim = size(hull1, 2);
   min_d2 = 1.0e+10;
   n1 = size(hull1, 1);
   %n2 = size(hull2, 1);
   for i = 1 : n1
      %d2 = (hull1(i, 1) - hull2(:, 1)).^2 + (hull1(i, 2) - hull2(:, 2)).^2;
      d2 = 0;
      for j = 1 : dim
         d2 = d2 + (hull1(i, j) - hull2(:, j)).^2;
      end
      min_d2 = min(min_d2, min(d2));
   end
   min_d = sqrt(min_d2);

end

./MATLAB/+smi_cluster/@Clustering/Clustering.m
classdef Clustering < handle

% Clustering class written by Michael Wester, Keith Lidke, Carolyn Pehlke, Flor
%    Espinoza Hidalgo, Stanly Steinberg and others as noted internally
%    (2/22/2018) <wester@math.unm.edu>
% The New Mexico Center for the Spatiotemporal Modeling of Cell Signaling
% University of New Mexico Health Sciences Center
% Albuquerque, New Mexico, USA   87131
% Copyright (c) 2015-2021 by Michael J. Wester and Keith A. Lidke
%
%    DBSCAN_Daszykowski is the recommended DBSCAN algorithm as it is both fast
%    and stable under coordinate reordering.
%
% Martin Ester, Hans-Peter Kriegel and J\"org Sander and Xiaowei Xu, ``A
% Density-Based Algorithm for Discovering Clusters in Large Spatial Databases
% with Noise'', in _Proceedings of 2nd International Conference on Knowledge
% Discovery and Data Mining (KDD-96)_ edited by Evangelos Simoudis, Jiawei Han
% and Usama M. Fayyad, AAAI Press, 1996, 226--231, ISBN:1-57735-004-9,
% DOI:10.1.1.71.1980.
%
% M. Daszykowski, B. Walczak, D. L. Massart, Looking for Natural Patterns in
% Data. Part 1: Density Based Approach, Chemom. Intell. Lab. Syst. 56 (2001)
% 83-92. 
%
%    Hierarchical is Matlab's hierarchal clustering algorithm with some small
%    additions.
%
%    Voronoi is Florian Levet et al's Voronoi based algorithm.
%
% Florian Levet, Eric Hosy, Adel Kechkar, Corey Butler, Anne Beghin, Daniel
% Choquet and Jean-Baptiste Sibarita, ``SR-Tesseler: a method to segment and
% quantify localization-based super-resolution microscopy data'', _Nature
% Methods_, Volume 12, Number 11, 2015, 1065--1071 (DOI:10.1038/NMETH.3579).
%
%    H-SET is the clustering implied by H-SET, in which the nodes that would be
%    combined in normal H-SET are taken to be clusters here.
%
% Jia Lin, Michael J. Wester, Matthew S. Graus, Keith~A. Lidke and Aaron K.
% Neumann, ``Nanoscopic cell wall architecture of an immunogenic ligand in
% _Candida albicans_ during antifungal drug treatment'', _Molecular
% Biology of the Cell_, Volume 27, Number 6, March 15, 2016, 1002--1014
% (DOI: 10.1091/mbc.E15-06-0355, PMID: 26792838, PMCID: PMC4791122).

% =============================================================================
properties
% =============================================================================

   % --- Generic properties.
   Font_props = {'FontSize', 15, 'FontWeight', 'bold'};
   Fig_ext = 'png';
   ResultsDir = '.'; % Directory to store results.
   ShrinkFactor = 0.5; % 'boundary' compactness factor in the range 0 - 1
   Verbose = 0; % verbosity level
   Xlim = [];   % x-axis limits if defined
   Ylim = [];   % y-axis limits if defined

   % Properties used by clusterStats.
   DoSigmaActual = true; % this calc. can run out of memory for very dense ROIs
                         % (see clusterStats), so make it optional

   % Properties used by voronoi_Levet.
   Alpha      = 2;
      % Ratio of local density / overall density for a point's Voronoi
      % region to be considered sufficiently dense for clustering purposes
   Valgorithm = 2;       % Voronoi algorithm to apply:
      % 1   [0]  calculations consider Voronoi regions only
      % 2   [1]  calculations consider Voronoi regions and their adjacent
      %          neighbors
      % 3   [1M] consider the median density of each cell and its neighbors
   Plotting   = false;   % Produce Voronoi plots
   PtIDs      = false;   % Label the points in the plots

   % --- H-SET properties.
   % H-SET collapse method: 'hierarchal_singlelabel' or 'trivial'.
   Method = 'hierarchal_singlelabel';
   LoS = 0.01;           % level of significance
   PixelSize = 100;      % conversion from pixels to nm
   PlotFigures = true;   % plot various cluster related figures
   Sigma_Reg = [10, 10]; % registration error in x, y (nm)
   Timing = true;        % produce timings for clustering

% =============================================================================
end % properties
% =============================================================================

% =============================================================================
methods
% =============================================================================
% Constructor.  SMF is an optional argument.
   function obj = Clustering(SMF)

      if ~exist('SMF', 'var')
         SMF = smi_core.SingleMoleculeFitting();
      end
      obj.ResultsDir = SMF.Data.ResultsDir;
      obj.PixelSize  = SMF.Data.PixelSize;

   end
% =============================================================================
end % methods
% =============================================================================

% =============================================================================
methods(Static)
% =============================================================================

   [nC, C] = cluster_voronoi(i_rho, self_nbrs, epsilon, minPts, XY)
   [class,type,Eps]=dbscan_Daszykowski(x,k,Eps)
   min_d = edge2edge(hull1, hull2)
   [XY_combined, sigma_combined, nodes_combined] = ...
      hierarchalSingleLabel(XY, sigma, Sigma_Reg, LoS)
   [C, ptsI] = hierarchal(XY, E, minPts)
   [lia] = my_ismemberBuiltinTypes(a,b)
   min_d = nn_distances(xy)
   plot_voronoi(X, Y, v, c, rho, str, dense, ptIDs)
   plot_voronoi3(X, Y, Z, v, c, rho, str, dense, ptIDs)
   [Pvalue, X_Point, Sigma_Point] = singleLabelTest(X, Sigma, Sigma_Reg)
   success = unitTest()

% =============================================================================
end % methods(Static)
% =============================================================================
end % classdef

./MATLAB/+smi_cluster/@Clustering/clusterSR.m
function [XY, sigma, combined, SRsave] = ...
   clusterSR(obj, XY_orig, sigma_orig, Sigma_Reg)
% Combine multiple clustered points into single localizations when appropriate
% via a top-down descent through a hierarchal dendrogram relationship between
% points.
% n is the original number of points and m is the dimension.
% n' is the final number of points after combinations have occurred.
%
% INPUTS:
%    obj          various properties used by the algorithms
%       LoS                level of significance [0 <= LoS <= 1; 0.01 typical]
%       Method             H-SET collapse method:
%                             'trivial' (for testing), 'hierarchal_singlelabel'
%       Timing             produce timings
%    XY_orig      n x m matrix of coordinates (nm)
%    sigma_orig   n x m matrix of position uncertainties (1 std deviation) (nm)
%    Sigma_Reg    1 x m array of registration error (1 standard deviation) (nm)
%
% OUTPUTS:
%    XY           n' x m final coordinate matrix (nm)
%    sigma        n' x m final position uncertainty matrix (nm)
%    combined     cell array of indices of combined points per cluster
%    SRsave       temporary storage and final results that should NOT be
%                 modified by the user
%       Sigma_Reg        sigma registration (nm)
%       XY_orig          input (x, y) (nm)
%       Sigma_orig       input sigma (nm)
%       XY               collapsed (x, y) (nm)
%       Sigma            collapsed sigma (nm)
%       Nodes_combined   indices of multiple node collapsed into single nodes

% Created by
%    Michael Wester (2019)

   SRsave.XY_orig = XY_orig;
   SRsave.Sigma_orig = sigma_orig;
   SRsave.Sigma_Reg = Sigma_Reg;

   % Find clusters in the data.
   if obj.Timing
      tic
   end
   switch obj.Method
   case 'trivial'
      % For testing purposes only.
      SRsave.XY = XY_orig;
      SRsave.Sigma = sigma_orig;

   case 'hierarchal_singlelabel'
      % Collapse multiple emitters into single emitters.
      [SRsave.XY, SRsave.Sigma, SRsave.Nodes_combined] = ...
         obj.hierarchalSingleLabel(XY_orig, sigma_orig, Sigma_Reg, obj.LoS);

   otherwise
      error('Unknown method: %s\n', obj.Method);
   end
   if obj.Timing
      toc
   end

   XY = SRsave.XY;
   sigma = SRsave.Sigma;
   combined = SRsave.Nodes_combined;

end

./MATLAB/+smi_cluster/@Clustering/nn_ROIcombined.m
function nn_dists = nn_ROIcombined(obj, base_name, n_ROIs, RoI)
%nn_ROIcombined plots the mean particle nearest neighbor distances for a series
% of ROIs.
%
% INPUTS:
%    obj         various properties used by the algorithms
%       Font_props      [{'FontSize', 15, 'FontWeight', 'bold'}]
%       Fig_ext         ['png']  figure extension
%       ResultsDir      ['.']    directory to store results
%       Xlim            []       x-axis limits if defined
%       Ylim            []       y-axis limits if defined
%    base_name   name to identify saved plots, which can have various
%                descriptive suffixes attached 
%    n_ROIs      number of ROIs to combine
%    RoI         n_ROIs cell array containing the following fields:
%       X,Y{,Z}  x, y {, z} coordinates
%
% OUTPUT:
%    nn_dists    nearest nighbor distances over all particles for each ROI

% Created by
%    Michael J. Wester (2020)

   nn_dists = cell(n_ROIs, 1);
   if isfield(RoI{1}, 'Z') && ~isempty(RoI{1}.Z)
      for i = 1 : n_ROIs
         nn_dists{i} = ...
            Clustering.nn_distances([RoI{i}.X, RoI{i}.Y, RoI{i}.Z]);
      end
   else
      for i = 1 : n_ROIs
         nn_dists{i} = Clustering.nn_distances([RoI{i}.X, RoI{i}.Y]);
      end
   end

   if isempty(base_name)
      return;
   end
   base_text = regexprep(base_name, '_', '\\_');

   % Histogram
   if ~isempty(obj.Fig_ext)
      figure('Visible', 'off');
   else
      figure;
   end
   axes(obj.Font_props{:})
   hold on
   histogram(arrayfun(@(i) mean(nn_dists{i}), 1 : n_ROIs), 25);
   if ~isempty(obj.Xlim)
       xlim(obj.Xlim);
   end
   title(base_text);
   xlabel('nearest neighbor distance (nm)');
   ylabel('frequency');
   hold off
   name = fullfile(obj.ResultsDir, [base_name, '_nn_RC']);
   if ~isempty(obj.Fig_ext)
      print(['-d', obj.Fig_ext], name);
   else
      saveas(gcf, name);
      delete(gcf);
   end

   % PDF
   if ~isempty(obj.Fig_ext)
      figure('Visible', 'off');
   else
      figure;
   end
   axes(obj.Font_props{:})
   hold on
   histogram(arrayfun(@(i) mean(nn_dists{i}), 1 : n_ROIs), 25, ...
             'Normalization', 'probability');
   ylim([0, 1]);
   if ~isempty(obj.Xlim)
       xlim(obj.Xlim);
   end
   if ~isempty(obj.Ylim)
       ylim(obj.Ylim);
   end
   title([base_text, ' [all ROIs]']);
   xlabel('nearest neighbor distance (nm)');
   ylabel('probability');
   hold off
   name = fullfile(obj.ResultsDir, [base_name, '_nn_PDF_RC']);
   if ~isempty(obj.Fig_ext)
      print(['-d', obj.Fig_ext], name);
   else
      saveas(gcf, name);
      delete(gcf);
   end

end

./MATLAB/+smi_cluster/@Clustering/my_ismemberBuiltinTypes.m
function [lia] = my_ismemberBuiltinTypes(a,b)
% Extracted and simplified from MATLAB's ismember.m for the above usage.
% General handling.
% Use FIND method for very small sizes of the input vector to avoid SORT.
% Handle empty arrays and scalars.  
numelA = numel(a);
numelB = numel(b);
if numelA == 0 || numelB <= 1
    if numelA > 0 && numelB == 1
        lia = (a == b);
    else
        lia = false(size(a));
    end
    return
end

scalarcut = 5;
if numelA <= scalarcut
    lia = false(size(a));
        for i=1:numelA
            lia(i) = any(a(i)==b(:));   % ANY returns logical.
        end
else
    % Use method which sorts list, then performs binary search.
    % Convert to full to work in C helper.
    
%       % Find out whether list is presorted before sort
%       % If the list is short enough, SORT will be faster than ISSORTED
%       % If the list is longer, ISSORTED can potentially save time
%       checksortcut = 1000;
%       if numelB > checksortcut
%           sortedlist = issorted(b(:));
%       else
%           sortedlist = 0;
%       end
%       if ~sortedlist
%           b = sort(b(:));
%       end
    
    % Use builtin helper function ISMEMBERHELPER:
    % [LIA,LOCB] = ISMEMBERHELPER(A,B) Returns logical array LIA indicating
    % which elements of A occur in B and a double array LOCB with the
    % locations of the elements of A occuring in B. If multiple instances
    % occur, the first occurence is returned. B must be already sorted.
    
            lia = builtin('_ismemberhelper',a,b);
end

./MATLAB/+smi_cluster/@Clustering/plot_voronoi.m
function plot_voronoi(X, Y, v, c, rho, str, dense, ptIDs)
%plot_voronoi plots the Voronoi diagram corresponding to (X, Y), coloring cells
% according to the density rho.
%
% INPUTS:
%    X, Y    point coordinates, each [N x 1]
%    v       vertices [N x 2]
%    c       vertex indices cooresponding to each cell [Nc x 1]
%    rho     density of each cell [Nc x 1]
%    str     figure title
%    dense   indices of those cells >= prescribed density criterion
%    ptIDs   [OPTIONAL] write out point IDs if true [default = false]

% Created by
%    Michael J. Wester (2019)

   n_XY = length(X);
   n_v  = size(v, 1);
   n_c  = length(c);

   delta = 0.001 * (max(X) - min(X));
   figure();
   hold on
   voronoi(X, Y);
   limits = axis;
   colormap(jet);
   caxis([min(rho), max(rho)]);
   for i = 1 : n_c
      c_i = c{i};
      if all(c_i ~= 1)
         fill(v(c_i, 1), v(c_i, 2), rho(i));
         %fill(v(c_i, 1), v(c_i, 2), floor((i - 1)/(n_c - 1) * 255 + 1));
      end
   end
   plot(X, Y, 'k.', 'MarkerSize', 10);
   plot(X(dense), Y(dense), 'r.', 'MarkerSize', 10);
   if exist('ptIDs', 'var') & ptIDs
      for i = 1 : n_XY
         text(X(i) + delta, Y(i), sprintf('%d', i), 'Color', 'k');
      end
   end
%  plot(v(:, 1), v(:, 2), 'g.', 'MarkerSize', 10);
%  for i = 2 : n_v
%     text(v(i, 1) + delta, v(i, 2), sprintf('%d', i), 'Color', 'g');
%  end
   axis(limits);
   cb = colorbar;
   cb.Label.String = 'relative density';
   title(str);
   hold off

end

./MATLAB/+smi_cluster/@Clustering/plotClustersSE.m
function clusterFig = plotClustersSE(obj, SMD, C, centers, ptsI, txt, ...
                                     options)
% Plot and label the 2D clusters, producing circles with radii proportional to
% the standard error (SE).
%
% INPUTS:
%    SMD          (x, y) coordinates in the format
%                     (1) SMD structure: SMD.X, SMD.Y, SMD.X_SE, SMD.Y_SE (pixel)
%                     (2) N x 4 array of coordinates and precsions (nm):
%                         X, Y, X_SE, Y_SE
%    C            cell array of XY indices forming each cluster [nC x 1]
%    centers      coordinates of the center of each cluster [nC x n_dim]
%    ptsI         indices of points not found in any cluster
%    txt          descriptive text to add to the plot's title
%    options      'L': label each cluster
%                 'O': outline each cluster
%                 'P': print the size of each cluster
%                 '1': use only one color for all clusters
%                 'Y': reverse the y-axis of the plot (useful for comparison
%                      with image plots where (0, 0) is at the upper left)
% OUTPUT:
%    clusterFig   figure handle

   % Check for SMD structure; in this situation, assume the units are pixels.
   SMDstruct = false;
   if isfield(SMD, 'X') & isfield(SMD, 'Y')
      SMDstruct = true;
      XY = [SMD.X, SMD.Y] .* obj.PixelSize;
      XY_SE = [SMD.X_SE, SMD.Y_SE] .* obj.PixelSize;
   % Check for N x 2 or N x 3 matrix of coordinates.
   elseif ismatrix(SMD) && size(SMD, 2) == 4
      XY = SMD(:, 1:2);
      XY_SE = SMD(:, 3:4);
   else
      error('Unrecognized coordinate input!');
   end

   if exist('options', 'var')
      labeling = strfind(options, 'L');
      outlines = strfind(options, 'O');
      printing = strfind(options, 'P');
      onecolor = strfind(options, '1');
      reverseY = strfind(options, 'Y');
   else
      labeling = false;
      outlines = true;
      printing = false;
      onecolor = false;
      reverseY = false;
   end

   colors = 'rgbcmy';
   n_colors = length(colors);

   nC = length(C);
   n_isolated = length(ptsI);
   n_points = size(XY, 1);
   n_clustered = 0;

   clusterFig = figure('Visible', 'off');
   hold on
   fprintf('\n');
   theta = 0 : 0.05 : 2*pi + 0.05;
   for i = 1 : nC
      j = smi_helpers.nMODm(i, n_colors);
      if onecolor
         color = 'm';
      else
         color = colors(j);
      end
      n_pts = length(C{i});
      n_clustered = n_clustered + n_pts;
      if printing
         fprintf('cluster %d has %2d points (%s)\n', i, n_pts, color);
      end
      %plot(XY(C{i}, 1), XY(C{i}, 2), [color, '.'], 'MarkerSize', 12);
      plot(XY(C{i}, 1), XY(C{i}, 2), [color, '.']);
      for j = 1 : n_pts
         r = sqrt(2*(XY_SE(C{i}(j), 1)^2 + XY_SE(C{i}(j), 2)^2));
         x = XY(C{i}(j), 1) + r*cos(theta);
         y = XY(C{i}(j), 2) + r*sin(theta);
         plot(x, y, [color, '-']);
      end
      if labeling
         text(centers(1, i), centers(2, i), sprintf('%d', i));
      end
      if outlines
         if length(C{i}) <= 2
            plot(XY(C{i}, 1), XY(C{i}, 2), [color, '-'], 'LineWidth', 2);
         else %if length(C{i}) >= 3
            xy = double(XY(C{i}, :));
            %k = convhull(XY(C{i}, 1), XY(C{i}, 2));
            k = boundary(xy(:, 1), xy(:, 2), obj.ShrinkFactor);
            k = C{i}(k);
            plot(XY(k, 1), XY(k, 2), [color, '-'], 'LineWidth', 2);
         end
      end
   end
   if n_isolated > 0
      %plot(XY(ptsI, 1), XY(ptsI, 2), 'k.', 'MarkerSize', 12);
      plot(XY(ptsI, 1), XY(ptsI, 2), 'k.');
      for j = 1 : n_isolated
         r = sqrt((XY_SE(ptsI(j), 1)^2 + XY_SE(ptsI(j), 2)^2) / 2);
         x = XY(ptsI(j), 1) + r*cos(theta);
         y = XY(ptsI(j), 2) + r*sin(theta);
         plot(x, y, 'k-');
      end
   end
   if reverseY
      set(gca, 'YDir', 'reverse');
   end
   title(sprintf('%s (points = %d, clusters = %d, clustered %% = %.3f)', ...
                 regexprep(txt, '_', '\\_'), n_points, nC,               ...
                 n_clustered/n_points * 100));
   hold off

end

./MATLAB/+smi_cluster/@Clustering/clusterStats.m
function results = clusterStats(obj, SMD, C, centers)
%clusterStats produces statistics on computed clusters.
%
% INPUTS:
%    SMD            (x, y) coordinates of all the points processed (nm) in the
%                   format
%                      (1) SMD structure: SMD.X, SMD.Y with optional SMD.X_SE,
%                          SMD.Y_SE (needed for H-SET clustering) (pixel)
%                      (2) N x 2 or N x 3 array of coordinates (nm)
%    C              cell array of the indices of the points in each cluster
%    centers        array of the coordinates of the center of each cluster
%
% OUTPUTS (contained in results):
%    nC                number of clusters
%    C                 cell array of the indices of the points in each cluster
%    SMD               (x, y) coordinates in the format
%                       (1) SMD structure: SMD.X, SMD.Y with optional SMD.X_SE,
%                           SMD.Y_SE (only needed for H-SET clustering) (pixel)
%                       (2) N x 2 or N x 3 array of coordinates (nm)
%    n_points          total number of points
%    n_clustered       number of points in clusters
%    n_isolated        number of points not in clusters
%    n_pts             number of points per cluster
%    numclust(1,2,3)   number of singlet, double, multiple clusters, where
%                      singlet clusters include isolated points (see
%                      SRcluster.m for an equivalent definition)
%    singlet_faction   numclust(1) / sum(numclust)
%    sigma_actual      actual (computed) sigma of each cluster, that is, the
%                      standard deviation of the intracluster distances
%    indices_hull      cell array of boundary hull indices relative to XY per
%                      cluster
%    areas             area of each cluster
%    equiv_radii       equivalent radius of each cluster
%    n_pts_per_area    number of points per area for clusters containing 3 or
%                      more points
%    perimeters        perimeter of each cluster
%    compactness       4 pi area / perimeter^2 of each cluster
%    min_c2c_dists     minimum center-to-center distances for each cluster
%                      with respect to all the others
%    min_e2e_dists     minimum edge-to-edge distances for each cluster convex
%                      hull with respect to all the others
%    min_c2c_dist      min(min_c2c_dists)
%    min_e2e_dist      min(min_e2e_dists)
%    nn_within_clust   nearest neighbor distances between points within
%                      clusters only

% Created by
%    Michael J. Wester (2021)

   % Check for SMD structure; in this situation, assume the units are pixels.
   SMDstruct = false;
   if isfield(SMD, 'X') & isfield(SMD, 'Y')
      SMDstruct = true;
      if isfield(SMD, 'Z') && ~isempty(SMD.Z)
         XY = [SMD.X, SMD.Y, SMD.Z] .* obj.PixelSize;
      else
         XY = [SMD.X, SMD.Y] .* obj.PixelSize;
      end
   % Check for N x 2 or N x 3 matrix of coordinates.
   elseif ismatrix(SMD) && (size(SMD, 2) == 2 || size(SMD, 2) == 3)
      XY = SMD;
   else
      error('Unrecognized coordinate input!');
   end

   dim = size(XY, 2);

   nC = length(C);
   results.nC = nC;
   results.C  = C;
   results.XY = XY;

   xy_hull       = cell(1, nC);
   min_e2e_dists = zeros(1, nC);
   results.n_points     = size(XY, 1);
   results.n_clustered  = 0;
   results.n_isolated   = 0;
   results.n_pts        = zeros(1, nC);
   results.numclust     = zeros(1, 3);
   results.sigma_actual = zeros(1, nC);
   results.indices_hull = cell(1, nC);
   results.areas        = zeros(1, nC);
   results.equiv_radii  = zeros(1, nC);
   results.n_pts_per_area = [];
   results.perimeters   = [];
   results.compactness  = [];
   results.nn_within_clust = [];
   for i = 1 : nC
      xy = double(XY(C{i}, :));
      n_pts = size(xy, 1);
      results.n_pts(i) = n_pts;
      results.n_clustered = results.n_clustered + n_pts;
      if n_pts == 1
         results.numclust(1) = results.numclust(1) + 1;
         results.sigma_actual(i) = 0;
         results.indices_hull{i} = 1;
         results.areas(i)        = 0;
         results.equiv_radii(i)  = 0;
         results.compactness(i)  = 1;
      elseif n_pts == 2
         results.numclust(2) = results.numclust(2) + 1;
         results.sigma_actual(i) = std(pdist(xy));
         results.indices_hull{i} = [1, 2];
         results.areas(i)        = 0;
         results.equiv_radii(i)  = pdist(xy) / 2;
         results.compactness(i)  = 0;
         results.nn_within_clust = [results.nn_within_clust, ...
                                    repmat(pdist(xy), 1, 2)];
      else % n_pts >= 3
         results.numclust(3) = results.numclust(3) + 1;
         % The line below can sometimes cause MATLAB to crash inelegantly if
         % n_pts is large and may have some special size.
         %results.sigma_actual(i) = std(pdist(xy));
         % DoSigmaActual is a flag to allow this calculation to be performed,
         % noting the potential memory issues.
         if obj.DoSigmaActual
            results.sigma_actual(i) = std(pdist(xy));
         else
            results.sigma_actual(i) = 0;
         end
         try
            %[k, A] = convhull(xy(:, 1), xy(:, 2));
            if dim == 2
               [k, A] = boundary(xy(:, 1), xy(:, 2), obj.ShrinkFactor);
            else
               [k, A] = boundary(xy(:, 1), xy(:, 2), xy(:, 3), ...
                                 obj.ShrinkFactor);
            end
            if isempty(k)
               k = 1;
            end
         catch
            fprintf('boundary collinear (n_points = %d)\n', n_pts);
            %xy
            k = 1;
            A = 0;
         end
         results.indices_hull{i} = k;
         results.areas(i)        = A;
         if dim == 2
            % A = pi r^2
            results.equiv_radii(i)  = sqrt(A / pi);
         else
            % V (A) = 4/3 pi r^3
            results.equiv_radii(i)  = (3/4*A / pi)^(1/3);
         end
         if A > 0
            results.n_pts_per_area  = [results.n_pts_per_area, n_pts / A];
            if dim == 2
               perim = 0;
               for j = 1 : length(k) - 1
                  perim = perim + pdist([xy(k(j), :); xy(k(j + 1), :)]);
               end
               results.perimeters      = [results.perimeters, perim];
               results.compactness     = [results.compactness, ...
                                          4*pi*A / perim^2];
            end
         end
      end
      xy_hull{i} = xy(results.indices_hull{i}, :);
      results.nn_within_clust = [results.nn_within_clust, ...
                                 smi_cluster.Clustering.nn_distances(xy)];
   end
   results.n_isolated = results.n_points - results.n_clustered;
   results.numclust(1) = results.numclust(1) + results.n_isolated;
   results.singlet_fraction = results.numclust(1) / sum(results.numclust);

   % The below can be an expensive operation timewise.
   if nC > 1 
      %results.min_c2c_dists = ...
      %   min(squareform(pdist(centers')) + 1.0e+10 * eye(nC));
      results.min_c2c_dists = smi_cluster.Clustering.nn_distances(centers');
      results.min_c2c_dist = min(results.min_c2c_dists);

      results.min_e2e_dists = zeros(1, nC);
      min_e2e_dist = 1.0e+10;
      for i = 1 : nC
         min_e2e_dists(i) = 1.0e+10;
         for j = 1 : i - 1
            e2e = smi_cluster.Clustering.edge2edge(xy_hull{i}, xy_hull{j});
            min_e2e_dist = min(min_e2e_dist, e2e);
            min_e2e_dists(i) = min(min_e2e_dists(i), e2e);
         end
         for j = i + 1 : nC
            e2e = smi_cluster.Clustering.edge2edge(xy_hull{i}, xy_hull{j});
            min_e2e_dist = min(min_e2e_dist, e2e);
            min_e2e_dists(i) = min(min_e2e_dists(i), e2e);
         end
         results.min_e2e_dists(i) = min_e2e_dists(i);
      end
      results.min_e2e_dist = min_e2e_dist;
   else
      results.min_c2c_dists = [];
      results.min_c2c_dist  = [];
      results.min_e2e_dists = [];
      results.min_e2e_dist  = [];
   end

end

./MATLAB/+smi_cluster/clusterSTDist.m
function [ConnectID] = clusterSTDist(SMD, MaxFrameGap, MaxDist)
%clusterSTSigma performs pre-clustering on localizations in SMD.
% This method clusters localizations in SMD based on their spatiotemporal
% separations.  Localizations within MaxDist of one another which 
% appear within MaxFrameGap frames will be assigned to the same cluster.  
% The assignment is designated by a shared integer value of the output 
% ConnectID.
%
% NOTE: This function was originally written in the context of
%       FrameConnection.lapFC().
%
% INPUTS:
%   SMD: SingleMoleculeData structure with the localizations that we wish
%        to frame-connect.
%   MaxFrameGap: Maximum frame gap allowed between cluster members.
%   MaxDist: Maximum distance allowed between members of the same cluster.
%
% OUTPUTS:
%   ConnectID: Set of integers defining links between localizations in SMD,
%              with indexing matching the indices of SMD localizations.

% Created by:
%   David J. Schodt (Lidke Lab, 2021)


% Gather/revise/reorganize some arrays for further use.
[DatasetNum, SortIndices] = sort(SMD.DatasetNum);
X = SMD.X(SortIndices);
Y = SMD.Y(SortIndices);
X_SE = SMD.X_SE(SortIndices);
Y_SE = SMD.Y_SE(SortIndices);
FrameNum = SMD.FrameNum(SortIndices);
MeanXYSE = mean([X_SE, Y_SE], 2);

% Initialize each localization as a new cluster.
NLocalizations = numel(SMD.FrameNum);
ConnectID = (1:NLocalizations).';

% Loop through datasets and perform the pre-clustering.
[NLocPerDataset, DatasetArray] = groupcounts(DatasetNum);
CumulativeDatasetLocs = [0; cumsum(NLocPerDataset)];
MaxID = NLocalizations;
for ii = 1:numel(DatasetArray)
    % Isolate some arrays for the current dataset (CDS = current dataset)
    CurrentDatasetInd = (1:NLocPerDataset(ii)) + CumulativeDatasetLocs(ii);
    [FrameNumCDs, SortIndicesFN] = sort(FrameNum(CurrentDatasetInd));
    CurrentDatasetInd = CurrentDatasetInd(SortIndicesFN);
    XCDs = X(CurrentDatasetInd);
    YCDs = Y(CurrentDatasetInd);
    MeanXYSECDs = MeanXYSE(CurrentDatasetInd);
    ConnectIDCDs = ConnectID(CurrentDatasetInd);
    
    % Loop through frames and add localizations to clusters.
    IsClustered = zeros(NLocPerDataset(ii), 1, 'logical');
    [NLocPerFrame, FrameArray] = groupcounts(FrameNumCDs);
    CumulativeLocs = [0; cumsum(NLocPerFrame)];
    for ff = 1:numel(FrameArray)
        % Determine which localizations should be considered for clustering.
        % NOTE: Even though we don't want clusters with multiple 
        %       localizations in the same frame for the final results, we 
        %       don't want to exclude those until later (since inclusion of
        %       WRONG localizations now can exclude CORRECT localizations 
        %       if we restrict same frame localizations).
        CurrentFrameInd = (1:NLocPerFrame(ff)) + CumulativeLocs(ff);
        CandidateFrameInd = ...
            find((FrameNumCDs >= (FrameArray(ff)-MaxFrameGap)) ...
            & (FrameNumCDs<=FrameArray(ff)));
        if isempty(CandidateFrameInd)
            MaxID = MaxID + 1;
            ConnectID(CurrentFrameInd) = (1:NLocPerFrame(ff)).' + MaxID;
            MaxID = MaxID + NLocPerFrame(ff);
            continue
        end
        
        % Determine the nearest neighbor to the current localizations in
        % all candidate frames (noting that we're allowing comparisons to
        % the current frame as well).
        [NNIndices, NNDistances] = knnsearch(...
            [XCDs(CandidateFrameInd), YCDs(CandidateFrameInd)], ...
            [XCDs(CurrentFrameInd), YCDs(CurrentFrameInd)], ...
            'k', 2);
        NNIndices = NNIndices(:, 2:end);
        NNDistances = NNDistances(:, 2:end);
        
        % Place the CurrentFrameInd localizations into clusters.
        ValidNNInd = find(NNDistances <= MaxDist);
        if isempty(ValidNNInd)
            continue
        end
        for nn = ValidNNInd.'
            % Place this localization into the same cluster as its nearest
            % neighbor.
            NNIndex = CandidateFrameInd(NNIndices(nn));
            if IsClustered(NNIndex)
                ConnectIDCDs(CurrentFrameInd(nn)) = ConnectIDCDs(NNIndex);
                IsClustered(CurrentFrameInd(nn)) = true;
            else
                MaxID = MaxID + 1;
                ConnectIDCDs([CurrentFrameInd(nn), NNIndex]) = MaxID;
                IsClustered([CurrentFrameInd(nn), NNIndex]) = true;
            end
        end
    end
    ConnectID(CurrentDatasetInd) = ConnectIDCDs;
end
ConnectID(SortIndices, 1) = ConnectID;
ConnectID = smi_helpers.compressToRange(ConnectID);


end
./MATLAB/+smi_cluster/README.md
### +smi_cluster

+smi_cluster is the namespace for the post-processing clustering classes of
***smite***:
- [@Clustering](@Clustering/README.md):
  clustering algorithms (DBSCAN, Voronoi, H-SET)
- [@ClusterInterface](@ClusterInterface/README.md): 
  interface functions for Clustering class
- [@PairAnalysis](@PairAnalysis/README.md): 
  interface functions for PairCorrelation class
- [@PairCorrelation](@PairCorrelation/README.md): 
  pair correlation (auto- and cross-) on ROIs
- [@StatisticsClustering](@StatisticsClustering/README.md): 
  clustering statistical analyses

In addition, there are functions:
- **[clusterSTDist](clusterSTDist.m)**:
  performs pre-clustering on localizations in SMD based
  on their spatiotemporal separations with cutoffs MaxFrameGap and MaxDist
- **[clusterSTSigma](clusterSTSigma.m)**:
  performs pre-clustering on localizations in SMD based on their spatiotemporal
  separations with cutoffs MaxFrameGap, NSigmaDev, MaxNN

./MATLAB/+smi_cluster/@ClusterInterface/combineBaGoLROIs.m
function combineBaGoLROIs(pathnameR, filesR, pathnameB, filesB, MAPNfile, ...
                          keep_numbering)
% ---------- Possibly, combine individually processed BaGoL ROIs into a single
%            _ROIs.mat file using the _ROIs.mat file that was used to define
%            the ROIs originally from the SR data
% If datasets are too dense, it becomes necessary to process each ROI
% separately.  This function will combine multiple BaGoL processed ROIs from
% multiple (biological) cells into appropriately named combined _ROIs.mat
% files.  This assumes the various files involved are following a naming
% convention.  For example, the original collection of ROIs produced from the
% SR data (combining both labels):
%    Cell_01_Label_01_Results_ROIs.mat
%    Cell_02_Label_01_Results_ROIs.mat
%    ...
% The BaGoL MAPN coordinates per ROI are named:
%    MAPN_Cell_01_Label_01_Results_ROI_01.mat
%    MAPN_Cell_01_Label_01_Results_ROI_02.mat
%    ...
%    MAPN_Cell_01_Label_02_Results_ROI_01.mat
%    ...
%    MAPN_Cell_02_Label_01_Results_ROI_01.mat
%    ...
% The collection of ROIs (combining both labels) produced from the BaGoL data:
%    Cell_01_Results_BaGoL_ROIs.mat
%    Cell_02_Results_BaGoL_ROIs.mat
%    ...
%
% INPUTS:
%    pathnameR   path to where the ROIs file below are located
%    filesR      _Results_ROIs.mat files to collect ROI info from
%    pathnameB   path to where the BaGoL files below are located
%    filesB      BaGoL files to collect ROI coordinate info from
%    MAPNfile    if false, assume BaGoL_Results_*_Results*.mat files,
%                otherwise if true, assume MAPN_*.mat files
%    keep_numbering retain the ROI numbering even if there are missing ROIs
%                (which will be treated as empty) [default: false]
%
% OUTPUTS:
%    Saves pathnameB/Analysis/*_BaGoL_ROIs.mat

% Created by
%    Michael J. Wester (2022)

   if ~exist('keep_numbering', 'var')
      keep_numbering = false;
   end

   results_dir = pathnameB;

   n_files = numel(filesB);
   n_cells = numel(filesR);
   k = 0;
   for cc = 1 : n_cells
      % Extract the cell number from the file name.
      c = str2num(regexprep(filesR{cc}, '^.*Cell_([0-9][0-9]).*$', '$1'));
      cellno(c) = cc;
      % Copy the global parameters from the original SR _ROIs.mat file.
      dataR = load(fullfile(pathnameR, filesR{cc}));
      if isfield(dataR, 'ResultsFile');
         ResultsFile = dataR.ResultsFile;
      else
         ResultsFile = dataR.Label1;
         ResultsFile = regexprep(ResultsFile, '_Label_[0-9][0-9]', '');
         ResultsFile = regexprep(ResultsFile, '_L[0-9][0-9]', '');
      end
      if isfield(dataR, 'Label1');
         Label1 = dataR.Label1;
      end
      if isfield(dataR, 'Label2');
         Label2 = dataR.Label2;
      end
      Pixel2nm = dataR.Pixel2nm;
      XYsize = dataR.XYsize;
      n_labels = numel(dataR.RoI{1}.X);
      n_ROIs = dataR.n_ROIs;

      % Consistency check.
      %n_files = numel(filesB);
      %if n_labels * n_ROIs ~= numel(filesB)
      %   error('n_labels * n_ROIs != n_filesBaGoL!')
      %end

      % Gather the coordinates and standard errors from the individual
      %_ROI_*.mat files containing BaGoL processed data.
      found = [];   % a list of found ROIs
      RoI = cell(n_ROIs, 1);
      for jj = 1 : n_labels
         for ii = 1 : n_ROIs
            k = k + 1;
            if k <= n_files
               fileB = filesB{k};
               dataB = load(fullfile(pathnameB, fileB));
               % Extract the ROI number and label number from the file name. 
               i = str2num(regexprep(fileB, '^.*ROI_([0-9][0-9]).*$',   '$1'));
               j = str2num(regexprep(fileB, '^.*Label_([0-9][0-9]).*$', '$1'));
               d = str2num(regexprep(fileB, '^.*Cell_([0-9][0-9]).*$',  '$1'));
               if d ~= c
                  error('Inconsistency in Cell #: expected %d, got %d', c, d);
               end
               found = [found, i]; 
               
               RoI{i}.ROI = dataR.RoI{i}.ROI;
               if MAPNfile
                  dataB_MAPN = dataB.MAPN;
               else
                  dataB_MAPN = dataB.BGL.MAPN;
               end
               RoI{i}.X{j} = dataB_MAPN.X;
               RoI{i}.Y{j} = dataB_MAPN.Y;
               RoI{i}.X_STD{j} = dataB_MAPN.X_SE;
               RoI{i}.Y_STD{j} = dataB_MAPN.Y_SE;
            elseif keep_numbering
               % Not enough BaGoL files; insert empty data for the missing ROIs
               % to keep ROI numbering consistent.
               missing = setdiff(1 : n_ROIs, found);
               for kk = 1 : numel(missing)
                  RoI{missing(kk)}.ROI = dataR.RoI{missing(kk)}.ROI;
                  RoI{missing(kk)}.X = {[],[]};
                  RoI{missing(kk)}.Y = {[],[]};
                  RoI{missing(kk)}.X_SE = {[],[]};
                  RoI{missing(kk)}.Y_SE = {[],[]};
               end
               break
            end
         end
      end

      % Eliminate empty ROIs.
      missing = setdiff(1 : n_ROIs, found);
      if ~keep_numbering && isempty(missing)
         RoI_new = cell(n_ROIs - numel(missing), 1);
         k = 1;
         for ii = 1 : n_ROIs
            RoI_new{k} = RoI{ii};
            if ~ismember(ii, missing)
               k = k + 1;
            end
         end
         n_ROIs = n_ROIs - numel(missing); 
         RoI = RoI_new;
      end

      [~, fileB, ~] = fileparts(ResultsFile);
      short = regexprep(fileB, '.mat$', '');

      for i = 1 : n_ROIs
         ROI = RoI{i}.ROI;
         xmin = ROI(1);   xmax = ROI(2);   ymin = ROI(3);   ymax = ROI(4);
         for j = 1 : n_labels
            Xnm = RoI{i}.X{j};
%           if RT.GaussIm    % if GaussIm, have DIPimage style coordinates
%              Ynm = XYsize(2) - RoI{i}.Y;
%           else
               Ynm = RoI{i}.Y{j};
%           end
            l = xmin <= Xnm & Xnm <= xmax & ymin <= Ynm & Ynm <= ymax;
            fprintf('Cell %d ROI %d Label %d: %d points\n', c, i, j, sum(l));
            % Check that l includes some points!
            if any(l)
               % Sanity check!
               if min(Ynm(l)) < ymin || max(Ynm(l)) > ymax
                  error('ROI -> BaGoL ROI: ROI = %f %f, min/max Ynm = %f %f',...
                        ROI(3), ROI(4), min(Ynm(l)), max(Ynm(l)));
               end
            else
               warning('ROI -> BaGoL ROI: no points!');
            end
         end
      end

      fprintf('Saving %s ...\n', [short, '_BaGoL_ROIs.mat']);
      if exist('ResultsFile', 'var')
         save(fullfile(results_dir, [short, '_BaGoL_ROIs.mat']), ...
              'ResultsFile', 'Pixel2nm', 'XYsize', 'n_ROIs', 'RoI');
      else
         save(fullfile(results_dir, [short, '_BaGoL_ROIs.mat']), ...
              'Label1', 'Label2', 'Pixel2nm', 'XYsize', 'n_ROIs', 'RoI');
      end
   end % for cc

   if MAPNfile
      txt = 'MAPN ROIs';
   else
      txt = 'ROIs';
   end
   fprintf('Done combining BaGoL %s: %s.\n', txt, results_dir);

end

./MATLAB/+smi_cluster/@ClusterInterface/genMAPNIm1.m
function [SRIm]=genMAPNIm1(obj,ImFlag)
%makeIm: Produces a Gaussian blob image from either SMD or MAPN.
% Calculate BoxSize from MAPN SEs only.  This is useful in the SMD case to
% reduce the memory usage which may crash MATLAB if too much is needed.  Also,
% the MAPN and SMD plots produced will have the same resolution.
%
% [SRIm]=obj.genMAPNIm(ImFlag)
%
% Each input coordinate and standard error is used to add a normalized, 
% 2D Gaussian blob to an intially empty image. The size and image region
% is given by the input parameters. 
%
% For computational speed, this operation is done by calculating all blobs 
% within small boxes of the same size in one operation and then copying the 
% results into the output image. 
% 
% INPUTS:
%   ImFlag: Type of image to make. (Default = MAPN Image)
%      1: Retrieves the MAPN coordinates from obj and makes the MAPN image
%      2: Retrieves the SMD coordinates from obj and makes the SR image
%
% OUTPUTS: 
%   SRIm:    Output image.
%

% Created by:
%    Mohamadreza Fazel (LidkeLab, 2020)

%% SR-Image

MinX = -obj.XStart;
MinY = -obj.YStart;
if nargin==1||ImFlag==1
    SMR = obj.MAPN;
elseif ImFlag == 2
    SMR = obj.SMD;
else
    error('ImFlag must be either 1 or 2.')
end
BoxSize = floor(15*median([obj.MAPN.X_SE;obj.MAPN.Y_SE])/obj.PixelSize); %Size of box in pixels
%BoxSize = floor(15*median([SMR.X_SE;SMR.Y_SE])/obj.PixelSize); %Size of box in pixels
if floor(BoxSize/2)~=BoxSize/2
    BoxSize = BoxSize + 1; 
end

XBox = single(floor((SMR.X+MinX)/obj.PixelSize)-floor(BoxSize/2));
YBox = single(floor((SMR.Y+MinY)/obj.PixelSize)-floor(BoxSize/2));
X = single((SMR.X+MinX) - obj.PixelSize*floor((SMR.X+MinX)/obj.PixelSize) + obj.PixelSize*floor(BoxSize/2)-1);
Y = single((SMR.Y+MinY) - obj.PixelSize*floor((SMR.Y+MinY)/obj.PixelSize) + obj.PixelSize*floor(BoxSize/2)-1);

[Xg,Yg,~]=meshgrid((obj.PixelSize/2:obj.PixelSize:BoxSize*obj.PixelSize-obj.PixelSize/2),...
    (obj.PixelSize/2:obj.PixelSize:BoxSize*obj.PixelSize-obj.PixelSize/2),(1:length(SMR.X)));
Xg = single(Xg);
Yg = single(Yg);
MuX = ones(size(Xg),'single');
SigX = ones(size(Xg),'single');
MuY = MuX;
SigY = SigX;
for ii = 1:length(SMR.X)
     SigX(:,:,ii) = SMR.X_SE(ii);
     SigY(:,:,ii) = SMR.Y_SE(ii);
     MuX(:,:,ii) = X(ii);
     MuY(:,:,ii) = Y(ii);
end
Im = normpdf(Xg,MuX,SigX).*normpdf(Yg,MuY,SigY);
ExtendSZ=100;  %imae size extension
SRImT = zeros(ceil(obj.PImageSize/obj.PixelSize)+ExtendSZ,'single');
for ii = 1:length(SMR.X) 
    try
        SRImT(YBox(ii)+(ExtendSZ/2+1):YBox(ii)+BoxSize+(ExtendSZ/2),...
            XBox(ii)+(ExtendSZ/2+1):XBox(ii)+BoxSize+(ExtendSZ/2)) = ...
            SRImT(YBox(ii)+(ExtendSZ/2+1):YBox(ii)+BoxSize+(ExtendSZ/2),...
            XBox(ii)+(ExtendSZ/2+1):XBox(ii)+BoxSize+(ExtendSZ/2)) + Im(:,:,ii);
    catch
    end
end
SRIm = SRImT((ExtendSZ/2+1):end-(ExtendSZ/2),(ExtendSZ/2+1):end-(ExtendSZ/2));
end

./MATLAB/+smi_cluster/@ClusterInterface/combinedStatistics1.m
function combinedStatistics1(SC, pathname, files, base_name, A_ROI, doHopkins)
% ---------- Combined statistics for one or more conditions
% For multiple conditions, experimental (e.g., resting vs. activated) and/or
% analytical (e.g., various DBSCAN parameter combinations), produce plots
% that compare the results for a variety of studies (e.g., Hopkins' statistic,
% number of clusters per ROI, circular equivalent cluster radii, etc.).
%
% INPUTS:
%    SC          smi_cluster.StatisticsClustering object setting values for
%                properties PlotDo, ShowMM, LinLog, Ylim
%
%                SC = smi_cluster.StatisticsClustering();
%                % Make various plots:
%                %    'f'   frequency
%                %    'n'   normalized
%                %    'p'   PDF
%                %    'c'   CDF
%                %    'C'   CDF (alternative)
%                %    's'   PlotSpread
%                %    'S'   PlotSpread (bars for mean & median)
%                %    'x'   box
%                %    'b'   bar
%                SC.PlotDo = 'CSx';
%                % Red mean, green median (2 only mean, 3 only median)
%                % for PlotSpread plots.
%                SC.ShowMM = 1;
%                % Options for CDF2 plots are:
%                %    'plot', 'semilogx', 'semilogy', 'loglog'.
%                SC.LinLog = 'semilogx';
%                SC.Ylim = [0.01, 1];
%                % Produce a comma separated value file with the data for easy
%                % import into other software.
%                SC.CSV = true;
%
%                NOTE: SC.CSV is turned on and off internally to produce comma
%                separated values files for some plots.
%
%    pathname    path to where the single condition results are located
%    files       _results.mat files to collect info from
%    base_name   analysis identification string
%    A_ROI       ROI area (nm^2)
%    doHopkins   [DEFAULT = true] Hopkins' test can be time consuming for dense
%                ROIs
%
% OUTPUTS:
%    A variety of plots are produced via SC.plotCombined and are placed in a
%    subdirectory of pathname.  The subdirectory's name is derived from the
%    the analysisCondition taken from the first input filename (all filenames
%    compared are assumed to have been analyzed similarly), which is assumed
%    to have the form:
%       experimentalConditions#analysisConditions_results.mat
%    where experimentalConditions contains no #.  This function will extract
%    the various experimentalConditions being compared and use them to label
%    the plots created.

% Created by
%    Michael J. Wester (2022)

CSVglobal = false;

c = smi_cluster.Clustering();

n_files = numel(files);

% Make a subdirectory for this particular analysis.  The filenames are assumed
% to have the structure:
%    experimentalConditions#analysisConditions_results.mat
% where experimentalConditions contains no #.
econd = cell(1, n_files);
for i = 1 : n_files
   econd{i} = regexprep(files{i}, '^(.*)#.*_results.mat', '$1');
end
analysis = regexprep(files{1}, '^.*#(.*)_results.mat', '$1');
Cresults_dir = fullfile(pathname, [base_name, '_', analysis]);
SC.ResultsDir = Cresults_dir;
% Create Cresults_dir if it does not already exist.
if ~isfolder(Cresults_dir)
   mkdir(Cresults_dir);
end

SC.BaseName = '';

for j = 1 : n_files
   rdata{j} = load(fullfile(pathname, files{j}));
end

% Create file and format for P-values.
out = fopen(fullfile(Cresults_dir, 'P_values.txt'), 'w');
fmt = '';
for j = 1 : n_files
   fmt = [fmt, ' %.5e'];
end
fmt = [fmt, '\n'];

% Filter out extrema.
for j = 1 : n_files
%  rdata{j}.collected.n_clusts      = ...
%     rdata{j}.collected.n_clusts(rdata{j}.collected.n_clusts         < 400);
%  rdata{j}.collected.c_density     = ...
%     rdata{j}.collected.c_density(rdata{j}.collected.c_density       < 1.6e-5);
%  rdata{j}.collected.n_points      = ...
%     rdata{j}.collected.n_points(rdata{j}.collected.n_points         < 10000);
%  rdata{j}.collected.n_pts         = ...
%     rdata{j}.collected.n_pts(rdata{j}.collected.n_pts               < 600);
%  rdata{j}.collected.nn_dists      = ...
%     rdata{j}.collected.nn_dists(rdata{j}.collected.nn_dists         < 800);
%  rdata{j}.collected.equiv_radii   = ...
%     rdata{j}.collected.equiv_radii(rdata{j}.collected.equiv_radii   < 300);
%  rdata{j}.collected.nn_loc_dists  = ...
%     rdata{j}.collected.nn_loc_dists(rdata{j}.collected.nn_loc_dists < 400);
end

% Hopkins' statistic per ROI.
if doHopkins
   %SC.CSV = true;
   P_hopkins_ROI = ...
   SC.plotCombined(arrayfun(@(i) rdata{i}.collected.H_ROI, 1 : n_files, ...
                            'UniformOutput', false),                    ...
                   0.01, 'Hopkins per ROI', econd, 'hopkins_ROI');
   %SC.CSV = false;
   fprintf(out, 'P_hopkins per ROI =\n');
   fprintf(out, fmt, P_hopkins_ROI);
   fprintf(out, '\n');
end

% Number of clusters per ROI.
P_n_clusts = ...
SC.plotCombined(arrayfun(@(i) rdata{i}.collected.n_clusts, 1 : n_files,  ...
                         'UniformOutput', false),                        ...
                1, '# of clusters per ROI', econd, 'n_clusts_ROI');
fprintf(out, 'P_# of clusters per ROI =\n');
fprintf(out, fmt, P_n_clusts);
fprintf(out, '\n');

% Density of clusters per ROI.
P_c_density = ...
SC.plotCombined(arrayfun(@(i) rdata{i}.collected.c_density*1000^2,  ...
                              1 : n_files, 'UniformOutput', false), ...
                1/(A_ROI/1000^2),                                   ...
                'density of clusters per ROI (\mu m^{-2})',         ...
                econd, 'c_density_ROI');
fprintf(out, 'P_density of clusters per ROI =\n');
fprintf(out, fmt, P_c_density);
fprintf(out, '\n');

% Number of localizations per ROI.
if CSVglobal
   SC.CSV = true;
end
P_n_local = ...
SC.plotCombined(arrayfun(@(i) rdata{i}.collected.n_points, 1 : n_files, ...
                         'UniformOutput', false),                       ...
                [], '# of localizations per ROI', econd, 'n_local_ROI');
SC.CSV = false;
fprintf(out, 'P_# of localizations per ROI =\n');
fprintf(out, fmt, P_n_local);
fprintf(out, '\n');

% Density of localizations per ROI.      
P_den_local = ...
SC.plotCombined(arrayfun(@(i) rdata{i}.collected.n_points/A_ROI*1000^2, ...
                              1 : n_files, 'UniformOutput', false),     ...
                [], 'density of localizations per ROI (\mu m^{-2})',    ...
                econd, 'den_local_ROI');
fprintf(out, 'P_density of localizations per ROI =\n');
fprintf(out, fmt, P_den_local);
fprintf(out, '\n');

% Number of points per cluster.
P_npts_per_clust = ...
SC.plotCombined(arrayfun(@(i) rdata{i}.collected.n_pts, 1 : n_files, ...
                         'UniformOutput', false),                    ...
                1, 'localizations per cluster', econd, 'npts_per_clust');
fprintf(out, 'P_n points per cluster =\n');
fprintf(out, fmt, P_npts_per_clust);
fprintf(out, '\n');

% Nearest neighbour center-to-center cluster distances.
P_nn_dists = ...
SC.plotCombined(arrayfun(@(i) rdata{i}.collected.nn_dists, 1 : n_files, ...
                         'UniformOutput', false),                       ...
                [], 'nn c2c cluster distances (nm)', econd, 'nn_dists');
fprintf(out, 'P_nn c2c cluster distances =\n');
fprintf(out, fmt, P_nn_dists);
fprintf(out, '\n');

% Mean nearest neighbor center-to-center cluster distances per ROI.
P_nn_dists_ROI = ...
SC.plotCombined(arrayfun(@(i) rdata{i}.collected.nn_dists_ROI, 1 : n_files, ...
                         'UniformOutput', false),                           ...
                1, 'mean nn c2c cluster distances per ROI (nm)',            ...
                econd, 'nn_dists_ROI');
fprintf(out, 'P_nn mean c2c cluster distances per ROI =\n');
fprintf(out, fmt, P_nn_dists_ROI);
fprintf(out, '\n');

% Cluster sizes (equivalent radii corresponding to the cluster areas).
P_equiv_radii = ...
SC.plotCombined(arrayfun(@(i) rdata{i}.collected.equiv_radii, 1 : n_files, ...
                         'UniformOutput', false),                          ...
                1, 'cluster equiv radii (nm)', econd, 'equiv_radii');
fprintf(out, 'P_cluster equiv radii =\n');
fprintf(out, fmt, P_equiv_radii);
fprintf(out, '\n');

% Nearest neighbor localization distances.
if CSVglobal
   SC.CSV = true;
end
P_nn_loc_dists = ...
SC.plotCombined(arrayfun(@(i) rdata{i}.collected.nn_loc_dists, 1 : n_files, ...
                         'UniformOutput', false),                           ...
                1, 'nn localization distances (nm)', econd, 'nn_local');
SC.CSV = false;
fprintf(out, 'P_nn localization distances =\n');
fprintf(out, fmt, P_nn_loc_dists);
fprintf(out, '\n');

% Nearest neighbor localization distances within clusters.
P_nn_withinC = ...
SC.plotCombined(arrayfun(@(i) rdata{i}.collected.nn_within_clust, 1:n_files, ...
                         'UniformOutput', false),                            ...
                1, 'nn localization distances within clusters (nm)',         ...
                econd, 'nn_withinC');
fprintf(out, 'P_nn localization distances within clusters =\n');
fprintf(out, fmt, P_nn_withinC);
fprintf(out, '\n');

% How to add additional plots using rdata.results:
%
% Clustered fraction per ROI.
clustered_frac = cell(1, n_files);
for j = 1 : n_files
   clustered_frac{j} = [];
   for i = 1 : numel(rdata{j}.results)
      clustered_frac{j} =    ...
         [clustered_frac{j}, ...
          rdata{j}.results{i}.n_clustered / rdata{j}.results{i}.n_points];
   end
end
P_clustered_frac = ...
SC.plotCombined(clustered_frac,                                      ...
                0.05, 'fraction of clustered localizations per ROI', ...
                econd, 'clustered_frac_ROI');
fprintf(out, 'P_clustered fraction per ROI =\n');
fprintf(out, fmt, P_clustered_frac);
fprintf(out, '\n');

% Cluster areas.
areas = cell(1, n_files);
for j = 1 : n_files
   areas{j} = [];
   for i = 1 : numel(rdata{j}.results)
      areas{j} = [areas{j}, rdata{j}.results{i}.areas];
   end
end
P_areas = ...
SC.plotCombined(areas, ...
                5, 'cluster areas (nm^2)', ...
                econd, 'areas');
fprintf(out, 'P_cluster areas =\n');
fprintf(out, fmt, P_areas);
fprintf(out, '\n');

% Cluster areas per ROI.
areas_ROI = cell(1, n_files);
for j = 1 : n_files
   areas_ROI{j} = [];
   for i = 1 : numel(rdata{j}.results)
      areas_ROI{j} = [areas_ROI{j}, mean(rdata{j}.results{i}.areas)];
   end
end
P_areas_ROI = ...
SC.plotCombined(areas_ROI, ...
                5, 'cluster areas per ROI (nm^2)', ...
                econd, 'areas_ROI');
fprintf(out, 'P_cluster areas per ROI =\n');
fprintf(out, fmt, P_areas_ROI);
fprintf(out, '\n');

% Cluster compactness.
compactness = cell(1, n_files);
for j = 1 : n_files
   compactness{j} = [];
   for i = 1 : numel(rdata{j}.results)
      compactness{j} = [compactness{j}, rdata{j}.results{i}.compactness];
   end
end
P_compactness = ...
SC.plotCombined(compactness,                        ...
                0.05, 'cluster compactness', econd, 'compactness');
fprintf(out, 'P_cluster compactness =\n');
fprintf(out, fmt, P_compactness);
fprintf(out, '\n');

% Cluster compactness per ROI.
compactness_ROI = cell(1, n_files);
for j = 1 : n_files
   compactness_ROI{j} = [];
   for i = 1 : numel(rdata{j}.results)
      compactness_ROI{j} = [compactness_ROI{j}, ...
                            mean(rdata{j}.results{i}.compactness)];
   end
end
P_compactness_ROI = ...
SC.plotCombined(compactness_ROI, ...
                0.05, 'cluster compactness per ROI', econd, 'compactness_ROI');
fprintf(out, 'P_cluster compactness per ROI =\n');
fprintf(out, fmt, P_compactness_ROI);
fprintf(out, '\n');

% Number of points per cluster per ROI.
n_pts_ROI = cell(1, n_files);
for j = 1 : n_files
   n_pts_ROI{j} = [];
   for i = 1 : numel(rdata{j}.results)
      n_pts_ROI{j} = [n_pts_ROI{j}, mean(rdata{j}.results{i}.n_pts)];
   end
end
P_npts_per_clust_ROI = ...
SC.plotCombined(n_pts_ROI, 1, 'localizations per cluster per ROI', ...
                econd, 'npts_per_clust_ROI');
fprintf(out, 'P_n points per cluster per ROI =\n');
fprintf(out, fmt, P_npts_per_clust_ROI);
fprintf(out, '\n');

% Cluster sizes (equivalent radii corresponding to the cluster areas) per ROI.
equiv_radii_ROI = cell(1, n_files);
for j = 1 : n_files
   equiv_radii_ROI{j} = [];
   for i = 1 : numel(rdata{j}.results)
      equiv_radii_ROI{j} = [equiv_radii_ROI{j}, ...
                            mean(rdata{j}.results{i}.equiv_radii)];
   end
end
%SC.CSV = true;
P_equiv_radii_ROI = ...
SC.plotCombined(equiv_radii_ROI, 1,                        ...
                'cluster equiv radii per ROI (nm)', econd, ...
                'equiv_radii_ROI');
%SC.CSV = false;
fprintf(out, 'P_cluster equiv radii per ROI =\n');
fprintf(out, fmt, P_equiv_radii_ROI);
fprintf(out, '\n');

% Nearest neighbor localization distances per ROI.
nn_loc_dists_ROI = cell(1, n_files);
for j = 1 : n_files
   nn_loc_dists_ROI{j} = [];
   for i = 1 : numel(rdata{j}.results)
      XY_ROI = rdata{j}.results{i}.XY;
      nn_loc_dists_ROI{j} = [nn_loc_dists_ROI{j}, ...
                             mean(c.nn_distances(XY_ROI))];
   end
end
if CSVglobal
   SC.CSV = true;
end
P_nn_loc_dists_ROI = ...
SC.plotCombined(nn_loc_dists_ROI, 1,                             ...
                'nn localization distances per ROI (nm)', econd, ...
                'nn_local_ROI');
SC.CSV = false;
fprintf(out, 'P_nn localization distances per ROI =\n');
fprintf(out, fmt, P_nn_loc_dists_ROI);
fprintf(out, '\n');

% Nearest neighbor localization distances within clusters per ROI.
nn_within_clust_ROI = cell(1, n_files);
for j = 1 : n_files
   nn_within_clust_ROI{j} = [];
   for i = 1 : numel(rdata{j}.results)
      nn_within_clust_ROI{j} = [nn_within_clust_ROI{j}, ...
                                mean(rdata{j}.results{i}.nn_within_clust)];
   end
end
%SC.CSV = true;
P_nn_withinC_ROI = ...
SC.plotCombined(nn_within_clust_ROI, 1,                                   ...
                'nn localization distances within clusters per ROI (nm)', ...
                econd, 'nn_withinC_ROI');
%SC.CSV = false;
fprintf(out, 'P_nn localization distances within clusters per ROI =\n');
fprintf(out, fmt, P_nn_withinC_ROI);
fprintf(out, '\n');

% Number of clusters vs number of localizations per ROI.
clust_vs_loc_ROI = cell(1, n_files);
for j = 1 : n_files
   clust_vs_loc_ROI{j} = [];
   for i = 1 : numel(rdata{j}.results)
      clust_vs_loc_ROI{j} = [clust_vs_loc_ROI{j}, ...
         rdata{j}.results{i}.nC / rdata{j}.results{i}.n_points];
   end
end
%SC.CSV = true;
P_clust_vs_loc_ROI = ...
SC.plotCombined(clust_vs_loc_ROI, 1,                    ...
                'cluster / localization ratio per ROI', ...
                econd, 'clust_vs_loc_ROI');
%SC.CSV = false;
fprintf(out, 'P_cluster / localization ratio per ROI =\n');
fprintf(out, fmt, P_clust_vs_loc_ROI);
fprintf(out, '\n');

fclose(out);

fprintf('Done %s.\n', base_name);

end

./MATLAB/+smi_cluster/@ClusterInterface/defineBaGoLROIs.m
function defineBaGoLROIs(pathnameR, filesR, pathnameB, filesB, MAPNfile)
% ---------- Possibly, define BaGoL ROIs from previous ROIs and BaGoL results
% Often, ROIs are defined from SR data, then need to be transferred to BaGoL
% (MAPN) processing of that SR data.  The BaGoL coordinates will replace the
% SR coordinates in the original ROI files.  Note that the two sets of files
% provided to this function should be in corresponding order.
%
% INPUTS:
%    pathnameR   path to where the ROI files below are located
%    filesR      _Results_ROIs.mat files to collect ROI info from
%    pathnameB   path to where the BaGoL files below are located
%    filesB      BaGoL files to collect ROI coordinate info from
%    MAPNfile    if false, assume BaGoL_Results_*_Results*.mat files,
%                otherwise if true, assume MAPN_*.mat files
%
% OUTPUTS:
%    Saves pathnameB/Analysis/*_BaGoL_ROIs.mat

% Created by
%    Michael J. Wester (2022)

   n_files = numel(filesR);
   if n_files ~= numel(filesB)
      error('n_filesROIs != n_filesBaGoL!')
   end
   results_dir = fullfile(pathnameB, 'Analysis');
   % Create results_dir if it does not already exist.
   if ~isfolder(results_dir)
      mkdir(results_dir);
   end

   for l = 1 : n_files
      dataR = load(fullfile(pathnameR, filesR{l}));
      dataB = load(fullfile(pathnameB, filesB{l}));
      if MAPNfile
         dataB_MAPN = dataB.MAPN;
      else
         dataB_MAPN = dataB.BGL.MAPN;
      end
      [~, fileB, ~] = fileparts(dataR.ResultsFile);
      short = regexprep(fileB, '.mat$', '');
      ResultsFile = dataR.ResultsFile;
      Pixel2nm = dataR.Pixel2nm;
      XYsize = dataR.XYsize;
      n_ROIs = dataR.n_ROIs;
      RoI = cell(1, n_ROIs);
      for i = 1 : n_ROIs
         ROI = dataR.RoI{i}.ROI;
         RoI{i}.ROI = ROI;
         xmin = ROI(1);   xmax = ROI(2);   ymin = ROI(3);   ymax = ROI(4);
         n_labels = numel(dataR.RoI{1}.X);
         for j = 1 : n_labels
            Xnm = dataB_MAPN.X; % * Pixel2nmGlobal;
%           if RT.GaussIm    % if GaussIm, have DIPimage style coordinates
%              Ynm = XYsize(2) - dataB_MAPN.Y;
%           else
               Ynm = dataB_MAPN.Y;
%           end
            k = xmin <= Xnm & Xnm <= xmax & ymin <= Ynm & Ynm <= ymax;
            fprintf('File %d ROI %d Label %d: %d points\n', l, i, j, sum(k));
            % Check that k includes some points!
            if any(k)
               % Sanity check!
               if min(Ynm(k)) < ymin || max(Ynm(k)) > ymax
                  error('ROI -> BaGoL ROI: ROI = %f %f, min/max Ynm = %f %f',...
                        ROI(3), ROI(4), min(Ynm(k)), max(Ynm(k)));
               end

               RoI{i}.X{j}     = Xnm(k);
               RoI{i}.Y{j}     = Ynm(k);
               RoI{i}.X_STD{j} = dataB_MAPN.X_SE(k);
               RoI{i}.Y_STD{j} = dataB_MAPN.Y_SE(k);
            else
               warning('ROI -> BaGoL ROI: no points!');
               RoI{i}.X{j}     = [];
               RoI{i}.Y{j}     = [];
               RoI{i}.X_STD{j} = [];
               RoI{i}.Y_STD{j} = [];
            end
         end
      end
      save(fullfile(results_dir, [short, '_BaGoL_ROIs.mat']), ...
           'ResultsFile', 'Pixel2nm', 'XYsize', 'n_ROIs', 'RoI');
   end
   if MAPNfile
      txt = 'MAPN ROIs';
   else
      txt = 'ROIs';
   end
   fprintf('Done BaGoL %s: %s.\n', txt, results_dir);

end

./MATLAB/+smi_cluster/@ClusterInterface/genSRMAPNOverlay1.m
function OverlayImageCircle ...
  = genSRMAPNOverlay1(SMD, MAPN, XSize, YSize, PixelSize, ...
                      SaveDir, Xstart, Ystart, RadiusScale, ScaleBarLength)
%genSRMAPNOverlay generates a multicolor overlay containing circles with radii
% proportional to the average localization precision (the generalized mean
% between the X and Y precisions) for each localization from an SMD and a BaGoL
% MAPN structure.  The overlay is saved as a .png file with the identifier
% Overlay_SR_Map_circle.
%
% Additional features to smi.BaGoL.genSRMAPNOVerlay have been added, in
% particular, SMD is magenta and MAPN green, the latter emphasized with a
% series of concentric rings for each localization.
%
% INPUTS:
%    SMD            SMD structure with the following fields (nm):
%                      X, Y, X_SE, Y_SE
%    MAPN           MAPN structure with the following fields (nm):
%                      X, Y, X_SE, Y_SE
%    XSize          x-size of image (nm)
%    YSize          y-size of image (nm)
%    PixelSize      either pixel linear dimension (nm), or string 'rescale'
%                   where an appropriate pixel size will be calculated.
%    SaveDir        directory in which to save the overlay image file
%    XStart:        X starting coordinate of the output image
%    YStart:        Y starting coordinate of the output image
%    RadiusScale    [OPTIONAL, Default = 1] scalar to multiply the localization
%                   precision by
%    ScaleBarLength [OPTIONAL, Default = 500] length of scale bar on generated
%                   image (nm)
%
% OUTPUT:
%    OverlayCircleImage   overlay image with scalebar
%                   If genSRMAPNOverlay is called with no output argument,then
%                   this image will be saved in SaveDir as
%                   Overlay_SR_Map_circle.png

% Created by:
%    Michael J. Wester, Mohamadreza Fazel (2021) and David J. Schodt (Lidke Lab, 2018)

if ~exist('RadiusScale', 'var')
   RadiusScale = 1;
end
if ~exist('ScaleBarLength', 'var')
   ScaleBarLength = 500;
end
if ~exist('Xstart', 'var')
   Xstart = 0;
end
if ~exist('Ystart', 'var')
   Ystart = 0;
end
if ~exist('PixelSize','var') || strcmp(PixelSize,'rescale')
    %If not given, the pixel size will be calculated here based on the
    %smallest precision.
    MinPixelsPerCircle = 16;
    CircleRadius = sqrt((MAPN.X_SE.^2+MAPN.Y_SE.^2) / 2) .* RadiusScale;
    CircleRadius = max(1, CircleRadius);   % Don't let value become too small!
    SmallestCircumference= 2 * pi * min(CircleRadius);
    if SmallestCircumference == 0
       error('Precision cannot be zero'); 
    end
    PixelSize = SmallestCircumference/MinPixelsPerCircle;
end

% Compute parameters needed for the circle images (these are computed for
% the MAPN dataset and then left the same for the SMD).
BitDepth = 8; % specific to the save type: this is for a 8 bit png
ImageSize = ceil([XSize, YSize]/PixelSize);
if ((ImageSize(1)*ImageSize(2)*3) > (2^32 - 1))
    % imwrite() won't work for an image this large so we'll
    % have to settle with something smaller.
    % NOTE: The 3 corresponds to the 3 color channels that will
    %       be in the final overlay image.
    ImageSize = floor(2^16 * [1, 1] / sqrt(3));
    PixelSize = max([XSize,YSize])/ImageSize(1);
end
fprintf('ImageSize = %d x %d\n', ImageSize);

for ii = 1 : 2
   CircleImage = zeros(ImageSize, 'uint8'); % create the 0 image
   if ii == 1
      X = ((SMD.X-Xstart) / PixelSize);
      Y = ((SMD.Y-Ystart) / PixelSize);
      X_SE = (SMD.X_SE / PixelSize);
      Y_SE = (SMD.Y_SE / PixelSize);
      n_rings = 1;   % number of concentric rings
   else
      X = ((MAPN.X-Xstart) / PixelSize);
      Y = ((MAPN.Y-Ystart) / PixelSize);
      X_SE = (MAPN.X_SE / PixelSize);
      Y_SE = (MAPN.Y_SE / PixelSize);
      n_rings = 5;   % number of concentric rings
   end

   % Loop through each localization and construct the circle image.
   for mm = 1:numel(X)
       % Create the binary circle image by creating ~2*circumference
       % points for each circle (the extra points help make the circle
       % appear smooth).
       CircleRadius = sqrt((X_SE(mm)^2 + Y_SE(mm)^2) / 2) * RadiusScale;
       Theta = linspace(0, 2*pi, ceil(4 * pi * CircleRadius));
       for j = 1 : n_rings
           CircleX = CircleRadius*cos(Theta) + X(mm);
           CircleY = CircleRadius*sin(Theta) + Y(mm);
           for nn = 1:numel(Theta)
               % Place the computed points for each circle in the binary image.
               ImageRow = round(CircleY(nn)); % row in the image
               ImageCol = round(CircleX(nn)); % column in the image
               if ((ImageRow<ImageSize(1)) && (ImageRow>1) ...
                       && (ImageCol<ImageSize(2)) && (ImageCol>1))
                   % This point lies within the bounds of the image.
                   CircleImage(ImageRow, ImageCol) = 2^BitDepth - 1;
                   if ii == 2
                       CircleImages(ImageRow, ImageCol,1) = 0;
                   end
               end
           end
           CircleRadius = CircleRadius * 1.05;
       end
   end
   CircleImages(1:ImageSize(1), 1:ImageSize(2), ii) = CircleImage;
end

% Produce a green (G) and magenta (R+B) color overlay for the two
% images, with the first image being green.
% If the input stack wasn't a float, make the output OverlayImage a uint8.
OverlayImageCircle = ...
    zeros([size(CircleImages, 1), size(CircleImages, 2), 3], 'uint8');
% Scale the color channels individually to [0, 1].
%OverlayImageCircle(:, :, 1) = CircleImages(:, :, 2) ...
%    ./ max(max(CircleImages(:, :, 2))); % red
%OverlayImageCircle(:, :, 2) = CircleImages(:, :, 1) ...
%    ./ max(max(CircleImages(:, :, 1))); % green
%OverlayImageCircle(:, :, 3) = CircleImages(:, :, 2) ...
%    ./ max(max(CircleImages(:, :, 2))); % blue
% Produce a magenta and green color overlay with the first image being magenta
OverlayImageCircle(:, :, 1) = CircleImages(:, :, 1) ...
    ./ max(max(CircleImages(:, :, 1))); % red
OverlayImageCircle(:, :, 2) = CircleImages(:, :, 2) ...
    ./ max(max(CircleImages(:, :, 2))); % green
OverlayImageCircle(:, :, 3) = CircleImages(:, :, 1) ...
    ./ max(max(CircleImages(:, :, 1))); % blue
% For non-float images, we need to rescale the pixel values.
if ~isfloat(OverlayImageCircle)
    OverlayImageCircle = OverlayImageCircle * 255;
end

OverlayImageCircleName = sprintf('Overlay_SR_Map_circle.png');
% Add in a scalebar accounting for the size
% AdjustedScaleBarLength = ScaleBarLength * ImageSize(1) / XSize;
OverlayImageCircle = ...
   smi.BaGoL.scalebar(OverlayImageCircle, PixelSize, ScaleBarLength);
if nargout == 0
   imwrite(OverlayImageCircle, jet, fullfile(SaveDir, OverlayImageCircleName));
end

end

./MATLAB/+smi_cluster/@ClusterInterface/defineROIs.m
function defineROIs(pathname, files, Pixel2nm, RT, oneROI)
% ----------- Define the ROIs
% Choose ROIs of a fixed size over a series of images.  These are typically
% used for cluster analysis.
%
% INPUTS:
%    pathname          path to where the files are located
%    files             cell array of _Results*.mat file names containing
%                      coordinate data
%    Pixel2nm          conversion factor from pixels to nm
%    RT                class reference to smi_helpers.ROITools()
%    oneROI            treat the whole image as a single ROI (logical)
%
% OUTPUTS:
%    pathname/Analysis/*_ROIs.mat is saved containing the coordinates of the
%    ROIs selected for each cell image.  This selection process is performed
%    for each file name (cell image) provided, so the *_ROIs.mat files will be
%    identified by the names of the files containing the original (x, y)
%    coordinates.

% Created by
%    Michael J. Wester (2022)

   results_dir = fullfile(pathname, 'Analysis');
   % Create results_dir if it does not already exist.
   if ~isfolder(results_dir)
      mkdir(results_dir);
   end

   % Define the ROIs for each image.
   n_files = numel(files);
   for j = 1 : n_files
      short = regexprep(files{j}, '.mat$', '');
      ResultsFile = fullfile(pathname, files{j});
      fprintf('%s ...\n', short);
      if oneROI
         [XY, XY_STD, XYsize] = ...
            RT.import_XY(ResultsFile, Pixel2nm, '');
         n_ROIs = 1;
         RoI{1}.ROI = [0, ROI_sizes(1), 0, ROI_sizes(2)];
         RoI{1}.X = {XY(:, 1)};
         RoI{1}.Y = {XY(:, 2)};
         RoI{1}.X_STD = {XY_STD(:, 1)};
         RoI{1}.Y_STD = {XY_STD(:, 2)};
      else
         [n_ROIs, RoI, XYsize] = ...
            RT.getROI(ResultsFile, files{j});
         saveas(gcf, fullfile(results_dir, sprintf('%s_ROIs.fig', short)));
         saveas(gcf, fullfile(results_dir, sprintf('%s_ROIs.png', short)));
      end
      save(fullfile(results_dir, [short, '_ROIs.mat']), ...
           'ResultsFile', 'Pixel2nm', 'XYsize', 'n_ROIs', 'RoI');
      close
      fid = fopen(fullfile(results_dir, [short, '_ROIs.txt']), 'w');
      for i = 1 : n_ROIs
         fprintf(fid, '%d %7.3f %7.3f %7.3f %7.3f\n', ...
                      i, RoI{i}.ROI ./ Pixel2nm);
      end
      fclose(fid);
   end
   fprintf('Done ROIs.\n');

end

./MATLAB/+smi_cluster/@ClusterInterface/filterROIs.m
function [n_ROIs, RoI] = filterROIs(pathname, files, filter)
% ---------- Possibly, filter some ROIs out
% Filter out ROIs that meet certain criteria on their contents.
%
% INPUTS:
%    pathname          path to where the files are located
%    files             _ROIs.mat files to collect ROI info from
%    filter            structure that contains allowable limits
%       minLocROI      minimum number of localizations allowed in a ROI
%       maxLocROI      maximum number of localizations allowed in a ROI
%
% OUTPUTS:
%    _filtered_ROIs.mat files containing updated n_ROIs and RoI structure

   n_files = numel(files);
   for i = 1 : n_files
      data = load(fullfile(pathname, files{i}));
      toDelete = [];
      for j = 1 : data.n_ROIs
         n_locs = numel(data.RoI{j}.X{1});
         % Collect ROIs to delete.
         if (isfield(filter, 'minLocROI') && n_locs < filter.minLocROI) || ...
            (isfield(filter, 'maxLocROI') && n_locs > filter.maxLocROI)
            toDelete = [toDelete, j];
         end
      end
      if ~isempty(toDelete)
         fprintf('Deleting ROIs');
         for k = 1 : numel(toDelete)
            fprintf(' %d', toDelete(k));
         end
         fprintf(' from %s\n', files{i});
      end
      % Delete ROIs that exceeded the limits in filter.
      n_ROIs = data.n_ROIs - numel(toDelete);
      RoI = data.RoI;
      RoI(toDelete) = [];
      % Generate a filtered _ROIs.mat file.
      filename = files{i};
      filename = regexprep(filename, '_ROI', '_filtered_ROI');
      ResultsFile = data.ResultsFile;
      Pixel2nm    = data.Pixel2nm;
      XYsize      = data.XYsize;
      save(fullfile(pathname, filename), ...
           'ResultsFile', 'Pixel2nm', 'XYsize', 'n_ROIs', 'RoI');
   end

   fprintf('Done filtering ROIs.\n');

end

./MATLAB/+smi_cluster/@ClusterInterface/singleCondition.m
function singleCondition(pathname, files, algorithm_range, E_range, ...
                         minPts_range, Pixel2nm, base_name, A_ROI,  ...
                         doHopkins, doSigmaActual)
% ---------- Statistics for a single condition
% Perform cluster analysis for comparison of experimental conditions.  This is
% useful for performing parameter studies, especially over a range of E's
% (epsilons) and minPts' (N's).
%
% INPUTS:
%    pathname          path to where the files are located
%    files             _ROIs.mat files to collect ROI info from
%    algorithm_range   clustering algorithms to try (cell array of strings):
%                          {'DBSCAN', 'Hierarchical', 'Voronoi'}
%    E_range           minimum distances between clusters or maximum distance
%                      between points in a cluster (nm)
%    minPts_range      minimum numbers of points in a cluster
%    Pixel2nm          conversion factor from pixels to nm
%    base_name         analysis identification string
%    A_ROI             ROI area (nm^2)
%    doHopkins         [DEFAULT = true] Hopkins' test can be time consuming for
%                      dense ROIs
%    doSigmaActual     [DEFAULT = true] set to false for very dense ROIs to
%                      avoid crashes due to lack of memory
%
% OUTPUTS:
%    A variety of plots are produced and are placed in a subdirectory of
%    pathname, identified by the algorithm, minPts and E value used for
%    clustering, e.g., DBSCAN_N=3,E=30.  Plots are produced for each ROI of
%    the localizations and clusters detected [boundary colors are random]
%    (*_ROI#?_clusters), and a plot comparing the nearest neighbor histogram
%    of the localizations with a random distribution (_ROI#?_NN_loc_PDF).  A
%    variety of statistics are also computed and plotted (with prefix ALL_)
%    over the condition, and a .mat file is saved with a name like
%       base_nam#algorithm_N=*,E=*_results.mat
%    which is just the naming convention needed for comparing results of
%    multiple conditions by combinedStatistics1/2).

% Created by
%    Michael J. Wester (2022)

   if ~exist('doHopkins', 'var')
      doHopkins = true;
   end
   if ~exist('doSigmaActual', 'var')
      doSigmaActual = true;
   end

   c  = smi_cluster.Clustering();
   SC = smi_cluster.StatisticsClustering();
   PC = smi_cluster.PairCorrelation();

   base_name_save = base_name;
   if ~startsWith(base_name, 'ALL')
      base_name = ['ALL_', base_name];
   end
   SC.BaseName = base_name;
   PC.BaseName = base_name;

   % Set to false for very dense ROIs to avoid crashes due to lack of memory.
   c.DoSigmaActual = doSigmaActual;
   %c.Alpha = 800;   c.Plotting = true;

   LoS = 0.01;   % level of significance for H-SET
   c.LoS = LoS;
   User_Sigma_Reg = [10, 10];   % specified image registration error for H-SET

   % Cluster boundary is halfway between a convex hull and fully concave.
   shrinkFactor = 0.5;
   c.ShrinkFactor = shrinkFactor;

   for E = E_range
   for minPts = minPts_range
   for alg = algorithm_range
   algorithm = alg{1};

   % Make a subdirectory for this particular analysis.
   switch algorithm
   case 'Voronoi'
      Run = sprintf('%s_N=%d,Alpha=%0.1g', algorithm, minPts, c.Alpha);
   case 'H-SET'
      %Run = sprintf('%s_N=%d,LoS=%0.2f', algorithm, minPts, c.LoS);
      Run = sprintf('%s_N=%d,LoS=%g,SReg=%d', ...
                    algorithm, minPts, c.LoS, User_Sigma_Reg(1));
   otherwise
      Run = sprintf('%s_N=%d,E=%d', algorithm, minPts, E);
   end
   Aresults_dir = fullfile(pathname, Run);
   % Create Aresults_dir if it does not already exist.
   if ~isfolder(Aresults_dir)
      mkdir(Aresults_dir);
   end

   n_files = numel(files);
   if n_files == 0
      error('No files to analyze in %s!', pathname);
   end

   c.ResultsDir  = Aresults_dir;
   SC.ResultsDir = Aresults_dir;
   PC.ResultsDir = Aresults_dir;

   % Pair/auto-correlation properties.
   PC.Fig_ext = 'png';   % figure extension
   PC.Rmax_axis = 500;   % Sets plotting limit if > 0
   % Histogram bin size for pairwise correlation---this is the number of pixels
   % per bin over which correlation statistics are collected.
   PC.HistBinSize = 5;
   PC.Verbose = 0;       % verbose output and extra saved .mat files

   % Cluster all ROIs in all images, then collect statistics.
   n_ROIs = [];
   RoI = {};
   nC = 0;
   n_clusts = [];
   c_density = [];
   n_points = [];
   n_pts = [];
   compactness = [];
   nn_dists = [];
   nn_dists_ROI = [];
   equiv_radii = [];
   nn_loc_dists = [];
   nn_within_clust = [];
   clear results ROIs

   n = 0;   % count the total number of ROIs
   for j = 1 : n_files
      data = load(fullfile(pathname, files{j}));
      short = regexprep(files{j}, '_ROIs.mat$', '');
      n_ROIs = [n_ROIs, data.n_ROIs];
      RoI{j} = data.RoI;
      for i = 1 : data.n_ROIs
         nPts = numel(data.RoI{i}.X{1});
         % Skip completely empty ROIs!
         if nPts == 0
            continue;
         end
         n = n + 1;
         XY_ROI = [data.RoI{i}.X{1}, data.RoI{i}.Y{1}];
         %ROIs{n}.XY1 = XY_ROI;
         ROIs{n}.X = { data.RoI{i}.X{1} };
         ROIs{n}.Y = { data.RoI{i}.Y{1} };
         ROIs{n}.ROI = data.RoI{i}.ROI;
         fprintf('%s file %d ROI %d number of points = %d\n', Run, j, i, nPts);

         if strcmp(algorithm, 'H-SET')
            SMR = {};
            SMR.X = data.RoI{i}.X{1} ./ Pixel2nm;
            SMR.Y = data.RoI{i}.Y{1} ./ Pixel2nm;
            SMR.X_SE = data.RoI{i}.X_STD{1} ./ Pixel2nm;
            SMR.Y_SE = data.RoI{i}.Y_STD{1} ./ Pixel2nm;
            if exist('User_Sigma_Reg', 'var') && ~isempty('User_Sigma_Reg')
               SMR.Sigma_Reg = User_Sigma_Reg;
            else
               SMR.Sigma_Reg = data.Sigma_Reg;
            end
            [nC, C, centers, ptsI] = ...
               c.cluster(algorithm, XY_ROI, E, minPts, SMR);
         else
            [nC, C, centers, ptsI] = ...
               c.cluster(algorithm, XY_ROI, E, minPts);
         end
         fprintf('%s file %d ROI %d number of clusters = %d\n', Run, j, i, nC);
         results{n} = c.clusterStats(XY_ROI, C, centers);

         nC = nC + results{n}.nC;
         n_clusts     = [n_clusts,     results{n}.nC];
         c_density    = [c_density,    results{n}.nC / A_ROI];
         n_points     = [n_points,     results{n}.n_points];
         n_pts        = [n_pts,        results{n}.n_pts];
         compactness  = [compactness,  results{n}.compactness];
         nn_dists     = [nn_dists,     results{n}.min_c2c_dists];
         nn_dists_ROI = [nn_dists_ROI, mean(results{n}.min_c2c_dists)];
         equiv_radii  = [equiv_radii,  results{n}.equiv_radii];
         nn_loc_dists = [nn_loc_dists, c.nn_distances(XY_ROI)];
         nn_within_clust = [nn_within_clust, results{n}.nn_within_clust];

         clusterFig = c.plotClusters(XY_ROI, C, centers, ptsI, algorithm);
%        showm(clusterFig);   % comment out if not displaying to the screen
         filename = fullfile(Aresults_dir, ...
                             sprintf('%s_ROI#%d_clusters', short, i));
         saveas(clusterFig, filename, 'fig');
         %saveas(clusterFig, filename, 'png');
         try
            print(clusterFig, '-r300', filename, '-dpng');
         catch ME
            fprintf('### PROBLEM with %s ###\n', filename);
            fprintf('%s\n', ME.identifier);
            fprintf('%s\n', ME.message); 
         end

         if strcmp(algorithm, 'H-SET')
            XY_SE_ROI = [data.RoI{i}.X_STD{1}, data.RoI{i}.Y_STD{1}];
            clusterFig = c.plotClustersSE(XY_ROI, XY_SE_ROI, C, centers, ...
                                          ptsI, algorithm);
%           showm(clusterFig);   % comment out if not displaying to the screen
            filename = fullfile(Aresults_dir, ...
                                sprintf('%s_ROI#%d_SEclusters', short, i));
            %saveas(clusterFig, filename, 'fig');
            %saveas(clusterFig, filename, 'png');
            if nPts < 25000
               try
                  print(clusterFig, '-r600', filename, '-dpng');
               catch ME
                  fprintf('### clusterFig PROBLEM with %s ###\n', filename);
                  fprintf('%s\n', ME.identifier);
                  fprintf('%s\n', ME.message); 
               end
            end
         end

         c.nn_ROIrandom(XY_ROI, A_ROI, ...
                        sprintf('%s_ROI#%d localizations', short, i));
         filename = fullfile(Aresults_dir, ...
                             sprintf('%s_ROI#%d_NN_loc_PDF', short, i));
         try
            print(gcf, '-r300', filename, '-dpng');
         catch ME
            fprintf('### nn_ROIrandom PROBLEM with %s ###\n', filename);
            fprintf('%s\n', ME.identifier);
            fprintf('%s\n', ME.message); 
         end

         close
      end % i
   end % j

   collected.A_ROI = A_ROI;
   collected.nC = nC;
   collected.n_clusts = n_clusts;
   collected.c_density = c_density;
   collected.n_points = n_points;
   collected.n_pts = n_pts;
   collected.nn_dists = nn_dists;
   collected.nn_dists_ROI = nn_dists_ROI;
   collected.equiv_radii = equiv_radii;
   collected.nn_loc_dists = nn_loc_dists;
   collected.nn_within_clust = nn_within_clust;

   % Hopkins' statistic per ROI.
   if doHopkins
      H_ROI = SC.hopkins_ROIcombined(n, ROIs);
      collected.H_ROI = H_ROI;
   end

   % Save statistical results in case they are needed later.
%  save(fullfile(Aresults_dir, [base_name, '_results.mat']), ...
%       'files', 'n_ROIs', 'RoI', 'Pixel2nm', 'results', 'collected');
   save(fullfile(Aresults_dir, [base_name_save, '#', Run, '_results.mat']), ...
        'files', 'n_ROIs', 'RoI', 'Pixel2nm', 'results', 'collected');

   % Make various plots:
   %    'f'   frequency
   %    'n'   normalized
   %    'p'   PDF
   %    'c'   CDF
   %    'C'   CDF (alternative)
   %    's'   PlotSpread
   %    'S'   PlotSpread (bars for mean & median)
   %    'x'   box
   %    'b'   bar
   SC.PlotDo = 'pCSx';
   % Red mean, green median (2 only mean, 3 only median) for PlotSpread plots.
   %SC.ShowMM = 1;
   % Options for CDF2 plots are: 'plot', 'semilogx', 'semilogy', 'loglog'.
   %SC.LinLog = 'semilogx';

   econd = {};

   % Number of clusters per ROI.
   SC.plotCombined({n_clusts}, 1, '# of clusters per ROI', econd, ...
                  '_n_clusts_ROI');

   % Density of clusters per ROI.
   SC.plotCombined({c_density}, 1/(A_ROI/1000^2),                     ...
                   'density of clusters per ROI (\mu m^{-2})', econd, ...
                   '_c_density_ROI');

   % Number of localizations per ROI.
   SC.plotCombined({n_points}, [], '# of localizations per ROI', econd, ...
                   '_n_local_ROI');

   % Number of points per cluster.
   SC.plotCombined({n_pts}, 1, 'localizations per cluster', econd, ...
                   '_npts_per_clust');

   % Cluster compactness.
   SC.plotCombined({compactness}, 1, 'cluster compactness', econd, ...
                   '_compactness');

   % Nearest neighbour center-to-center cluster distances.
   SC.plotCombined({nn_dists}, [], 'nn c2c cluster distances (nm)', econd, ...
                   '_nn_dists');

   % Cluster sizes (equivalent radii corresponding to the cluster areas).
   SC.plotCombined({equiv_radii}, 1, 'cluster equiv radii (nm)', econd, ...
                   '_equiv_radii');

   % Nearest neighbor localization distances.
   SC.plotCombined({nn_loc_dists}, 1, 'nn localization distances (nm)', ...
                   econd, '_nn_local');

   % Nearest neighbor localization distances within clusters.
   SC.plotCombined({nn_within_clust}, 1,                             ...
                   'nn localization distances within clusters (nm)', ...
                   econd, '_nn_withinC');

   % Auto-correlation
   fprintf('ROI combined\n\n');
   txt = sprintf('%s_RC', base_name);
   resultsRC_pcc = PC.pair_correlation_ROIcombined(1, n, ROIs, 1);

   end % alg
   end % minPts
   end % E

   clear User_Sigma_Reg

   fprintf('Done %s_%s.\n', base_name, Run);

end

./MATLAB/+smi_cluster/@ClusterInterface/plotROI.m
function plotROI(opt, pathnameC, filesC, pathnameB, filesB, PixelSize, SaveDir)
% Plot dot, Gaussian or circle images of SMD/MAPN coordinates per ROI per cell.
%
% INPUTS:
%    opt         data characteristics and types of plots to produce if true
%       SR          SR Results file
%       BaGoL       BaGoL Results file (BGL.SMD)
%       MAPN        BaGoL Results file (BGL.MAPN)
%       Dot         Dot plot
%       Gaussian    Gaussian plot
%       Circle      Circle plot (BaGoL Results file: BGL.SMD + BGL.MAPN)
%       Boundary    Include ROI boundaries
%       Cluster     Include ROI clusters
%    pathnameC   path to filesC
%    filesC      cluster data per ROI per cell for a single condition; this
%                will be a single *_results.mat file
%    pathnameB   path to filesB
%    filesB      Results files (SR or BaGoL) defining SMD-like structures,
%                typically representing several cell images collected under a
%                single experimental condition and clustered together
%    PixelSize   conversion factor from pixels to nm
%    SaveDir     directory to which the plots produced are saved
%
% OUTPUTS:
%    The various plots opted for in the input will be produced for each ROI in
%    each fileB.

% Created by
%    Michael J. Wester (2022)

   % If zero, ROIs in simpleROIcluster were chosen using plotted points, but
   % if > 0, ROIs were chosen using GaussianIm = true so following the DIPimage
   % convention---the value should then be YSize * PixelSize.
   % Changes (9/20/21) in simpleROIcluster seem to have made this fix obsolete,
   % but will retain the code for new just in case they are needed once again.
   % Certainly useful when plotting boundaries/clusters on top of images.
   GaussianImageKludge = 256*PixelSize;
   % Boundary shrink factor (0 = convex hull, 1 = as concave as possible,
   % 0.5 = MATLAB default)
   ShrinkFactor = 0.5;

   CI = smi_cluster.ClusterInterface();

   dataC = load(fullfile(pathnameC, filesC{1}));
   for i = 1 : numel(filesB)
      fileB = filesB{i};
      dataB = load(fullfile(pathnameB, fileB));
      if opt.SR
         SMD = dataB.SMD;
      end
      % Remove extraneous material from the filenames.
      short = regexprep(fileB, '.mat$', '');
      short = regexprep(short, '_ResultsStruct$', '');
      short = regexprep(short, '_Results$', '');
      short = regexprep(short, '^BaGoL_Results_', '');
      shrt  = regexprep(short, '_', '\\_');

      % Display a quick summary of the upcoming analysis.
      if opt.SR
         fprintf('%s: SMD = %d\n', short, numel(SMD.X));
      elseif opt.BaGoL || opt.MAPN || opt.Circle
         BGL = dataB.BGL;
         fprintf('%s: SMD = %d, MAPN = %d\n', ...
                 short, numel(BGL.SMD.X), numel(BGL.MAPN.X));
      end

      % Plot ROIs individually.
      if opt.SR
         SMDsave = SMD;
      elseif opt.BaGoL
         SMDsave = BGL.SMD;
      elseif opt.MAPN
         SMDsave = BGL.MAPN;
      elseif opt.Circle
         SMDsave  = BGL.SMD;
         MAPNsave = BGL.MAPN;
      end
      j_ROI = sum(dataC.n_ROIs(1 : i - 1));
      for j = 1 : dataC.n_ROIs(i)
         j_ROI = j_ROI + 1;
         ROI = dataC.RoI{i}{j}.ROI;
         SMD = SMDsave;

         if opt.Boundary
            xExtra = 0.1 * (ROI(2) - ROI(1));
            yExtra = 0.1 * (ROI(4) - ROI(3));
         else
            xExtra = 0;
            yExtra = 0;
         end

         if opt.Dot
            plot(SMD.X, SMD.Y, 'k.');
            hold on
         elseif opt.Gaussian
            % Gaussian image plot of SR localizations.
            BGL.PixelSize = 1;
            %if GaussianImageKludge > 0
            %   BGL.MAPN.Y = GaussianImageKludge - BGL.MAPN.Y;
            %end
            GIK = GaussianImageKludge;
            indx = ROI(1) - xExtra <= SMD.X & SMD.X <= ROI(2) + yExtra & ...
                   ROI(3) - yExtra <= GIK - SMD.Y &                      ...
                   GIK - SMD.Y <= ROI(4) + yExtra;
            SMD.X = SMD.X(indx);
            SMD.Y = SMD.Y(indx);
            SMD.X_SE = SMD.X_SE(indx);
            SMD.Y_SE = SMD.Y_SE(indx);
            if opt.BaGoL
               BGL.SMD = SMD;
               MapIm = CI.genMAPNIm1(BGL, 2);
            elseif opt.MAPN
               BGL.MAPN = SMD;
               MapIm = CI.genMAPNIm1(BGL, 1);
            end
            MapIm = BGL.scaleIm(MapIm, 98);
         end

         % Gaussian image plot of SR localizations.
         ScaleBarLength = 100;  % nm
         ScaleBarWidth  = 25;   % nm
         if opt.Gaussian
            % Add in a scale bar (lower right).
            Xoffset = 100;
            Yoffset = 100;
            Xstart = ROI(2) - Xoffset - ScaleBarLength;
            Ystart = GaussianImageKludge - (ROI(3) + Yoffset + ScaleBarWidth);
            X = round(Xstart) : round(Xstart + ScaleBarLength);
            Y = round(Ystart) : round(Ystart + ScaleBarWidth);
            MapIm(Y, X) = 255;

            imshow(MapIm, hot);
            hold on
         elseif opt.Circle
            BGL.PixelSize = 1;
            SMD = SMDsave;
            GIK = GaussianImageKludge;
            indx = ROI(1) <= SMD.X & SMD.X <= ROI(2) & ...
                   ROI(3) <= GIK - SMD.Y & GIK - SMD.Y <= ROI(4);
            SMD.X = SMD.X(indx) - ROI(1);
            SMD.Y = SMD.Y(indx) - (GIK - ROI(4));
            SMD.X_SE = SMD.X_SE(indx);
            SMD.Y_SE = SMD.Y_SE(indx);
            BGL.SMD = SMD;

            MAPN = MAPNsave;
            GIK = GaussianImageKludge;
            indx = ROI(1) <= MAPN.X & MAPN.X <= ROI(2) & ...
                   ROI(3) <= GIK - MAPN.Y & GIK - MAPN.Y <= ROI(4);
            MAPN.X = MAPN.X(indx) - ROI(1);
            MAPN.Y = MAPN.Y(indx) - (GIK - ROI(4));
            MAPN.X_SE = MAPN.X_SE(indx);
            MAPN.Y_SE = MAPN.Y_SE(indx);
            BGL.MAPN = MAPN;

            ROISize = ROI(2) - ROI(1);
            MapIm = CI.genSRMAPNOverlay1(BGL.SMD, BGL.MAPN, ROISize,      ...
                                         ROISize, 1, SaveDir, BGL.XStart, ...
                                         BGL.YStart, 1, ScaleBarLength);

            % Gaussian image plot of SR (green) + MAPN (magenta) localizations.
            imshow(MapIm, hot);
            hold on
         end

         % Plot ROI boundaries.
         if opt.Boundary
            if opt.Circle
               y = [ROI(1), ROI(2), ROI(2), ROI(1), ROI(1)];
               x = [ROI(3), ROI(3), ROI(4), ROI(4), ROI(3)];
               %if GaussianImageKludge > 0
               %   y = GaussianImageKludge - y;
               %end
            else
               x = [ROI(1), ROI(2), ROI(2), ROI(1), ROI(1)];
               y = [ROI(3), ROI(3), ROI(4), ROI(4), ROI(3)];
               if GaussianImageKludge > 0
                  y = GaussianImageKludge - y;
               end
            end
            plot(x, y, 'g-', 'LineWidth', 2);
         end

         if  yExtra > 0
            % Add a label designating the ROI number.
            x_label = (ROI(1) + ROI(2))/2;
            y_label = ROI(4) + yExtra/2;
            if GaussianImageKludge > 0
               y_label = GaussianImageKludge - y_label;
            end
            text(x_label, y_label, sprintf('%d', j), 'Color', 'green');
         end

         if opt.Cluster
            % Plot cluster boundaries.
            results = dataC.results{j_ROI};
            for l = 1 : results.nC
               x = results.XY(:, 1);
               y = results.XY(:, 2);
               if GaussianImageKludge > 0
                  y = GaussianImageKludge - y;
               end
               C = results.C;
               if numel(C{l}) <= 2
                  plot(x(C{l}), y(C{l}), 'm.-', 'LineWidth', 2, ...
                       'MarkerSize', 12);
               else
                  % Determine cluster boundary indices from the cluster
                  % contents.
                  k = boundary(double(x(C{l})), double(y(C{l})), ShrinkFactor);
                  k = C{l}(k);
                  k = [k, k(1)];
                  plot(x(k), y(k), 'm.-', 'LineWidth', 2, 'MarkerSize', 12);
               end
            end % for l (cluster #)
         end % if opt.Cluster

         % Circle plots already are the full ROI.
         if ~opt.Circle
            xlim([ROI(1) - xExtra, ROI(2) + xExtra]); 
            ylim([ROI(3) - yExtra, ROI(4) + yExtra]); 
            if GaussianImageKludge
               ylim([GaussianImageKludge - ROI(4) - yExtra, ...
                     GaussianImageKludge - ROI(3) + yExtra]); 
            end
         end

         title(sprintf('%s ROI %d', shrt, j));
         axis off
         hold off

         if opt.SR
            in_type = 'SR';
         elseif opt.BaGoL
            in_type = 'BaGoLSR';
         elseif opt.MAPN
            in_type = 'MAPN';
         elseif opt.Circle
            in_type = 'SR+MAPN';
         end

         if opt.Dot
            out_type = 'dot';
         elseif opt.Gaussian
            out_type = 'Gaussian';
         elseif opt.Circle
            out_type = 'circle';
         end

         SaveFile = fullfile(SaveDir, sprintf('%s_ROI%d_%s_%s', ...
                                              short, j, in_type, out_type));

         % Use imwrite rather than print for good resolution, but only for the
         % basic bitmap image.
         if (opt.Gaussian || opt.Circle) && ~opt.Boundary && ~opt.Cluster
            imwrite(MapIm, [SaveFile, '.png']);
         else
            print(gcf, SaveFile, '-dpng', '-r600');
         end
         if opt.Dot
            saveas(gcf, SaveFile, 'fig');
         end
         close
      end % for j (ROI #)
      close all
   end % for i (file #)

end

./MATLAB/+smi_cluster/@ClusterInterface/README.md
### +smi_cluster/@ClusterInterface

A collection of functions that interface with the main smi.Clustering routines.
These are used in the MATLAB/examples simpleROIcluster.m, which performs a
series of steps (one per section, mostly optional) to analyze SR files produced
by smi.SMLM by computing clusters and various statistics.

---

methods:
- **[combineBaGoLROIs](combineBaGoLROIs.m)**:
  This function will combine multiple BaGoL processed ROIs from multiple
  (biological) cells into appropriately named combined \_ROIs.mat files
- **[combineResults](combineResults.m)**:
  Multiple instantiations of a single condition potentially located in multiple
  directories are collected into a combined instance in a specified directory.
- **[combinedStatistics1](combinedStatistics1.m)**:
  For multiple conditions, experimental (e.g., resting vs. activated) and/or
  analytical (e.g., various DBSCAN parameter combinations), produce plots
  that compare the results for a variety of studies (e.g., Hopkins' statistic,
  number of clusters per ROI, circular equivalent cluster radii, etc.)
- **[combinedStatistics2](combinedStatistics2.m)**:
  This routine is very similar to combinedStatistics1, but allows the user to
  have fine control over line colors and types.
- **[defineBaGoLROIs](defineBaGoLROIs.m)**:
  Often, ROIs are defined from SR data, then need to be transferred to BaGoL
  (MAPN) processing of that SR data.  The BaGoL coordinates will replace the
  SR coordinates in the original ROI files.
- **[defineROIs](defineROIs.m)**:
  Choose ROIs of a fixed size over a series of images.  These are typically
  used for cluster analysis
- **[filterROIs](filterROIs.m)**:
  Filter out ROIs that meet certain criteria on their contents
- **[genMAPNIm1](genMAPNIm1.m)**:
  Produces a Gaussian blob image from either SMD or MAPN
- **[genSRMAPNOverlay1](genSRMAPNOverlay1.m)**:
  generates a multicolor overlay containing circles with radii proportional to
  the average localization precision (the generalized mean between the X and Y
  precisions) for each localization from an SMD and a BaGoL MAPN structure.
  Additional features to smi.BaGoL.genSRMAPNOVerlay have been added, in
  particular, SMD is magenta and MAPN green, the latter emphasized with a
  series of concentric rings for each localization
- **[plotROI](plotROI.m)**:
  Plot dot, Gaussian or circle images of SMD/MAPN coordinates per ROI per cell
- **[singleCondition](singleCondition.m)**:
  Perform cluster analysis for comparison of experimental conditions

./MATLAB/+smi_cluster/@ClusterInterface/combinedStatistics2.m
function combinedStatistics2(SC, colors, line_type, pathname, files, ...
                             base_name, A_ROI, doHopkins)
% ---------- Combined statistics for multiple conditions and experiments
% For multiple conditions, experimental (e.g., resting vs. activated) and/or
% analytical (e.g., various DBSCAN parameter combinations), produce plots
% that compare the results for a variety of studies (e.g., Hopkins' statistic,
% number of clusters per ROI, circular equivalent cluster radii, etc.).
%
% This routine is very similar to combinedStatistics1, but allows the user to
% have fine control over line colors and types.
%
% INPUTS:
%    SC          smi_cluster.StatisticsClustering object setting values for
%                properties PlotDo, ShowMM, LinLog, Ylim
%
%                SC = smi_cluster.StatisticsClustering();
%                % Make various plots:
%                %    'f'   frequency
%                %    'n'   normalized
%                %    'p'   PDF
%                %    'c'   CDF
%                %    'C'   CDF (alternative)
%                %    's'   PlotSpread
%                %    'S'   PlotSpread (bars for mean & median)
%                %    'x'   box
%                %    'b'   bar
%                SC.PlotDo = 'CSx';
%                % Red mean, green median (2 only mean, 3 only median)
%                % for PlotSpread plots.
%                SC.ShowMM = 1;
%                % Options for CDF2 plots are:
%                %    'plot', 'semilogx', 'semilogy', 'loglog'.
%                SC.LinLog = 'semilogx';
%                SC.Ylim = [0.01, 1];
%
%                NOTE: SC.CSV is turned on and off internally to produce comma
%                separated values files for some plots.
%
%    colors      character array of line colors to be applied to each
%                condition: e.g., colors = ['b', 'r']
%    line_type   cell array of line types to be applied to each condition,
%                e.g., line_type = {'-', '--'}
%    pathname    path to where the single condition results are located
%    files       _results.mat files to collect info from
%    base_name   analysis identification string
%    A_ROI       ROI area (nm^2)
%    doHopkins   [DEFAULT = true] Hopkins' test can be time consuming for dense
%                ROIs
% OUTPUTS:
%    A variety of plots are produced via SC.plotCombined and are placed in a
%    subdirectory of pathname.  The subdirectory's name is derived from the
%    the analysisCondition taken from the first input filename (all filenames
%    compared are assumed to have been analyzed similarly), which is assumed
%    to have the form:
%       experimentalConditions#analysisConditions_results.mat
%    where experimentalConditions contains no #.  This function will extract
%    the various experimentalConditions being compared and use them to label
%    the plots created.

% Created by
%    Michael J. Wester (2022)

CSVglobal = false;

c = smi_cluster.Clustering();

n_files = numel(files);

% Make a subdirectory for this particular analysis.  The filenames are assumed
% to have the structure:
%    experimentalConditions#analysisConditions_results.mat
% where experimentalConditions contains no #.
econd = cell(1, n_files);
for i = 1 : n_files
   econd{i} = regexprep(files{i}, '^(.*)#.*_results.mat', '$1');
end
analysis = regexprep(files{1}, '^.*#(.*)_results.mat', '$1');
Cresults_dir = fullfile(pathname, [base_name, '_', analysis]);
SC.ResultsDir = Cresults_dir;
% Create Cresults_dir if it does not already exist.
if ~isfolder(Cresults_dir)
   mkdir(Cresults_dir);
end

SC.BaseName = '';

for j = 1 : n_files
   rdata{j} = load(fullfile(pathname, files{j}));
end

% Create file and format for P-values.
out = fopen(fullfile(Cresults_dir, 'P_values.txt'), 'w');
fmt = '';
for j = 1 : n_files
   fmt = [fmt, ' %.5e'];
end
fmt = [fmt, '\n'];

% Filter out extrema.
for j = 1 : n_files
%  rdata{j}.collected.n_clusts      = ...
%     rdata{j}.collected.n_clusts(rdata{j}.collected.n_clusts         < 400);
%  rdata{j}.collected.c_density     = ...
%     rdata{j}.collected.c_density(rdata{j}.collected.c_density       < 1.6e-5);
%  rdata{j}.collected.n_points      = ...
%     rdata{j}.collected.n_points(rdata{j}.collected.n_points         < 10000);
%  rdata{j}.collected.n_pts         = ...
%     rdata{j}.collected.n_pts(rdata{j}.collected.n_pts               < 600);
%  rdata{j}.collected.nn_dists      = ...
%     rdata{j}.collected.nn_dists(rdata{j}.collected.nn_dists         < 800);
%  rdata{j}.collected.equiv_radii   = ...
%     rdata{j}.collected.equiv_radii(rdata{j}.collected.equiv_radii   < 300);
%  rdata{j}.collected.nn_loc_dists  = ...
%     rdata{j}.collected.nn_loc_dists(rdata{j}.collected.nn_loc_dists < 400);
end

% Hopkins' statistic per ROI.
if doHopkins
   %SC.CSV = true;
   P_hopkins_ROI = ...
   SC.plotCombined(arrayfun(@(i) rdata{i}.collected.H_ROI, 1 : n_files, ...
                            'UniformOutput', false),                    ...
                   0.01, 'Hopkins per ROI', econd, 'hopkins_ROI',       ...
                   colors, line_type);
   %SC.CSV = false;
   fprintf(out, 'P_hopkins per ROI =\n');
   fprintf(out, fmt, P_hopkins_ROI);
   fprintf(out, '\n');
end

% Number of clusters per ROI.
P_n_clusts = ...
SC.plotCombined(arrayfun(@(i) rdata{i}.collected.n_clusts, 1 : n_files, ...
                         'UniformOutput', false),                       ...
                1, '# of clusters per ROI', econd, 'n_clusts_ROI',      ...
                colors, line_type);
fprintf(out, 'P_# of clusters per ROI =\n');
fprintf(out, fmt, P_n_clusts);
fprintf(out, '\n');

% Density of clusters per ROI.
P_c_density = ...
SC.plotCombined(arrayfun(@(i) rdata{i}.collected.c_density*1000^2,  ...
                              1 : n_files, 'UniformOutput', false), ...
                1/(A_ROI/1000^2),                                   ...
                'density of clusters per ROI (\mu m^{-2})',         ...
                econd, 'c_density_ROI', colors, line_type);
fprintf(out, 'P_density of clusters per ROI =\n');
fprintf(out, fmt, P_c_density);
fprintf(out, '\n');

% Number of localizations per ROI.
P_n_local = ...
SC.plotCombined(arrayfun(@(i) rdata{i}.collected.n_points, 1 : n_files, ...
                         'UniformOutput', false),                       ...
                [], '# of localizations per ROI', econd,                ...
                'n_local_ROI', colors, line_type);
fprintf(out, 'P_# of localizations per ROI =\n');
fprintf(out, fmt, P_n_local);
fprintf(out, '\n');

% Density of localizations per ROI.      
P_den_local = ...
SC.plotCombined(arrayfun(@(i) rdata{i}.collected.n_points/A_ROI*1000^2, ...
                              1 : n_files, 'UniformOutput', false),     ...
                [], 'density of localizations per ROI (\mu m^{-2})',    ...
                econd, 'den_local_ROI', colors, line_type);
fprintf(out, 'P_density of localizations per ROI =\n');
fprintf(out, fmt, P_den_local);
fprintf(out, '\n');

% Number of points per cluster.
P_npts_per_clust = ...
SC.plotCombined(arrayfun(@(i) rdata{i}.collected.n_pts, 1 : n_files, ...
                         'UniformOutput', false),                    ...
                1, 'localizations per cluster', econd,               ...
                'npts_per_clust', colors, line_type);
fprintf(out, 'P_n points per cluster =\n');
fprintf(out, fmt, P_npts_per_clust);
fprintf(out, '\n');

% Nearest neighbour center-to-center cluster distances.
P_nn_dists = ...
SC.plotCombined(arrayfun(@(i) rdata{i}.collected.nn_dists, 1 : n_files, ...
                         'UniformOutput', false),                       ...
                [], 'nn c2c cluster distances (nm)', econd,             ...
                'nn_dists', colors, line_type);
fprintf(out, 'P_nn c2c cluster distances =\n');
fprintf(out, fmt, P_nn_dists);
fprintf(out, '\n');

% Mean nearest neighbor center-to-center cluster distances per ROI.
P_nn_dists_ROI = ...
SC.plotCombined(arrayfun(@(i) rdata{i}.collected.nn_dists_ROI, 1 : n_files, ...
                         'UniformOutput', false),                           ...
                1, 'mean nn c2c cluster distances per ROI (nm)',            ...
                econd, 'nn_dists_ROI', colors, line_type);
fprintf(out, 'P_nn mean c2c cluster distances per ROI =\n');
fprintf(out, fmt, P_nn_dists_ROI);
fprintf(out, '\n');

% Cluster sizes (equivalent radii corresponding to the cluster areas).
P_equiv_radii = ...
SC.plotCombined(arrayfun(@(i) rdata{i}.collected.equiv_radii, 1 : n_files, ...
                         'UniformOutput', false),                          ...
                1, 'cluster equiv radii (nm)', econd, 'equiv_radii',       ...
                colors, line_type);
fprintf(out, 'P_cluster equiv radii =\n');
fprintf(out, fmt, P_equiv_radii);
fprintf(out, '\n');

% Nearest neighbor localization distances.
P_nn_loc_dists = ...
SC.plotCombined(arrayfun(@(i) rdata{i}.collected.nn_loc_dists, 1 : n_files, ...
                         'UniformOutput', false),                           ...
                1, 'nn localization distances (nm)', econd,                 ...
                'nn_local', colors, line_type);
fprintf(out, 'P_nn localization distances =\n');
fprintf(out, fmt, P_nn_loc_dists);
fprintf(out, '\n');

% Nearest neighbor localization distances within clusters.
P_nn_withinC = ...
SC.plotCombined(arrayfun(@(i) rdata{i}.collected.nn_within_clust, 1:n_files, ...
                         'UniformOutput', false),                            ...
                1, 'nn localization distances within clusters (nm)',         ...
                econd, 'nn_withinC', colors, line_type);
fprintf(out, 'P_nn localization distances within clusters =\n');
fprintf(out, fmt, P_nn_withinC);
fprintf(out, '\n');

% How to add additional plots using rdata.results:
%
% Clustered fraction per ROI.
clustered_frac = cell(1, n_files);
for j = 1 : n_files
   clustered_frac{j} = [];
   for i = 1 : numel(rdata{j}.results)
      clustered_frac{j} =    ...
         [clustered_frac{j}, ...
          rdata{j}.results{i}.n_clustered / rdata{j}.results{i}.n_points];
   end
end
P_clustered_frac = ...
SC.plotCombined(clustered_frac,                                     ...
                0.05, 'fraction of clustered localizations', econd, ...
                'clustered_frac', colors, line_type);
fprintf(out, 'P_clustered fraction per ROI =\n');
fprintf(out, fmt, P_clustered_frac);
fprintf(out, '\n');

% Cluster areas.
areas = cell(1, n_files);
for j = 1 : n_files
   areas{j} = [];
   for i = 1 : numel(rdata{j}.results)
      areas{j} = [areas{j}, rdata{j}.results{i}.areas];
   end
end
P_areas = ...
SC.plotCombined(areas, ...
                5, 'cluster areas (nm^2)', ...
                econd, 'areas', colors, line_type);
fprintf(out, 'P_cluster areas =\n');
fprintf(out, fmt, P_areas);
fprintf(out, '\n');

% Cluster areas per ROI.
areas_ROI = cell(1, n_files);
for j = 1 : n_files
   areas_ROI{j} = [];
   for i = 1 : numel(rdata{j}.results)
      areas_ROI{j} = [areas_ROI{j}, mean(rdata{j}.results{i}.areas)];
   end
end
P_areas_ROI = ...
SC.plotCombined(areas_ROI, ...
                5, 'cluster areas per ROI (nm^2)', ...
                econd, 'areas_ROI', colors, line_type);
fprintf(out, 'P_cluster areas per ROI =\n');
fprintf(out, fmt, P_areas_ROI);
fprintf(out, '\n');

% Cluster compactness.
compactness = cell(1, n_files);
for j = 1 : n_files
   compactness{j} = [];
   for i = 1 : numel(rdata{j}.results)
      compactness{j} = [compactness{j}, rdata{j}.results{i}.compactness];
   end
end
P_compactness = ...
SC.plotCombined(compactness,                        ...
                0.05, 'cluster compactness', econd, ...
                'compactness', colors, line_type);
fprintf(out, 'P_cluster compactness =\n');
fprintf(out, fmt, P_compactness);
fprintf(out, '\n');

% Cluster compactness per ROI.
compactness_ROI = cell(1, n_files);
for j = 1 : n_files
   compactness_ROI{j} = [];
   for i = 1 : numel(rdata{j}.results)
      compactness_ROI{j} = [compactness_ROI{j}, ...
                            mean(rdata{j}.results{i}.compactness)];
   end
end
P_compactness_ROI = ...
SC.plotCombined(compactness_ROI,                            ...
                0.05, 'cluster compactness per ROI', econd, ...
                'compactness_ROI', colors, line_type);
fprintf(out, 'P_cluster compactness per ROI =\n');
fprintf(out, fmt, P_compactness_ROI);
fprintf(out, '\n');

% Number of points per cluster per ROI.
n_pts_ROI = cell(1, n_files);
for j = 1 : n_files
   n_pts_ROI{j} = [];
   for i = 1 : numel(rdata{j}.results)
      n_pts_ROI{j} = [n_pts_ROI{j}, mean(rdata{j}.results{i}.n_pts)];
   end
end
P_npts_per_clust_ROI = ...
SC.plotCombined(n_pts_ROI, 1, 'localizations per cluster per ROI', ...
                econd, 'npts_per_clust_ROI', colors, line_type);
fprintf(out, 'P_n points per cluster per ROI =\n');
fprintf(out, fmt, P_npts_per_clust_ROI);
fprintf(out, '\n');

% Cluster sizes (equivalent radii corresponding to the cluster areas) per ROI.
equiv_radii_ROI = cell(1, n_files);
for j = 1 : n_files
   equiv_radii_ROI{j} = [];
   for i = 1 : numel(rdata{j}.results)
      equiv_radii_ROI{j} = [equiv_radii_ROI{j}, ...
                            mean(rdata{j}.results{i}.equiv_radii)];
   end
end
%SC.CSV = true;
P_equiv_radii_ROI = ...
SC.plotCombined(equiv_radii_ROI, 1,                        ...
                'cluster equiv radii per ROI (nm)', econd, ...
                'equiv_radii_ROI', colors, line_type);
%SC.CSV = false;
fprintf(out, 'P_cluster equiv radii per ROI =\n');
fprintf(out, fmt, P_equiv_radii_ROI);
fprintf(out, '\n');

% Nearest neighbor localization distances per ROI.
nn_loc_dists_ROI = cell(1, n_files);
for j = 1 : n_files
   nn_loc_dists_ROI{j} = [];
   for i = 1 : numel(rdata{j}.results)
      XY_ROI = rdata{j}.results{i}.XY;
      nn_loc_dists_ROI{j} = [nn_loc_dists_ROI{j}, ...
                             mean(c.nn_distances(XY_ROI))];
   end
end
if CSVglobal
   SC.CSV = true;
end
P_nn_loc_dists_ROI = ...
SC.plotCombined(nn_loc_dists_ROI, 1,                             ...
                'nn localization distances per ROI (nm)', econd, ...
                'nn_local_ROI');
SC.CSV = false;
fprintf(out, 'P_nn localization distances per ROI =\n');
fprintf(out, fmt, P_nn_loc_dists_ROI);
fprintf(out, '\n');

% Nearest neighbor localization distances within clusters per ROI.
nn_within_clust_ROI = cell(1, n_files);
for j = 1 : n_files
   nn_within_clust_ROI{j} = [];
   for i = 1 : numel(rdata{j}.results)
      nn_within_clust_ROI{j} = [nn_within_clust_ROI{j}, ...
                                mean(rdata{j}.results{i}.nn_within_clust)];
   end
end
%SC.CSV = true;
P_nn_withinC_ROI = ...
SC.plotCombined(nn_within_clust_ROI, 1,                                   ...
                'nn localization distances within clusters per ROI (nm)', ...
                econd, 'nn_withinC_ROI', colors, line_type);
%SC.CSV = false;
fprintf(out, 'P_nn localization distances within clusters per ROI =\n');
fprintf(out, fmt, P_nn_withinC_ROI);
fprintf(out, '\n');

% Number of clusters vs number of localizations per ROI.
clust_vs_loc_ROI = cell(1, n_files);
for j = 1 : n_files
   clust_vs_loc_ROI{j} = [];
   for i = 1 : numel(rdata{j}.results)
      clust_vs_loc_ROI{j} = [clust_vs_loc_ROI{j}, ...
         rdata{j}.results{i}.nC / rdata{j}.results{i}.n_points];
   end
end
%SC.CSV = true;
P_clust_vs_loc_ROI = ...
SC.plotCombined(clust_vs_loc_ROI, 1,                    ...
                'cluster / localization ratio per ROI', ...
                econd, 'clust_vs_loc_ROI', colors, line_type);
%SC.CSV = false;
fprintf(out, 'P_cluster / localization ratio per ROI =\n');
fprintf(out, fmt, P_clust_vs_loc_ROI);
fprintf(out, '\n');

fclose(out);

fprintf('Done %s.\n', base_name);

end

./MATLAB/+smi_cluster/@ClusterInterface/combineResults.m
function combineResults(Files, analysis_dir, out_file)
% ---------- Combine results from 1 or more conditions for further processing
% Multiple instantiations of a single condition potentially located in multiple
% directories are collected into a combined instance in a specified directory.
%
% INPUTS:
%    Files          _results.mat files to collect analyses from
%    analysis_dir   directory where to put the combined result
%    out_file       name of combined ouput _results.mat file
%
% OUTPUTS:
%    analysis_dir/out_file is saved where analysis_dir is typically
%    some_path/Analysis and outfile ends in _results.mat

% Created by
%    Michael J. Wester (2022)

   n_files = numel(Files);
   if n_files == 1
      copyfile(Files{1}, fullfile(analysis_dir, out_file));
   else
      if ~endsWith(out_file, '_results.mat')
         out_file = [out_file, '_results.mat'];
      end
      files = {};
      results = {};
      RoI = {};
      n_ROIs = 0;
      collected = {};
      for j = 1 : n_files
         cdata = load(Files{j});

         files = {files{:}, cdata.files{:}};
         results = {results{:}, cdata.results{:}};
         RoI = {RoI{:}, cdata.RoI{:}};

         % Pixel2nm should be consistent between result files.
         if j == 1
            Pixel2nm = cdata.Pixel2nm;
         elseif cdata.Pixel2nm ~= Pixel2nm
            error('Pixel2nm inconsistent: %g %g', Pixel2nm, cdata.Pixel2nm);
         end

         n_ROIs = n_ROIs + cdata.n_ROIs;

         fn = fieldnames(cdata.collected);
         for i = 1 : numel(fn)
            fn_i = fn{i};
            if j == 1
               if strcmp(fn_i, 'nC')
                  collected.nC = 0;
               else
                  collected.(fn_i) = [];
               end
            end
            cdatum = cdata.collected.(fn_i);
            if isscalar(cdatum)
               if strcmp(fn_i, 'nC')
                  collected.nC = collected.nC + cdatum;
               else
                  collected.(fn_i) = cdatum;
               end
            else
               collected.(fn_i) = [collected.(fn_i), cdatum];
            end
         end
      end
      save(fullfile(analysis_dir, out_file), 'files', 'Pixel2nm', 'n_ROIs', ...
                    'RoI', 'results', 'collected');
   end

   fprintf('Done.\n');

end

./MATLAB/+smi_cluster/@ClusterInterface/ClusterInterface.m
classdef ClusterInterface < handle

% ClusterInterface class written by Michael Wester
%    (9/29/2022) <wester@math.unm.edu>
% The New Mexico Center for the Spatiotemporal Modeling of Cell Signaling
% University of New Mexico Health Sciences Center
% Albuquerque, New Mexico, USA   87131
% Copyright (c) 2015-2023 by Michael J. Wester and Keith A. Lidke

% A collection of functions that interface with the main Clustering routines.

% =============================================================================
properties
% =============================================================================

% =============================================================================
end % properties
% =============================================================================

% =============================================================================
methods
% =============================================================================

% =============================================================================
end % methods
% =============================================================================

% =============================================================================
methods(Static)
% =============================================================================

   % Called by simpleROIcluster.
   combineResults(Files, analysis_dir, out_file)
   combinedStatistics1(SC, pathname, files, base_name, A_ROI, doHopkins)
   combinedStatistics2(SC, colors, line_type, pathname, files, ...
                       base_name, A_ROI, doHopkins)
   combineBaGoLROIs(pathnameR, filesR, pathnameB, filesB, MAPNfile, ...
                    keep_numbering)
   defineBaGoLROIs(pathnameR, filesR, pathnameB, filesB, MAPNfile)
   defineROIs(pathname, files, Pixel2nm, RT, oneROI)
   [n_ROIs, RoI] = filterROIs(pathname, files, filter)
   % Called by singleConditionDriver.
   singleCondition(pathname, files, algorithm_range, E_range, ...
                   minPts_range, Pixel2nm, base_name, A_ROI,  ...
                   doHopkins, doSigmaActual)

   % Called by plotROIDriver.
   plotROI(opt, pathnameC, filesC, pathnameB, filesB, PixelSize, SaveDir)
   [SRIm] = genMAPNIm1(obj, ImFlag)
   OverlayImageCircle = genSRMAPNOverlay1(SMD, MAPN, XSize, YSize, ...
      PixelSize, SaveDir, Xstart, Ystart, RadiusScale, ScaleBarLength)

% =============================================================================
end % methods(Static)
% =============================================================================
end % classdef

./MATLAB/+smi_cluster/clusterSTSigma.m
function [ConnectID] = clusterSTSigma(SMD, MaxFrameGap, NSigmaDev, MaxNN)
%clusterSTSigma performs pre-clustering on localizations in SMD.
% This method clusters localizations in SMD based on their spatiotemporal
% separations.  Localizations within NSigmaDev*SE of one another which 
% appear within MaxFrameGap frames will be assigned to the same cluster.  
% The assignment is designated by a shared integer value of the output 
% ConnectID.
%
% NOTE: This function was originally written in the context of
%       FrameConnection.lapFC().
%
% INPUTS:
%   SMD: SingleMoleculeData structure with the localizations that we wish
%        to frame-connect.
%   MaxFrameGap: Maximum frame gap allowed between cluster members.
%   NSigmaDev: Standard error multiplier defining distance cutoff (see
%              SMF.FrameConnection.NSigmaDev)
%   MaxNN: Maximum nearest-neighbors considered for cluster membership
%          (ideally this is inf, but numerically that's not possible in
%          some realistic cases). (Default = 2)
%
% OUTPUTS:
%   ConnectID: Set of integers defining links between localizations in SMD,
%              with indexing matching the indices of SMD localizations.

% Created by:
%   David J. Schodt (Lidke Lab, 2021)


% Set defaults.
if (~exist('MaxNN', 'var') || isempty(MaxNN))
    MaxNN = 2;
end

% Gather/revise/reorganize some arrays for further use.
[DatasetNum, SortIndices] = sort(SMD.DatasetNum);
X = SMD.X(SortIndices);
Y = SMD.Y(SortIndices);
X_SE = SMD.X_SE(SortIndices);
Y_SE = SMD.Y_SE(SortIndices);
FrameNum = SMD.FrameNum(SortIndices);
MeanXYSE = mean([X_SE, Y_SE], 2);

% Initialize each localization as a new cluster.
NLocalizations = numel(SMD.FrameNum);
ConnectID = (1:NLocalizations).';

% Loop through datasets and perform the pre-clustering.
[NLocPerDataset, DatasetArray] = groupcounts(DatasetNum);
CumulativeDatasetLocs = [0; cumsum(NLocPerDataset)];
MaxID = NLocalizations;
for ii = 1:numel(DatasetArray)
    % Isolate some arrays for the current dataset (CDS = current dataset)
    CurrentDatasetInd = (1:NLocPerDataset(ii)) + CumulativeDatasetLocs(ii);
    [FrameNumCDs, SortIndicesFN] = sort(FrameNum(CurrentDatasetInd));
    CurrentDatasetInd = CurrentDatasetInd(SortIndicesFN);
    XCDs = X(CurrentDatasetInd);
    YCDs = Y(CurrentDatasetInd);
    MeanXYSECDs = MeanXYSE(CurrentDatasetInd);
    ConnectIDCDs = ConnectID(CurrentDatasetInd);
    
    % Loop through frames and add localizations to clusters.
    ClusterInds = cell(NLocPerDataset(ii), 1);
    [NLocPerFrame, FrameArray] = groupcounts(FrameNumCDs);
    CumulativeLocs = [0; cumsum(NLocPerFrame)];
    for ff = 1:numel(FrameArray)
        % Determine which localizations should be considered for clustering.
        % NOTE: Even though we don't want clusters with multiple 
        %       localizations in the same frame for the final results, we 
        %       don't want to exclude those until later (since inclusion of
        %       WRONG localizations now can exclude CORRECT localizations 
        %       if we restrict same frame localizations).
        CurrentFrameInd = (1:NLocPerFrame(ff)) + CumulativeLocs(ff);
        CandidateFrameInd = ...
            find((FrameNumCDs >= (FrameArray(ff)-MaxFrameGap)) ...
            & (FrameNumCDs<=FrameArray(ff)));
        if isempty(CandidateFrameInd)
            MaxID = MaxID + 1;
            ConnectID(CurrentFrameInd) = (1:NLocPerFrame(ff)).' + MaxID;
            MaxID = MaxID + NLocPerFrame(ff);
            continue
        end
        
        % Determine the nearest neighbor to the current localizations in
        % all candidate frames (noting that we're allowing comparisons to
        % the current frame as well).
        [NNIndices, NNDistances] = knnsearch(...
            [XCDs(CandidateFrameInd), YCDs(CandidateFrameInd)], ...
            [XCDs(CurrentFrameInd), YCDs(CurrentFrameInd)], ...
            'k', MaxNN + 1);
        NNIndices = NNIndices(:, 2:end);
        NNDistances = NNDistances(:, 2:end);
        
        % Place the CurrentFrameInd localizations into clusters.
        for nn = 1:NLocPerFrame(ff)
            % Cluster all localizations within the distance cutoff of the
            % current localization.
            SESum = MeanXYSECDs(CurrentFrameInd(nn)) ...
                + MeanXYSECDs(CandidateFrameInd(NNIndices(nn, :)));
            ValidNNInd = NNIndices(nn, NNDistances(nn, :).' ...
                <= (NSigmaDev*SESum));
            UpdateInd = unique([CurrentFrameInd(nn); ...
                CandidateFrameInd(ValidNNInd); ...
                find(ConnectIDCDs == ConnectIDCDs(CurrentFrameInd(nn))); ...
                cell2mat(ClusterInds(CandidateFrameInd(ValidNNInd)))]);
            ConnectIDCDs(UpdateInd) = min(ConnectIDCDs(UpdateInd));

            % Store the indices clustered to this localization (this will
            % save some computation time on later iterations by preventing
            % the need for an ismember(ConnectIDCDs, ...
            %    ConnectIDCDs(CandidateFrameInd(ValidNNInd)))
            for jj = UpdateInd.'
                ClusterInds{jj} = [ClusterInds{jj}; UpdateInd];
            end
        end
    end
    ConnectID(CurrentDatasetInd) = ConnectIDCDs;
end
ConnectID(SortIndices, 1) = ConnectID;
ConnectID = smi_helpers.compressToRange(ConnectID);


end
./README.md
[![MATLAB](https://github.com/LidkeLab/smite/actions/workflows/ci.yml/badge.svg)](https://github.com/LidkeLab/smite/actions/workflows/ci.yml)

# ***smite***: Single Molecule Imaging Toolbox Extraordinaire

This MATLAB-based toolbox provides analysis tools for fluorescence
single molecule imaging with an emphasis on single molecule
localization microscopy (SMLM) and single particle tracking (SPT).

---

## Overview

### Workflow concept
***smite*** is designed around the concept that a parameter structure,
the Single Molecule Fitting (SMF) structure, uniquely and completely
defines the data analysis.  The results are completely contained
in a Single Molecule Data (SMD) structure.  ***smite*** is designed
to make lowest-level tools just as easy to use as the higher-level
application-specific classes.  All tools make use of the SMF and
SMD structures.

### Code organization
***smite*** is organized into a set of namespaces that group similar
tools and concepts.  The namespace  `+smi`  contains the highest
level tools that will be the most common entry point for processing
SMLM and SPT data sets.  The file [SMITEclasses.md](doc/SMITEclasses.md)
provides a short 1-line description of each class in the distribution.

### Image and Detector Model
Image arrays follow MATLAB's column-major format.  An image coordinate
of (1,1) means the center of the top-left pixel, whereas (2,1) would
indicate the center of the pixel that is one down from the top, but
in the left-most column.

---

## Installation
Clone (Linux/MacOS example; similar for Windows) into `~/Documents/MATLAB`
the ***smite*** GitHub distribution
(https://github.com/LidkeLab/smite.git).  Add to
`~/Documents/MATLAB/startup.m` the following:
```
   addpath '~/Documents/MATLAB/smite/MATLAB'
   setupSMITE
```
In addition, depending on the machine's architecture, you may need to
compile the mex files in `~/Documents/MATLAB/smite/MATLAB/source/c`
using `mex_Make`:
```
   cd ~/Documents/MATLAB/smite/MATLAB/source/c
   mex_Make
```
and the CUDA files in `~/Documents/MATLAB/smite/MATLAB/source/cuda`
using `cuda_Make`:
```
   cd ~/Documents/MATLAB/smite/MATLAB/source/cuda
   cuda_Make
```
The compiled files will be placed in the `smite/MATLAB/mex` or
`smite/MATLAB/ptx` directories, respectively.

To verify that ***smite*** is running properly, see the Testing
subsection below.

### Dependencies
For full functionality, ***smite*** requires:
- Linux, MacOS or Windows
- MATLAB version R2021a or later
- Nvidia GPU with CUDA compute capability [supported by your version of MATLAB](https://www.mathworks.com/help/parallel-computing/gpu-support-by-release.html)
- MATLAB Curve Fitting Toolbox [ONLY smi_cluster, smi_core.FRC,
  smi_stat.DiffusionEstimator]
- MATLAB Image Processing Toolbox
- MATLAB Optimization Toolbox [ONLY smi_cluster.PairCorrelation,
  smi_stat.DiffusionEstimator]
- MATLAB Parallel Computing Toolbox
- MATLAB Signal Processing Toolbox [ONLY smi_core.FRC]
- MATLAB Statistics and Machine Learning Toolbox
- ffmpeg installed for Linux (https://ffmpeg.org)
  [smi_core.LocalizeData.genLocalizations for obj.Verbose >= 3]

---

## Simple Examples
### Working with SMF
SMF is implemented as a class to enable a gui and to provide useful
helper methods.  However, the most common use will be as a structure
with fixed fields.

Create an SMF object:
```
  SMF = smi_core.SingleMoleculeFitting()
```
Get an SMF property:
```
  B = SMF.BoxFinding.BoxOverlap
```
Set an SMF property:
```
  SMF.BoxFinding.BoxOverlap = 0
```
Use the SMF GUI to interactively set values:
```
  SMF.gui()
```

### Finding coordinates from a stack of images containing blobs

Create a test dataset and make it noisy:
```
  B = smi_sim.GaussBlobs.genRandomBlobImage();
  B = poissrnd(B);
```
Create an `SMF` object with default values:
```
  SMF = smi_core.SingleMoleculeFitting()
```
Create a `LocalizeData` object with our `SMF`:
```
  LD = smi_core.LocalizeData(B, SMF)
```
Localize:
```
  [SMD] = LD.genLocalizations();
```

Localize again with `Verbose = 3` to show color overlay output:
```
  LD.Verbose = 3;
  [SMD] = LD.genLocalizations();
```

### High level SMLM analysis

Create an SMLM object.  When there are no input aruments, it will open the GUI:
```
  SMLMobj = smi.SMLM()  
```
Use the GUI to navigate to a test dataset such as available from

- Pallikkuth, S., Martin, C., Farzam, F., Edwards, J. S., Lakin,
  M. R., Lidke, D. S., & Lidke, K. A. (2018). Supporting data for
  Sequential Super-Resolution Imaging using DNA Strand Displacement
  [Data set]. University of New Mexico
  [https://doi.org/10.25827/CS2A-DH13](https://digitalrepository.unm.edu/physics_data/3/#attach_additional_files).
- Wester, Michael J., Mazloom-Farsibaf, Hanieh, Farzam, Farzin,
  Fazel, Mohamadreza, Meddens, Marjolein B. M., & Lidke, Keith A.
  (2020), Comparing Lifeact and Phalloidin for super-resolution imaging
  of actin in fixed cells, Dryad, Dataset,
  [https://doi.org/10.5061/dryad.xsj3tx9cn](https://datadryad.org/stash/dataset/doi:10.5061/dryad.xsj3tx9cn).

Set SMF values from within the GUI and run either a test dataset
or analyze all datasets.

---

## Getting Started
- Install ***smite*** as discussed above.
- Run the collection of unit tests as discussed in the Testing section
  below to verify that ***smite*** has been properly installed.
- Run some of the Code Examples linked to below which simulate data.
- Obtain or generate a dataset (see the citations above) and try out
  the core functionality (see Overview section below).  The user can
  also obtain a dataset by running
  [the SMLM unitTest](MATLAB/+smi/@SMLM/unitTest.m), which will produce
  the ~1 Gb `tempdir/smite/unitTest/SMLM/SMLM_testData.h5`.

### Testing
[run_tests](MATLAB/run_tests.m) run a series of unit tests that
cover major ***smite*** core functionality.  Much output will be
saved in tempdir/smite/unitTest/name_of_test.
[ExpectedResults](MATLAB/ExpectedResults/README.md) are provided
in the `smite/MATLAB` directory in which `run_tests.m` resides,
noting that very large files have been deleted so as to not bloat
up the the ***smite*** distribution (these files are listed in the
various `ExpectedResults` READMEs).  Also, the tests are frequently
stochastic in nature, so outputs from run to run will not necessarily
be identical, even on the same system, but the `ExpectedResults` will
provide a flavor of what to expect.

### [Code Examples](MATLAB/examples/README.md)
Additional ***smite*** examples can be found in the examples
subdirectory of MATLAB as well as the unitTests for some of the
classes (see [here](MATLAB/examples/README.md) for a summary).  Some
of the examples generate and analyze their own data, while others
provide a template for how to run the example given supplied data.
(The unit tests always generate their own data if any is needed.)

### [Overview of Core Functionality](doc/CoreOverview.md)
Additional details on the core functionality of ***smite*** can be
found [here](doc/CoreOverview.md), including both simple and
extended examples of usage.

---

## Contributions/Support
Issues or problems and people seeking support with the software
should be reported via the Issues tab of the ***smite*** GitHub
repository.  Contributions to ***smite*** should be performed on
new branches which are then requested to merge with the main branch
via Pull Requests.

---

## Related Software
Please note the related software: MATLAB Instrument Control
(***MIC***), a collection of MATLAB classes for automated data
collection on complex, multi-component custom built microscopes.
This software can be obtained from the ***MIC*** GitHub distribution
(https://github.com/LidkeLab/matlab-instrument-control.git).

./doc/DataStructures/TR.md
### TR

TrackingResults: A class defining the Tracking Results structure

This datatype is one of the primary results structures in the smite
enviroment. The Tracking Results (TR) structure is an input/output of
many methods in smite which are related to single-particle tracking
(SPT) analysis.  TR structures are organized as follows: each
structure element corresponds to a single trajectory, i.e., TR(n)
contains all relevant properties of the n-th trajectory. The TR
structure is intended to carry all necessary information from an SMD
structure (see (smi_core.SingleMoleculeData)[SMD.md]) but organized
in a more user-friendly manner for SPT data.

The TR structure is just an array of SMD structures, with each array
element being an SMD structure corresponding to a single trajectory.

SEE ALSO:
- [smi_core.SingleMoleculeData](SMD.md),
- [smi_core.SingleMoleculeFitting](SMF.md)

./doc/DataStructures/SMF.md
### SMF

SingleMoleculeFitting: A class defining the Single Molecule Fitting structure

The SMF structure is a structure of structures that collectively contain
all parameters required to go from raw data to an SMD results structure.
The SMF structure is an input of many smi methods. It
intended to be extensible to enable new analysis tools and methods.
The SMF class implements tools for working with SMF structures,
but the data structure itself is not an object of the class.

Parameters of sub-structures are explained in more detail in
the classes and methods that use them.  An incomplete list of classes
that use each sub-structure is listed in {}.

The SMF structure has the following sub-structures and fields:

```
SMF:  Fields that are structures:

Data:             {LoadData}
  FileName:       File name (cell array of char array)
  FileDir:        File directory (char array)
  ResultsDir:     Results directory (char array)(Default='FileDir/Results')
  AnalysisID:     ID tagged onto saved results (char array)(Default='')
  FileType:       Type of data specified by FileName. If using a custom
                  extension, you must set this field manually to the true
                  underlying file type (e.g., if using a .mat file saved
                  as exFile.spt, set obj.Data.FileType = 'mat')
                  (char array)(Default set to extension of FileName{1})
  DataVariable:   Name of variable saved in FileName which contains the
                  raw data. (char array)(Default='sequence')
  DatasetList:    List of datasets of the raw data to be analyzed.
                  (array of int32)(Default=int32([]))
  DatasetMods:    Cell array containing datasets to be used/excluded from
                  analysis (Mods <-> modifiers). This is meant to be the
                  user-facing lists which define DatasetList, meaning that
                  this is what would be set in the GUI. DatasetMods{1} will
                  contain an array of the "inclusion" dataset numbers and
                  DatasetMods{2} will contain an array of the "exclusion"
                  datasets. DatasetList will be set elsewhere (e.g.,
                  smi_core.LoadData) to include the set
                     intersect(intersect(1:NDatasets, DatasetMods{1}), ...
                     setdiff(1:NDatasets, DatasetMods{2}))
                  unless DatasetMods{1} is empty, in which case the first
                  parantheses term is dropped. For example, if
                  NDatasets = 20, and you only want to analyze datasets 1:5,
                  you can set DatasetMods{1} = 1:5. If you further decide to
                  exclude datsaets 2 and 4, you could set
                  DatasetMods{2} = [2, 4].
                  (cell array of int32 arrays)(Default={[]; []})
  CameraType:     'EMCCD','SCMOS' (Default='EMCCD')
  CameraGain:     Camera Gain, scalar or image (Default=1)
  CameraOffset:   Camera Offset, scalar or image (Default=0)
  CameraNoise:    Camera readnoise, scalar or image (Default=0)
  CalibrationFilePath: Path to the camera calibration file (Default='')
  RegistrationFilePath: Path to channel registration file (Default='')
  DataROI:        Region of interest of data file to be used (Default=[])
  FrameRate:      Data Collection Frame Rate (1/s)
  PixelSize:      Camera back-projected pixel size (micrometers)
  SEAdjust:       Standard error inflation per localization (Pixels)(Default=0)

BoxFinding:       {FindROI}
  BoxSize:        Linear box size for fitting (Pixels)(Default=7)
  BoxOverlap:     Overlap of boxes allowed (Pixels)(Default=2)
  MinPhotons:     Minimum number of photons from emitter (Default=200)

Fitting           {GaussMLE}
  PSFSigma:   Initial or fixed Sigma of 2D Gaussian PSF Model (Pixels)
              (Default=1)
  FitType:    See fit class for options  (Default='XYNB')
  NParams:    Number of fitting parameters (auto-set based on FitType)
  Iterations: Newton Raphson iterations (Default=20)
  ZFitStruct: Structure for astigmatic fitting:
      Ax:         Astigmatism fit parameter (see GaussMLE)
      Ay:         Astigmatism fit parameter (see GaussMLE)
      Bx:         Astigmatism fit parameter (see GaussMLE)
      By:         Astigmatism fit parameter (see GaussMLE)
      Gamma:      Astigmatism fit parameter (see GaussMLE)
      D:          Astigmatism fit parameter (see GaussMLE)

Thresholding      {ThresholdFits,SRA}
  On              Perform thresholding? (Default=true)
  MaxXY_SE:       Maximum allowed precision in x,y (Pixels)(Default=.2)
  MaxZ_SE:        Maximum allowed precision in z (Microns)(Default=.5)
  MinPValue:      Minimum accepted p-value from fit (Default=.01)
  AutoThreshLogL: Automatically threshold on LogL and ignore MinPValue
                  (Default = false)
  AutoThreshPrctile: Extrema percentile thrown out when computing LogL
                  auto-threshold (Default = 1e-4)
  MinPSFSigma:    Minimum PSF Sigma from fit (Pixels)(Default=.5);
  MaxPSFSigma:    Maximum PSF Sigma from fit (Pixels)(Default=2);
  MinPhotons:     Minimum accepted photons from fit (Default=100)
  MaxBg:          Maximum background accepted from fit (Default=Inf)
  InMeanMultiplier:   Determines maximum intensity accepted (Default=Inf)
  NNMedianMultiplier: Nearest neighbor acceptance region (Default=3)
  MinNumNeighbors:    Minimum number of neighbors in above (Default=0)

FrameConnection:  {FrameConnect,SRA}
  On              Perform frame connection? (Default=true)
  Method:         Frame connection method being used (Default='LAP-FC')
  MaxSeparation:  Maximum separation for connection (Pixels)(Default=1)
  LoS:            Minimum accepted p-value for connection (Default=.01)
  MaxFrameGap:    Maximum frame gap for connection (Frames)(Default=5)
  NSigmaDev:      SE multiplier for pre-cluster distance threshold (Default=5)
  NNearestClusters: Number of clusters used in density estimates (Default=2)
  NIterations:    Number of iterative FC attempts when Method=lap-fc
                  (Default=1)
  MinNFrameConns  Minimum accepted number of frame connections (Default=1)

DriftCorrection   {DriftCorrection,SRA}
 On               Perform drift correction? (Default=true)
 Method:          Drift correction method being used (Default='DC-KNN')
 BFRegistration   Was brightfield registration performed? (Default=true)
 L_intra          Intra-dataset threshold (Pixel)(Default=1)
 L_inter          Inter-dataset threshold (Pixel)(Default=2)
 PixelSizeZUnit   X/Y pixel size (3D drift correction) (um)(Default=0.1)
 PDegree          Degree intra-dataset fitting poly for drift rate (Default=1)

Tracking          {SPT}
  Method:         Type of method used for tracking (Default='CostMatrix')
  D:              Diffusion Constant (Pixels^2/Frame) (Default=0.01)
  TrajwiseD:      Use traj.-wise value for D (logical)(Default=true)
  K_on:           Off to On Rate (Frame^-1) (Default=.9)
  K_off:          On to Off Rate (Frame^-1) (Default=.1)
  MaxDistFF:      Maximum distance gap for frame-to-frame connection (Pixels)
                  (Default=5)
  MaxDistGC:      Maximum distance gap for Gap Closing (Pixels) (Default=10)
  MaxFrameGap:    Maximum frame gap for Gap Closing (Pixels) (Default=10)
  MinTrackLength: Minimum track length of trajectory (Frames) (Default=3)
  NIterMax:  Max. number of iterative tracking attempts (Integer)(Default=5)
  NIterMaxBatch:  Max. number of batch tracking iterations (Integer)
                  (Default = 5)
  MaxRelativeChange: Max. relative param. change to end iterations
                  (Default = 1e-5)
  MaxZScoreDist:  Max. abs(z-score) x/y jump size (Default=inf)
  MaxZScorePhotons: Max. abs(z-score) for photon diffs. (Default=inf)
  TryLowPValueLocs: Try to incorporate low p-val. locs. (Default=false)
```

./doc/DataStructures/SMD.md
### SMD

SingleMoleculeData: A class defining the Single Molecule Data structure

This datatype is one of the primary results structures in the ***smite***
environment. The SMD structure is an input and output of many smi
methods. It intended to be extensible.
The SMD class implements tools for working with SMD structures,
but the data structure itself is not an object of the class.

The structure has the following properties:

```
SMD:
  NDims:          Number of dimensions in localization information (2,3)
  NFrames:        Number of image frames in raw data sets
  NDatasets:      Number of 3D image stacks
  FrameRate:      Acquisition frame rate (1/seconds)
  PixelSize       Pixel size of camera projected onto sample (micrometers)
  XSize:          Number of pixels in X dimension of raw data
  YSize:          Number of pixels in Y dimension of raw data
  XBoxCorner:     X coordinate of top right box corner
  YBoxCorner:     Y coordinate of top right box corner
  ZOffset:        Z position of focal plane of sequence
  X:              Estimated X position
  Y:              Estimated Y position
  Z:              Estimated Z position
  Photons:        Estimated Photons  (Integrated collected photons)
  Bg:             Estimated Background (Photons/Pixel)
  PSFSigma:       Estimated or Fixed Sigma of 2D Gaussian PSF Model
                  (symmetric PSF)
  PSFSigmaX:      Estimated or FixedX Sigma of 2D Gaussian PSF Model
                  (asymmetric PSF)
  PSFSigmaY:      Estimated or FixedY Sigma of 2D Gaussian PSF Model
                  (asymmetric PSF)
  X_SE:           Standard Error of X
  Y_SE:           Standard Error of Y
  Z_SE:           Standard Error of Z
  Photons_SE:     Standard Error of Photons
  Bg_SE:          Standard Error of Bg
  PSFSigma_SE:    Standard Error of PSFSigma
  PSFSigmaX_SE:   Standard Error of PSFSigmaX
  PSFSigmaY_SE:   Standard Error of PSFSigmaY
  DatasetNum:     File number from which localization originates
  FrameNum:       Frame number from which localization originates
  PValue:         p-value of fit
  LogLikelihood:  Log likelihood of fit
  ConnectID:      Identifies the same emitter accross multiple frames
  IndSMD:         Indices in original SMD corresponding to frame
                  connected localizations (e.g., indices in SMD
                  corresponding to localizations in SMDCombined).
  ThreshFlag:     Indicates a valid fit.  0=valid.  See SMA_Core.ThresholdSM
  DriftX:         X drift relative to first frame (Pixels) (NFrames x NDatasets)
  DriftY:         Y drift relative to first frame (Pixels) (NFrames x NDatasets)
  DriftZ:         Z drift relative to first frame (Pixels) (NFrames x NDatasets)
  IsTransformed:  Flag indicating channel reg. was performed on this SMD
  RegError:       Error in channel registration. (Pixels)
```

SEE ALSO:
- [smi_core.SingleMoleculeFitting](SMF.md),
- [smi_core.TrackingResults](TR.md)

./doc/ExtExamples/Publish.md
## Publish

The Publish class batch-processes SR data assuming the data-containing
.h5 files follow a standard naming convention
(obj.CoverslipDir/Cell\*/Label\*/Data\*.h5).

[+smi/@Publish](../../MATLAB/+smi/@Publish/README.md) summarizes the
properties and methods of the Publish class.  See also tutorial
information on [SMLM](SMLM.md) and information on the
[SMF](DataStructures/SMF.md) data structure and its properties.

Below is a more annotated version of the script
[Example_Publish.m](../MATLAB/examples/Example_Publish.m).
[Example_Publish_generic.m](../MATLAB/examples/Example_Publish_generic.m)
is a similar example, but includes code at the end to perform additional
analyses using the same SMF parameters.

```
% This script will call smi.Publish to generate misc. results for an
% experiment on the sequential microscope.

%% Define the analysis parameters.
% Define the 'CoverslipDir'.
% NOTE: 'CoverslipDir' is the top-level directory which contains the
%        sub-directories 'CoverslipDir'/Cell*/Label*, which themselves
%        contain data in .h5 files 'CoverslipDir'/Cell*/Label*/Data*.h5
%        [MUST BE PROVIDED]
CoverslipDir = '/Experiment1';

% Prepare the SMF structure.
SMF = smi_core.SingleMoleculeFitting;
   % CameraType:     'EMCCD','SCMOS' (Default='EMCCD')
SMF.Data.CameraType = 'SCMOS';
   % Path to the camera calibration file (Default='')   [MUST BE PROVIDED]
SMF.Data.CalibrationFilePath = ...
   '/mnt/nas/lidkelab/sCMOS Calibrations/SequentialSR/GainCalibration_medianGain_2022_05_26.mat';
   % Camera back-projected pixel size (micrometers)
SMF.Data.PixelSize = 0.0954; % microns
   % Linear box size for fitting (Pixels)(Default=7)
SMF.BoxFinding.BoxSize = 8; % pixels
   % See fit class for options  (Default='XYNB')
SMF.Fitting.FitType = 'XYNBS';
   % Initial or fixed Sigma of 2D Gaussian PSF Model (Pixels) (Default=1)
SMF.Fitting.PSFSigma = 1.3; % pixels
   % Maximum allowed precision in x,y (Pixels)(Default=.2)
SMF.Thresholding.MaxXY_SE = 0.15; % pixels
   % Minimum accepted photons from fit (Default=100)
SMF.Thresholding.MinPhotons = 200;
   % Frame connection method being used (Default='LAP-FC')
SMF.FrameConnection.Method = 'LAP-FC';

% Alternatively, you may wish to prepare the SMF using the GUI.
% SMF.gui()

%% Prepare the smi.Publish class and run the standard analysis.
% The smi.Publish class requires the SMF (defined above) as well as the
% 'CoverslipDir'.  All other class properties specify which analyses to do.
    % SMF is a structure of parameters (see smi_core.SingleMoleculeFitting)
Publish = smi.Publish(SMF);
    % Directory containing the Cell*\Label*\Data*.h5 sub-directories.
Publish.CoverslipDir = CoverslipDir;
    % Verbosity of the main analysis workflow. (Default = 1)
Publish.Verbose = 1;
    % Flag to indicate SR results should be generated (Default = true)
Publish.GenerateSR = 1;
    % Flag to generate various imaging stats (Default = true)
Publish.GenerateImagingStats = 1;
    % Flag to generate overlay info. between channels (Default = false)
Publish.GenerateOverlayStats = 0;
    % Shift localizations based on brightfield results (Default = false)
Publish.ShiftToReg = 0;% can be useful for color overlay data, use with caution!

% Define trust regions, so that anything that seems to have a shift above the
% value below will be masked out.  Note that PixelSize is in microns/pixel, so
% the multiplying factor (0.2) is in units of microns.
    % Max. brightfield shift used to define overlay masks (pixels)
    % NOTE: This is defined in terms of brightfield pixels, e.g., units
    %       of obj.SMF.Data.PixelSize.
%Publish.MaxBrightfieldShift = 0.2 / SMF.Data.PixelSize; % pixels

% smi.Publish contains several useful methods, however we'll almost always
% just call performFullAnalysis().
Publish.performFullAnalysis();
```
Supposing the CoverslipDir is '/Experiment1', and data for 2 cells are
organized as follows:
```
/Experiment1/
  Cell_01/
    Label_01/
      Data_2022-8-11-17-10-2.h5
      Data_2022-8-12-9-1-51_bleaching.h5
    Label_02/
      Data_2022-8-12-11-32-50.h5
  Cell_02/
    Label_01/
      Data_2022-8-11-18-45-22.h5
      Data_2022-8-12-9-12-58_bleaching.h5
    Label_02/
      Data_2022-8-12-11-49-56.h5
```
Running the above script will produce files like:
```
/Experiment1/
  Results/
    Cell01_CircleOverlay_GM.png   (label 1 is green; label 2 is magenta)
    Cell01_GaussianOverlay_GM.png
    Cell_01/
      Label_01/
        Data_2022-8-11-17-10-2_GaussImage.png
        Data_2022-8-11-17-10-2/
          AlignRegDiffImageMovie.mp4
          AlignRegErrorPerDataset.png
          AlignRegErrorSignal.png
          AlignRegHistorySum.png
          AlignRegOverlayMovie.mp4
          AlignRegXCorrMaxima.png
          Data_2022-8-11-17-10-2_Background_Hist.png
          Data_2022-8-11-17-10-2_CircleImageDrift.png
          Data_2022-8-11-17-10-2_CircleImage.png
          Data_2022-8-11-17-10-2_Connected_emitters_Hist.png
          Data_2022-8-11-17-10-2_CumDriftCorrection.png
          Data_2022-8-11-17-10-2_DriftCorrection.png
          Data_2022-8-11-17-10-2_DriftImage.png
          Data_2022-8-11-17-10-2_FitsPerFrame.png
          Data_2022-8-11-17-10-2_GaussImage.png
          Data_2022-8-11-17-10-2_Intensity_Hist.png
          Data_2022-8-11-17-10-2_PSFSigma_Hist.png
          Data_2022-8-11-17-10-2_P_value_Hist.png
          Data_2022-8-11-17-10-2_Results.mat
          Data_2022-8-11-17-10-2_X_std_error_Hist.png
          Data_2022-8-11-17-10-2_Y_std_error_Hist.png
          DiffImageHistogram.png
          SSIM.png
          XCorrPlots/
            XCorrSequence1.fig
            XCorrSequence1.png
            XCorrSequence2.fig
            XCorrSequence2.png
            ...
      Label_02/
        Data_2022-8-12-11-32-50_GaussImage.png
        Data_2022-8-12-11-32-50/
          ...
    Cell02_CircleOverlay_GM.png
    Cell02_GaussianOverlay_GM.png
    Cell_02/
      ...
    ResultsStructs/
      Cell_01_Label_01_Data_2022-8-11-17-10-2_Results.mat
      Cell_01_Label_02_Data_2022-8-12-11-32-50_Results.mat
      Cell_02_Label_01_Data_2022-8-11-18-45-22_Results.mat
      Cell_02_Label_02_Data_2022-8-12-11-49-56_Results.mat

```
- AlignReg\* are various summary plots dealing with brightfield registration
  when using a sequential microscope (see also XCorrPlots below).
- Circle images use circles with radii proportional to the standard error to
  represent localizations.
- Drift images are color coded to show the movement over time (frame number)
  of localizations.
- Gaussian images use Gaussian blobs to represent localizations.
- Overlays are produced for 2-color (2-label) images.
- PSFSigma is the point spread function sigma or standard error.
- P_value refers to P-values from emitter fitting.
- Results,mat files contain the SMF and SMD structures generated for the
  given analysis.
- The single color Gaussian images and the Results files are duplicated for
  convenience in managing directories containing multiple analyses.
- XCorrPlots contains plots related to the brightfield registration process of
  the acquistion when using a sequential microscope, in which information about
  the cross-correlation process used to correct for sample drift during
  brightfield registration is displayed.

./doc/ExtExamples/SPT.md
### SPT (Single Particle Tracking)

Single Particle Tracking in ***smite*** allows for robust single 
molecule tracking by creating a TrackingResults (TR) structure, which 
itself is an array of SMD structures, where each array element is an 
SMD structure that corresponds to a single trajectory.

TR structures are organized as follows: each
structure element corresponds to a single trajectory, i.e., TR(n)
contains all relevant properties of the nth trajectory. The TR
structure is intended to carry all necessary information from an SMD
structure (see [smi_core.SingleMoleculeData](../DataStructures/SMD.md)),
but organized in a more user-friendly manner for SPT data.

The TrackingResults structure can be used for subsequent downstream 
data analysis of each trajectory contained in the TR structure, 
e.g., estimating diffusion, HMM analysis, etc.
(see [code examples](../../MATLAB/examples/README.md)).

Single particle tracking in ***smite*** also utilizes the SMF 
(Single Molecule Fitting) structure as described in the
[SMLM writeup](SMLM.md).

Parameters can be modified either in a script for batch tracking of
multiple files (see, for example,
[Example_SPTBatch.m](../../MATLAB/examples/Example_SPTBatch.m))
or through the SPT GUI.

#### Graphical User Interface (GUI) Parameters:

The ***smite*** SPT GUI allows for advanced single particle trajectory
analysis without any programming experience. In this extended example,
we present detailed step-by-step protocols on how to create a TR
structure by either creating a new SMF structure from raw data or
by importing a previously created SMF structure as described in
[SMLM writeup](SMLM.md).

The ***smite*** SPT GUI can be initialized by typing the command `smi.SPT()` 
in MATLAB. 

Figure 1 shows the main SPT GUI Tracking tab interface to create a
TR structure.
*(All other tabs for creating an SMF structure in the SPT GUI are exactly the
same as in the description of the [SMLM GUI](SMLM.md).)*

The components for tracking single molecule data from the SMF structure 
either from a script or through the GUI is briefly explained here.
*(Note that most GUI elements have a tool tip: hover with the mouse over
to the control to display it.)*

<IMG SRC="SPT1.png" WIDTH=50% HEIGHT=50%><BR>Figure 1. **Tracking** tab.

**Tracking:**     {SPT}

- **Method**:     Method used for tracking. CostMatrix can only be selected as
                  of now. (Default='CostMatrix')
- **D**:          Diffusion Constant (Pixels^2/Frame)  - The known or
                  anticipated diffusion constant of emitters in the raw data.
                  (Default=0.01).
- **TrajwiseD**:  Use traj.-wise value for D (logical) - This allows
                  for trajectory-wise estimated diffusion constants when
                  iteratively tracking. "NIterMax" or "NIterMaxBatch" must be 2
                  or higher. (Default=true)
- **K_on**:       Off to On Rate (Frame^-1) - The known or anticipated rate at
                  which dark emitters become fluorescent, or return from a dark
                  state (e.g., rate at which an out of focus emitter comes intoi
                  view). (Default=.9)

- **K_off**:      On to Off Rate (Frame^-1) - The known or anticipated rate at
                  which emitters transition to a dark state. (Default=.1)

- **MaxDistFF**:  Maximum distance gap for frame-to-frame connection (Pixels) -
                  The maximum separation between localizations such that they
                  can still be considered candidates for the frame-to-frame
                  connection procedure. (Default=5)
- **MaxDistGC**:  Maximum distance gap for Gap Closing (Pixels) - The maximum
                  separation between localizations such that they can still be
                  considered candidates for the gap closing procedure.
                  (Default=10)
- **MaxFrameGap**:Maximum frame gap for Gap Closing (Pixels) - The maximum
                  number of frames elapsed between localizations such that they
                  still can be considered candidates for the gap-closing
                  procedure. (Default=10)
- **MinTrackLength**: Minimum track length of trajectory (Frames) - The minimum
                  number of observations (localizations) a trajectory must have
                  to not be culled after tracking. (Default=3)
- **MaxZScoreDist**:  Max. abs(z-score) x/y jump size - The maximum z-score for
                  jump sizes allowed for trajectory connections. (Default=inf)
- **MaxZScorePhotons**: Max. abs(z-score) for photon diffs. - The maximum
                  z-score for photon differences allowed for trajectory
                  connections. (Default=inf)
- **NIterMax**:   Max. number of iterative tracking attempts (Integer) - The
                  maximum number of iterations permitted if iteratively
                  tracking. (Default=5)
- **NIterMaxBatch**:  Max. number of batch tracking iterations (Integer) - The
                  maximum number of iterations permitted if iteratively
                  tracking over batches. (Default = 5)
- **MaxRelativeChange**: Max. relative param. change to end iterations - The
                  maximum relative change in parameters allowed before ending
                  iterative tracking.(Default = 1e-5)
- **TryLowPValueLocs**: Try to incorporate low p-val. locs. - This allows to
                  track with localizations that were thresholded based on on
                  their p-value. If those localizations are incorporated into
                  trajectories - they are kept, otherwise they are discarded. 
                  (Default=false)

### Single Particle Tracking in ***smite*** walkthrough:

1. Create an SMF structure from raw data as described in the
   [SMLM writeup](SMLM.md) or by importing a previously created SMF structure.
   It is imperative for single particle tracking that the single molecule
   fitting is capturing all wanted emitters throughout the frames being
   analyzed. This can be insured by clicking the "Test Fit" button in
   either the SMLM or SPT GUI. *(Note: Make sure the "Frame Connection"
   is **off**, when performing the Test Fit.)* Various histograms will pop
   up, helping the user optimize their fitting parameters.

<IMG SRC="SPT2.PNG" WIDTH=50% HEIGHT=50%><BR>Figure 2. **Test Fit Output.**

2. The tracking tab in the SPT GUI allows the user to adjust the trajectory 
   creation parameters. To test the parameters selected, the user simply has
   to click the "Test Track" button. *(Note: Make sure "Frame Connection" is
   on.)*

<IMG SRC="SPT3.PNG" WIDTH=50% HEIGHT=50%><BR>Figure 3. **Test Track Image.**

3. Additionally, movies can be created and saved displaying the overlay of the
   tracking results on top of the raw data by clicking the "Movie GUI" button.
   Tracking results can easily be visualized across the entire sequence.

<IMG SRC="SPT4.PNG" WIDTH=50% HEIGHT=50%><BR>Figure 4. **Movie GUI Image.**

4. Once satisfied with the parameters, the user simply has to click the
   "Track" button on the the Tracking tab (see Figure 1).

For batch tracking multiple raw-data files, the user can then adjust
the tracking parameters described above into a script such as
[Example\_SPTBatch.m](../../MATLAB/examples/Example_SPTBatch.m).

Single particle tracking from multiple channels can be accomplished by
importing channel registration results into the script or using the GUI.  

## Tips

Ensuring the SMF structure created is capturing all emitters wanted
from the raw data, by using the SMLM or SPT GUI, is perhaps the most
important step of single particle tracking. Adjusting the SMF parameters
using the "Test Fit" button in the SMLM or SPT GUI allows for quickly
modifying the SMF parameters.

The estimated diffusion constant in pixel^2/frame is constantly iterated
on if TrajwiseD is true.

The "Test Track" button in the GUI makes it easy to adjust the parameters
quickly and see the trajectory overlay on top of the raw data immediately.
This is very helpful if there are multiple files to track.

Once parameters are optimized for the modality being analyzed, it is easy
to modify and save a script for processing multiple files from that modality.

FrameConnection must be on for tracking multiple frames.

./doc/ExtExamples/SMLM.md
### SMLM GUI

A comprehensive software platform for single-molecule localization
microscopy's raw data fitting and subsequent analysis. 

#### Graphical User Interface (GUI) Parameters:

The ***smite*** GUI allow advanced data analysis without any programming
experience. In this guide, we present detailed step-by-step protocols on
how to analyze SMLM data using ***smite***. The ***smite*** GUI can be
initialized by typing the command `smi.SMLM()` in MATLAB. Figure 1 shows
the main SMLM Interface. Note that most GUI elements have tool tips:
hover with the mouse over to the control to display it. The components
of the GUI are briefly explained here:

1. **Data:**  In this part of the GUI, a data file can be imported. We
   provide two different functionalities for data anaysis. One is *Test fit*
   in which a single dataset is processed for a quick idea of how well the
   analysis parameters work; the other is *Full fit* which does a complete
   analysis of all datasets.

    - **FileName**: Name of the raw data file you wish to analyze. Files
      can be selected by the button `Select File(s)`
    - **FileDir**: Name of directory containing the raw data file
    - **ResultsDir**: Name of directory in which results will be saved
    - **Analysis ID**: Optional identifier to be tagged onto the filenames
      of saved results
    - **FileType**: Type of raw data file, e.g., mat or h5
    - **DataVariable**: Name of variable in raw data .mat file(s) containing
      the data
    - **DatasetList**: Array specifying the dataset number(s) to be analyzed
    - **DatasetMods**: This drop-down menu allows you to include/exclude
      specific datasets from analysis
    - **CameraType**: The type of a camera used to collect raw data. The
      drop-down menu includes *EMCCD* and *SCMOS* cameras.  **NOTE**: The next
      3 quantities (**CameraGain**, **CameraOffset**, **CameraReadNoise**)
      should be scalars if the **CameraType** is *EMCCD* while if *SCMOS*,
      square arrays taken from the
      [CalibrationFile](../FileFormats/CalibrationFile.md)
      located at the **CalibrationFilePath**
    - **CameraGain**: Gain of a camera used to collect raw data 
    - **CameraOffset**: Offset of a camera used to collect raw data
    - **CameraReadNoise**: Variance of the read-noise of a camera used to
      collect raw data
    - **CalibrationFilePath**: Path to camera calibration file to be used;
      see [CalibrationFile](../FileFormats/CalibrationFile.md)
    - **RegistrationFilePath**: Path to channel registration file containing
      a transform applied to the data.
    - **DataROI**: Region-of-Interest of camera (optional)
    - **FrameRate**: Acquisition frame rate of a camera used to collect raw data
    - **PixelSize**: Pixel size of a camera used to collect raw data,
      back-projected to the objective focal plane (um)
    - **SEAdjust**: Standard error inflation applied to each localization

* In the GUI, we have different buttons whose functionality is provided below:

    - **Import SMF**: This button allows you to import an SMF structure
      saved in a .mat file
    - **Export SMF**: This button allows you to export the current settings
      displayed in this GUI to an SMF structure in a .mat file
    - **Reset SMF**: This button allows you to reset current settings to their
      default values defined in the `smi_core.SingleMoleculeFitting` class

<IMG SRC="SMLM1.png" WIDTH=50% HEIGHT=50%><BR>Figure 1. **Data** tab.

2. **BoxFinding:** Box finding finds and collates subregions of local
   maxima from a stack of 2D images. Local maxima are used as the center
   of ROIs if the estimated single molecule intensity is greater than
   MinPhotons. The fields are:

    - **BoxSize**: Linear box size for fitting (pixels)
    - **BoxOverlap**: Overlap of boxes (pixels)
    - **MinPhotons**: Minimum number of photons allowed from an emitter.

<IMG SRC="SMLM2.png" WIDTH=50% HEIGHT=50%><BR>Figure 2. **BoxFinding** tab.

3. **Fitting:** Fits a 2D Gaussian blob model to the each image in a
   stack of 2D images. The fields are:

    - **PSFSigma**: Known or initial PSF Sigma (pixels) which can be scalar
      or an array [SigmaX SigmaY]
    - **FitType**: In the GUI, several fit types ('XYNB', 'XYNBS', 'XYNBSXSY',
      'XYZNB') are available. Here X & Y are lateral and Z is the axial
      dimension, N is number of photons, B is background, S is the PSF
      sigma, and SX & SY are standard errors (uncertainty) in the lateral
      dimensions
    - **NParams**: Number of fitting parameters based on the chosen FitType
      (user does not need to set this)
    - **Iterations**: Newton-Raphson iterations
    - **ZFitStruct**: Structure for astigmatic fitting with fields in
      drop-down menu.

<IMG SRC="SMLM3.png" WIDTH=50% HEIGHT=50%><BR>Figure 3. **Fitting** tab.

4. **Thresholding:** This part of the GUI thresholds localizations based
   on various set properties of the localizations. The thresholding can be
   set On in the start. The fields are:
    
    - **MaxXY_SE**: Maximum value of X or Y standard error of localizations
      retained after thresholding
    - **MaxZ_SE**: Maximum value of Z standard error of localizations retained
      after thresholding
    - **MinPValue**: Minimum value of the p-value of localizations retained
      after thresholding. In this context, p-value is bigger for good
      localizations and smaller for bad localizations
    - **AutoThreshLogL**: Automatically select threshold for log-likelihood
      using the triangle method and use it in place of MinPValue threshold
    - **AutoThreshPrctile**: Percentile of extrema of log-likelihood thrown
      out before computing auto-threshold when using AutoThreshLogL
    - **MinPSFSigma**: Minimum value of PSF sigma of localizations retained
      after thresholding
    - **MaxPSFSigma**: Maximum value of PSF sigma of localizations retained
      after thresholding
    - **MinPhotons**: Minimum number of photons in localizations retained
      after thresholding
    - **MaxBg**: Maximum number of background photons in localizations
      retained after thresholding
    - **InMeanMultiplier**: Intensity mean multiplier defining maximum
      photons allowed to retain a localization
    - **NNMedianMultiplier**: Standard error mean multiplier defining the
      acceptance region for counting numbers of neighbours (only suggested
      to use for DNA-PAINT data)
    - **MinNumNeighbors**: In conjunction with NNMedianMultiplier, the
      minimum number of neighbors that must be in acceptance region to
      retain a localization (only suggested to use for DNA-PAINT data)

<IMG SRC="SMLM4.png" WIDTH=50% HEIGHT=50%><BR>Figure 4. **Thresholding** tab.

5. **FrameConnection:** In this part of the GUI, frame connection is
   performed on the data in an single molecule data (SMD) structure. The
   frame connection can be set On in the start. The fields are:

    - **Method**: Several methods are available to connect repeate
      localizations of the same emitter on events
    - **MaxSeparation**: Maximum separation between two localizations such
      that they can be still considered candidates for frame connection
    - **LoS**: Level of Significance compared to p-values computed in
      frame-connection procedure. In this context, a lower value of LoS
      corresponds to a more liberal connection of localizations
    - **MaxFrameGap**: Maximum number of frames separating two localizations
      in time such that they can still be considered candidates for frame
      connection
    - **NSigmaDev**: Localization error multiplier used to set pre-clustering
      separation threshold when the LAP-FC frame-connection method is
      selected
    - **NNearestClusters**: Number of nearest clusters used in local emitter
      density estimation when the LAP-FC frame-connection method is
      selected
    - **NIterations**: Number of iterative calls to LAP-FC algorithm when
      the LAP-FC frame-connection method is selected. With each iteration,
      internal parameters are re-estimated from the previous iteration's
      results
    - **MinNFrameConns**: Do not retain localizations representing fewer
      frame connection sequences (only suggested to use for DNA-PAINT data)

<IMG SRC="SMLM5.png" WIDTH=50% HEIGHT=50%><BR>Figure 5. **FrameConnection** tab.

6. **DriftCorrection:** This GUI screen is use to correct drift on 2D
   or 3D data provided in an SMD structure. Drift correction can be set On
   in the start.

    - **Method**: This drop-down menu provide couple of methods needed to
      correct emitter drift.
    - **BFRegistration**: This indicate whether or not bright field
      registration was performed during data collection. If bright field
      registration was performed then user can set this logical value to on
    - **L_intra**: Intra-dataset threshold (pixel)
    - **L_inter**: Inter-dataset threshold (pixel)
    - **PixelSizeZUnit**: This is X/Y pixel size in microns (only needed
      for 3D drift correction)
    - **PDegree**: Degree of the intra-dataset fitting polynomial for drift rate

<IMG SRC="SMLM6.png" WIDTH=50% HEIGHT=50%><BR>Figure 6. **DriftCorrection** tab.

./doc/ExtExamples/BaGoL.md
## BaGoL (Bayesian Grouping of Localizations)

This [example](BaGoL_EGFR_dSTORM.m) is slightly modified (`EGF = BaGoL;`
replaced by `EGF = smi.BaGoL;`) from the BaGoL distribution example of
the same name found at
[https://github.com/LidkeLab/BaGoL](https://github.com/LidkeLab/BaGoL)
(under Software).  Two other examples of running BaGoL and expected results
can be found there as well.  This software can also be found in *Code Ocean*:

> Mohamadreza Fazel, Michael J. Wester, David J. Schodt, Sebastian Restrepo
Cruz, Sebastian Strauss, Florian Schueder, Thomas Schlichthaerle, Jennifer M.
Gillette, Diane S. Lidke, Bernd Rieger, Ralf Jungmann, Keith A. Lidke,
"BaGoL (Bayesian Grouping of Localizations) [Source Code]",
*Code Ocean*, November 10, 2022,
[https://codeocean.com/capsule/de6769fd-f009-492d-9055-4c694848b128/](https://codeocean.com/capsule/de6769fd-f009-492d-9055-4c694848b128/)
(DOI: 10.24433/CO.3605166.v1).

Details on [BaGoL properties](../../MATLAB/+smi/@BaGoL/README.md) used in
the above example are described more fully, along with a list of BaGoL methods.

In addition,
[MATLAB/examples/hierBaGoL_wrapper](../../MATLAB/examples/hierBaGoL_wrapper.m)
is a script for processing multiple hierarchical BaGoL datasets or
splitting a single dataset into multiple previously defined ROIs.
See the [summary](hierBaGoL_wrapperSummary.md) for further details.

---

A full reference to the BaGoL paper:

> Mohamadreza Fazel, Michael J. Wester, David J. Schodt, Sebastian Restrepo
Cruz, Sebastian Strauss, Florian Schueder, Thomas Schlichthaerle, Jennifer M.
Gillette, Diane S. Lidke, Bernd Rieger, Ralf Jungmann and Keith A. Lidke,
"High-Precision Estimation of Emitter Positions using Bayesian Grouping of
Localizations" *Nature Communications*, Volume 13, Number 7152,
November 22, 2022, 1--11,
[https://www.nature.com/articles/s41467-022-34894-2](https://www.nature.com/articles/s41467-022-34894-2)
(DOI: 10.1038/s41467-022-34894-2).

### Abstract

Single-molecule localization microscopy super-resolution methods rely
on stochastic blinking/binding events, which often occur multiple times
from each emitter over the course of data acquisition. Typically, the
blinking/binding events from each emitter are treated as independent
events, without an attempt to assign them to a particular emitter. Here,
we describe a Bayesian method of inferring the positions of the
tagged molecules by exploring the possible grouping and combination
of localizations from multiple blinking/binding events. The results are
position estimates of the tagged molecules that have improved localization
precision and facilitate nanoscale structural insights. The Bayesian
framework uses the localization precisions to learn the statistical
distribution of the number of blinking/binding events per emitter and
infer the number and position of emitters. We demonstrate the method on
a range of synthetic data with various emitter densities, DNA origami
constructs and biological structures using DNA-PAINT and dSTORM data. We
show that under some experimental conditions it is possible to achieve
sub-nanometer precision.

./doc/ExtExamples/BaGoL_EGFR_dSTORM.m
%% Bayesian Grouping of Localizations (BaGoL) Example for dSTORM EGFR
%  BaGoL is run for a region of the data using hierarchical  
%  Bayes to find the distribution of the number of localizations per  
%  emitter (Xi) from the data itself. In the second run of BaGoL, the entire 
%  region is processed using the found distribution as an input.
%
% Requirements and Setup:
%   1. Windows 64 bit OS
%   2. MATLAB 2017b or higher versions
%   3. Statistics and Machine Learning Toolbox
%   4. BaGoL class
%   5. Set MATLAB directory to BaGoL directory.
%
% Description of how to run...
%   1. Set the parameters in the following section
%   2. Set a cutoff for filtering too bright localizations 
%   3. Select a region of data to learn Xi.
%   4. Set the parameter 'DataROI' for the entire data set to be processed.
%
% Results include:
%   Saved Results:
%     SR_Im.png:                 Traditional super-resolution image. 
%     Post-Im.png:               Posterior image or histogram image of the chain
%                                (weighted average over all models).
%     MAPN-Im.png:               MAPN image which is the image of localizations from the
%                                most likely model. 
%     Overlay_SR_Map.png:        Overlay of grayscale SR-image and color MAPN image.
%     Overlay_SR_Post.png:       Overlay of grayscale SR-image and color posterior image. 
%     Overlay_SR_Map_circle.png: Overlay of the SR & MAPN coordinates where 
%                                every coordinate is represented by a circle  
% 		                         located at the given location and a radius 
%                                of double of the given precision.
%     Xi.png:                    Number of localizations per emitter dist.
%     NND.png:                   Histogram of nearest neighbor distances from
%                                MAPN-coordinates. 
%     BaGoL_X-SE.png:            Histogram of X-localization precisions after grouping. 
%     BaGoL_Y-SE.png:            Histogram of Y-Localization precisions after grouping.
%     LocsScatter-MAPN.fig:      Plot of time color-coded localizations and
%                                MAPN-coordinates.
%     MAPN.mat:                  Structure containing the MAPN-coordinates of emitters.
%   Output available on work space:
%     MAPN: Clusters information are stored in this property:
%     MAPN.X: X-Centers (nm)
%     MAPN.Y: Y-Centers (nm)
%     MAPN.X_SE: X-Centers precisions (nm)
%     MAPN.Y_SE: Y-Centers precisions (nm)
%     MAPN.AlphaX: X-Drifts of clusters (nm/frame)
%     MAPN.AlphaY: Y-Drifts of clusters (nm/frame)
%     MAPN.AlphaX_SE: X-Drift precisions (nm/frame)
%     MAPN.AlphaY_SE: Y-Drift precisions (nm/frame)
%     MAPN.Nmean: Mean number of binding events per docking strand

warning('OFF', 'stats:kmeans:FailedToConvergeRep');

%% Important Parameters

PixelSize = 97;   % (nm)
IntensityCutoff = 4000; %Intensity cutoff (double of the main intensity peak)
PrecCorrect = 0.75; %Precision inflation. Added to X_SE, Y_SE (nm)
ClusterDrift = 0; %No cluster drift
ROIsz = 200; %ROI size (nm)
OverLap = 15; %Size of overlapping region (nm)
SaveDir = fullfile('Results_EGFR'); %Saving Directory
if ~isdir(SaveDir)
    mkdir(SaveDir); 
end
%% Load data
DataDir = fullfile('Data');
FileName = 'SMR_dSTORM_EGFR';
load(fullfile(DataDir,FileName))

%% Remove bright localizations that are likely to be more than one emitters 
IndP = SMR.Photons < IntensityCutoff;

%% First run: Estimating Xi using hierarchical Bayes
Xi = [1 6]; %[gamma,etha] parameters for gamma prior.
DataROI = [110 134 110 134]; %Region to find Xi (pixel) [XStart XEnd YStart YEnd]

Ind = SMR.X >= DataROI(1) & SMR.X < DataROI(2) & SMR.Y > DataROI(3) & SMR.Y < DataROI(4) & IndP;
SMD = [];
SMD.X = PixelSize*SMR.X(Ind); %Converting units from pixel to nm
SMD.Y = PixelSize*SMR.Y(Ind); %Converting units from pixel to nm
SMD.Z = [];
SMD.X_SE = PixelSize*SMR.X_SE(Ind)+PrecCorrect; %Converting units from pixel to nm
SMD.Y_SE = PixelSize*SMR.Y_SE(Ind)+PrecCorrect; %Converting units from pixel to nm
SMD.Z_SE = [];
SMD.FrameNum = SMR.Nframes*single((SMR.DatasetNum(Ind)-1))+single(SMR.FrameNum(Ind));

%Setting the class properties
EGF = smi.BaGoL;
EGF.SMD = SMD;
EGF.ROIsize = ROIsz; %size of the subregions to be processed
EGF.Overlap = OverLap; %Overlapping region size between the adjacent regions.
EGF.Xi = Xi; %Parameters for prior distribution (gamma in this case)
EGF.N_Burnin = 2000; %Length of Burn-in chain
EGF.N_Trials = 3000; %Length of post-burn-in chain
EGF.ChainFlag = 0; %Save the chain
EGF.Drift = ClusterDrift; %No cluster drift;
EGF.HierarchFlag = 1; %Flag indicating to learn Xi
EGF.Cutoff = 50;
EGF.PixelSize = 2;

%Analyzing the data
EGF.analyze_all();

%% Adjusting the class properties for the second run, using results from the
% first run to fix \xi for the second run

DataROI = [110 158 110 158]; %Region to analyze (pixel) [XStart XEnd YStart YEnd]
ImSize = (DataROI(2)-DataROI(1))*PixelSize;
XStart = DataROI(1)*PixelSize;
YStart = DataROI(3)*PixelSize;
PixSZ = 2; %Pixel size of the output images (nm)

%Populating SMD with localizations from the selected region.

Ind = SMR.X >= DataROI(1) & SMR.X < DataROI(2) & SMR.Y > DataROI(3) & SMR.Y < DataROI(4) & IndP;
SMD = [];
SMD.X = PixelSize*SMR.X(Ind); %Converting units from pixel to nm
SMD.Y = PixelSize*SMR.Y(Ind); %Converting units from pixel to nm
SMD.Z = [];
SMD.X_SE = PixelSize*SMR.X_SE(Ind)+PrecCorrect; %Converting units from pixel to nm
SMD.Y_SE = PixelSize*SMR.Y_SE(Ind)+PrecCorrect; %Converting units from pixel to nm
SMD.Z_SE = [];
SMD.FrameNum = SMR.Nframes*single((SMR.DatasetNum(Ind)-1))+single(SMR.FrameNum(Ind));

%Ajusting the class properties
EGF.SMD = SMD;
EGF.Xi = [1,mean(prod(EGF.XiChain'))]; %Mean number of blinking estimated from the former section
EGF.N_Burnin = 2000; %Length of Burn-in chain
EGF.N_Trials = 3000; %Length of post-burn-in chain
EGF.PImageSize = ImSize; %size of the posterior image
EGF.PixelSize = PixSZ; %Pixel size for the posterior image
EGF.PImageFlag = 1; %Producing the posterior image
EGF.XStart = XStart;
EGF.YStart = YStart;
EGF.HierarchFlag = 0;

%Analyzing the data
tic;
EGF.analyze_all();
T = toc();
fprintf('It took %g seconds to process the selected region of dSTORM EGFR data.\n',T)

%Generating output plots and images.
ScaleBar = 1000; %length of scale bars (nm)
EGF.saveBaGoL(ScaleBar,SaveDir);
EGF.plotMAPN(SaveDir)

RadiusScale = 2;
BaGoL.genSRMAPNOverlay(EGF.SMD, EGF.MAPN, ImSize, ImSize, PixSZ, SaveDir, ...
                       XStart, YStart, RadiusScale, ScaleBar);

%NND from EGFR vs NND of randomly distributed data.
[~,D]=knnsearch([EGF.MAPN.X,EGF.MAPN.Y],[EGF.MAPN.X,EGF.MAPN.Y],'k',2);
Dis = D(:,2);
figure('Visible','off');histogram(Dis(Dis<4*median(Dis)),'normalization','pdf','BinEdges',0:2:250)
Rho = length(EGF.MAPN.X)/(ImSize*ImSize);
X = 0:0.1:250;
Y = 2*pi*Rho*X.*exp(-pi*Rho*X.^2);
hold;plot(X,Y,'r','linewidth',1.5)
xlabel('NND(nm)');ylabel('PDF')
legend('Found-NND','Random-NND')
xlim([0 250]);ylim([0 0.050])
set(gca,'FontSize',15)
print(gcf,fullfile(SaveDir,'NND-Hist+Random'),'-dpng')

./doc/ExtExamples/hierBaGoL_wrapperSummary.md
### hierBaGoL_wrapper Summary

[examples/hierBaGoL_wrapper](../../MATLAB/examples/hierBaGoL_wrapper.m)
is a script for processing multiple hierarchical BaGoL datasets or
splitting a single dataset into multiple previously defined ROIs.
It calls
[smi.BaGoL.hierBaGoL_run](../../MATLAB/+smi/@BaGoL/hierBaGoL_run.m)
which runs one or more BaGoL analyses, calling
[smi.BaGoL.hierBaGoL_analysis](../../MATLAB/+smi/@BaGoL/hierBaGoL_analysis.m)
on each individual dataset to be processed, so acting as a dispatch
intermediary.  A single dataset is run directly, while a set of datasets
(which could be a single dataset split into multiple ROIs) are run in
parallel using a parfor loop.  hierBaGoL_analysis.m is adapted from a
version of BaGoL_EGFR_dSTORM.  hierBaGol_wrapper was designed to be
the only routine that the user needs to interact with, but new features
should regard this flow.

A basic description is as follows:

Script to produce BaGoL results from SMITE \*\_Results.mat files.  The BaGoL
results are placed in the subdirectory Results_BaGoL, assigned a name below,
under the directory containing the \*\_Results.mat files.  hierBaGoL_analysis
is called separately on each file in a parfor loop, assigning a worker for
each dataset, so conducive to be run on a multi-core machine.
The wrapper sets parameters and lists files (full paths) to be analyzed and
optional ROIs to apply in the next to last section.

For \_Results.mat files with large numbers of localizations (> 300,000 or so),
hierBaGoL may crash (or partially crash), so should not be part of a parfor
loop as a crash will cause ALL of the non-finished parallel jobs to restart.
Such \_Results.mat files should be analyzed in separate MATLABs.

NOTE: MAPN\_\*.mat files are always produced containing simply the MAPN
coordinates.  See
[smi.BaGoL.hierBaGoL_analysis](../../MATLAB/+smi/@BaGoL/hierBaGoL_analysis.m)
for more details on files produced.

If the variable ROIs is true and only one filename is provided (see below),
and assuming SMD files are of the form Cell_nn_Label_0n_Results.mat and ROI
files are of the form Cell_nn_Label_01_Results_ROIs.mat (and are located
in the subdirectory 'Analysis' of DataDir) as done when choosing ROIs using
the scripts
[examples/simpleROIcluster](../../MATLAB/examples/simpleROIcluster.m) or
[examples/simplePairCorr](../../MATLAB/examples/simplePairCorr.m),
this current script will
automatically use the ROI information in the \_ROIs.mat file to produce a
series of individual analyses for each ROI which smi.BaGoL.hierBaGoL_run will
parallelize via a parfor loop.  The set of analyses will take on names of the
form Cell_nn_Label_0n_Results_ROI_mm.
[smi_cluster.PairAnalysis.overlayBaGoLROIs](../../MATLAB/+smi_cluster/@PairAnalysis/overlayBaGoLROIs.m)
is a useful function for plotting the ROIs produced by this process,
both 1-color and 2-color.

---

An example input file structure with `ROIs = true;` and 2 ROIs selected
previously:
```
DATA/
  ResultsStructs/
    Cell_02_Label_01_Results.mat'
    Analysis/
      Cell_02_Label_01_Results_ROIs.mat'
```
results in these files:
```
      BaGoL_Results_Cell_02_Label_01_Results_ROI_01_ResultsStruct.mat
      BaGoL_Results_Cell_02_Label_01_Results_ROI_02_ResultsStruct.mat
      MAPN_Cell_02_Label_01_Results_ROI_01.mat
      MAPN_Cell_02_Label_01_Results_ROI_02.mat
      Cell_02_Label_01_Results_ROI_01/
        BaGoL_X-SE.png
        BaGoL_Y-SE.png
        FULL.png
        LocsScatter-MAPN.fig
        MAPN.mat
        MAPN-Im.png
        MAPN_NmeanHist.png
        NND.png
        NNDScaledData.png
        NNDScaledRandom.png
        NND.txt
        Overlay_cPost_rMap.png
        Overlay_gSR_bPost_rMap.png
        Overlay_gSR_mMap.png
        Overlay_gSR_mPost.png
        Overlay_SR_Map_circle.png
        Post-Im.png
        prior.txt
        ROI.png
        SR-Im.png
        Xi.png
        XiChain.png
      Cell_02_Label_01_Results_ROI_02/
        ...
```
- The scale bar throughout is 500 nm.
- FULL.png and ROI.png are the SR localizations in the full cell and the ROI,
  respectively.
- Overlay_cPost_rMap: posterior localizations are colored cyan and MAPN red.
- Overlay_gSR_bPost_rMap: SR, posterior and MAPN localizations are colored
  green, blue and red, respectively.
- Overlay_gSR_mMap: SR localizations are colored green and MAPN magenta.
- Overlay_SR_Map_circle use the same color scheme as above (SR: green, MAPN:
  magenta) and plots circles instead of Gaussian blobs where the radii of the
  circles are proportional to the standard error (SE) of the localizations.
- prior.txt is the estimated prior for a second run of the data, which is not
  needed in hierarchical BaGoL.

---

Suggested pre-filtering actions (frame connection and NN not used for dSTORM
data) [NOTE that the middle four actions should be performed during the SMLM
analysis, e.g., Publish]:
```
SR data -> remove localizations with negative coordinates
           [smi_helpers.Filters.filterNonNeg called by hierBaGoL_analysis]
        -> intensity filter [SMF.Thresholding.InMeanMultiplier]
        -> inflate standard errors [SMF.Data.SEAdjust]
        -> frame connection, removing connections which involve only a
           specified number of frames [SMF.FrameConnection.MinNFrameConns]
        -> Nearest Neighbor filter (N_NN) --- Do not use on dSTORM data!
           [SMF.Thresholding.NNMedianMultiplier,
            SMF.Thresholding.MinNumNeighbors]
        -> BaGoL (via parfor calling hierBaGoL_analysis on each dataset)
```
The pre-filtering (except for removing negative coordinates) is all now in
SMLM, although SE_Adjust can be set here as well.

---

hierBaGoL_wrapper collects together important BaGoL parameters in the
structure `BaGoLParams`.  These (along with some important local
parameters) are:
```
% Output directory name.
Results_BaGoL = 'Results_BaGoLHier';

% Generic parameters.
BaGoLParams.ImageSize = 256;        % (pixel)
%BaGoLParams.PixelSize = 108.018;    % camera back projected size (nm) [TIRF]
BaGoLParams.PixelSize = 97.8;       % (nm) [sequential]
BaGoLParams.OutputPixelSize = 4;    %2; % pixel size for posterior images (nm)
BaGoLParams.N_Burnin = 32000;       % Length of Burn-in chain
BaGoLParams.N_Trials = 8000;        % Length of post-burn-in chain
%BaGoLParams.N_Burnin = 8000;        % Length of Burn-in chain
%BaGoLParams.N_Trials = 2000;        % Length of post-burn-in chain
BaGoLParams.NSamples = 10;          % Number of samples before sampling Xi
BaGoLParams.ClusterDrift = 0;       % Expected magnitude of drift (nm/frame)

% Y_Adjust is sometimes needed to deal with lower left versus upper left
% y-origin issues.  Lower left with y increasing upwards is the default,
% requiring no changes, while upper left with y increasing downwards can
% sometimes occur, so Y must be replaced by Y - Y_Adjust, where Y_Adjust is the
% image size (see below) [pixels].
%BaGoLParams.Y_Adjust = BaGoLParams.ImageSize;
BaGoLParams.Y_Adjust = [];

% SE_Adjust adds to X_SE and Y_SE, so inflates the precision.  For DNA_PAINT
% data, SE_Adjust = 1--2 nm, while for dSTORM, slightly bigger values should
% be used.  Note that this quantity can be specified as an array of length
% n_files if applied differently to each file.
BaGoLParams.SE_Adjust = 0;          % Precision inflation applied to SE (nm)
%BaGoLParams.SE_Adjust = [0, 0];     % Precision inflation applied to SE (nm)

% The values for ROIsz and OverLap directly below are good overall for much
% data, but note that the larger the ROIsz, the more the computational effort.
% Artifacts in dense data can come about if the ROIsz is too large.  The
% pre-clustering cutoff should be around the localization precision.
BaGoLParams.ROIsz = 500;            % ROI size for RJMCMC (nm)
BaGoLParams.OverLap = 50;           % Size of overlapping region (nm)
BaGoLParams.Cutoff = 25;            % Pre-clustering cutoff (nm)
%BaGoLParams.ROIsz = 100;            % ROI size for RJMCMC (nm)
%BaGoLParams.OverLap = 25;           % Size of overlapping region (nm)
%BaGoLParams.ROIsz = 50;             % ROI size for RJMCMC (nm)
%BaGoLParams.OverLap = 10;           % Size of overlapping region (nm)

% k and theta below are the shape and scale parameters for the Gamma
% probability distribution function.  If just one parameter is provided,
% a Poisson distribution is used.
BaGoLParams.Xi = [20, 1];           % [k, theta] parameters for gamma prior

% Note for batch runs, in which Files and DataROI are input by hand, please see
% ### comments below.
BaGoLParams.DataROI = [];           % [Xmin, Xmax, Ymin, Ymax] (pixel)
DataROI = [];

% If ROIs is true, the input file has ROIs already defined (\*\_ROIs.mat),
% so use them below if only one filename is provided.
ROIs = false;
```
Results files (produced by SMLM analyis) to be batch-processed.
```
D1 = 'DATA';
Files = {
fullfile(D1, 'Cell_02_Label_01_Results.mat');
fullfile(D1, 'Cell_03_Label_01_Results.mat');
};
```
DataROI is used automatically when ROIs is true, so should be left commented
out in this situation, otherwise it can be helpful in downsizing the
computational effort needed for very dense datasets.
```
% DataROI is defined when running BaGoL over only part of the image.
% If DataROI is empty, use the whole image.
% 
% Define a single region of interest for each dataset (units are pixels).
% [YStart, XStart, YEnd, XEnd] = [163, 385, 233, 455]
% [Xmin, Xmax, Ymin, Ymax] (pixel)
% [385, 455, 163, 233]

%DataROI = [
%[120, 136, 190, 206]
%[110, 126,  90, 106]
%];
```

./doc/SMITEclasses.md
### smite namespaces and classes

|***SMITE*** classes|description|
-------------|---
[MATLAB/+smi](../MATLAB/+smi/README.md):
&nbsp;&nbsp;&nbsp;[@BaGoL/](../MATLAB/+smi/@BaGoL/README.md)                    | [Bayesian Grouping of Localizations](https://www.nature.com/articles/s41467-022-34894-2)
&nbsp;&nbsp;&nbsp;[@Publish/](../MATLAB/+smi/@Publish/README.md)                | batch processing of SR data
&nbsp;&nbsp;&nbsp;[@SMLM/](../MATLAB/+smi/@SMLM/README.md)                      | single molecule localization microscopy
&nbsp;&nbsp;&nbsp;[@SPT/](../MATLAB/+smi/@SPT/README.md)                        | single-particle tracking analysis
[MATLAB/+smi_cluster](../MATLAB/+smi_cluster/README.md):
&nbsp;&nbsp;&nbsp;[@Clustering/](../MATLAB/+smi_cluster/@Clustering/README.md)  | clustering algorithms (DBSCAN, Voronoi, H-SET)
&nbsp;&nbsp;&nbsp;[@ClusterInterface/](../MATLAB/+smi_cluster/@ClusterInterface/README.md)         | interface functions for Clustering class
&nbsp;&nbsp;&nbsp;[@PairAnalysis/](../MATLAB/+smi_cluster/@PairAnalysis/README.md)                 | interface functions for PairCorrelation class
&nbsp;&nbsp;&nbsp;[@PairCorrelation/](../MATLAB/+smi_cluster/@PairCorrelation/README.md)           | pair correlation (auto- and cross-) on ROIs
&nbsp;&nbsp;&nbsp;[@StatisticsClustering/](../MATLAB/+smi_cluster/@StatisticsClustering/README.md) | clustering statistical analyses
[MATLAB/+smi_core](../MATLAB/+smi_core/README.md):
&nbsp;&nbsp;&nbsp;[@ChannelRegistration/](../MATLAB/+smi_core/@ChannelRegistration/README.md)      | channel registration
&nbsp;&nbsp;&nbsp;[@DataToPhotons/](../MATLAB/+smi_core/@DataToPhotons/README.md)                  | convert raw data to photons
&nbsp;&nbsp;&nbsp;[@DriftCorrection/](../MATLAB/+smi_core/@DriftCorrection/README.md)              | [drift correction on 2D/3D data](https://www.nature.com/articles/s41598-021-02850-7)
&nbsp;&nbsp;&nbsp;[@FRC/](../MATLAB/+smi_core/@FRC/README.md)                   | Fourier Ring Correlation for image resolution
&nbsp;&nbsp;&nbsp;[@FindROI/](../MATLAB/+smi_core/@FindROI/README.md)           | find/collate subregions from a 2D image stack
&nbsp;&nbsp;&nbsp;[@FrameConnection/](../MATLAB/+smi_core/@FrameConnection/README.md)              | [frame connection](https://www.frontiersin.org/article/10.3389/fbinf.2021.724325)
&nbsp;&nbsp;&nbsp;[@LoadData/](../MATLAB/+smi_core/@LoadData/README.md)         | load raw microscope data from .mat/.h5 files
&nbsp;&nbsp;&nbsp;[@LocalizeData/](../MATLAB/+smi_core/@LocalizeData/README.md) | find localizations in raw data
&nbsp;&nbsp;&nbsp;[@SingleMoleculeData/](../MATLAB/+smi_core/@SingleMoleculeData/README.md)        | define SMD structure
&nbsp;&nbsp;&nbsp;[@SingleMoleculeFitting/](../MATLAB/+smi_core/@SingleMoleculeFitting/README.md)  | define SMF structure
&nbsp;&nbsp;&nbsp;[@Threshold/](../MATLAB/+smi_core/@Threshold/README.md)       | threshold based on various SMLM properties
&nbsp;&nbsp;&nbsp;[@TrackingResults/](../MATLAB/+smi_core/@TrackingResults/README.md)              | define Tracking Results (TR) structure
&nbsp;&nbsp;&nbsp;[GaussMLE.m](../MATLAB/+smi_core/README_GaussMLE.md)        | [max likelihood estimate of 2D Gaussian blobs](https://www.nature.com/articles/nmeth.1449)
[MATLAB/+smi_helpers](../MATLAB/+smi_helpers/README.md):
&nbsp;&nbsp;&nbsp;[@Filters/](../MATLAB/+smi_helpers/@Filters/README.md)        | filters useful for BaGoL operating on SMDs
&nbsp;&nbsp;&nbsp;[@ROITools/](../MATLAB/+smi_helpers/@ROITools/README.md)      | select ROIs from an image; save in a structure
[MATLAB/+smi_psf](../MATLAB/+smi_psf/README.md):
&nbsp;&nbsp;&nbsp;[@PointSpreadFunction/](../MATLAB/+smi_psf/@PointSpreadFunction/README.md)       | create and quantify point spread functions
&nbsp;&nbsp;&nbsp;[@Zernike/](../MATLAB/+smi_psf/@Zernike/README.md)            | low-level Zernike polynomial functions
[MATLAB/+smi_sim](../MATLAB/+smi_sim/README.md):
&nbsp;&nbsp;&nbsp;[@GaussBlobs/](../MATLAB/+smi_sim/@GaussBlobs/README.md)      | generate 2D Gaussian blob images
&nbsp;&nbsp;&nbsp;[@SimSMLM/](../MATLAB/+smi_sim/@SimSMLM/README.md)            | simulate SMLM data
&nbsp;&nbsp;&nbsp;[@SimSPT/](../MATLAB/+smi_sim/@SimSPT/README.md)              | simulate SPT data
[MATLAB/+smi_stat](../MATLAB/+smi_stat/README.md):
&nbsp;&nbsp;&nbsp;[@ChangeDetection/](../MATLAB/+smi_stat/@ChangeDetection/README.md)              | change detection analysis methods
&nbsp;&nbsp;&nbsp;[@DiffusionEstimator/](../MATLAB/+smi_stat/@DiffusionEstimator/README.md)        | diffusion estimation methods
&nbsp;&nbsp;&nbsp;[@HMM/](../MATLAB/+smi_stat/@HMM/README.md)                   | hidden Markov model methods
[MATLAB/+smi_vis](../MATLAB/+smi_vis/README.md):
&nbsp;&nbsp;&nbsp;[@GenerateImages/](../MATLAB/+smi_vis/@GenerateImages/README.md)                 | general visualization of super-resolution data
&nbsp;&nbsp;&nbsp;[@GenerateMovies/](../MATLAB/+smi_vis/@GenerateMovies/README.md)                 | generate movies
&nbsp;&nbsp;&nbsp;[@InspectResults/](../MATLAB/+smi_vis/@InspectResults/README.md)                 | inspect super-resolution data

See also the [Overview of Core Functionality](CoreOverview.md) for additional
details was well as links to a number of examples.

./doc/FileFormats/CalibrationFile.md
### Camera Calibration File

For quantitative analysis of single molecule localization microscopy
(SMLM) images, pixelwise properties of the camera must be well
characterized and accounted for in the analysis algorithm to avoid
artifacts. Offset and gain maps are considered the basis for numerous
camera correction algorithms. We collect the offset and gain maps
of sCMOS cameras and add them via the ***smite*** GUI or in an analysis
script by providing the path of a saved `CalibrationFile`.
We determine the mean ('offset'),
variance and amplification gain of each pixel of the signal over many
images at several light levels. Following are the necessary steps where
we use
[***MIC***](https://github.com/LidkeLab/matlab-instrument-control.git)),
[DIPimage](https://diplib.org/) and ***smite*** tools:

* Connect to the devices:

    1. Connect to camera:
    ```
    CameraSCMOS = MIC_HamamatsuCamera();
    CameraSCMOS.ReturnType = 'matlab';
    CameraSCMOS.gui();
    ```
    2. Connect to lamp:
    ```
    Lamp660 = MIC_ThorlabsLED('Dev1', 'ao0');
    Lamp660.gui();
    ```
* Define a few parameters: 
```
    LampPowerRange = linspace(0, 3.6, 20); % selected to reach ~600 max. camera counts
    CameraSCMOS.DefectCorrection = 1; % no correction
    CameraSCMOS.ScanMode = 1; % slow scan
    CameraSCMOS.ExpTime_Sequence = 0.01;
    CameraSCMOS.SequenceLength = 1000;
    CameraSCMOS.ROI = [897, 1152, 897, 1152]; % [XStart, XEnd, YStart, YEnd]
```
* Collect the gain/offset data:
```
    Params = [];
    MeanLevel = [];
    VarLevel = [];
    CameraSCMOS.AcquisitionType = 'sequence';
    CameraSCMOS.ExpTime_Sequence = 0.01;
    CameraSCMOS.setup_acquisition();
    for ii = 1:numel(LampPowerRange)
       fprintf('Lamp power %i of %i\n', ii, numel   (LampPowerRange))
       Lamp660.setPower(LampPowerRange(ii));
       pause(1)
       CameraSCMOS.start_sequence();
       MeanLevel = cat(3, MeanLevel, mean(CameraSCMOS.Data, 3));
       VarLevel = cat(3, VarLevel, var(single(CameraSCMOS.Data), [], 3));
    end
    Lamp660.setPower(0);
    Params.MeanLevel = single(MeanLevel);
    Params.VarLevel = single(VarLevel);
```
* Perform Least-Squares Fit on collected data:

    leastSquaresFit from smi_stat class performs a least squares (ls)
    fit on the provided data.
    This function computes a least squares fit for the paired data in
    XData, YData, and Weights. Check
    [`smi_stat.leastSquaresFit()`](../../MATLAB/+smi_stat/leastSquaresFit.m)
    for further documentation.
```
    % Here [:, :, 1] is ls offset, [:, :, 2] is ls slope (Gain)
    Beta = NaN(size(MeanLevel, 1), size(MeanLevel, 2), 2);
    for ii = 1:size(MeanLevel, 1)
       disp(ii)
       for jj = 1:size(MeanLevel, 2)
          Beta(ii, jj, 1:2) = smi_stat.leastSquaresFit(                   ...
             squeeze(MeanLevel(ii, jj, :)), squeeze(VarLevel(ii, jj, :)), ...
             1 ./ squeeze(VarLevel(ii, jj, :)));
       end
    end
    dipshow(Beta(:, :, 2))

    figure;
    histogram(Beta(:, :, 2))
    xlabel('Gain (ADU/e-)')

    figure;
    histogram(MeanLevel(:,:,1))
    xlabel('ADU')
    Params.CCDVar=single(VarLevel(:,:,1));
    Params.Gain=single(Beta(:,:,2));
    Params.CCDOffset=single(MeanLevel(:,:,1));
```
* Save the calibration:
```
    SaveDir = 'Y:\sCMOS Calibrations\Sequential SR';
    FileName = fullfile(SaveDir, ...
       ['GainCalibration-', smi_helpers.genTimeString()]);
    Params.CameraObj.ROI = CameraSCMOS.ROI;
    Params.LampPowerRange = single(LampPowerRange);
    save(FileName, 'Params', '-v7.3')
```
* Example camera calibration file:

```
   >> CalibrationFile.Params

   ans = 

     struct with fields:

                      MeanLevel: [25625620 single]
                       VarLevel: [25625620 single]
                 DarkImagesMean: [2562565 single]
                  DarkImagesVar: [2562565 single]
              DarkImagesExpTime: [0.0100 0.1325 0.2550 0.3775 0.5000]
       DarkImagesSequenceLength: 1000
                         CCDVar: [256256 single]
                        CCDGain: [256256 single]
                      CCDOffset: [256256 single]
                      CameraObj: [11 struct]
                 LampPowerRange: [120 single]
                           Gain: [256256 single]
```

./doc/FileFormats/HDF5.md
### HDF5 Data File Format (.h5 file)

An .h5 file is a type of the Hierarchical Data Formats (HDF) that is
used to store large, well-organized multidimensional data for quick
retrieval and analysis. `smite` extracts contents of an .h5 file into
H5Structure. The structure consists of the `Data` and `Attributes`
associated with each group. The data can be loaded and extracted. In
Figure 1, cell data is loaded.

<IMG SRC="H1.png" WIDTH=50% HEIGHT=50%><BR>Figure 1. Top-level view.

Each level of the HDF5 file hierarchy is named in the 'Groups'
structure. For the data included here, we have two layers:
/Channel01/Zposition001/.

<IMG SRC="H2.png" WIDTH=50% HEIGHT=50%><BR>Figure 2. Top 3 levels.

Zposition001/ contains various groups with their group attributes.

<IMG SRC="H3.png" WIDTH=50% HEIGHT=50%><BR>Figure 3. Zposition001 groups.

Zposition001/ can be further extracted.

<IMG SRC="H4.png" WIDTH=50% HEIGHT=50%><BR>Figure 4. Datasets 1 through 5.

As can be seen from the above figure, Data0001 is the 2D microscopy raw
data from the camera. A number of datasets can be written in the HDF5
file. The figure example only contain 5 datasets. The `LoadData` class in
`smite` has the functionality of loading and extracting further information
about HDF5 data.

<IMG SRC="H5.png" WIDTH=50% HEIGHT=50%><BR>Figure 5. Contents of Data0001.

`/Channel01/Zposition001/Data0001/Data0001` of size 2000 x 256 x 256
contains the raw data from the camera (arrays given in Analog to Digital Units
[ADU]) for 2000 frames of 256x256 (y, x) 2D images.

---

HDF5 files can be directly loaded into MATLAB.  As an example, to
access the images for Sample 1 located at

   https://datadryad.org/stash/dataset/doi:10.5061/dryad.xsj3tx9cn

run the following commands in MATLAB:

1) Find the number of sequences for a sample:  
```
   Info = h5info('LifeactApproach-HeLaCell-Sample1.h5')
```

2) Each level of the h5 file hierarchy is named in the 'Groups' structure.
For the data included here, we have two layers: /Channel01/Zposition001/.
To find the number of the sequence:
```
   Num_Dataset = numel(Info.Groups.Groups.Datasets)
```

3) To load a data set:
```
   DataSet_1 = h5read('LifeactApproach-HeLaCell-Sample1.h5', ...
                      '/Channel01/Zposition001/Data0001');
```

./doc/CoreOverview.md
## Overview of Core Functionality

***smite*** (Single Molecule Imaging Toolbox Extraordinaire) is a
collection of MATLAB tools developed to process, either through
GUIs or via batch, fluorescent single molecule imaging data.  This
data is typically collected into .h5 (Hierarchical Data Format 5)
files created by the sister software MATLAB Instrument Control
(**MIC**), a collection of MATLAB classes for automated data
collection on complex, multi-component custom built microscopes.
This software can be obtained from the **MIC** GitHub distribution
(https://github.com/LidkeLab/matlab-instrument-control.git).

***smite*** is organized into a set of namespaces that group similar
tools and concepts.  The namespace  `+smi`  contains the highest
level tools that will be the most common entry point for processing
SMLM and SPT data sets.

List of [***smite*** namespaces and classes](SMITEclasses.md).

The core functionality of ***smite*** (contained in the namespace
`+smi`) is
- [SMLM](../MATLAB/+smi/@SMLM/README.md) (Single Molecule Localization
  Microscopy), which processes 2D super-resolution (SR) data in
  [.h5 files](FileFormats/HDF5.md) with standard contents.  Data can also be
  stored in .mat files under a variable with a name like `sequence`;
- [Publish](../MATLAB/+smi/@Publish/README.md), which batch-processes
  SR data assuming the .h5 files follow a standard naming convention
  (obj.CoverslipDir/Cell\*/Label\*/Data\*.h5);
- [SPT](../MATLAB/+smi/@SPT/README.md) (Single Particle Tracking),
  which analyzes tracking data;
- [BaGoL](../MATLAB/+smi/@BaGoL/README.md) (Bayesian Grouping of
  Localizations) explores the possible number of emitters and their
  positions that can explain the observed localizations and
  uncertainties in the data.

Note: A [camera calibration file](FileFormats/CalibrationFile.md) is
used by SMLM (and hence Publish and SPT) as well.

Corresponding examples/extended examples are presented in:
- [\[SMLM\]](../MATLAB/examples/Example_SMLM_Basic.m)
  [\[SMLM_ExtendedExample\]](ExtExamples/SMLM.md)
- [\[Publish\]](../MATLAB/examples/Example_Publish.m)
  [\[Publish_ExtendedExample\]](ExtExamples/Publish.md)
- [\[SPT\]](../MATLAB/examples/Example_SPT.m)
  [\[SPT_ExtendedExample\]](ExtExamples/SPT.md)
- BaGoL (see below)
  [\[BaGoL_ExtendedExample\]](ExtExamples/BaGoL.md)
```
  B=BaGoL()       % create object
  B.SMD=....      % set properties
  B.analyze_all() % run complete analysis
```

In all the examples and throughout ***smite***, three main data
structures are used to organize the analysis parameters and data:
- [SMF](DataStructures/SMF.md) (Single Molecule Fitting), which
  uniquely and completely defines the data analysis parameters;
- [SMD](DataStructures/SMD.md) (Single Molecule Data), which stores
  the data results;
- [TR](DataStructures/TR.md) (Tracking Results), which is a variation
  of SMD used for tracking data results.

Many [further examples](../MATLAB/examples/README.md) demonstrate
various ***smite*** functionalities.

./paper/example.md
# See https://joss.readthedocs.io/en/latest/submitting.html
---
title: 'Gala: A Python package for galactic dynamics'
tags:
  - Python
  - astronomy
  - dynamics
  - galactic dynamics
  - milky way
authors:
  - name: Adrian M. Price-Whelan^[co-first author] # note this makes a footnote saying 'co-first author'
    orcid: 0000-0003-0872-7098
    affiliation: "1, 2" # (Multiple affiliations must be quoted)
  - name: Author Without ORCID^[co-first author] # note this makes a footnote saying 'co-first author'
    affiliation: 2
  - name: Author with no affiliation^[corresponding author]
    affiliation: 3
affiliations:
 - name: Lyman Spitzer, Jr. Fellow, Princeton University
   index: 1
 - name: Institution Name
   index: 2
 - name: Independent Researcher
   index: 3
date: 13 August 2017
bibliography: paper.bib

# Optional fields if submitting to a AAS journal too, see this blog post:
# https://blog.joss.theoj.org/2018/12/a-new-collaboration-with-aas-publishing
aas-doi: 10.3847/xxxxx <- update this with the DOI from AAS once you know it.
aas-journal: Astrophysical Journal <- The name of the AAS journal.
---

# Summary

The forces on stars, galaxies, and dark matter under external gravitational
fields lead to the dynamical evolution of structures in the universe. The orbits
of these bodies are therefore key to understanding the formation, history, and
future state of galaxies. The field of "galactic dynamics," which aims to model
the gravitating components of galaxies to study their structure and evolution,
is now well-established, commonly taught, and frequently used in astronomy.
Aside from toy problems and demonstrations, the majority of problems require
efficient numerical tools, many of which require the same base code (e.g., for
performing numerical orbit integration).

# Statement of need

`Gala` is an Astropy-affiliated Python package for galactic dynamics. Python
enables wrapping low-level languages (e.g., C) for speed without losing
flexibility or ease-of-use in the user-interface. The API for `Gala` was
designed to provide a class-based and user-friendly interface to fast (C or
Cython-optimized) implementations of common operations such as gravitational
potential and force evaluation, orbit integration, dynamical transformations,
and chaos indicators for nonlinear dynamics. `Gala` also relies heavily on and
interfaces well with the implementations of physical units and astronomical
coordinate systems in the `Astropy` package [@astropy] (`astropy.units` and
`astropy.coordinates`).

`Gala` was designed to be used by both astronomical researchers and by
students in courses on gravitational dynamics or astronomy. It has already been
used in a number of scientific publications [@Pearson:2017] and has also been
used in graduate courses on Galactic dynamics to, e.g., provide interactive
visualizations of textbook material [@Binney:2008]. The combination of speed,
design, and support for Astropy functionality in `Gala` will enable exciting
scientific explorations of forthcoming data releases from the *Gaia* mission
[@gaia] by students and experts alike.

# Mathematics

Single dollars ($) are required for inline mathematics e.g. $f(x) = e^{\pi/x}$

Double dollars make self-standing equations:

$$\Theta(x) = \left\{\begin{array}{l}
0\textrm{ if } x < 0\cr
1\textrm{ else}
\end{array}\right.$$

You can also use plain \LaTeX for equations
\begin{equation}\label{eq:fourier}
\hat f(\omega) = \int_{-\infty}^{\infty} f(x) e^{i\omega x} dx
\end{equation}
and refer to \autoref{eq:fourier} from text.

# Citations

Citations to entries in paper.bib should be in
[rMarkdown](http://rmarkdown.rstudio.com/authoring_bibliographies_and_citations.html)
format.

If you want to cite a software repository URL (e.g. something on GitHub without a preferred
citation) then you can do it with the example BibTeX entry below for @fidgit.

For a quick reference, the following citation commands can be used:
- `@author:2001`  ->  "Author et al. (2001)"
- `[@author:2001]` -> "(Author et al., 2001)"
- `[@author1:2001; @author2:2001]` -> "(Author1 et al., 2001; Author2 et al., 2002)"

# Figures

Figures can be included like this:
![Caption for example figure.\label{fig:example}](figure.png)
and referenced from text using \autoref{fig:example}.

Figure sizes can be customized by adding an optional second parameter:
![Caption for example figure.](figure.png){ width=20% }

# Acknowledgements

We acknowledge contributions from Brigitta Sipocz, Syrtis Major, and Semyeong
Oh, and support from Kathryn Johnston during the genesis of this project.

# References


./paper/paper.md
---
title: 'SMITE: Single Molecule Imaging Toolbox Extraordinaire (MATLAB)'
tags:
  - MATLAB
  - single molecule localization microscopy (SMLM)
  - single particle tracking (SPT)
  - super resolution
authors:
  - name: David J. Schodt
    orcid: 0000-0002-8986-2736
    affiliation: 1
    equal-contrib: true
  - name: Michael J. Wester
    orcid: 0000-0002-3520-7605
    affiliation: "1, 2" # (Multiple affiliations must be quoted)
    equal-contrib: true
  - name: Mohamadreza Fazel
    orcid: 0000-0002-6215-1336
    affiliation: 1
  - name: Sajjad Khan
    orcid: 0000-0002-6910-5199
    affiliation: 1
  - name: Hanieh Mazloom-Farsibaf
    orcid: 0000-0002-2571-0418
    affiliation: 1
  - name: Sandeep Pallikkuth
    affiliation: 1
  - name: Marjolein B. M. Meddens
    orcid: 0000-0002-9965-1342
    affiliation: 1
  - name: Farzin Farzam
    affiliation: 1
  - name: Eric A. Burns
    orcid: 0000-0002-1625-2400
    affiliation: 3
  - name: William K. Kanagy
    orcid: 0000-0002-5756-9965
    affiliation: 3
  - name: Derek A. Rinaldi
    orcid: 0009-0000-8394-3626
    affiliation: 3
  - name: Elton Jhamba
    orcid: 0000-0002-5272-6466
    affiliation: 3
  - name: Sheng Liu
    affiliation: 1
  - name: Peter K. Relich
    orcid: 0000-0002-6063-6233
    affiliation: 1
  - name: Mark J. Olah
    affiliation: 1
  - name: Stanly L. Steinberg
    affiliation: 2
  - name: Keith A. Lidke^[corresponding author]
    orcid: 0000-0002-9328-4318
    affiliation: 1
    corresponding: true
affiliations:
 - name: Department of Physics and Astronomy, University of New Mexico
   index: 1
 - name: Department of Mathematics and Statistics, University of New Mexico
   index: 2
 - name: Department of Pathology, University of New Mexico Health Sciences Center
   index: 3
date: 29 September 2022
bibliography: paper.bib

---

# Summary

Fluorescence single molecule imaging comprises a variety of techniques that
involve detecting individual fluorescent molecules.  Many of these techniques
involve localizing individual fluorescent molecules with precisions below the
diffraction limit, which limits the spatial resolution of (visible) light-based
microscopes.  These methodologies are widely used to image biological
structures at the nanometer scale by fluorescently tagging the structures of
interest, elucidating details of the biological behavior observed.

Two common techniques are single-molecule localization microscropy (SMLM),
[@Lidke_article:2005; @Betzig_article:2006; @Rust_article:2006;
@Hell_article:2007; @vandeLinde_article:2011; @Fazel_article:2022]
which is used to produce 2D or 3D super-resolution images of static or nearly
static structures, and single-particle tracking (SPT) [@Shen_article:2017],
which follows the time course of one or a very small number of moving tagged
molecules.  SMLM often involves distributions of particles at medium to high
density, while SPT works in a very low density domain.  These procedures all
require intensive numerical computation, and the methods are tightly
interwoven.

# Statement of need

SMITE is a MATLAB-based toolbox that provides analysis tools for fluorescence
single molecule imaging with an emphasis on single molecule localization
microscopy (SMLM) and single-particle tracking (SPT).  The SMITE toolbox
consists of a MATLAB infrastructure with some C and CUDA code embedded to
provide CPU/GPU speed-ups for particularly expensive computations.
The source code for SMITE has been archived to GitHub:
[https://github.com/LidkeLab/smite](https://github.com/LidkeLab/smite)

SMITE is designed around the concept that a parameter structure, the Single
Molecule Fitting (SMF) structure, uniquely and completely defines the data
analysis.  The results are completely contained in a Single Molecule Data (SMD)
structure.  SMITE is designed to make lowest-level tools just as easy to use as
the higher-level application-specific classes.  All tools make use of the SMF
and SMD structures.  SMITE is organized into a set of namespaces that group
similar tools and concepts.  The namespace  `+smi`  contains the highest level
tools that will be the most common entry point for processing SMLM and SPT data
sets. 

Code coverage includes mature SMLM data analysis techniques (applying gain and 
offset corrections to raw data, finding localizations, thresholding
localizations based on various criteria, frame connection and drift
correction), SMLM/SPT simulations, sophisticated SPT analyses, post-processing
clustering and statistical analyses (e.g., diffusion analysis and hidden Markov
models for characterizing dimers in SPT results), a variety of visualizations,
experimental point spread function creation and characterization, all sprinkled
with various examples of usage.  Interaction with these tools is via GUIs or
scripting.  See \autoref{fig:smite_overview} for several examples of SMITE
GUIs.

SMITE is a tool designed to be used by researchers and upper level students
interested in fluorescence single molecule imaging and applications.
Some of the algorithms have already been published: 2D Gaussian blob maximum
likelihood estimate [@Smith_article:2010], frame connection
[@Schodt_article:2021], drift correction [@Wester_article:2021], Bayesian
grouping of localizations [@Fazel_article:2022a], diffusion estimation
[@Relich_article:2016].  However, this is the first time that they have been
integrated together, sharing common data structures.
Applications are described in [@FrancoNitta_article:2021;
@Mazloom-Farsibaf_article:2021; @Bailey_article:2022].
Typical raw image data can be found in [@Pallikkuth_data:2018].
A summary of the namespaces and classes in SMITE can be found in the online
documentation at
[https://github.com/LidkeLab/smite/blob/main/doc/SMITEclasses.md](https://github.com/LidkeLab/smite/blob/main/doc/SMITEclasses.md).

SMAP [@Ries_article:2020], an alternative MATLAB integrated SMLM/SPT code, is
GUI oriented, while SMITE was designed to be more focused on scripting
(although many GUIs are available as well) in order to make batch processing
extremely simple.  SMITE, in addition, is designed to operate with HDF5
(Hierarchical Data Format) files which efficiently store very large datasets,
while SMAP preferentially works with TIFF formatted files.  Both SMITE and SMAP
work with separate software to control instruments, MATLAB Instrument Control
(MIC) [@Pallikkuth_article:2018] and Micro-Manager [@Edelstein_article:2014],
respectively.

![SMITE GUIs for (upper left) making movies from SPT trajectories, (upper
right) SMLM analysis, (lower left) channel registration, and (lower right)
inspection of results contained in SMD
structures.\label{fig:smite_overview}](smite_overview.pdf){ width=100% }

# Author Contributions

KAL conceived and supervised development of SMITE and its predecessors.
DJS, MF, HMF, MBMM and KAL coded SR localization techniques.
SP, MJW, MF and HMF implemented thresholding.
DJS and HMF wrote frame connection.
MJW, KAL and DJS developed drift correction based on an earlier version by FF.
MF and KAL devloped BaGoL; MJW wrote the interface to SMITE.
DJS, HMF, WKK, DAR and EJ designed and wrote code for single particle tracking
based on ideas from PKR.
DJS, MBMM, HMF and SP created visualizations.
SK, MJW and DJS added SMLM and SPT simulations.
KAL, SL and MJW developed Zernike polynomial point spread function engineering.
MJW packaged clustering techniques, and
SLS and MJW wrote code for various cluster statistics.
DJS added channel registration, various statistics, dimer hidden Markov
modeling and the batch Publish class.
PKR and MJO developed the diffusion estimator, while MJO also contributed to
the change detector.
MJW, SK and EAB added GitHub documentation.
MJW and DJS wrote the manuscript.
All authors reviewed the manuscript.

# Acknowledgements

This work was supported by NIH grants NIBIB R21EB019589, NIGMS R21GM132716,
NCI R01CA248166, NCI P30CA118100, NIGMS R35GM126934,
and the New Mexico Spatiotemporal Modeling Center (NIGMS P50GM085273).

# References

